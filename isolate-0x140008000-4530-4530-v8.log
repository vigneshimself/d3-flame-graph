v8-version,9,6,180,15,-node.15,0
v8-platform,macos,macos
shared-library,/Users/vignesh/.nvm/versions/node/v17.7.1/bin/node,0x100326000,0x10152c138,3293184
shared-library,/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation,0x1bfdbf7a0,0x1bffa2164,1067761664
shared-library,/usr/lib/libobjc.A.dylib,0x1bfbf67a0,0x1bfc23d18,1067761664
shared-library,/usr/lib/liboah.dylib,0x1ca88ce9c,0x1ca891e78,1067761664
shared-library,/usr/lib/libfakelink.dylib,0x1ca8bdfd8,0x1ca8c0ba0,1067761664
shared-library,/usr/lib/libicucore.A.dylib,0x1c21eeacc,0x1c243c390,1067761664
shared-library,/usr/lib/libSystem.B.dylib,0x1ca8bc514,0x1ca8bcb0c,1067761664
shared-library,/System/Library/PrivateFrameworks/SoftLinking.framework/Versions/A/SoftLinking,0x1ca8c1be4,0x1ca8c1e50,1067761664
shared-library,/usr/lib/libc++abi.dylib,0x1bfd20764,0x1bfd33dc8,1067761664
shared-library,/usr/lib/libc++.1.dylib,0x1bfcbd1cc,0x1bfd14544,1067761664
shared-library,/usr/lib/system/libcache.dylib,0x1ca8b66d0,0x1ca8b9390,1067761664
shared-library,/usr/lib/system/libcommonCrypto.dylib,0x1ca873a94,0x1ca87eb54,1067761664
shared-library,/usr/lib/system/libcompiler_rt.dylib,0x1ca89c980,0x1ca89f864,1067761664
shared-library,/usr/lib/system/libcopyfile.dylib,0x1ca893990,0x1ca89a040,1067761664
shared-library,/usr/lib/system/libcorecrypto.dylib,0x1bfafc980,0x1bfb66010,1067761664
shared-library,/usr/lib/system/libdispatch.dylib,0x1bfbafbf8,0x1bfbec208,1067761664
shared-library,/usr/lib/system/libdyld.dylib,0x1bfd7cca0,0x1bfd880a8,1067761664
shared-library,/usr/lib/system/libkeymgr.dylib,0x1ca8ab764,0x1ca8abe50,1067761664
shared-library,/usr/lib/system/libmacho.dylib,0x1ca852690,0x1ca8569bc,1067761664
shared-library,/usr/lib/system/libquarantine.dylib,0x1c9f43d2c,0x1c9f45bb8,1067761664
shared-library,/usr/lib/system/libremovefile.dylib,0x1ca8a9560,0x1ca8aac60,1067761664
shared-library,/usr/lib/system/libsystem_asl.dylib,0x1c4ee536c,0x1c4efa010,1067761664
shared-library,/usr/lib/system/libsystem_blocks.dylib,0x1bfa9e4c4,0x1bfa9ec68,1067761664
shared-library,/usr/lib/system/libsystem_c.dylib,0x1bfc378a0,0x1bfcb0b50,1067761664
shared-library,/usr/lib/system/libsystem_collections.dylib,0x1ca8a0904,0x1ca8a4960,1067761664
shared-library,/usr/lib/system/libsystem_configuration.dylib,0x1c93d2534,0x1c93d56e8,1067761664
shared-library,/usr/lib/system/libsystem_containermanager.dylib,0x1c862e6f8,0x1c86462e0,1067761664
shared-library,/usr/lib/system/libsystem_coreservices.dylib,0x1ca5b1884,0x1ca5b52a8,1067761664
shared-library,/usr/lib/system/libsystem_darwin.dylib,0x1c24a549c,0x1c24ac220,1067761664
shared-library,/usr/lib/system/libsystem_dnssd.dylib,0x1ca8ad8ec,0x1ca8b3168,1067761664
shared-library,/usr/lib/system/libsystem_featureflags.dylib,0x1bfc33cfc,0x1bfc35ad8,1067761664
shared-library,/usr/lib/system/libsystem_info.dylib,0x1bfd92bf0,0x1bfdb93f0,1067761664
shared-library,/usr/lib/system/libsystem_m.dylib,0x1ca8167c0,0x1ca83e9a8,1067761664
shared-library,/usr/lib/system/libsystem_malloc.dylib,0x1bfb84028,0x1bfba84a0,1067761664
shared-library,/usr/lib/system/libsystem_networkextension.dylib,0x1c4e73de4,0x1c4e86b80,1067761664
shared-library,/usr/lib/system/libsystem_notify.dylib,0x1c28fe8c0,0x1c290bc00,1067761664
shared-library,/usr/lib/system/libsystem_product_info_filter.dylib,0x1d0bfa000,0x1d0bfa000,1067761664
shared-library,/usr/lib/system/libsystem_sandbox.dylib,0x1c93d68f4,0x1c93da0f0,1067761664
shared-library,/usr/lib/system/libsystem_secinit.dylib,0x1ca8a5b38,0x1ca8a7318,1067761664
shared-library,/usr/lib/system/libsystem_kernel.dylib,0x1bfd38520,0x1bfd68884,1067761664
shared-library,/usr/lib/system/libsystem_platform.dylib,0x1bfd8a4c0,0x1bfd90314,1067761664
shared-library,/usr/lib/system/libsystem_pthread.dylib,0x1bfd6fda0,0x1bfd7a8f0,1067761664
shared-library,/usr/lib/system/libsystem_symptoms.dylib,0x1c663d740,0x1c66432ac,1067761664
shared-library,/usr/lib/system/libsystem_trace.dylib,0x1bfae2e54,0x1bfaf8200,1067761664
shared-library,/usr/lib/system/libunwind.dylib,0x1ca884c9c,0x1ca88a40c,1067761664
shared-library,/usr/lib/system/libxpc.dylib,0x1bfaa03cc,0x1bfad6a78,1067761664
shared-library-end
profiler,begin,1000
tick,0x1bfd3890c,375,0,0x0,6
new,CodeRange,0x1050c0000,0
new,MemoryChunk,0x32abc8680000,262144
tick,0x100a06674,1667,0,0x0,6
new,MemoryChunk,0x246835c40000,262144
new,MemoryChunk,0xba0a3ec0000,262144
new,MemoryChunk,0x949c6e80000,262144
new,MemoryChunk,0x2f8818f80000,262144
heap-capacity,1031072
heap-available,2198648640
new,MemoryChunk,0x2b48e0c40000,262144
new,MemoryChunk,0x3faec8440000,262144
new,MemoryChunk,0x232faba00000,262144
new,MemoryChunk,0x815de600000,262144
new,MemoryChunk,0x174551ec0000,262144
new,MemoryChunk,0xd2efcc00000,262144
new,MemoryChunk,0x3beccac0000,262144
new,MemoryChunk,0x1050c0000,262144
new,MemoryChunk,0xcc76ab40000,262144
tick,0x10055e774,2917,0,0x0,6
code-creation,Builtin,2,3375,0x100c88360,828,DeoptimizationEntry_Eager
code-creation,Builtin,2,3417,0x100c886a0,828,DeoptimizationEntry_Soft
code-creation,Builtin,2,3417,0x100c889e0,828,DeoptimizationEntry_Bailout
code-creation,Builtin,2,3417,0x100c88d20,828,DeoptimizationEntry_Lazy
code-creation,Builtin,2,3417,0x100c89060,128,DynamicCheckMapsTrampoline
code-creation,Builtin,2,3417,0x100c89100,128,DynamicCheckMapsWithFeedbackVectorTrampoline
code-creation,Builtin,2,3417,0x100c891a0,976,RecordWriteEmitRememberedSetSaveFP
code-creation,Builtin,2,3417,0x100c89580,344,RecordWriteOmitRememberedSetSaveFP
code-creation,Builtin,2,3417,0x100c896e0,688,RecordWriteEmitRememberedSetIgnoreFP
code-creation,Builtin,2,3417,0x100c899a0,248,RecordWriteOmitRememberedSetIgnoreFP
code-creation,Builtin,2,3417,0x100c89aa0,272,EphemeronKeyBarrierSaveFP
code-creation,Builtin,2,3459,0x100c89bc0,176,EphemeronKeyBarrierIgnoreFP
code-creation,Builtin,2,3459,0x100c89c80,112,AdaptorWithBuiltinExitFrame
code-creation,Builtin,2,3459,0x100c89d00,380,CallFunction_ReceiverIsNullOrUndefined
code-creation,Builtin,2,3459,0x100c89e80,456,CallFunction_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,3459,0x100c8a060,496,CallFunction_ReceiverIsAny
code-creation,Builtin,2,3459,0x100c8a260,228,CallBoundFunction
code-creation,Builtin,2,3459,0x100c8a360,180,Call_ReceiverIsNullOrUndefined
code-creation,Builtin,2,3459,0x100c8a420,180,Call_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,3459,0x100c8a4e0,180,Call_ReceiverIsAny
code-creation,Builtin,2,3459,0x100c8a5a0,896,Call_ReceiverIsNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,3459,0x100c8a940,892,Call_ReceiverIsNullOrUndefined_Baseline
code-creation,Builtin,2,3500,0x100c8acc0,1044,Call_ReceiverIsNotNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,3500,0x100c8b0e0,1040,Call_ReceiverIsNotNullOrUndefined_Baseline
code-creation,Builtin,2,3500,0x100c8b500,1044,Call_ReceiverIsAny_Baseline_Compact
code-creation,Builtin,2,3500,0x100c8b920,1040,Call_ReceiverIsAny_Baseline
code-creation,Builtin,2,3500,0x100c8bd40,868,Call_ReceiverIsNullOrUndefined_WithFeedback
code-creation,Builtin,2,3500,0x100c8c0c0,868,Call_ReceiverIsNotNullOrUndefined_WithFeedback
code-creation,Builtin,2,3500,0x100c8c440,868,Call_ReceiverIsAny_WithFeedback
code-creation,Builtin,2,3500,0x100c8c7c0,768,CallProxy
code-creation,Builtin,2,3500,0x100c8cae0,164,CallVarargs
code-creation,Builtin,2,3500,0x100c8cba0,1164,CallWithSpread
code-creation,Builtin,2,3500,0x100c8d040,1992,CallWithSpread_Baseline
code-creation,Builtin,2,3542,0x100c8d820,2048,CallWithSpread_WithFeedback
code-creation,Builtin,2,3542,0x100c8e040,1180,CallWithArrayLike
code-creation,Builtin,2,3542,0x100c8e4e0,2032,CallWithArrayLike_WithFeedback
code-creation,Builtin,2,3542,0x100c8ece0,188,CallForwardVarargs
code-creation,Builtin,2,3542,0x100c8eda0,188,CallFunctionForwardVarargs
code-creation,Builtin,2,3542,0x100c8ee60,152,CallFunctionTemplate_CheckAccess
code-creation,Builtin,2,3542,0x100c8ef00,236,CallFunctionTemplate_CheckCompatibleReceiver
code-creation,Builtin,2,3542,0x100c8f000,324,CallFunctionTemplate_CheckAccessAndCompatibleReceiver
code-creation,Builtin,2,3542,0x100c8f160,24,ConstructFunction
code-creation,Builtin,2,3542,0x100c8f180,232,ConstructBoundFunction
code-creation,Builtin,2,3542,0x100c8f280,44,ConstructedNonConstructable
code-creation,Builtin,2,3584,0x100c8f2c0,88,Construct
code-creation,Builtin,2,3584,0x100c8f320,164,ConstructVarargs
code-creation,Builtin,2,3584,0x100c8f3e0,1192,ConstructWithSpread
code-creation,Builtin,2,3584,0x100c8f8a0,1992,ConstructWithSpread_Baseline
code-creation,Builtin,2,3584,0x100c90080,1972,ConstructWithSpread_WithFeedback
code-creation,Builtin,2,3584,0x100c90840,1308,ConstructWithArrayLike
code-creation,Builtin,2,3584,0x100c90d60,2088,ConstructWithArrayLike_WithFeedback
code-creation,Builtin,2,3584,0x100c915a0,240,ConstructForwardVarargs
code-creation,Builtin,2,3584,0x100c916a0,240,ConstructFunctionForwardVarargs
code-creation,Builtin,2,3584,0x100c917a0,780,Construct_Baseline
code-creation,Builtin,2,3625,0x100c91ac0,784,Construct_WithFeedback
code-creation,Builtin,2,3625,0x100c91de0,580,JSConstructStubGeneric
code-creation,Builtin,2,3625,0x100c92040,492,JSBuiltinsConstructStub
code-creation,Builtin,2,3625,0x100c92240,688,FastNewObject
code-creation,Builtin,2,3625,0x100c92500,324,FastNewClosure
code-creation,Builtin,2,3625,0x100c92660,752,ConstructProxy
code-creation,Builtin,2,3625,0x100c92960,264,JSEntry
code-creation,Builtin,2,3625,0x100c92a80,264,JSConstructEntry
code-creation,Builtin,2,3625,0x100c92ba0,264,JSRunMicrotasksEntry
code-creation,Builtin,2,3625,0x100c92cc0,184,JSEntryTrampoline
code-creation,Builtin,2,3625,0x100c92d80,184,JSConstructEntryTrampoline
code-creation,Builtin,2,3625,0x100c92e40,376,ResumeGeneratorTrampoline
code-creation,Builtin,2,3667,0x100c92fc0,1204,StringCodePointAt
code-creation,Builtin,2,3667,0x100c93480,1700,StringFromCodePointAt
code-creation,Builtin,2,3667,0x100c93b40,576,StringEqual
code-creation,Builtin,2,3667,0x100c93da0,320,StringGreaterThan
code-creation,Builtin,2,3667,0x100c93f00,320,StringGreaterThanOrEqual
code-creation,Builtin,2,3667,0x100c94060,320,StringLessThan
code-creation,Builtin,2,3667,0x100c941c0,320,StringLessThanOrEqual
code-creation,Builtin,2,3667,0x100c94320,2720,StringSubstring
code-creation,Builtin,2,3667,0x100c94de0,116,OrderedHashTableHealIndex
code-creation,Builtin,2,3667,0x100c94e60,1364,InterpreterEntryTrampoline
code-creation,Builtin,2,3667,0x100c953c0,124,InterpreterPushArgsThenCall
code-creation,Builtin,2,3667,0x100c95440,132,InterpreterPushUndefinedAndArgsThenCall
code-creation,Builtin,2,3667,0x100c954e0,132,InterpreterPushArgsThenCallWithFinalSpread
code-creation,Builtin,2,3709,0x100c95580,132,InterpreterPushArgsThenConstruct
code-creation,Builtin,2,3709,0x100c95620,132,InterpreterPushArgsThenConstructArrayFunction
code-creation,Builtin,2,3709,0x100c956c0,140,InterpreterPushArgsThenConstructWithFinalSpread
code-creation,Builtin,2,3709,0x100c95760,92,InterpreterEnterAtBytecode
code-creation,Builtin,2,3709,0x100c957c0,220,InterpreterEnterAtNextBytecode
code-creation,Builtin,2,3709,0x100c958a0,80,InterpreterOnStackReplacement
code-creation,Builtin,2,3709,0x100c95900,704,BaselineOutOfLinePrologue
code-creation,Builtin,2,3709,0x100c95be0,76,BaselineOnStackReplacement
code-creation,Builtin,2,3709,0x100c95c40,104,BaselineLeaveFrame
code-creation,Builtin,2,3709,0x100c95cc0,232,BaselineOrInterpreterEnterAtBytecode
code-creation,Builtin,2,3709,0x100c95dc0,236,BaselineOrInterpreterEnterAtNextBytecode
code-creation,Builtin,2,3750,0x100c95ec0,208,InterpreterOnStackReplacement_ToBaseline
code-creation,Builtin,2,3750,0x100c95fa0,1112,CompileLazy
code-creation,Builtin,2,3750,0x100c96400,88,CompileLazyDeoptimizedCode
code-creation,Builtin,2,3750,0x100c96460,336,InstantiateAsmJs
code-creation,Builtin,2,3750,0x100c965c0,44,NotifyDeoptimized
code-creation,Builtin,2,3750,0x100c96600,88,ContinueToCodeStubBuiltin
code-creation,Builtin,2,3750,0x100c96660,92,ContinueToCodeStubBuiltinWithResult
code-creation,Builtin,2,3750,0x100c966c0,92,ContinueToJavaScriptBuiltin
code-creation,Builtin,2,3750,0x100c96720,108,ContinueToJavaScriptBuiltinWithResult
code-creation,Builtin,2,3750,0x100c967a0,396,CallApiCallback
code-creation,Builtin,2,3750,0x100c96940,372,CallApiGetter
code-creation,Builtin,2,3792,0x100c96ac0,8,HandleApiCall
code-creation,Builtin,2,3792,0x100c96ae0,8,HandleApiCallAsFunction
code-creation,Builtin,2,3792,0x100c96b00,8,HandleApiCallAsConstructor
code-creation,Builtin,2,3792,0x100c96b20,56,AllocateInYoungGeneration
code-creation,Builtin,2,3792,0x100c96b60,52,AllocateRegularInYoungGeneration
code-creation,Builtin,2,3792,0x100c96ba0,56,AllocateInOldGeneration
code-creation,Builtin,2,3792,0x100c96be0,52,AllocateRegularInOldGeneration
code-creation,Builtin,2,3792,0x100c96c20,428,CopyFastSmiOrObjectElements
code-creation,Builtin,2,3792,0x100c96de0,544,GrowFastDoubleElements
code-creation,Builtin,2,3792,0x100c97020,436,GrowFastSmiOrObjectElements
code-creation,Builtin,2,3792,0x100c971e0,416,DebugBreakTrampoline
code-creation,Builtin,2,3834,0x100c973a0,228,ToNumber
code-creation,Builtin,2,3834,0x100c974a0,336,ToNumber_Baseline
code-creation,Builtin,2,3834,0x100c97600,400,ToNumeric_Baseline
code-creation,Builtin,2,3834,0x100c977a0,152,PlainPrimitiveToNumber
code-creation,Builtin,2,3834,0x100c97840,268,ToNumberConvertBigInt
code-creation,Builtin,2,3834,0x100c97960,148,Typeof
code-creation,Builtin,2,3834,0x100c97a00,140,BigIntToI64
code-creation,Builtin,2,3834,0x100c97aa0,8,BigIntToI32Pair
code-creation,Builtin,2,3834,0x100c97ac0,256,I64ToBigInt
code-creation,Builtin,2,3834,0x100c97be0,8,I32PairToBigInt
code-creation,Builtin,2,3834,0x100c97c00,136,ToBooleanLazyDeoptContinuation
code-creation,Builtin,2,3834,0x100c97ca0,3932,KeyedLoadIC_PolymorphicName
code-creation,Builtin,2,3834,0x100c98c00,14604,KeyedStoreIC_Megamorphic
code-creation,Builtin,2,3875,0x100c9c520,332,LoadGlobalIC_NoFeedback
code-creation,Builtin,2,3875,0x100c9c680,84,LoadIC_FunctionPrototype
code-creation,Builtin,2,3875,0x100c9c6e0,16,LoadIC_StringLength
code-creation,Builtin,2,3875,0x100c9c700,20,LoadIC_StringWrapperLength
code-creation,Builtin,2,3875,0x100c9c720,3116,LoadIC_NoFeedback
code-creation,Builtin,2,3875,0x100c9d360,44,StoreGlobalIC_Slow
code-creation,Builtin,2,3875,0x100c9d3a0,5836,StoreIC_NoFeedback
code-creation,Builtin,2,3875,0x100c9ea80,220,KeyedLoadIC_SloppyArguments
code-creation,Builtin,2,3875,0x100c9eb60,68,LoadIndexedInterceptorIC
code-creation,Builtin,2,3875,0x100c9ebc0,304,KeyedStoreIC_SloppyArguments_Standard
code-creation,Builtin,2,3875,0x100c9ed00,304,KeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW
code-creation,Builtin,2,3917,0x100c9ee40,304,KeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB
code-creation,Builtin,2,3917,0x100c9ef80,304,KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW
code-creation,Builtin,2,3917,0x100c9f0c0,11600,StoreFastElementIC_Standard
code-creation,Builtin,2,3917,0x100ca1e20,10856,StoreFastElementIC_GrowNoTransitionHandleCOW
code-creation,Builtin,2,3917,0x100ca48a0,10940,StoreFastElementIC_NoTransitionIgnoreOOB
code-creation,Builtin,2,3917,0x100ca7360,5776,StoreFastElementIC_NoTransitionHandleCOW
code-creation,Builtin,2,3917,0x100ca8a00,8580,ElementsTransitionAndStore_Standard
code-creation,Builtin,2,3917,0x100caaba0,21752,ElementsTransitionAndStore_GrowNoTransitionHandleCOW
code-creation,Builtin,2,3917,0x100cb00a0,8580,ElementsTransitionAndStore_NoTransitionIgnoreOOB
code-creation,Builtin,2,3917,0x100cb2240,11620,ElementsTransitionAndStore_NoTransitionHandleCOW
code-creation,Builtin,2,3959,0x100cb4fc0,768,KeyedHasIC_PolymorphicName
code-creation,Builtin,2,3959,0x100cb52e0,200,KeyedHasIC_SloppyArguments
code-creation,Builtin,2,3959,0x100cb53c0,68,HasIndexedInterceptorIC
code-creation,Builtin,2,3959,0x100cb5420,356,DynamicCheckMaps
code-creation,Builtin,2,3959,0x100cb55a0,316,DynamicCheckMapsWithFeedbackVector
code-creation,Builtin,2,3959,0x100cb56e0,164,EnqueueMicrotask
code-creation,Builtin,2,3959,0x100cb57a0,8,RunMicrotasksTrampoline
code-creation,Builtin,2,3959,0x100cb57c0,3536,RunMicrotasks
code-creation,Builtin,2,3959,0x100cb65a0,2700,HasProperty
code-creation,Builtin,2,3959,0x100cb7040,1084,DeleteProperty
code-creation,Builtin,2,3959,0x100cb7480,2196,CopyDataProperties
code-creation,Builtin,2,3959,0x100cb7d20,8000,SetDataProperties
code-creation,Builtin,2,3959,0x100cb9c80,32,Abort
code-creation,Builtin,2,4000,0x100cb9cc0,32,AbortCSADcheck
code-creation,Builtin,2,4000,0x100cb9d00,8,EmptyFunction
code-creation,Builtin,2,4000,0x100cb9d20,8,Illegal
code-creation,Builtin,2,4000,0x100cb9d40,8,StrictPoisonPillThrower
code-creation,Builtin,2,4000,0x100cb9d60,8,UnsupportedThrower
code-creation,Builtin,2,4000,0x100cb9d80,84,ReturnReceiver
code-creation,Builtin,2,4000,0x100cb9de0,36,ArrayConstructor
code-creation,Builtin,2,4000,0x100cb9e20,464,ArrayConstructorImpl
code-creation,Builtin,2,4000,0x100cba000,236,ArrayNoArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,4000,0x100cba100,236,ArrayNoArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,4042,0x100cba200,196,ArrayNoArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,4042,0x100cba2e0,196,ArrayNoArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,4042,0x100cba3c0,196,ArrayNoArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,4042,0x100cba4a0,196,ArrayNoArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,4042,0x100cba580,200,ArrayNoArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,4042,0x100cba660,200,ArrayNoArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,4042,0x100cba740,500,ArraySingleArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,4042,0x100cba940,484,ArraySingleArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,4042,0x100cbab40,420,ArraySingleArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,4084,0x100cbad00,408,ArraySingleArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,4084,0x100cbaea0,420,ArraySingleArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,4084,0x100cbb060,408,ArraySingleArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,4084,0x100cbb200,424,ArraySingleArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,4084,0x100cbb3c0,412,ArraySingleArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,4084,0x100cbb560,68,ArrayNArgumentsConstructor
code-creation,Builtin,2,4084,0x100cbb5c0,8,ArrayConcat
code-creation,Builtin,2,4084,0x100cbb5e0,8,ArrayPrototypeFill
code-creation,Builtin,2,4084,0x100cbb600,1020,ArrayIncludesSmiOrObject
code-creation,Builtin,2,4084,0x100cbba00,172,ArrayIncludesPackedDoubles
code-creation,Builtin,2,4125,0x100cbbac0,252,ArrayIncludesHoleyDoubles
code-creation,Builtin,2,4125,0x100cbbbc0,600,ArrayIncludes
code-creation,Builtin,2,4125,0x100cbbe20,920,ArrayIndexOfSmiOrObject
code-creation,Builtin,2,4125,0x100cbc1c0,128,ArrayIndexOfPackedDoubles
code-creation,Builtin,2,4125,0x100cbc260,128,ArrayIndexOfHoleyDoubles
code-creation,Builtin,2,4125,0x100cbc300,600,ArrayIndexOf
code-creation,Builtin,2,4125,0x100cbc560,8,ArrayPop
code-creation,Builtin,2,4125,0x100cbc580,636,ArrayPrototypePop
code-creation,Builtin,2,4125,0x100cbc800,8,ArrayPush
code-creation,Builtin,2,4125,0x100cbc820,2436,ArrayPrototypePush
code-creation,Builtin,2,4125,0x100cbd1c0,8,ArrayShift
code-creation,Builtin,2,4167,0x100cbd1e0,8,ArrayUnshift
code-creation,Builtin,2,4167,0x100cbd200,916,CloneFastJSArray
code-creation,Builtin,2,4167,0x100cbd5a0,2092,CloneFastJSArrayFillingHoles
code-creation,Builtin,2,4167,0x100cbdde0,932,ExtractFastJSArray
code-creation,Builtin,2,4167,0x100cbe1a0,268,ArrayPrototypeEntries
code-creation,Builtin,2,4167,0x100cbe2c0,264,ArrayPrototypeKeys
code-creation,Builtin,2,4167,0x100cbe3e0,268,ArrayPrototypeValues
code-creation,Builtin,2,4167,0x100cbe500,4192,ArrayIteratorPrototypeNext
code-creation,Builtin,2,4167,0x100cbf580,4124,FlattenIntoArray
code-creation,Builtin,2,4167,0x100cc05a0,4108,FlatMapIntoArray
code-creation,Builtin,2,4167,0x100cc15c0,412,ArrayPrototypeFlat
code-creation,Builtin,2,4209,0x100cc1760,468,ArrayPrototypeFlatMap
code-creation,Builtin,2,4209,0x100cc1940,8,ArrayBufferConstructor
code-creation,Builtin,2,4209,0x100cc1960,8,ArrayBufferConstructor_DoNotInitialize
code-creation,Builtin,2,4209,0x100cc1980,8,ArrayBufferPrototypeSlice
code-creation,Builtin,2,4209,0x100cc19a0,8,ArrayBufferPrototypeResize
code-creation,Builtin,2,4209,0x100cc19c0,864,AsyncFunctionEnter
code-creation,Builtin,2,4209,0x100cc1d40,132,AsyncFunctionReject
code-creation,Builtin,2,4209,0x100cc1de0,124,AsyncFunctionResolve
code-creation,Builtin,2,4209,0x100cc1e60,16,AsyncFunctionLazyDeoptContinuation
code-creation,Builtin,2,4209,0x100cc1e80,2864,AsyncFunctionAwaitCaught
code-creation,Builtin,2,4250,0x100cc29c0,2864,AsyncFunctionAwaitUncaught
code-creation,Builtin,2,4250,0x100cc3500,212,AsyncFunctionAwaitRejectClosure
code-creation,Builtin,2,4250,0x100cc35e0,212,AsyncFunctionAwaitResolveClosure
code-creation,Builtin,2,4250,0x100cc36c0,8,BigIntConstructor
code-creation,Builtin,2,4250,0x100cc36e0,8,BigIntAsUintN
code-creation,Builtin,2,4250,0x100cc3700,8,BigIntAsIntN
code-creation,Builtin,2,4250,0x100cc3720,8,BigIntPrototypeToLocaleString
code-creation,Builtin,2,4250,0x100cc3740,8,BigIntPrototypeToString
code-creation,Builtin,2,4250,0x100cc3760,8,BigIntPrototypeValueOf
code-creation,Builtin,2,4250,0x100cc3780,8,CallSitePrototypeGetColumnNumber
code-creation,Builtin,2,4292,0x100cc37a0,8,CallSitePrototypeGetEnclosingColumnNumber
code-creation,Builtin,2,4292,0x100cc37c0,8,CallSitePrototypeGetEnclosingLineNumber
code-creation,Builtin,2,4292,0x100cc37e0,8,CallSitePrototypeGetEvalOrigin
code-creation,Builtin,2,4292,0x100cc3800,8,CallSitePrototypeGetFileName
code-creation,Builtin,2,4292,0x100cc3820,8,CallSitePrototypeGetFunction
code-creation,Builtin,2,4292,0x100cc3840,8,CallSitePrototypeGetFunctionName
code-creation,Builtin,2,4292,0x100cc3860,8,CallSitePrototypeGetLineNumber
code-creation,Builtin,2,4292,0x100cc3880,8,CallSitePrototypeGetMethodName
code-creation,Builtin,2,4292,0x100cc38a0,8,CallSitePrototypeGetPosition
code-creation,Builtin,2,4292,0x100cc38c0,8,CallSitePrototypeGetPromiseIndex
code-creation,Builtin,2,4292,0x100cc38e0,8,CallSitePrototypeGetScriptNameOrSourceURL
code-creation,Builtin,2,4334,0x100cc3900,8,CallSitePrototypeGetThis
code-creation,Builtin,2,4334,0x100cc3920,8,CallSitePrototypeGetTypeName
code-creation,Builtin,2,4334,0x100cc3940,8,CallSitePrototypeIsAsync
code-creation,Builtin,2,4334,0x100cc3960,8,CallSitePrototypeIsConstructor
code-creation,Builtin,2,4334,0x100cc3980,8,CallSitePrototypeIsEval
code-creation,Builtin,2,4334,0x100cc39a0,8,CallSitePrototypeIsNative
code-creation,Builtin,2,4334,0x100cc39c0,8,CallSitePrototypeIsPromiseAll
code-creation,Builtin,2,4334,0x100cc39e0,8,CallSitePrototypeIsToplevel
code-creation,Builtin,2,4334,0x100cc3a00,8,CallSitePrototypeToString
code-creation,Builtin,2,4334,0x100cc3a20,8,ConsoleDebug
code-creation,Builtin,2,4334,0x100cc3a40,8,ConsoleError
code-creation,Builtin,2,4375,0x100cc3a60,8,ConsoleInfo
code-creation,Builtin,2,4375,0x100cc3a80,8,ConsoleLog
code-creation,Builtin,2,4375,0x100cc3aa0,8,ConsoleWarn
code-creation,Builtin,2,4375,0x100cc3ac0,8,ConsoleDir
code-creation,Builtin,2,4375,0x100cc3ae0,8,ConsoleDirXml
code-creation,Builtin,2,4375,0x100cc3b00,8,ConsoleTable
code-creation,Builtin,2,4375,0x100cc3b20,8,ConsoleTrace
code-creation,Builtin,2,4375,0x100cc3b40,8,ConsoleGroup
code-creation,Builtin,2,4375,0x100cc3b60,8,ConsoleGroupCollapsed
code-creation,Builtin,2,4375,0x100cc3b80,8,ConsoleGroupEnd
code-creation,Builtin,2,4375,0x100cc3ba0,8,ConsoleClear
code-creation,Builtin,2,4375,0x100cc3bc0,8,ConsoleCount
code-creation,Builtin,2,4417,0x100cc3be0,8,ConsoleCountReset
code-creation,Builtin,2,4417,0x100cc3c00,8,ConsoleAssert
code-creation,Builtin,2,4417,0x100cc3c20,8,ConsoleProfile
code-creation,Builtin,2,4417,0x100cc3c40,8,ConsoleProfileEnd
code-creation,Builtin,2,4417,0x100cc3c60,8,ConsoleTime
code-creation,Builtin,2,4417,0x100cc3c80,8,ConsoleTimeLog
code-creation,Builtin,2,4417,0x100cc3ca0,8,ConsoleTimeEnd
code-creation,Builtin,2,4417,0x100cc3cc0,8,ConsoleTimeStamp
code-creation,Builtin,2,4417,0x100cc3ce0,8,ConsoleContext
code-creation,Builtin,2,4417,0x100cc3d00,8,DataViewConstructor
code-creation,Builtin,2,4417,0x100cc3d20,8,DateConstructor
code-creation,Builtin,2,4459,0x100cc3d40,212,DatePrototypeGetDate
code-creation,Builtin,2,4459,0x100cc3e20,212,DatePrototypeGetDay
code-creation,Builtin,2,4459,0x100cc3f00,212,DatePrototypeGetFullYear
code-creation,Builtin,2,4459,0x100cc3fe0,212,DatePrototypeGetHours
code-creation,Builtin,2,4459,0x100cc40c0,184,DatePrototypeGetMilliseconds
code-creation,Builtin,2,4459,0x100cc4180,212,DatePrototypeGetMinutes
code-creation,Builtin,2,4459,0x100cc4260,212,DatePrototypeGetMonth
code-creation,Builtin,2,4459,0x100cc4340,212,DatePrototypeGetSeconds
code-creation,Builtin,2,4459,0x100cc4420,148,DatePrototypeGetTime
code-creation,Builtin,2,4459,0x100cc44c0,184,DatePrototypeGetTimezoneOffset
code-creation,Builtin,2,4500,0x100cc4580,184,DatePrototypeGetUTCDate
code-creation,Builtin,2,4500,0x100cc4640,184,DatePrototypeGetUTCDay
code-creation,Builtin,2,4500,0x100cc4700,184,DatePrototypeGetUTCFullYear
code-creation,Builtin,2,4500,0x100cc47c0,184,DatePrototypeGetUTCHours
code-creation,Builtin,2,4500,0x100cc4880,184,DatePrototypeGetUTCMilliseconds
code-creation,Builtin,2,4500,0x100cc4940,184,DatePrototypeGetUTCMinutes
code-creation,Builtin,2,4500,0x100cc4a00,184,DatePrototypeGetUTCMonth
code-creation,Builtin,2,4500,0x100cc4ac0,184,DatePrototypeGetUTCSeconds
code-creation,Builtin,2,4500,0x100cc4b80,148,DatePrototypeValueOf
code-creation,Builtin,2,4500,0x100cc4c20,384,DatePrototypeToPrimitive
code-creation,Builtin,2,4500,0x100cc4dc0,8,DatePrototypeGetYear
code-creation,Builtin,2,4542,0x100cc4de0,8,DatePrototypeSetYear
code-creation,Builtin,2,4542,0x100cc4e00,8,DateNow
code-creation,Builtin,2,4542,0x100cc4e20,8,DateParse
code-creation,Builtin,2,4542,0x100cc4e40,8,DatePrototypeSetDate
code-creation,Builtin,2,4542,0x100cc4e60,8,DatePrototypeSetFullYear
code-creation,Builtin,2,4542,0x100cc4e80,8,DatePrototypeSetHours
code-creation,Builtin,2,4542,0x100cc4ea0,8,DatePrototypeSetMilliseconds
code-creation,Builtin,2,4542,0x100cc4ec0,8,DatePrototypeSetMinutes
code-creation,Builtin,2,4542,0x100cc4ee0,8,DatePrototypeSetMonth
code-creation,Builtin,2,4542,0x100cc4f00,8,DatePrototypeSetSeconds
code-creation,Builtin,2,4542,0x100cc4f20,8,DatePrototypeSetTime
code-creation,Builtin,2,4542,0x100cc4f40,8,DatePrototypeSetUTCDate
code-creation,Builtin,2,4584,0x100cc4f60,8,DatePrototypeSetUTCFullYear
code-creation,Builtin,2,4584,0x100cc4f80,8,DatePrototypeSetUTCHours
code-creation,Builtin,2,4584,0x100cc4fa0,8,DatePrototypeSetUTCMilliseconds
code-creation,Builtin,2,4584,0x100cc4fc0,8,DatePrototypeSetUTCMinutes
code-creation,Builtin,2,4584,0x100cc4fe0,8,DatePrototypeSetUTCMonth
code-creation,Builtin,2,4584,0x100cc5000,8,DatePrototypeSetUTCSeconds
code-creation,Builtin,2,4584,0x100cc5020,8,DatePrototypeToDateString
code-creation,Builtin,2,4584,0x100cc5040,8,DatePrototypeToISOString
code-creation,Builtin,2,4584,0x100cc5060,8,DatePrototypeToUTCString
code-creation,Builtin,2,4584,0x100cc5080,8,DatePrototypeToString
code-creation,Builtin,2,4584,0x100cc50a0,8,DatePrototypeToTimeString
code-creation,Builtin,2,4625,0x100cc50c0,8,DatePrototypeToJson
code-creation,Builtin,2,4625,0x100cc50e0,8,DateUTC
code-creation,Builtin,2,4625,0x100cc5100,8,ErrorConstructor
code-creation,Builtin,2,4625,0x100cc5120,8,ErrorCaptureStackTrace
code-creation,Builtin,2,4625,0x100cc5140,8,ErrorPrototypeToString
code-creation,Builtin,2,4625,0x100cc5160,8,FunctionConstructor
code-creation,Builtin,2,4625,0x100cc5180,80,FunctionPrototypeApply
code-creation,Builtin,2,4625,0x100cc51e0,8,FunctionPrototypeBind
code-creation,Builtin,2,4625,0x100cc5200,144,FunctionPrototypeCall
code-creation,Builtin,2,4625,0x100cc52a0,8,FunctionPrototypeToString
code-creation,Builtin,2,4625,0x100cc52c0,224,CreateIterResultObject
code-creation,Builtin,2,4667,0x100cc53c0,912,CreateGeneratorObject
code-creation,Builtin,2,4667,0x100cc5760,8,GeneratorFunctionConstructor
code-creation,Builtin,2,4667,0x100cc5780,444,GeneratorPrototypeNext
code-creation,Builtin,2,4667,0x100cc5940,444,GeneratorPrototypeReturn
code-creation,Builtin,2,4667,0x100cc5b00,456,GeneratorPrototypeThrow
code-creation,Builtin,2,4667,0x100cc5ce0,8,AsyncFunctionConstructor
code-creation,Builtin,2,4667,0x100cc5d00,404,SuspendGeneratorBaseline
code-creation,Builtin,2,4667,0x100cc5ea0,108,ResumeGeneratorBaseline
code-creation,Builtin,2,4667,0x100cc5f20,56,GetIteratorWithFeedbackLazyDeoptContinuation
code-creation,Builtin,2,4667,0x100cc5f60,8,GlobalDecodeURI
code-creation,Builtin,2,4709,0x100cc5f80,8,GlobalDecodeURIComponent
code-creation,Builtin,2,4709,0x100cc5fa0,8,GlobalEncodeURI
code-creation,Builtin,2,4709,0x100cc5fc0,8,GlobalEncodeURIComponent
code-creation,Builtin,2,4709,0x100cc5fe0,8,GlobalEscape
code-creation,Builtin,2,4709,0x100cc6000,8,GlobalUnescape
code-creation,Builtin,2,4709,0x100cc6020,8,GlobalEval
code-creation,Builtin,2,4709,0x100cc6040,164,GlobalIsFinite
code-creation,Builtin,2,4709,0x100cc6100,160,GlobalIsNaN
code-creation,Builtin,2,4709,0x100cc61c0,8,JsonParse
code-creation,Builtin,2,4709,0x100cc61e0,8,JsonStringify
code-creation,Builtin,2,4709,0x100cc6200,4312,LoadIC
code-creation,Builtin,2,4709,0x100cc72e0,3968,LoadIC_Megamorphic
code-creation,Builtin,2,4750,0x100cc8280,4228,LoadIC_Noninlined
code-creation,Builtin,2,4750,0x100cc9320,48,LoadICTrampoline
code-creation,Builtin,2,4750,0x100cc9360,28,LoadICBaseline
code-creation,Builtin,2,4750,0x100cc9380,48,LoadICTrampoline_Megamorphic
code-creation,Builtin,2,4750,0x100cc93c0,7360,LoadSuperIC
code-creation,Builtin,2,4750,0x100ccb0a0,28,LoadSuperICBaseline
code-creation,Builtin,2,4750,0x100ccb0c0,7876,KeyedLoadIC
code-creation,Builtin,2,4750,0x100cccfa0,12456,KeyedLoadIC_Megamorphic
code-creation,Builtin,2,4750,0x100cd0060,48,KeyedLoadICTrampoline
code-creation,Builtin,2,4750,0x100cd00a0,28,KeyedLoadICBaseline
code-creation,Builtin,2,4750,0x100cd00c0,48,KeyedLoadICTrampoline_Megamorphic
code-creation,Builtin,2,4792,0x100cd0100,4708,StoreGlobalIC
code-creation,Builtin,2,4792,0x100cd1380,48,StoreGlobalICTrampoline
code-creation,Builtin,2,4792,0x100cd13c0,28,StoreGlobalICBaseline
code-creation,Builtin,2,4792,0x100cd13e0,4908,StoreIC
code-creation,Builtin,2,4792,0x100cd2720,48,StoreICTrampoline
code-creation,Builtin,2,4792,0x100cd2760,28,StoreICBaseline
code-creation,Builtin,2,4792,0x100cd2780,5324,KeyedStoreIC
code-creation,Builtin,2,4792,0x100cd3c60,48,KeyedStoreICTrampoline
code-creation,Builtin,2,4792,0x100cd3ca0,28,KeyedStoreICBaseline
code-creation,Builtin,2,4792,0x100cd3cc0,436,StoreInArrayLiteralIC
code-creation,Builtin,2,4792,0x100cd3e80,28,StoreInArrayLiteralICBaseline
code-creation,Builtin,2,4792,0x100cd3ea0,172,LookupContextBaseline
code-creation,Builtin,2,4834,0x100cd3f60,172,LookupContextInsideTypeofBaseline
code-creation,Builtin,2,4834,0x100cd4020,3252,LoadGlobalIC
code-creation,Builtin,2,4834,0x100cd4ce0,3236,LoadGlobalICInsideTypeof
code-creation,Builtin,2,4834,0x100cd59a0,48,LoadGlobalICTrampoline
code-creation,Builtin,2,4834,0x100cd59e0,28,LoadGlobalICBaseline
code-creation,Builtin,2,4834,0x100cd5a00,48,LoadGlobalICInsideTypeofTrampoline
code-creation,Builtin,2,4834,0x100cd5a40,28,LoadGlobalICInsideTypeofBaseline
code-creation,Builtin,2,4834,0x100cd5a60,164,LookupGlobalICBaseline
code-creation,Builtin,2,4834,0x100cd5b20,164,LookupGlobalICInsideTypeofBaseline
code-creation,Builtin,2,4834,0x100cd5be0,1976,CloneObjectIC
code-creation,Builtin,2,4834,0x100cd63a0,28,CloneObjectICBaseline
code-creation,Builtin,2,4875,0x100cd63c0,2224,CloneObjectIC_Slow
code-creation,Builtin,2,4875,0x100cd6c80,2480,KeyedHasIC
code-creation,Builtin,2,4875,0x100cd7640,28,KeyedHasICBaseline
code-creation,Builtin,2,4875,0x100cd7660,2692,KeyedHasIC_Megamorphic
code-creation,Builtin,2,4875,0x100cd8100,1408,IterableToList
code-creation,Builtin,2,4875,0x100cd86a0,1224,IterableToFixedArray
code-creation,Builtin,2,4875,0x100cd8b80,860,IterableToListWithSymbolLookup
code-creation,Builtin,2,4875,0x100cd8ee0,64,IterableToFixedArrayWithSymbolLookupSlow
code-creation,Builtin,2,4875,0x100cd8f40,148,IterableToListMayPreserveHoles
code-creation,Builtin,2,4875,0x100cd8fe0,1032,IterableToFixedArrayForWasm
code-creation,Builtin,2,4875,0x100cd9400,1680,StringListFromIterable
code-creation,Builtin,2,4917,0x100cd9aa0,1208,FindOrderedHashMapEntry
code-creation,Builtin,2,4917,0x100cd9f60,4296,MapConstructor
code-creation,Builtin,2,4917,0x100cdb040,1984,MapPrototypeSet
code-creation,Builtin,2,4917,0x100cdb820,1520,MapPrototypeDelete
code-creation,Builtin,2,4917,0x100cdbe20,240,MapPrototypeGet
code-creation,Builtin,2,4917,0x100cdbf20,196,MapPrototypeHas
code-creation,Builtin,2,4917,0x100cdc000,8,MapPrototypeClear
code-creation,Builtin,2,4917,0x100cdc020,300,MapPrototypeEntries
code-creation,Builtin,2,4917,0x100cdc160,164,MapPrototypeGetSize
code-creation,Builtin,2,4959,0x100cdc220,540,MapPrototypeForEach
code-creation,Builtin,2,4959,0x100cdc440,300,MapPrototypeKeys
code-creation,Builtin,2,4959,0x100cdc580,300,MapPrototypeValues
code-creation,Builtin,2,4959,0x100cdc6c0,1024,MapIteratorPrototypeNext
code-creation,Builtin,2,4959,0x100cdcae0,1140,MapIteratorToList
code-creation,Builtin,2,4959,0x100cdcf60,8,NumberPrototypeToExponential
code-creation,Builtin,2,4959,0x100cdcf80,8,NumberPrototypeToFixed
code-creation,Builtin,2,4959,0x100cdcfa0,8,NumberPrototypeToLocaleString
code-creation,Builtin,2,4959,0x100cdcfc0,8,NumberPrototypeToPrecision
code-creation,Builtin,2,4959,0x100cdcfe0,332,SameValue
code-creation,Builtin,2,4959,0x100cdd140,192,SameValueNumbersOnly
code-creation,Builtin,2,5000,0x100cdd220,788,Add_Baseline
code-creation,Builtin,2,5000,0x100cdd540,844,Subtract_Baseline
code-creation,Builtin,2,5000,0x100cdd8a0,824,Multiply_Baseline
code-creation,Builtin,2,5000,0x100cddbe0,832,Divide_Baseline
code-creation,Builtin,2,5000,0x100cddf40,692,Modulus_Baseline
code-creation,Builtin,2,5000,0x100cde200,716,Exponentiate_Baseline
code-creation,Builtin,2,5000,0x100cde4e0,612,BitwiseAnd_Baseline
code-creation,Builtin,2,5000,0x100cde760,608,BitwiseOr_Baseline
code-creation,Builtin,2,5000,0x100cde9e0,612,BitwiseXor_Baseline
code-creation,Builtin,2,5000,0x100cdec60,612,ShiftLeft_Baseline
code-creation,Builtin,2,5000,0x100cdeee0,612,ShiftRight_Baseline
code-creation,Builtin,2,5000,0x100cdf160,720,ShiftRightLogical_Baseline
code-creation,Builtin,2,5042,0x100cdf440,700,Add_WithFeedback
code-creation,Builtin,2,5042,0x100cdf700,780,Subtract_WithFeedback
code-creation,Builtin,2,5042,0x100cdfa20,776,Multiply_WithFeedback
code-creation,Builtin,2,5042,0x100cdfd40,784,Divide_WithFeedback
code-creation,Builtin,2,5042,0x100ce0060,644,Modulus_WithFeedback
code-creation,Builtin,2,5042,0x100ce0300,668,Exponentiate_WithFeedback
code-creation,Builtin,2,5042,0x100ce05a0,580,BitwiseAnd_WithFeedback
code-creation,Builtin,2,5042,0x100ce0800,580,BitwiseOr_WithFeedback
code-creation,Builtin,2,5042,0x100ce0a60,580,BitwiseXor_WithFeedback
code-creation,Builtin,2,5042,0x100ce0cc0,580,ShiftLeft_WithFeedback
code-creation,Builtin,2,5042,0x100ce0f20,580,ShiftRight_WithFeedback
code-creation,Builtin,2,5084,0x100ce1180,684,ShiftRightLogical_WithFeedback
code-creation,Builtin,2,5084,0x100ce1440,1716,Equal_Baseline
code-creation,Builtin,2,5084,0x100ce1b00,804,StrictEqual_Baseline
code-creation,Builtin,2,5084,0x100ce1e40,1240,LessThan_Baseline
code-creation,Builtin,2,5084,0x100ce2320,1240,GreaterThan_Baseline
code-creation,Builtin,2,5084,0x100ce2800,1240,LessThanOrEqual_Baseline
code-creation,Builtin,2,5084,0x100ce2ce0,1240,GreaterThanOrEqual_Baseline
code-creation,Builtin,2,5084,0x100ce31c0,1736,Equal_WithFeedback
code-creation,Builtin,2,5084,0x100ce38a0,824,StrictEqual_WithFeedback
code-creation,Builtin,2,5084,0x100ce3be0,1216,LessThan_WithFeedback
code-creation,Builtin,2,5084,0x100ce40c0,1216,GreaterThan_WithFeedback
code-creation,Builtin,2,5084,0x100ce45a0,1216,LessThanOrEqual_WithFeedback
code-creation,Builtin,2,5125,0x100ce4a80,1216,GreaterThanOrEqual_WithFeedback
code-creation,Builtin,2,5125,0x100ce4f60,284,BitwiseNot_Baseline
code-creation,Builtin,2,5125,0x100ce5080,460,Decrement_Baseline
code-creation,Builtin,2,5125,0x100ce5260,460,Increment_Baseline
code-creation,Builtin,2,5125,0x100ce5440,468,Negate_Baseline
code-creation,Builtin,2,5125,0x100ce5620,264,BitwiseNot_WithFeedback
code-creation,Builtin,2,5125,0x100ce5740,440,Decrement_WithFeedback
code-creation,Builtin,2,5125,0x100ce5900,440,Increment_WithFeedback
code-creation,Builtin,2,5125,0x100ce5ac0,448,Negate_WithFeedback
code-creation,Builtin,2,5125,0x100ce5ca0,284,ObjectAssign
code-creation,Builtin,2,5167,0x100ce5dc0,848,ObjectCreate
tick,0x1bfd3cab0,5167,0,0x0,6
code-creation,Builtin,2,5167,0x100ce6120,8,ObjectDefineGetter
code-creation,Builtin,2,5167,0x100ce6140,8,ObjectDefineProperties
code-creation,Builtin,2,5167,0x100ce6160,8,ObjectDefineProperty
code-creation,Builtin,2,5167,0x100ce6180,8,ObjectDefineSetter
code-creation,Builtin,2,5167,0x100ce61a0,1532,ObjectEntries
code-creation,Builtin,2,5167,0x100ce67a0,8,ObjectFreeze
code-creation,Builtin,2,5167,0x100ce67c0,5704,ObjectGetOwnPropertyDescriptor
code-creation,Builtin,2,5209,0x100ce7e20,8,ObjectGetOwnPropertyDescriptors
code-creation,Builtin,2,5209,0x100ce7e40,628,ObjectGetOwnPropertyNames
code-creation,Builtin,2,5209,0x100ce80c0,8,ObjectGetOwnPropertySymbols
code-creation,Builtin,2,5209,0x100ce80e0,212,ObjectHasOwn
code-creation,Builtin,2,5209,0x100ce81c0,400,ObjectIs
code-creation,Builtin,2,5209,0x100ce8360,8,ObjectIsFrozen
code-creation,Builtin,2,5209,0x100ce8380,8,ObjectIsSealed
code-creation,Builtin,2,5209,0x100ce83a0,568,ObjectKeys
code-creation,Builtin,2,5209,0x100ce85e0,8,ObjectLookupGetter
code-creation,Builtin,2,5209,0x100ce8600,8,ObjectLookupSetter
code-creation,Builtin,2,5209,0x100ce8620,2268,ObjectPrototypeHasOwnProperty
code-creation,Builtin,2,5209,0x100ce8f00,272,ObjectPrototypeIsPrototypeOf
code-creation,Builtin,2,5250,0x100ce9020,8,ObjectPrototypePropertyIsEnumerable
code-creation,Builtin,2,5250,0x100ce9040,8,ObjectPrototypeGetProto
code-creation,Builtin,2,5250,0x100ce9060,8,ObjectPrototypeSetProto
code-creation,Builtin,2,5250,0x100ce9080,8,ObjectSeal
code-creation,Builtin,2,5250,0x100ce90a0,1104,ObjectToString
code-creation,Builtin,2,5250,0x100ce9500,1264,ObjectValues
code-creation,Builtin,2,5250,0x100ce9a00,412,OrdinaryHasInstance
code-creation,Builtin,2,5250,0x100ce9ba0,432,InstanceOf
code-creation,Builtin,2,5250,0x100ce9d60,684,InstanceOf_WithFeedback
code-creation,Builtin,2,5250,0x100cea020,700,InstanceOf_Baseline
code-creation,Builtin,2,5250,0x100cea2e0,304,ForInEnumerate
code-creation,Builtin,2,5250,0x100cea420,144,ForInPrepare
code-creation,Builtin,2,5250,0x100cea4c0,2688,ForInFilter
code-creation,Builtin,2,5292,0x100ceaf60,68,ReflectApply
code-creation,Builtin,2,5292,0x100ceafc0,72,ReflectConstruct
code-creation,Builtin,2,5292,0x100ceb020,8,ReflectDefineProperty
code-creation,Builtin,2,5292,0x100ceb040,8,ReflectGetOwnPropertyDescriptor
code-creation,Builtin,2,5292,0x100ceb060,8,ReflectOwnKeys
code-creation,Builtin,2,5292,0x100ceb080,8,ReflectSet
code-creation,Builtin,2,5292,0x100ceb0a0,8,RegExpCapture1Getter
code-creation,Builtin,2,5292,0x100ceb0c0,8,RegExpCapture2Getter
code-creation,Builtin,2,5292,0x100ceb0e0,8,RegExpCapture3Getter
code-creation,Builtin,2,5292,0x100ceb100,8,RegExpCapture4Getter
code-creation,Builtin,2,5292,0x100ceb120,8,RegExpCapture5Getter
code-creation,Builtin,2,5292,0x100ceb140,8,RegExpCapture6Getter
code-creation,Builtin,2,5334,0x100ceb160,8,RegExpCapture7Getter
code-creation,Builtin,2,5334,0x100ceb180,8,RegExpCapture8Getter
code-creation,Builtin,2,5334,0x100ceb1a0,8,RegExpCapture9Getter
code-creation,Builtin,2,5334,0x100ceb1c0,2320,RegExpConstructor
code-creation,Builtin,2,5334,0x100cebae0,8,RegExpInputGetter
code-creation,Builtin,2,5334,0x100cebb00,8,RegExpInputSetter
code-creation,Builtin,2,5334,0x100cebb20,8,RegExpLastMatchGetter
code-creation,Builtin,2,5334,0x100cebb40,8,RegExpLastParenGetter
code-creation,Builtin,2,5334,0x100cebb60,8,RegExpLeftContextGetter
code-creation,Builtin,2,5334,0x100cebb80,1020,RegExpPrototypeCompile
code-creation,Builtin,2,5334,0x100cebf80,8,RegExpPrototypeToString
code-creation,Builtin,2,5334,0x100cebfa0,8,RegExpRightContextGetter
code-creation,Builtin,2,5375,0x100cebfc0,272,RegExpExecAtom
code-creation,Builtin,2,5375,0x100cec0e0,1048,RegExpExecInternal
code-creation,Builtin,2,5375,0x100cec500,8,RegExpInterpreterTrampoline
code-creation,Builtin,2,5375,0x100cec520,8,RegExpExperimentalTrampoline
code-creation,Builtin,2,5375,0x100cec540,2736,SetConstructor
code-creation,Builtin,2,5375,0x100ced000,1280,SetPrototypeHas
code-creation,Builtin,2,5375,0x100ced520,1740,SetPrototypeAdd
code-creation,Builtin,2,5375,0x100cedc00,1472,SetPrototypeDelete
code-creation,Builtin,2,5375,0x100cee1e0,8,SetPrototypeClear
code-creation,Builtin,2,5417,0x100cee200,300,SetPrototypeEntries
code-creation,Builtin,2,5417,0x100cee340,164,SetPrototypeGetSize
code-creation,Builtin,2,5417,0x100cee400,504,SetPrototypeForEach
code-creation,Builtin,2,5417,0x100cee600,300,SetPrototypeValues
code-creation,Builtin,2,5417,0x100cee740,956,SetIteratorPrototypeNext
code-creation,Builtin,2,5417,0x100ceeb00,1084,SetOrSetIteratorToList
code-creation,Builtin,2,5417,0x100ceef40,8,SharedArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,5417,0x100ceef60,8,SharedArrayBufferPrototypeSlice
code-creation,Builtin,2,5417,0x100ceef80,8,SharedArrayBufferPrototypeGrow
code-creation,Builtin,2,5417,0x100ceefa0,1236,AtomicsLoad
code-creation,Builtin,2,5417,0x100cef480,984,AtomicsStore
code-creation,Builtin,2,5459,0x100cef860,1668,AtomicsExchange
code-creation,Builtin,2,5459,0x100ceff00,2060,AtomicsCompareExchange
code-creation,Builtin,2,5459,0x100cf0720,1700,AtomicsAdd
code-creation,Builtin,2,5459,0x100cf0de0,1700,AtomicsSub
code-creation,Builtin,2,5459,0x100cf14a0,1700,AtomicsAnd
code-creation,Builtin,2,5459,0x100cf1b60,1700,AtomicsOr
code-creation,Builtin,2,5459,0x100cf2220,1700,AtomicsXor
code-creation,Builtin,2,5459,0x100cf28e0,8,AtomicsNotify
code-creation,Builtin,2,5459,0x100cf2900,8,AtomicsIsLockFree
code-creation,Builtin,2,5459,0x100cf2920,8,AtomicsWait
code-creation,Builtin,2,5459,0x100cf2940,8,AtomicsWaitAsync
code-creation,Builtin,2,5459,0x100cf2960,8,StringFromCodePoint
code-creation,Builtin,2,5500,0x100cf2980,1416,StringFromCharCode
code-creation,Builtin,2,5500,0x100cf2f20,8,StringPrototypeLastIndexOf
code-creation,Builtin,2,5500,0x100cf2f40,4388,StringPrototypeMatchAll
code-creation,Builtin,2,5500,0x100cf4080,8,StringPrototypeLocaleCompare
code-creation,Builtin,2,5500,0x100cf40a0,1304,StringPrototypeReplace
code-creation,Builtin,2,5500,0x100cf45c0,2728,StringPrototypeSplit
code-creation,Builtin,2,5500,0x100cf5080,8,StringRaw
code-creation,Builtin,2,5500,0x100cf50a0,8,SymbolConstructor
code-creation,Builtin,2,5500,0x100cf50c0,8,SymbolFor
code-creation,Builtin,2,5500,0x100cf50e0,8,SymbolKeyFor
code-creation,Builtin,2,5500,0x100cf5100,96,TypedArrayBaseConstructor
code-creation,Builtin,2,5542,0x100cf5180,320,TypedArrayConstructor
code-creation,Builtin,2,5542,0x100cf52e0,8,TypedArrayPrototypeBuffer
code-creation,Builtin,2,5542,0x100cf5300,840,TypedArrayPrototypeByteLength
code-creation,Builtin,2,5542,0x100cf5660,336,TypedArrayPrototypeByteOffset
code-creation,Builtin,2,5542,0x100cf57c0,564,TypedArrayPrototypeLength
code-creation,Builtin,2,5542,0x100cf5a00,8,TypedArrayPrototypeCopyWithin
code-creation,Builtin,2,5542,0x100cf5a20,8,TypedArrayPrototypeFill
code-creation,Builtin,2,5542,0x100cf5a40,8,TypedArrayPrototypeIncludes
code-creation,Builtin,2,5542,0x100cf5a60,8,TypedArrayPrototypeIndexOf
code-creation,Builtin,2,5542,0x100cf5a80,8,TypedArrayPrototypeLastIndexOf
code-creation,Builtin,2,5584,0x100cf5aa0,8,TypedArrayPrototypeReverse
code-creation,Builtin,2,5584,0x100cf5ac0,324,TypedArrayPrototypeToStringTag
code-creation,Builtin,2,5584,0x100cf5c20,9704,TypedArrayPrototypeMap
code-creation,Builtin,2,5584,0x100cf8220,4,GenericJSToWasmWrapper
code-creation,Builtin,2,5584,0x100cf8240,124,WasmCompileLazy
code-creation,Builtin,2,5584,0x100cf82c0,260,WasmDebugBreak
code-creation,Builtin,2,5584,0x100cf83e0,4,WasmOnStackReplace
code-creation,Builtin,2,5584,0x100cf8400,156,WasmFloat32ToNumber
code-creation,Builtin,2,5584,0x100cf84a0,160,WasmFloat64ToNumber
code-creation,Builtin,2,5584,0x100cf8560,8,WasmI32AtomicWait32
code-creation,Builtin,2,5584,0x100cf8580,8,WasmI64AtomicWait32
code-creation,Builtin,2,5625,0x100cf85a0,24,JSToWasmLazyDeoptContinuation
code-creation,Builtin,2,5625,0x100cf85c0,4444,WeakMapConstructor
code-creation,Builtin,2,5625,0x100cf9720,208,WeakMapLookupHashIndex
code-creation,Builtin,2,5625,0x100cf9800,248,WeakMapGet
code-creation,Builtin,2,5625,0x100cf9900,208,WeakMapPrototypeHas
code-creation,Builtin,2,5625,0x100cf99e0,232,WeakMapPrototypeSet
code-creation,Builtin,2,5625,0x100cf9ae0,180,WeakMapPrototypeDelete
code-creation,Builtin,2,5625,0x100cf9ba0,2916,WeakSetConstructor
code-creation,Builtin,2,5625,0x100cfa720,208,WeakSetPrototypeHas
code-creation,Builtin,2,5625,0x100cfa800,232,WeakSetPrototypeAdd
code-creation,Builtin,2,5667,0x100cfa900,180,WeakSetPrototypeDelete
code-creation,Builtin,2,5667,0x100cfa9c0,420,WeakCollectionDelete
code-creation,Builtin,2,5667,0x100cfab80,768,WeakCollectionSet
code-creation,Builtin,2,5667,0x100cfaea0,328,AsyncGeneratorResolve
code-creation,Builtin,2,5667,0x100cfb000,124,AsyncGeneratorReject
code-creation,Builtin,2,5667,0x100cfb080,2840,AsyncGeneratorYield
code-creation,Builtin,2,5667,0x100cfbba0,2972,AsyncGeneratorReturn
code-creation,Builtin,2,5667,0x100cfc740,308,AsyncGeneratorResumeNext
code-creation,Builtin,2,5667,0x100cfc880,8,AsyncGeneratorFunctionConstructor
code-creation,Builtin,2,5667,0x100cfc8a0,1028,AsyncGeneratorPrototypeNext
code-creation,Builtin,2,5667,0x100cfccc0,1024,AsyncGeneratorPrototypeReturn
code-creation,Builtin,2,5709,0x100cfd0e0,1024,AsyncGeneratorPrototypeThrow
code-creation,Builtin,2,5709,0x100cfd500,2796,AsyncGeneratorAwaitCaught
code-creation,Builtin,2,5709,0x100cfe000,2796,AsyncGeneratorAwaitUncaught
code-creation,Builtin,2,5709,0x100cfeb00,128,AsyncGeneratorAwaitResolveClosure
code-creation,Builtin,2,5709,0x100cfeba0,132,AsyncGeneratorAwaitRejectClosure
code-creation,Builtin,2,5709,0x100cfec40,128,AsyncGeneratorYieldResolveClosure
code-creation,Builtin,2,5709,0x100cfece0,128,AsyncGeneratorReturnClosedResolveClosure
code-creation,Builtin,2,5709,0x100cfed80,124,AsyncGeneratorReturnClosedRejectClosure
code-creation,Builtin,2,5709,0x100cfee00,132,AsyncGeneratorReturnResolveClosure
code-creation,Builtin,2,5709,0x100cfeea0,1604,AsyncFromSyncIteratorPrototypeNext
code-creation,Builtin,2,5750,0x100cff500,1720,AsyncFromSyncIteratorPrototypeThrow
code-creation,Builtin,2,5750,0x100cffbc0,1748,AsyncFromSyncIteratorPrototypeReturn
code-creation,Builtin,2,5750,0x100d002a0,132,AsyncIteratorValueUnwrap
code-creation,Builtin,2,5750,0x100d00340,304,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,5750,0x100d00480,304,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,5750,0x100d005c0,284,CEntry_Return1_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,5750,0x100d006e0,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,5750,0x100d00880,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,5750,0x100d00a20,304,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,5750,0x100d00b60,304,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,5792,0x100d00ca0,284,CEntry_Return2_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,5792,0x100d00dc0,400,CEntry_Return2_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,5792,0x100d00f60,400,CEntry_Return2_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,5792,0x100d01100,16,DirectCEntry
code-creation,Builtin,2,5792,0x100d01120,1188,StringAdd_CheckNone
code-creation,Builtin,2,5792,0x100d015e0,2692,SubString
code-creation,Builtin,2,5792,0x100d02080,12,StackCheck
code-creation,Builtin,2,5792,0x100d020a0,80,DoubleToI
code-creation,Builtin,2,5792,0x100d02100,2408,GetProperty
code-creation,Builtin,2,5792,0x100d02a80,2588,GetPropertyWithReceiver
code-creation,Builtin,2,5834,0x100d034a0,14700,SetProperty
code-creation,Builtin,2,5834,0x100d06e20,12724,SetPropertyInLiteral
code-creation,Builtin,2,5834,0x100d09fe0,4,MemCopyUint8Uint8
code-creation,Builtin,2,5834,0x100d0a000,4,MemMove
code-creation,Builtin,2,5834,0x100d0a020,8,IsTraceCategoryEnabled
code-creation,Builtin,2,5834,0x100d0a040,8,Trace
code-creation,Builtin,2,5834,0x100d0a060,8,FinalizationRegistryUnregister
code-creation,Builtin,2,5834,0x100d0a080,448,AsyncModuleEvaluate
code-creation,Builtin,2,5834,0x100d0a260,8,CallAsyncModuleFulfilled
code-creation,Builtin,2,5834,0x100d0a280,8,CallAsyncModuleRejected
code-creation,Builtin,2,5875,0x100d0a2a0,308,AggregateErrorConstructor
code-creation,Builtin,2,5875,0x100d0a3e0,828,ArrayPrototypeAt
code-creation,Builtin,2,5875,0x100d0a720,664,ArrayPrototypeConcat
code-creation,Builtin,2,5875,0x100d0a9c0,4988,ArrayPrototypeCopyWithin
code-creation,Builtin,2,5875,0x100d0bd40,244,ArrayEveryLoopEagerDeoptContinuation
code-creation,Builtin,2,5875,0x100d0be40,584,ArrayEveryLoopLazyDeoptContinuation
code-creation,Builtin,2,5875,0x100d0c0a0,3448,ArrayEveryLoopContinuation
code-creation,Builtin,2,5875,0x100d0ce20,1488,ArrayEvery
code-creation,Builtin,2,5875,0x100d0d400,300,ArrayFilterLoopEagerDeoptContinuation
code-creation,Builtin,2,5875,0x100d0d540,900,ArrayFilterLoopLazyDeoptContinuation
code-creation,Builtin,2,5917,0x100d0d8e0,3652,ArrayFilterLoopContinuation
code-creation,Builtin,2,5917,0x100d0e740,4324,ArrayFilter
code-creation,Builtin,2,5917,0x100d0f840,236,ArrayFindLoopEagerDeoptContinuation
code-creation,Builtin,2,5917,0x100d0f940,52,ArrayFindLoopLazyDeoptContinuation
code-creation,Builtin,2,5917,0x100d0f980,356,ArrayFindLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,5917,0x100d0fb00,544,ArrayFindLoopContinuation
code-creation,Builtin,2,5917,0x100d0fd40,1488,ArrayPrototypeFind
code-creation,Builtin,2,5917,0x100d10320,236,ArrayFindIndexLoopEagerDeoptContinuation
code-creation,Builtin,2,5917,0x100d10420,52,ArrayFindIndexLoopLazyDeoptContinuation
code-creation,Builtin,2,5917,0x100d10460,356,ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,5917,0x100d105e0,536,ArrayFindIndexLoopContinuation
code-creation,Builtin,2,5959,0x100d10800,1484,ArrayPrototypeFindIndex
code-creation,Builtin,2,5959,0x100d10de0,468,ArrayFindLastLoopContinuation
code-creation,Builtin,2,5959,0x100d10fc0,1628,ArrayPrototypeFindLast
code-creation,Builtin,2,5959,0x100d11620,460,ArrayFindLastIndexLoopContinuation
code-creation,Builtin,2,5959,0x100d11800,1624,ArrayPrototypeFindLastIndex
code-creation,Builtin,2,5959,0x100d11e60,244,ArrayForEachLoopEagerDeoptContinuation
code-creation,Builtin,2,5959,0x100d11f60,244,ArrayForEachLoopLazyDeoptContinuation
code-creation,Builtin,2,5959,0x100d12060,3344,ArrayForEachLoopContinuation
code-creation,Builtin,2,5959,0x100d12d80,1336,ArrayForEach
code-creation,Builtin,2,5959,0x100d132c0,3956,ArrayFrom
code-creation,Builtin,2,6000,0x100d14240,196,ArrayIsArray
code-creation,Builtin,2,6000,0x100d14320,396,LoadJoinElement_DictionaryElements_0
code-creation,Builtin,2,6000,0x100d144c0,64,LoadJoinElement_FastSmiOrObjectElements_0
code-creation,Builtin,2,6000,0x100d14520,168,LoadJoinElement_FastDoubleElements_0
code-creation,Builtin,2,6000,0x100d145e0,372,ConvertToLocaleString
code-creation,Builtin,2,6000,0x100d14760,856,JoinStackPush
code-creation,Builtin,2,6000,0x100d14ac0,324,JoinStackPop
code-creation,Builtin,2,6000,0x100d14c20,6524,ArrayPrototypeJoin
code-creation,Builtin,2,6000,0x100d165a0,5324,ArrayPrototypeToLocaleString
code-creation,Builtin,2,6000,0x100d17a80,280,ArrayPrototypeToString
code-creation,Builtin,2,6000,0x100d17ba0,5800,TypedArrayPrototypeJoin
tick,0x1bfd70e9c,6042,0,0x0,6
code-creation,Builtin,2,6042,0x100d19260,4588,TypedArrayPrototypeToLocaleString
code-creation,Builtin,2,6042,0x100d1a460,3488,ArrayPrototypeLastIndexOf
code-creation,Builtin,2,6042,0x100d1b220,264,ArrayMapPreLoopLazyDeoptContinuation
code-creation,Builtin,2,6042,0x100d1b340,264,ArrayMapLoopEagerDeoptContinuation
code-creation,Builtin,2,6042,0x100d1b460,504,ArrayMapLoopLazyDeoptContinuation
code-creation,Builtin,2,6042,0x100d1b660,3320,ArrayMapLoopContinuation
code-creation,Builtin,2,6042,0x100d1c360,3856,ArrayMap
code-creation,Builtin,2,6042,0x100d1d280,988,ArrayOf
code-creation,Builtin,2,6042,0x100d1d660,428,ArrayReduceRightPreLoopEagerDeoptContinuation
code-creation,Builtin,2,6084,0x100d1d820,236,ArrayReduceRightLoopEagerDeoptContinuation
code-creation,Builtin,2,6084,0x100d1d920,236,ArrayReduceRightLoopLazyDeoptContinuation
code-creation,Builtin,2,6084,0x100d1da20,3308,ArrayReduceRightLoopContinuation
code-creation,Builtin,2,6084,0x100d1e720,1888,ArrayReduceRight
code-creation,Builtin,2,6084,0x100d1eea0,212,ArrayReducePreLoopEagerDeoptContinuation
code-creation,Builtin,2,6084,0x100d1ef80,236,ArrayReduceLoopEagerDeoptContinuation
code-creation,Builtin,2,6084,0x100d1f080,236,ArrayReduceLoopLazyDeoptContinuation
code-creation,Builtin,2,6084,0x100d1f180,3428,ArrayReduceLoopContinuation
code-creation,Builtin,2,6084,0x100d1ff00,1600,ArrayReduce
code-creation,Builtin,2,6125,0x100d20560,3076,ArrayPrototypeReverse
code-creation,Builtin,2,6125,0x100d21180,3304,ArrayPrototypeShift
code-creation,Builtin,2,6125,0x100d21e80,4980,ArrayPrototypeSlice
code-creation,Builtin,2,6125,0x100d23200,244,ArraySomeLoopEagerDeoptContinuation
code-creation,Builtin,2,6125,0x100d23300,572,ArraySomeLoopLazyDeoptContinuation
code-creation,Builtin,2,6125,0x100d23540,3436,ArraySomeLoopContinuation
code-creation,Builtin,2,6125,0x100d242c0,1484,ArraySome
code-creation,Builtin,2,6125,0x100d248a0,12704,ArrayPrototypeSplice
code-creation,Builtin,2,6125,0x100d27a60,2992,ArrayPrototypeUnshift
code-creation,Builtin,2,6125,0x100d28620,316,ArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,6125,0x100d28760,328,ArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,6125,0x100d288c0,232,ArrayBufferPrototypeGetResizable
code-creation,Builtin,2,6167,0x100d289c0,316,SharedArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,6167,0x100d28b00,232,SharedArrayBufferPrototypeGetGrowable
code-creation,Builtin,2,6167,0x100d28c00,132,ArrayBufferIsView
code-creation,Builtin,2,6167,0x100d28ca0,224,ToInteger
code-creation,Builtin,2,6167,0x100d28da0,4032,FastCreateDataProperty
code-creation,Builtin,2,6167,0x100d29d80,484,CheckNumberInRange
code-creation,Builtin,2,6167,0x100d29f80,664,CheckSameObject
code-creation,Builtin,2,6167,0x100d2a220,948,BooleanConstructor
code-creation,Builtin,2,6167,0x100d2a5e0,188,BooleanPrototypeToString
code-creation,Builtin,2,6167,0x100d2a6a0,184,BooleanPrototypeValueOf
code-creation,Builtin,2,6167,0x100d2a760,1048,BigIntAddNoThrow
code-creation,Builtin,2,6167,0x100d2ab80,1144,BigIntAdd
code-creation,Builtin,2,6209,0x100d2b000,1048,BigIntSubtractNoThrow
code-creation,Builtin,2,6209,0x100d2b420,1144,BigIntSubtract
code-creation,Builtin,2,6209,0x100d2b8a0,332,BigIntUnaryMinus
code-creation,Builtin,2,6209,0x100d2ba00,1372,ToString
code-creation,Builtin,2,6209,0x100d2bf60,180,StringPrototypeToString
code-creation,Builtin,2,6209,0x100d2c020,180,StringPrototypeValueOf
code-creation,Builtin,2,6209,0x100d2c0e0,2440,StringToList
code-creation,Builtin,2,6209,0x100d2ca80,1056,StringPrototypeCharAt
code-creation,Builtin,2,6209,0x100d2cec0,728,StringPrototypeCharCodeAt
code-creation,Builtin,2,6209,0x100d2d1a0,1280,StringPrototypeCodePointAt
code-creation,Builtin,2,6209,0x100d2d6c0,428,StringPrototypeConcat
code-creation,Builtin,2,6209,0x100d2d880,1024,StringConstructor
code-creation,Builtin,2,6209,0x100d2dca0,1440,StringAddConvertLeft
code-creation,Builtin,2,6250,0x100d2e260,1492,StringAddConvertRight
code-creation,Builtin,2,6250,0x100d2e840,924,StringCharAt
code-creation,Builtin,2,6250,0x100d2ebe0,20,FastNewClosureBaseline
code-creation,Builtin,2,6250,0x100d2ec00,228,FastNewFunctionContextEval
code-creation,Builtin,2,6250,0x100d2ed00,228,FastNewFunctionContextFunction
code-creation,Builtin,2,6250,0x100d2ee00,304,CreateRegExpLiteral
code-creation,Builtin,2,6250,0x100d2ef40,1036,CreateShallowArrayLiteral
code-creation,Builtin,2,6250,0x100d2f360,540,CreateEmptyArrayLiteral
code-creation,Builtin,2,6250,0x100d2f580,1716,CreateShallowObjectLiteral
code-creation,Builtin,2,6250,0x100d2fc40,444,ObjectConstructor
code-creation,Builtin,2,6250,0x100d2fe00,200,CreateEmptyLiteralObject
code-creation,Builtin,2,6250,0x100d2fee0,616,NumberConstructor
code-creation,Builtin,2,6292,0x100d30160,96,GenericLazyDeoptContinuation
code-creation,Builtin,2,6292,0x100d301e0,92,StringToNumber
code-creation,Builtin,2,6292,0x100d30240,248,NonNumberToNumber
code-creation,Builtin,2,6292,0x100d30340,296,NonNumberToNumeric
code-creation,Builtin,2,6292,0x100d30480,60,ToNumeric
code-creation,Builtin,2,6292,0x100d304c0,1444,NumberToString
code-creation,Builtin,2,6292,0x100d30a80,128,ToBoolean
code-creation,Builtin,2,6292,0x100d30b20,128,ToBooleanForBaselineJump
code-creation,Builtin,2,6292,0x100d30bc0,568,ToLength
code-creation,Builtin,2,6292,0x100d30e00,1340,ToName
code-creation,Builtin,2,6292,0x100d31340,796,ToObject
code-creation,Builtin,2,6334,0x100d31660,276,NonPrimitiveToPrimitive_Default
code-creation,Builtin,2,6334,0x100d31780,276,NonPrimitiveToPrimitive_Number
code-creation,Builtin,2,6334,0x100d318a0,276,NonPrimitiveToPrimitive_String
code-creation,Builtin,2,6334,0x100d319c0,412,OrdinaryToPrimitive_Number
code-creation,Builtin,2,6334,0x100d31b60,412,OrdinaryToPrimitive_String
code-creation,Builtin,2,6334,0x100d31d00,272,FastConsoleAssert
code-creation,Builtin,2,6334,0x100d31e20,184,DataViewPrototypeGetBuffer
code-creation,Builtin,2,6334,0x100d31ee0,356,DataViewPrototypeGetByteLength
code-creation,Builtin,2,6334,0x100d32060,356,DataViewPrototypeGetByteOffset
code-creation,Builtin,2,6334,0x100d321e0,528,DataViewPrototypeGetUint8
code-creation,Builtin,2,6334,0x100d32400,528,DataViewPrototypeGetInt8
code-creation,Builtin,2,6334,0x100d32620,616,DataViewPrototypeGetUint16
code-creation,Builtin,2,6375,0x100d328a0,616,DataViewPrototypeGetInt16
code-creation,Builtin,2,6375,0x100d32b20,764,DataViewPrototypeGetUint32
code-creation,Builtin,2,6375,0x100d32e20,648,DataViewPrototypeGetInt32
code-creation,Builtin,2,6375,0x100d330c0,788,DataViewPrototypeGetFloat32
code-creation,Builtin,2,6375,0x100d333e0,848,DataViewPrototypeGetFloat64
code-creation,Builtin,2,6375,0x100d33740,928,DataViewPrototypeGetBigUint64
code-creation,Builtin,2,6375,0x100d33b00,956,DataViewPrototypeGetBigInt64
code-creation,Builtin,2,6375,0x100d33ec0,856,DataViewPrototypeSetUint8
code-creation,Builtin,2,6375,0x100d34220,856,DataViewPrototypeSetInt8
code-creation,Builtin,2,6375,0x100d34580,976,DataViewPrototypeSetUint16
code-creation,Builtin,2,6375,0x100d34960,976,DataViewPrototypeSetInt16
code-creation,Builtin,2,6375,0x100d34d40,1008,DataViewPrototypeSetUint32
code-creation,Builtin,2,6417,0x100d35140,1008,DataViewPrototypeSetInt32
code-creation,Builtin,2,6417,0x100d35540,1012,DataViewPrototypeSetFloat32
code-creation,Builtin,2,6417,0x100d35940,1072,DataViewPrototypeSetFloat64
code-creation,Builtin,2,6417,0x100d35d80,928,DataViewPrototypeSetBigUint64
code-creation,Builtin,2,6417,0x100d36140,928,DataViewPrototypeSetBigInt64
code-creation,Builtin,2,6417,0x100d36500,860,FinalizationRegistryConstructor
code-creation,Builtin,2,6417,0x100d36860,1104,FinalizationRegistryRegister
code-creation,Builtin,2,6417,0x100d36cc0,668,FinalizationRegistryPrototypeCleanupSome
code-creation,Builtin,2,6417,0x100d36f60,356,FunctionPrototypeHasInstance
code-creation,Builtin,2,6417,0x100d370e0,900,FastFunctionPrototypeBind
code-creation,Builtin,2,6417,0x100d37480,100,IncBlockCounter
code-creation,Builtin,2,6459,0x100d37500,324,GetTemplateObject
code-creation,Builtin,2,6459,0x100d37660,28,BytecodeBudgetInterruptFromCode
code-creation,Builtin,2,6459,0x100d37680,132,ForInNext
code-creation,Builtin,2,6459,0x100d37720,180,GetImportMetaObjectBaseline
code-creation,Builtin,2,6459,0x100d377e0,128,GetIteratorWithFeedback
code-creation,Builtin,2,6459,0x100d37880,124,GetIteratorBaseline
code-creation,Builtin,2,6459,0x100d37900,292,CreateAsyncFromSyncIteratorBaseline
code-creation,Builtin,2,6459,0x100d37a40,1132,CallIteratorWithFeedback
code-creation,Builtin,2,6459,0x100d37ec0,296,MathAbs
code-creation,Builtin,2,6459,0x100d38000,260,MathCeil
code-creation,Builtin,2,6459,0x100d38120,260,MathFloor
code-creation,Builtin,2,6459,0x100d38240,284,MathRound
code-creation,Builtin,2,6459,0x100d38360,260,MathTrunc
code-creation,Builtin,2,6500,0x100d38480,360,MathPow
code-creation,Builtin,2,6500,0x100d38600,392,MathMax
code-creation,Builtin,2,6500,0x100d387a0,392,MathMin
code-creation,Builtin,2,6500,0x100d38940,296,MathAcos
code-creation,Builtin,2,6500,0x100d38a80,296,MathAcosh
code-creation,Builtin,2,6500,0x100d38bc0,296,MathAsin
code-creation,Builtin,2,6500,0x100d38d00,296,MathAsinh
code-creation,Builtin,2,6500,0x100d38e40,296,MathAtan
code-creation,Builtin,2,6500,0x100d38f80,372,MathAtan2
code-creation,Builtin,2,6500,0x100d39100,296,MathAtanh
code-creation,Builtin,2,6500,0x100d39240,296,MathCbrt
code-creation,Builtin,2,6500,0x100d39380,160,MathClz32
code-creation,Builtin,2,6542,0x100d39440,296,MathCos
code-creation,Builtin,2,6542,0x100d39580,296,MathCosh
code-creation,Builtin,2,6542,0x100d396c0,296,MathExp
code-creation,Builtin,2,6542,0x100d39800,296,MathExpm1
code-creation,Builtin,2,6542,0x100d39940,268,MathFround
code-creation,Builtin,2,6542,0x100d39a60,232,MathImul
code-creation,Builtin,2,6542,0x100d39b60,296,MathLog
code-creation,Builtin,2,6542,0x100d39ca0,296,MathLog1p
code-creation,Builtin,2,6542,0x100d39de0,296,MathLog10
code-creation,Builtin,2,6542,0x100d39f20,296,MathLog2
code-creation,Builtin,2,6542,0x100d3a060,296,MathSin
code-creation,Builtin,2,6542,0x100d3a1a0,184,MathSign
code-creation,Builtin,2,6542,0x100d3a260,296,MathSinh
code-creation,Builtin,2,6542,0x100d3a3a0,264,MathSqrt
code-creation,Builtin,2,6584,0x100d3a4c0,296,MathTan
code-creation,Builtin,2,6584,0x100d3a600,296,MathTanh
code-creation,Builtin,2,6584,0x100d3a740,1048,MathHypot
code-creation,Builtin,2,6584,0x100d3ab60,332,MathRandom
code-creation,Builtin,2,6584,0x100d3acc0,2956,NumberPrototypeToString
code-creation,Builtin,2,6584,0x100d3b860,176,NumberIsFinite
code-creation,Builtin,2,6584,0x100d3b920,160,NumberIsInteger
code-creation,Builtin,2,6584,0x100d3b9e0,156,NumberIsNaN
code-creation,Builtin,2,6584,0x100d3ba80,188,NumberIsSafeInteger
code-creation,Builtin,2,6584,0x100d3bb40,184,NumberPrototypeValueOf
code-creation,Builtin,2,6584,0x100d3bc00,224,NumberParseFloat
code-creation,Builtin,2,6584,0x100d3bd00,192,ParseInt
code-creation,Builtin,2,6584,0x100d3bde0,112,NumberParseInt
code-creation,Builtin,2,6625,0x100d3be60,780,Add
code-creation,Builtin,2,6625,0x100d3c180,408,Subtract
code-creation,Builtin,2,6625,0x100d3c320,564,Multiply
code-creation,Builtin,2,6625,0x100d3c560,480,Divide
code-creation,Builtin,2,6625,0x100d3c760,532,Modulus
code-creation,Builtin,2,6625,0x100d3c980,496,Exponentiate
code-creation,Builtin,2,6625,0x100d3cb80,316,Negate
code-creation,Builtin,2,6625,0x100d3ccc0,124,BitwiseNot
code-creation,Builtin,2,6625,0x100d3cd40,124,Decrement
code-creation,Builtin,2,6625,0x100d3cdc0,124,Increment
code-creation,Builtin,2,6625,0x100d3ce40,372,ShiftLeft
code-creation,Builtin,2,6625,0x100d3cfc0,372,ShiftRight
code-creation,Builtin,2,6625,0x100d3d140,464,ShiftRightLogical
code-creation,Builtin,2,6667,0x100d3d320,372,BitwiseAnd
code-creation,Builtin,2,6667,0x100d3d4a0,372,BitwiseOr
code-creation,Builtin,2,6667,0x100d3d620,372,BitwiseXor
code-creation,Builtin,2,6667,0x100d3d7a0,876,LessThan
code-creation,Builtin,2,6667,0x100d3db20,876,LessThanOrEqual
code-creation,Builtin,2,6667,0x100d3dea0,876,GreaterThan
code-creation,Builtin,2,6667,0x100d3e220,876,GreaterThanOrEqual
code-creation,Builtin,2,6667,0x100d3e5a0,940,Equal
code-creation,Builtin,2,6667,0x100d3e960,368,StrictEqual
code-creation,Builtin,2,6667,0x100d3eae0,3300,ObjectFromEntries
code-creation,Builtin,2,6667,0x100d3f7e0,840,CreateObjectWithoutProperties
code-creation,Builtin,2,6709,0x100d3fb40,180,ObjectIsExtensible
code-creation,Builtin,2,6709,0x100d3fc00,184,ObjectPreventExtensions
code-creation,Builtin,2,6709,0x100d3fcc0,188,ObjectGetPrototypeOf
code-creation,Builtin,2,6709,0x100d3fd80,316,ObjectSetPrototypeOf
code-creation,Builtin,2,6709,0x100d3fec0,96,ObjectPrototypeToString
code-creation,Builtin,2,6709,0x100d3ff40,120,ObjectPrototypeValueOf
code-creation,Builtin,2,6709,0x100d3ffc0,200,ObjectPrototypeToLocaleString
code-creation,Builtin,2,6709,0x100d400a0,876,FulfillPromise
code-creation,Builtin,2,6709,0x100d40420,1008,RejectPromise
code-creation,Builtin,2,6709,0x100d40820,2432,NewPromiseCapability
code-creation,Builtin,2,6709,0x100d411c0,208,PromiseCapabilityDefaultReject
code-creation,Builtin,2,6709,0x100d412a0,192,PromiseCapabilityDefaultResolve
code-creation,Builtin,2,6750,0x100d41380,1416,PerformPromiseThen
code-creation,Builtin,2,6750,0x100d41920,688,PromiseReject
code-creation,Builtin,2,6750,0x100d41be0,336,PromiseGetCapabilitiesExecutor
code-creation,Builtin,2,6750,0x100d41d40,144,PromiseConstructorLazyDeoptContinuation
code-creation,Builtin,2,6750,0x100d41de0,4544,PromiseAll
code-creation,Builtin,2,6750,0x100d42fc0,4888,PromiseAllSettled
code-creation,Builtin,2,6750,0x100d442e0,1176,PromiseAllResolveElementClosure
code-creation,Builtin,2,6750,0x100d44780,1464,PromiseAllSettledResolveElementClosure
code-creation,Builtin,2,6750,0x100d44d40,1472,PromiseAllSettledRejectElementClosure
code-creation,Builtin,2,6792,0x100d45320,1248,PromiseAnyRejectElementClosure
code-creation,Builtin,2,6792,0x100d45820,2400,PromiseAny
code-creation,Builtin,2,6792,0x100d461a0,2996,PromiseConstructor
code-creation,Builtin,2,6792,0x100d46d60,384,PromisePrototypeCatch
code-creation,Builtin,2,6792,0x100d46f00,112,PromiseValueThunkFinally
code-creation,Builtin,2,6792,0x100d46f80,108,PromiseThrowerFinally
code-creation,Builtin,2,6792,0x100d47000,992,PromiseCatchFinally
code-creation,Builtin,2,6792,0x100d47400,992,PromiseThenFinally
code-creation,Builtin,2,6792,0x100d47800,1736,PromisePrototypeFinally
code-creation,Builtin,2,6792,0x100d47ee0,1408,PromiseRace
code-creation,Builtin,2,6792,0x100d48480,316,PromiseFulfillReactionJob
code-creation,Builtin,2,6834,0x100d485c0,424,PromiseRejectReactionJob
code-creation,Builtin,2,6834,0x100d48780,176,PromiseResolveTrampoline
code-creation,Builtin,2,6834,0x100d48840,712,PromiseResolve
code-creation,Builtin,2,6834,0x100d48b20,812,ResolvePromise
code-creation,Builtin,2,6834,0x100d48e60,2312,PromisePrototypeThen
code-creation,Builtin,2,6834,0x100d49780,1220,PromiseResolveThenableJob
code-creation,Builtin,2,6834,0x100d49c60,448,ProxyConstructor
code-creation,Builtin,2,6834,0x100d49e40,1748,ProxyDeleteProperty
code-creation,Builtin,2,6834,0x100d4a520,2076,ProxyGetProperty
code-creation,Builtin,2,6834,0x100d4ad40,1044,ProxyGetPrototypeOf
code-creation,Builtin,2,6834,0x100d4b160,1696,ProxyHasProperty
code-creation,Builtin,2,6834,0x100d4b820,800,ProxyIsExtensible
code-creation,Builtin,2,6875,0x100d4bb60,820,ProxyPreventExtensions
code-creation,Builtin,2,6875,0x100d4bea0,1124,ProxyRevocable
code-creation,Builtin,2,6875,0x100d4c320,148,ProxyRevoke
code-creation,Builtin,2,6875,0x100d4c3c0,2196,ProxySetProperty
code-creation,Builtin,2,6875,0x100d4cc60,1260,ProxySetPrototypeOf
code-creation,Builtin,2,6875,0x100d4d160,232,ReflectIsExtensible
code-creation,Builtin,2,6875,0x100d4d260,236,ReflectPreventExtensions
code-creation,Builtin,2,6875,0x100d4d360,212,ReflectGetPrototypeOf
code-creation,Builtin,2,6875,0x100d4d440,300,ReflectSetPrototypeOf
code-creation,Builtin,2,6875,0x100d4d580,312,ReflectGet
code-creation,Builtin,2,6875,0x100d4d6c0,180,ReflectDeleteProperty
code-creation,Builtin,2,6917,0x100d4d780,168,ReflectHas
code-creation,Builtin,2,6917,0x100d4d840,5004,RegExpPrototypeExecSlow
code-creation,Builtin,2,6917,0x100d4ebe0,5032,RegExpPrototypeExec
code-creation,Builtin,2,6917,0x100d4ffa0,2416,RegExpPrototypeMatchAll
code-creation,Builtin,2,6917,0x100d50920,9072,RegExpStringIteratorPrototypeNext
code-creation,Builtin,2,6917,0x100d52ca0,8620,RegExpMatchFast
code-creation,Builtin,2,6917,0x100d54e60,3520,RegExpPrototypeMatch
code-creation,Builtin,2,6917,0x100d55c40,6324,RegExpReplace
code-creation,Builtin,2,6917,0x100d57500,548,RegExpPrototypeReplace
code-creation,Builtin,2,6917,0x100d57740,1432,RegExpSearchFast
code-creation,Builtin,2,6917,0x100d57ce0,1584,RegExpPrototypeSearch
code-creation,Builtin,2,6959,0x100d58320,216,RegExpPrototypeSourceGetter
code-creation,Builtin,2,6959,0x100d58400,5636,RegExpSplit
code-creation,Builtin,2,6959,0x100d59a20,508,RegExpPrototypeSplit
code-creation,Builtin,2,6959,0x100d59c20,2248,RegExpPrototypeTest
code-creation,Builtin,2,6959,0x100d5a500,1356,RegExpPrototypeTestFast
code-creation,Builtin,2,6959,0x100d5aa60,240,RegExpPrototypeGlobalGetter
code-creation,Builtin,2,6959,0x100d5ab60,248,RegExpPrototypeIgnoreCaseGetter
code-creation,Builtin,2,6959,0x100d5ac60,248,RegExpPrototypeMultilineGetter
code-creation,Builtin,2,6959,0x100d5ad60,248,RegExpPrototypeHasIndicesGetter
code-creation,Builtin,2,6959,0x100d5ae60,248,RegExpPrototypeLinearGetter
code-creation,Builtin,2,7000,0x100d5af60,248,RegExpPrototypeDotAllGetter
code-creation,Builtin,2,7000,0x100d5b060,276,RegExpPrototypeStickyGetter
code-creation,Builtin,2,7000,0x100d5b180,276,RegExpPrototypeUnicodeGetter
code-creation,Builtin,2,7000,0x100d5b2a0,2440,RegExpPrototypeFlagsGetter
code-creation,Builtin,2,7000,0x100d5bc40,1448,StringPrototypeAt
code-creation,Builtin,2,7000,0x100d5c200,3268,StringPrototypeEndsWith
code-creation,Builtin,2,7000,0x100d5cee0,468,CreateHTML
code-creation,Builtin,2,7000,0x100d5d0c0,180,StringPrototypeAnchor
code-creation,Builtin,2,7000,0x100d5d180,156,StringPrototypeBig
code-creation,Builtin,2,7000,0x100d5d220,156,StringPrototypeBlink
code-creation,Builtin,2,7000,0x100d5d2c0,156,StringPrototypeBold
code-creation,Builtin,2,7042,0x100d5d360,188,StringPrototypeFontcolor
code-creation,Builtin,2,7042,0x100d5d420,188,StringPrototypeFontsize
code-creation,Builtin,2,7042,0x100d5d4e0,156,StringPrototypeFixed
code-creation,Builtin,2,7042,0x100d5d580,156,StringPrototypeItalics
code-creation,Builtin,2,7042,0x100d5d620,188,StringPrototypeLink
code-creation,Builtin,2,7042,0x100d5d6e0,156,StringPrototypeSmall
code-creation,Builtin,2,7042,0x100d5d780,156,StringPrototypeStrike
code-creation,Builtin,2,7042,0x100d5d820,156,StringPrototypeSub
code-creation,Builtin,2,7042,0x100d5d8c0,156,StringPrototypeSup
code-creation,Builtin,2,7042,0x100d5d960,1000,StringPrototypeIncludes
code-creation,Builtin,2,7042,0x100d5dd60,572,StringPrototypeIndexOf
code-creation,Builtin,2,7084,0x100d5dfa0,356,StringPrototypeIterator
code-creation,Builtin,2,7084,0x100d5e120,2052,StringIteratorPrototypeNext
code-creation,Builtin,2,7084,0x100d5e940,1376,StringPrototypeMatch
code-creation,Builtin,2,7084,0x100d5eec0,1376,StringPrototypeSearch
code-creation,Builtin,2,7084,0x100d5f440,832,StringPrototypePadStart
code-creation,Builtin,2,7084,0x100d5f7a0,836,StringPrototypePadEnd
code-creation,Builtin,2,7084,0x100d5fb00,132,StringRepeat
code-creation,Builtin,2,7084,0x100d5fba0,404,StringPrototypeRepeat
code-creation,Builtin,2,7084,0x100d5fd40,10760,StringPrototypeReplaceAll
code-creation,Builtin,2,7084,0x100d62760,3252,StringPrototypeSlice
code-creation,Builtin,2,7084,0x100d63420,3304,StringPrototypeStartsWith
code-creation,Builtin,2,7125,0x100d64120,3236,StringPrototypeSubstr
code-creation,Builtin,2,7125,0x100d64de0,3208,StringPrototypeSubstring
code-creation,Builtin,2,7125,0x100d65a80,7212,StringPrototypeTrim
code-creation,Builtin,2,7125,0x100d676c0,6568,StringPrototypeTrimStart
code-creation,Builtin,2,7125,0x100d69080,6132,StringPrototypeTrimEnd
code-creation,Builtin,2,7125,0x100d6a880,188,SymbolPrototypeDescriptionGetter
code-creation,Builtin,2,7125,0x100d6a940,196,SymbolPrototypeToPrimitive
tick,0x1bfba1770,7125,0,0x0,6
code-creation,Builtin,2,7125,0x100d6aa20,208,SymbolPrototypeToString
code-creation,Builtin,2,7125,0x100d6ab00,184,SymbolPrototypeValueOf
code-creation,Builtin,2,7167,0x100d6abc0,1044,TypedArrayPrototypeAt
code-creation,Builtin,2,7167,0x100d6afe0,9132,CreateTypedArray
code-creation,Builtin,2,7167,0x100d6d3a0,1676,TypedArrayPrototypeEvery
code-creation,Builtin,2,7167,0x100d6da40,428,TypedArrayPrototypeEntries
code-creation,Builtin,2,7167,0x100d6dc00,3488,TypedArrayPrototypeFilter
code-creation,Builtin,2,7167,0x100d6e9c0,1016,TypedArrayPrototypeFind
code-creation,Builtin,2,7167,0x100d6edc0,1016,TypedArrayPrototypeFindIndex
code-creation,Builtin,2,7167,0x100d6f1c0,996,TypedArrayPrototypeFindLast
code-creation,Builtin,2,7167,0x100d6f5c0,996,TypedArrayPrototypeFindLastIndex
code-creation,Builtin,2,7167,0x100d6f9c0,876,TypedArrayPrototypeForEach
code-creation,Builtin,2,7167,0x100d6fd40,2088,TypedArrayFrom
code-creation,Builtin,2,7209,0x100d70580,424,TypedArrayPrototypeKeys
code-creation,Builtin,2,7209,0x100d70740,912,TypedArrayOf
code-creation,Builtin,2,7209,0x100d70ae0,972,TypedArrayPrototypeReduce
code-creation,Builtin,2,7209,0x100d70ec0,952,TypedArrayPrototypeReduceRight
code-creation,Builtin,2,7209,0x100d71280,2420,TypedArrayPrototypeSet
code-creation,Builtin,2,7209,0x100d71c00,3428,TypedArrayPrototypeSlice
code-creation,Builtin,2,7209,0x100d72980,1656,TypedArrayPrototypeSome
code-creation,Builtin,2,7209,0x100d73000,1136,TypedArrayMergeSort
code-creation,Builtin,2,7209,0x100d73480,1520,TypedArrayPrototypeSort
code-creation,Builtin,2,7209,0x100d73a80,2524,TypedArrayPrototypeSubArray
code-creation,Builtin,2,7250,0x100d74460,428,TypedArrayPrototypeValues
code-creation,Builtin,2,7250,0x100d74620,972,WeakRefConstructor
code-creation,Builtin,2,7250,0x100d74a00,216,WeakRefDeref
code-creation,Builtin,2,7250,0x100d74ae0,776,NewSloppyArgumentsElements
code-creation,Builtin,2,7250,0x100d74e00,356,NewStrictArgumentsElements
code-creation,Builtin,2,7250,0x100d74f80,388,NewRestArgumentsElements
code-creation,Builtin,2,7250,0x100d75120,1660,FastNewSloppyArguments
code-creation,Builtin,2,7250,0x100d757a0,580,FastNewStrictArguments
code-creation,Builtin,2,7250,0x100d75a00,620,FastNewRestArguments
code-creation,Builtin,2,7250,0x100d75c80,652,StringSlowFlatten
code-creation,Builtin,2,7250,0x100d75f20,2084,StringIndexOf
code-creation,Builtin,2,7292,0x100d76760,8,GenericBuiltinTest_JSAny_0
code-creation,Builtin,2,7292,0x100d76780,16,TestHelperPlus1
code-creation,Builtin,2,7292,0x100d767a0,16,TestHelperPlus2
code-creation,Builtin,2,7292,0x100d767c0,116,NewSmiBox
code-creation,Builtin,2,7292,0x100d76840,20,ReturnTwoValues
code-creation,Builtin,2,7292,0x100d76860,44,Load_FastSmiElements_0
code-creation,Builtin,2,7292,0x100d768a0,44,Load_FastObjectElements_0
code-creation,Builtin,2,7292,0x100d768e0,168,Load_FastDoubleElements_0
code-creation,Builtin,2,7292,0x100d769a0,48,Store_FastSmiElements_0
code-creation,Builtin,2,7292,0x100d769e0,124,Store_FastObjectElements_0
code-creation,Builtin,2,7292,0x100d76a60,56,Store_FastDoubleElements_0
code-creation,Builtin,2,7292,0x100d76aa0,52,Delete_FastSmiElements_0
code-creation,Builtin,2,7334,0x100d76ae0,52,Delete_FastObjectElements_0
code-creation,Builtin,2,7334,0x100d76b20,52,Delete_FastDoubleElements_0
code-creation,Builtin,2,7334,0x100d76b60,284,SortCompareDefault
code-creation,Builtin,2,7334,0x100d76c80,128,SortCompareUserFn
code-creation,Builtin,2,7334,0x100d76d20,12,CanUseSameAccessor_GenericElementsAccessor_0
code-creation,Builtin,2,7334,0x100d76d40,356,Copy
code-creation,Builtin,2,7334,0x100d76ec0,5704,MergeAt
code-creation,Builtin,2,7334,0x100d78520,848,GallopLeft
code-creation,Builtin,2,7334,0x100d78880,884,GallopRight
code-creation,Builtin,2,7334,0x100d78c00,3880,ArrayTimSort
code-creation,Builtin,2,7334,0x100d79b40,1912,ArrayPrototypeSort
code-creation,Builtin,2,7334,0x100d7a2c0,112,WasmInt32ToHeapNumber
code-creation,Builtin,2,7375,0x100d7a340,84,WasmTaggedNonSmiToInt32
code-creation,Builtin,2,7375,0x100d7a3a0,96,WasmTaggedToFloat64
code-creation,Builtin,2,7375,0x100d7a420,96,WasmMemoryGrow
code-creation,Builtin,2,7375,0x100d7a4a0,112,WasmTableInit
code-creation,Builtin,2,7375,0x100d7a520,112,WasmTableCopy
code-creation,Builtin,2,7375,0x100d7a5a0,96,WasmTableFill
code-creation,Builtin,2,7375,0x100d7a620,76,WasmTableGrow
code-creation,Builtin,2,7375,0x100d7a680,188,WasmTableGet
code-creation,Builtin,2,7375,0x100d7a740,280,WasmTableSet
code-creation,Builtin,2,7375,0x100d7a860,112,WasmRefFunc
code-creation,Builtin,2,7375,0x100d7a8e0,180,WasmAllocateFixedArray
code-creation,Builtin,2,7375,0x100d7a9a0,40,WasmThrow
code-creation,Builtin,2,7375,0x100d7a9e0,56,WasmRethrow
code-creation,Builtin,2,7417,0x100d7aa20,44,WasmTriggerTierUp
code-creation,Builtin,2,7417,0x100d7aa60,28,WasmStackGuard
code-creation,Builtin,2,7417,0x100d7aa80,28,WasmStackOverflow
code-creation,Builtin,2,7417,0x100d7aaa0,40,WasmTraceMemory
code-creation,Builtin,2,7417,0x100d7aae0,28,WasmTraceEnter
code-creation,Builtin,2,7417,0x100d7ab00,40,WasmTraceExit
code-creation,Builtin,2,7417,0x100d7ab40,364,WasmAllocateJSArray
code-creation,Builtin,2,7417,0x100d7acc0,128,WasmAllocatePair
code-creation,Builtin,2,7417,0x100d7ad60,56,WasmAllocateRtt
code-creation,Builtin,2,7417,0x100d7ada0,56,WasmAllocateFreshRtt
code-creation,Builtin,2,7417,0x100d7ade0,144,WasmAllocateStructWithRtt
code-creation,Builtin,2,7459,0x100d7ae80,180,WasmAllocateArray_Uninitialized
code-creation,Builtin,2,7459,0x100d7af40,228,WasmAllocateArray_InitZero
code-creation,Builtin,2,7459,0x100d7b040,228,WasmAllocateArray_InitNull
code-creation,Builtin,2,7459,0x100d7b140,160,WasmArrayCopyWithChecks
code-creation,Builtin,2,7459,0x100d7b200,272,WasmAllocateObjectWrapper
code-creation,Builtin,2,7459,0x100d7b320,84,WasmSubtypeCheck
code-creation,Builtin,2,7459,0x100d7b380,12,WasmInt32ToNumber
code-creation,Builtin,2,7459,0x100d7b3a0,128,WasmUint32ToNumber
code-creation,Builtin,2,7459,0x100d7b440,132,UintPtr53ToNumber
code-creation,Builtin,2,7459,0x100d7b4e0,120,WasmAtomicNotify
code-creation,Builtin,2,7459,0x100d7b560,136,WasmI32AtomicWait64
code-creation,Builtin,2,7459,0x100d7b600,136,WasmI64AtomicWait64
code-creation,Builtin,2,7500,0x100d7b6a0,604,WasmGetOwnProperty
code-creation,Builtin,2,7500,0x100d7b900,40,WasmTrap
code-creation,Builtin,2,7500,0x100d7b940,12,ThrowWasmTrapUnreachable
code-creation,Builtin,2,7500,0x100d7b960,12,ThrowWasmTrapMemOutOfBounds
code-creation,Builtin,2,7500,0x100d7b980,12,ThrowWasmTrapUnalignedAccess
code-creation,Builtin,2,7500,0x100d7b9a0,12,ThrowWasmTrapDivByZero
code-creation,Builtin,2,7500,0x100d7b9c0,12,ThrowWasmTrapDivUnrepresentable
code-creation,Builtin,2,7500,0x100d7b9e0,12,ThrowWasmTrapRemByZero
code-creation,Builtin,2,7500,0x100d7ba00,12,ThrowWasmTrapFloatUnrepresentable
code-creation,Builtin,2,7500,0x100d7ba20,12,ThrowWasmTrapFuncSigMismatch
code-creation,Builtin,2,7500,0x100d7ba40,12,ThrowWasmTrapDataSegmentDropped
code-creation,Builtin,2,7500,0x100d7ba60,12,ThrowWasmTrapElemSegmentDropped
code-creation,Builtin,2,7542,0x100d7ba80,12,ThrowWasmTrapTableOutOfBounds
code-creation,Builtin,2,7542,0x100d7baa0,12,ThrowWasmTrapRethrowNull
code-creation,Builtin,2,7542,0x100d7bac0,12,ThrowWasmTrapNullDereference
code-creation,Builtin,2,7542,0x100d7bae0,12,ThrowWasmTrapIllegalCast
code-creation,Builtin,2,7542,0x100d7bb00,12,ThrowWasmTrapArrayOutOfBounds
code-creation,Builtin,2,7542,0x100d7bb20,12,ThrowWasmTrapArrayTooLarge
code-creation,Builtin,2,7542,0x100d7bb40,164,LoadJoinElement_GenericElementsAccessor_0
code-creation,Builtin,2,7542,0x100d7bc00,28,LoadJoinTypedElement_Int32Elements_0
code-creation,Builtin,2,7542,0x100d7bc20,128,LoadJoinTypedElement_Float32Elements_0
code-creation,Builtin,2,7542,0x100d7bcc0,124,LoadJoinTypedElement_Float64Elements_0
code-creation,Builtin,2,7542,0x100d7bd40,28,LoadJoinTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,7584,0x100d7bd60,240,LoadJoinTypedElement_BigUint64Elements_0
code-creation,Builtin,2,7584,0x100d7be60,272,LoadJoinTypedElement_BigInt64Elements_0
code-creation,Builtin,2,7584,0x100d7bf80,28,LoadJoinTypedElement_Uint8Elements_0
code-creation,Builtin,2,7584,0x100d7bfa0,28,LoadJoinTypedElement_Int8Elements_0
code-creation,Builtin,2,7584,0x100d7bfc0,28,LoadJoinTypedElement_Uint16Elements_0
code-creation,Builtin,2,7584,0x100d7bfe0,28,LoadJoinTypedElement_Int16Elements_0
code-creation,Builtin,2,7584,0x100d7c000,144,LoadJoinTypedElement_Uint32Elements_0
code-creation,Builtin,2,7584,0x100d7c0a0,12,GenericBuiltinTest_Smi_0
code-creation,Builtin,2,7584,0x100d7c0c0,52,CanUseSameAccessor_FastDoubleElements_0
code-creation,Builtin,2,7584,0x100d7c100,52,CanUseSameAccessor_FastSmiElements_0
code-creation,Builtin,2,7584,0x100d7c140,52,CanUseSameAccessor_FastObjectElements_0
code-creation,Builtin,2,7625,0x100d7c180,2804,Load_GenericElementsAccessor_0
code-creation,Builtin,2,7625,0x100d7cc80,44,Store_GenericElementsAccessor_0
code-creation,Builtin,2,7625,0x100d7ccc0,48,Delete_GenericElementsAccessor_0
code-creation,Builtin,2,7625,0x100d7cd00,28,LoadTypedElement_Int32Elements_0
code-creation,Builtin,2,7625,0x100d7cd20,168,StoreTypedElementNumeric_Int32Elements_0
code-creation,Builtin,2,7625,0x100d7cde0,180,StoreTypedElementJSAny_Int32Elements_0
code-creation,Builtin,2,7625,0x100d7cea0,128,LoadTypedElement_Float32Elements_0
code-creation,Builtin,2,7625,0x100d7cf40,36,StoreTypedElementNumeric_Float32Elements_0
code-creation,Builtin,2,7625,0x100d7cf80,184,StoreTypedElementJSAny_Float32Elements_0
code-creation,Builtin,2,7667,0x100d7d040,124,LoadTypedElement_Float64Elements_0
code-creation,Builtin,2,7667,0x100d7d0c0,32,StoreTypedElementNumeric_Float64Elements_0
code-creation,Builtin,2,7667,0x100d7d100,180,StoreTypedElementJSAny_Float64Elements_0
code-creation,Builtin,2,7667,0x100d7d1c0,28,LoadTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,7667,0x100d7d1e0,32,StoreTypedElementNumeric_Uint8ClampedElements_0
code-creation,Builtin,2,7667,0x100d7d220,264,StoreTypedElementJSAny_Uint8ClampedElements_0
code-creation,Builtin,2,7667,0x100d7d340,240,LoadTypedElement_BigUint64Elements_0
code-creation,Builtin,2,7667,0x100d7d440,72,StoreTypedElementNumeric_BigUint64Elements_0
code-creation,Builtin,2,7667,0x100d7d4a0,228,StoreTypedElementJSAny_BigUint64Elements_0
code-creation,Builtin,2,7667,0x100d7d5a0,272,LoadTypedElement_BigInt64Elements_0
code-creation,Builtin,2,7709,0x100d7d6c0,72,StoreTypedElementNumeric_BigInt64Elements_0
code-creation,Builtin,2,7709,0x100d7d720,228,StoreTypedElementJSAny_BigInt64Elements_0
code-creation,Builtin,2,7709,0x100d7d820,28,LoadTypedElement_Uint8Elements_0
code-creation,Builtin,2,7709,0x100d7d840,32,StoreTypedElementNumeric_Uint8Elements_0
code-creation,Builtin,2,7709,0x100d7d880,180,StoreTypedElementJSAny_Uint8Elements_0
code-creation,Builtin,2,7709,0x100d7d940,28,LoadTypedElement_Int8Elements_0
code-creation,Builtin,2,7709,0x100d7d960,32,StoreTypedElementNumeric_Int8Elements_0
code-creation,Builtin,2,7709,0x100d7d9a0,180,StoreTypedElementJSAny_Int8Elements_0
code-creation,Builtin,2,7709,0x100d7da60,28,LoadTypedElement_Uint16Elements_0
code-creation,Builtin,2,7709,0x100d7da80,32,StoreTypedElementNumeric_Uint16Elements_0
code-creation,Builtin,2,7709,0x100d7dac0,180,StoreTypedElementJSAny_Uint16Elements_0
code-creation,Builtin,2,7750,0x100d7db80,28,LoadTypedElement_Int16Elements_0
code-creation,Builtin,2,7750,0x100d7dba0,32,StoreTypedElementNumeric_Int16Elements_0
code-creation,Builtin,2,7750,0x100d7dbe0,180,StoreTypedElementJSAny_Int16Elements_0
code-creation,Builtin,2,7750,0x100d7dca0,144,LoadTypedElement_Uint32Elements_0
code-creation,Builtin,2,7750,0x100d7dd40,168,StoreTypedElementNumeric_Uint32Elements_0
code-creation,Builtin,2,7750,0x100d7de00,180,StoreTypedElementJSAny_Uint32Elements_0
code-creation,Builtin,2,7750,0x100d7dec0,8,CollatorConstructor
code-creation,Builtin,2,7750,0x100d7dee0,8,CollatorInternalCompare
code-creation,Builtin,2,7750,0x100d7df00,8,CollatorPrototypeCompare
code-creation,Builtin,2,7750,0x100d7df20,8,CollatorSupportedLocalesOf
code-creation,Builtin,2,7750,0x100d7df40,8,CollatorPrototypeResolvedOptions
code-creation,Builtin,2,7792,0x100d7df60,8,DatePrototypeToLocaleDateString
code-creation,Builtin,2,7792,0x100d7df80,8,DatePrototypeToLocaleString
code-creation,Builtin,2,7792,0x100d7dfa0,8,DatePrototypeToLocaleTimeString
code-creation,Builtin,2,7792,0x100d7dfc0,8,DateTimeFormatConstructor
code-creation,Builtin,2,7792,0x100d7dfe0,8,DateTimeFormatInternalFormat
code-creation,Builtin,2,7792,0x100d7e000,8,DateTimeFormatPrototypeFormat
code-creation,Builtin,2,7792,0x100d7e020,8,DateTimeFormatPrototypeFormatRange
code-creation,Builtin,2,7792,0x100d7e040,8,DateTimeFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,7792,0x100d7e060,8,DateTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,7792,0x100d7e080,8,DateTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,7792,0x100d7e0a0,8,DateTimeFormatSupportedLocalesOf
code-creation,Builtin,2,7834,0x100d7e0c0,8,DisplayNamesConstructor
code-creation,Builtin,2,7834,0x100d7e0e0,8,DisplayNamesPrototypeOf
code-creation,Builtin,2,7834,0x100d7e100,8,DisplayNamesPrototypeResolvedOptions
code-creation,Builtin,2,7834,0x100d7e120,8,DisplayNamesSupportedLocalesOf
code-creation,Builtin,2,7834,0x100d7e140,8,IntlGetCanonicalLocales
code-creation,Builtin,2,7834,0x100d7e160,8,IntlSupportedValuesOf
code-creation,Builtin,2,7834,0x100d7e180,8,ListFormatConstructor
code-creation,Builtin,2,7834,0x100d7e1a0,248,ListFormatPrototypeFormat
code-creation,Builtin,2,7834,0x100d7e2a0,248,ListFormatPrototypeFormatToParts
code-creation,Builtin,2,7834,0x100d7e3a0,8,ListFormatPrototypeResolvedOptions
code-creation,Builtin,2,7834,0x100d7e3c0,8,ListFormatSupportedLocalesOf
code-creation,Builtin,2,7875,0x100d7e3e0,8,LocaleConstructor
code-creation,Builtin,2,7875,0x100d7e400,8,LocalePrototypeBaseName
code-creation,Builtin,2,7875,0x100d7e420,8,LocalePrototypeCalendar
code-creation,Builtin,2,7875,0x100d7e440,8,LocalePrototypeCalendars
code-creation,Builtin,2,7875,0x100d7e460,8,LocalePrototypeCaseFirst
code-creation,Builtin,2,7875,0x100d7e480,8,LocalePrototypeCollation
code-creation,Builtin,2,7875,0x100d7e4a0,8,LocalePrototypeCollations
code-creation,Builtin,2,7875,0x100d7e4c0,8,LocalePrototypeHourCycle
code-creation,Builtin,2,7875,0x100d7e4e0,8,LocalePrototypeHourCycles
code-creation,Builtin,2,7875,0x100d7e500,8,LocalePrototypeLanguage
code-creation,Builtin,2,7875,0x100d7e520,8,LocalePrototypeMaximize
code-creation,Builtin,2,7875,0x100d7e540,8,LocalePrototypeMinimize
code-creation,Builtin,2,7917,0x100d7e560,8,LocalePrototypeNumeric
code-creation,Builtin,2,7917,0x100d7e580,8,LocalePrototypeNumberingSystem
code-creation,Builtin,2,7917,0x100d7e5a0,8,LocalePrototypeNumberingSystems
code-creation,Builtin,2,7917,0x100d7e5c0,8,LocalePrototypeRegion
code-creation,Builtin,2,7917,0x100d7e5e0,8,LocalePrototypeScript
code-creation,Builtin,2,7917,0x100d7e600,8,LocalePrototypeTextInfo
code-creation,Builtin,2,7917,0x100d7e620,8,LocalePrototypeTimeZones
code-creation,Builtin,2,7917,0x100d7e640,8,LocalePrototypeToString
code-creation,Builtin,2,7917,0x100d7e660,8,LocalePrototypeWeekInfo
code-creation,Builtin,2,7917,0x100d7e680,8,NumberFormatConstructor
code-creation,Builtin,2,7959,0x100d7e6a0,8,NumberFormatInternalFormatNumber
code-creation,Builtin,2,7959,0x100d7e6c0,8,NumberFormatPrototypeFormatNumber
code-creation,Builtin,2,7959,0x100d7e6e0,8,NumberFormatPrototypeFormatToParts
code-creation,Builtin,2,7959,0x100d7e700,8,NumberFormatPrototypeResolvedOptions
code-creation,Builtin,2,7959,0x100d7e720,8,NumberFormatSupportedLocalesOf
code-creation,Builtin,2,7959,0x100d7e740,8,PluralRulesConstructor
code-creation,Builtin,2,7959,0x100d7e760,8,PluralRulesPrototypeResolvedOptions
code-creation,Builtin,2,7959,0x100d7e780,8,PluralRulesPrototypeSelect
code-creation,Builtin,2,7959,0x100d7e7a0,8,PluralRulesSupportedLocalesOf
code-creation,Builtin,2,7959,0x100d7e7c0,8,RelativeTimeFormatConstructor
code-creation,Builtin,2,8000,0x100d7e7e0,8,RelativeTimeFormatPrototypeFormat
code-creation,Builtin,2,8000,0x100d7e800,8,RelativeTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,8000,0x100d7e820,8,RelativeTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,8000,0x100d7e840,8,RelativeTimeFormatSupportedLocalesOf
code-creation,Builtin,2,8000,0x100d7e860,8,SegmenterConstructor
code-creation,Builtin,2,8000,0x100d7e880,8,SegmenterPrototypeResolvedOptions
code-creation,Builtin,2,8000,0x100d7e8a0,8,SegmenterPrototypeSegment
code-creation,Builtin,2,8000,0x100d7e8c0,8,SegmenterSupportedLocalesOf
code-creation,Builtin,2,8000,0x100d7e8e0,8,SegmentIteratorPrototypeNext
code-creation,Builtin,2,8000,0x100d7e900,8,SegmentsPrototypeContaining
code-creation,Builtin,2,8042,0x100d7e920,8,SegmentsPrototypeIterator
code-creation,Builtin,2,8042,0x100d7e940,8,StringPrototypeNormalizeIntl
code-creation,Builtin,2,8042,0x100d7e960,8,StringPrototypeToLocaleLowerCase
code-creation,Builtin,2,8042,0x100d7e980,8,StringPrototypeToLocaleUpperCase
code-creation,Builtin,2,8042,0x100d7e9a0,220,StringPrototypeToLowerCaseIntl
code-creation,Builtin,2,8042,0x100d7ea80,8,StringPrototypeToUpperCaseIntl
code-creation,Builtin,2,8042,0x100d7eaa0,720,StringToLowerCaseIntl
code-creation,Builtin,2,8042,0x100d7ed80,8,V8BreakIteratorConstructor
code-creation,Builtin,2,8042,0x100d7eda0,8,V8BreakIteratorInternalAdoptText
code-creation,Builtin,2,8042,0x100d7edc0,8,V8BreakIteratorInternalBreakType
code-creation,Builtin,2,8084,0x100d7ede0,8,V8BreakIteratorInternalCurrent
code-creation,Builtin,2,8084,0x100d7ee00,8,V8BreakIteratorInternalFirst
code-creation,Builtin,2,8084,0x100d7ee20,8,V8BreakIteratorInternalNext
code-creation,Builtin,2,8084,0x100d7ee40,8,V8BreakIteratorPrototypeAdoptText
code-creation,Builtin,2,8084,0x100d7ee60,8,V8BreakIteratorPrototypeBreakType
code-creation,Builtin,2,8084,0x100d7ee80,8,V8BreakIteratorPrototypeCurrent
code-creation,Builtin,2,8084,0x100d7eea0,8,V8BreakIteratorPrototypeFirst
code-creation,Builtin,2,8084,0x100d7eec0,8,V8BreakIteratorPrototypeNext
code-creation,Builtin,2,8084,0x100d7eee0,8,V8BreakIteratorPrototypeResolvedOptions
code-creation,Builtin,2,8084,0x100d7ef00,8,V8BreakIteratorSupportedLocalesOf
code-creation,BytecodeHandler,0,8125,0x100d7ef20,28,Wide
code-creation,BytecodeHandler,0,8125,0x100d7ef40,28,ExtraWide
code-creation,BytecodeHandler,0,8125,0x100d7ef60,124,DebugBreakWide
code-creation,BytecodeHandler,0,8125,0x100d7efe0,124,DebugBreakExtraWide
code-creation,BytecodeHandler,0,8125,0x100d7f060,188,DebugBreak0
code-creation,BytecodeHandler,0,8125,0x100d7f120,124,DebugBreak1
code-creation,BytecodeHandler,0,8125,0x100d7f1a0,124,DebugBreak2
code-creation,BytecodeHandler,0,8125,0x100d7f220,124,DebugBreak3
code-creation,BytecodeHandler,0,8125,0x100d7f2a0,124,DebugBreak4
code-creation,BytecodeHandler,0,8125,0x100d7f320,124,DebugBreak5
code-creation,BytecodeHandler,0,8125,0x100d7f3a0,124,DebugBreak6
code-creation,BytecodeHandler,0,8167,0x100d7f420,44,Ldar
code-creation,BytecodeHandler,0,8167,0x100d7f460,76,LdaZero
code-creation,BytecodeHandler,0,8167,0x100d7f4c0,84,LdaSmi
code-creation,BytecodeHandler,0,8167,0x100d7f520,76,LdaUndefined
code-creation,BytecodeHandler,0,8167,0x100d7f580,76,LdaNull
code-creation,BytecodeHandler,0,8167,0x100d7f5e0,76,LdaTheHole
code-creation,BytecodeHandler,0,8167,0x100d7f640,28,LdaTrue
code-creation,BytecodeHandler,0,8167,0x100d7f660,28,LdaFalse
code-creation,BytecodeHandler,0,8167,0x100d7f680,92,LdaConstant
code-creation,BytecodeHandler,0,8167,0x100d7f6e0,168,LdaContextSlot
code-creation,BytecodeHandler,0,8167,0x100d7f7a0,168,LdaImmutableContextSlot
code-creation,BytecodeHandler,0,8209,0x100d7f860,112,LdaCurrentContextSlot
code-creation,BytecodeHandler,0,8209,0x100d7f8e0,112,LdaImmutableCurrentContextSlot
code-creation,BytecodeHandler,0,8209,0x100d7f960,40,Star
code-creation,BytecodeHandler,0,8209,0x100d7f9a0,52,Mov
code-creation,BytecodeHandler,0,8209,0x100d7f9e0,48,PushContext
code-creation,BytecodeHandler,0,8209,0x100d7fa20,44,PopContext
code-creation,BytecodeHandler,0,8209,0x100d7fa60,64,TestReferenceEqual
code-creation,BytecodeHandler,0,8209,0x100d7fac0,64,TestUndetectable
code-creation,BytecodeHandler,0,8209,0x100d7fb20,52,TestNull
code-creation,BytecodeHandler,0,8209,0x100d7fb60,52,TestUndefined
code-creation,BytecodeHandler,0,8209,0x100d7fba0,388,TestTypeOf
code-creation,BytecodeHandler,0,8250,0x100d7fd40,6108,LdaGlobal
code-creation,BytecodeHandler,0,8250,0x100d81520,4580,LdaGlobalInsideTypeof
code-creation,BytecodeHandler,0,8250,0x100d82720,184,StaGlobal
code-creation,BytecodeHandler,0,8250,0x100d827e0,200,StaContextSlot
code-creation,BytecodeHandler,0,8250,0x100d828c0,144,StaCurrentContextSlot
code-creation,BytecodeHandler,0,8250,0x100d82960,152,LdaLookupSlot
code-creation,BytecodeHandler,0,8250,0x100d82a00,308,LdaLookupContextSlot
code-creation,BytecodeHandler,0,8250,0x100d82b40,4920,LdaLookupGlobalSlot
code-creation,BytecodeHandler,0,8250,0x100d83e80,152,LdaLookupSlotInsideTypeof
code-creation,BytecodeHandler,0,8250,0x100d83f20,308,LdaLookupContextSlotInsideTypeof
code-creation,BytecodeHandler,0,8292,0x100d84060,4848,LdaLookupGlobalSlotInsideTypeof
code-creation,BytecodeHandler,0,8292,0x100d85360,256,StaLookupSlot
code-creation,BytecodeHandler,0,8292,0x100d85480,5096,LdaNamedProperty
code-creation,BytecodeHandler,0,8292,0x100d86880,208,LdaNamedPropertyFromSuper
code-creation,BytecodeHandler,0,8292,0x100d86960,240,LdaKeyedProperty
code-creation,BytecodeHandler,0,8292,0x100d86a60,216,LdaModuleVariable
code-creation,BytecodeHandler,0,8292,0x100d86b40,356,StaModuleVariable
code-creation,BytecodeHandler,0,8292,0x100d86cc0,200,StaNamedProperty
code-creation,BytecodeHandler,0,8292,0x100d86da0,200,StaNamedOwnProperty
code-creation,BytecodeHandler,0,8334,0x100d86e80,192,StaKeyedProperty
code-creation,BytecodeHandler,0,8334,0x100d86f60,192,StaInArrayLiteral
code-creation,BytecodeHandler,0,8334,0x100d87040,228,StaDataPropertyInLiteral
code-creation,BytecodeHandler,0,8334,0x100d87140,188,CollectTypeProfile
code-creation,BytecodeHandler,0,8334,0x100d87200,992,Add
code-creation,BytecodeHandler,0,8334,0x100d87600,1032,Sub
code-creation,BytecodeHandler,0,8334,0x100d87a20,988,Mul
code-creation,BytecodeHandler,0,8334,0x100d87e00,940,Div
code-creation,BytecodeHandler,0,8334,0x100d881c0,840,Mod
code-creation,BytecodeHandler,0,8334,0x100d88520,884,Exp
code-creation,BytecodeHandler,0,8334,0x100d888a0,784,BitwiseOr
code-creation,BytecodeHandler,0,8334,0x100d88bc0,796,BitwiseXor
code-creation,BytecodeHandler,0,8375,0x100d88ee0,796,BitwiseAnd
code-creation,BytecodeHandler,0,8375,0x100d89200,796,ShiftLeft
code-creation,BytecodeHandler,0,8375,0x100d89520,796,ShiftRight
code-creation,BytecodeHandler,0,8375,0x100d89840,908,ShiftRightLogical
code-creation,BytecodeHandler,0,8375,0x100d89be0,968,AddSmi
code-creation,BytecodeHandler,0,8375,0x100d89fc0,996,SubSmi
code-creation,BytecodeHandler,0,8375,0x100d8a3c0,908,MulSmi
code-creation,BytecodeHandler,0,8375,0x100d8a760,992,DivSmi
code-creation,BytecodeHandler,0,8375,0x100d8ab60,792,ModSmi
code-creation,BytecodeHandler,0,8375,0x100d8ae80,796,ExpSmi
code-creation,BytecodeHandler,0,8375,0x100d8b1a0,468,BitwiseOrSmi
code-creation,BytecodeHandler,0,8375,0x100d8b380,468,BitwiseXorSmi
code-creation,BytecodeHandler,0,8417,0x100d8b560,468,BitwiseAndSmi
code-creation,BytecodeHandler,0,8417,0x100d8b740,468,ShiftLeftSmi
code-creation,BytecodeHandler,0,8417,0x100d8b920,468,ShiftRightSmi
code-creation,BytecodeHandler,0,8417,0x100d8bb00,604,ShiftRightLogicalSmi
code-creation,BytecodeHandler,0,8417,0x100d8bd60,664,Inc
code-creation,BytecodeHandler,0,8417,0x100d8c000,664,Dec
code-creation,BytecodeHandler,0,8417,0x100d8c2a0,624,Negate
code-creation,BytecodeHandler,0,8417,0x100d8c520,452,BitwiseNot
code-creation,BytecodeHandler,0,8417,0x100d8c700,140,ToBooleanLogicalNot
code-creation,BytecodeHandler,0,8417,0x100d8c7a0,44,LogicalNot
code-creation,BytecodeHandler,0,8417,0x100d8c7e0,216,TypeOf
code-creation,BytecodeHandler,0,8459,0x100d8c8c0,132,DeletePropertyStrict
code-creation,BytecodeHandler,0,8459,0x100d8c960,132,DeletePropertySloppy
code-creation,BytecodeHandler,0,8459,0x100d8ca00,48,GetSuperConstructor
code-creation,BytecodeHandler,0,8459,0x100d8ca40,972,CallAnyReceiver
code-creation,BytecodeHandler,0,8459,0x100d8ce20,972,CallProperty
code-creation,BytecodeHandler,0,8459,0x100d8d200,980,CallProperty0
code-creation,BytecodeHandler,0,8459,0x100d8d5e0,992,CallProperty1
code-creation,BytecodeHandler,0,8459,0x100d8d9e0,1012,CallProperty2
code-creation,BytecodeHandler,0,8459,0x100d8dde0,960,CallUndefinedReceiver
code-creation,BytecodeHandler,0,8459,0x100d8e1c0,956,CallUndefinedReceiver0
code-creation,BytecodeHandler,0,8500,0x100d8e580,968,CallUndefinedReceiver1
code-creation,BytecodeHandler,0,8500,0x100d8e960,988,CallUndefinedReceiver2
code-creation,BytecodeHandler,0,8500,0x100d8ed40,972,CallWithSpread
code-creation,BytecodeHandler,0,8500,0x100d8f120,140,CallRuntime
code-creation,BytecodeHandler,0,8500,0x100d8f1c0,176,CallRuntimeForPair
code-creation,BytecodeHandler,0,8500,0x100d8f280,100,CallJSRuntime
code-creation,BytecodeHandler,0,8500,0x100d8f300,1384,InvokeIntrinsic
code-creation,BytecodeHandler,0,8500,0x100d8f880,996,Construct
code-creation,BytecodeHandler,0,8500,0x100d8fc80,512,ConstructWithSpread
code-creation,BytecodeHandler,0,8500,0x100d8fea0,1976,TestEqual
code-creation,BytecodeHandler,0,8500,0x100d90660,952,TestEqualStrict
code-creation,BytecodeHandler,0,8542,0x100d90a20,1636,TestLessThan
code-creation,BytecodeHandler,0,8542,0x100d910a0,1636,TestGreaterThan
code-creation,BytecodeHandler,0,8542,0x100d91720,1636,TestLessThanOrEqual
code-creation,BytecodeHandler,0,8542,0x100d91da0,1636,TestGreaterThanOrEqual
code-creation,BytecodeHandler,0,8542,0x100d92420,872,TestInstanceOf
code-creation,BytecodeHandler,0,8542,0x100d927a0,184,TestIn
code-creation,BytecodeHandler,0,8542,0x100d92860,128,ToName
code-creation,BytecodeHandler,0,8542,0x100d92900,244,ToNumber
code-creation,BytecodeHandler,0,8542,0x100d92a00,264,ToNumeric
code-creation,BytecodeHandler,0,8542,0x100d92b20,128,ToObject
code-creation,BytecodeHandler,0,8584,0x100d92bc0,156,ToString
code-creation,BytecodeHandler,0,8584,0x100d92c60,464,CreateRegExpLiteral
code-creation,BytecodeHandler,0,8584,0x100d92e40,1436,CreateArrayLiteral
code-creation,BytecodeHandler,0,8584,0x100d933e0,108,CreateArrayFromIterable
code-creation,BytecodeHandler,0,8584,0x100d93460,860,CreateEmptyArrayLiteral
code-creation,BytecodeHandler,0,8584,0x100d937c0,2144,CreateObjectLiteral
code-creation,BytecodeHandler,0,8584,0x100d94040,248,CreateEmptyObjectLiteral
code-creation,BytecodeHandler,0,8584,0x100d94140,192,CloneObject
code-creation,BytecodeHandler,0,8584,0x100d94220,240,GetTemplateObject
code-creation,BytecodeHandler,0,8584,0x100d94320,380,CreateClosure
code-creation,BytecodeHandler,0,8625,0x100d944a0,140,CreateBlockContext
code-creation,BytecodeHandler,0,8625,0x100d94540,148,CreateCatchContext
code-creation,BytecodeHandler,0,8625,0x100d945e0,304,CreateFunctionContext
code-creation,BytecodeHandler,0,8625,0x100d94720,304,CreateEvalContext
code-creation,BytecodeHandler,0,8625,0x100d94860,148,CreateWithContext
code-creation,BytecodeHandler,0,8625,0x100d94900,1948,CreateMappedArguments
code-creation,BytecodeHandler,0,8625,0x100d950a0,660,CreateUnmappedArguments
code-creation,BytecodeHandler,0,8625,0x100d95340,700,CreateRestParameter
code-creation,BytecodeHandler,0,8625,0x100d95600,472,JumpLoop
code-creation,BytecodeHandler,0,8625,0x100d957e0,60,Jump
code-creation,BytecodeHandler,0,8625,0x100d95820,80,JumpConstant
code-creation,BytecodeHandler,0,8667,0x100d95880,112,JumpIfNullConstant
code-creation,BytecodeHandler,0,8667,0x100d95900,112,JumpIfNotNullConstant
code-creation,BytecodeHandler,0,8667,0x100d95980,112,JumpIfUndefinedConstant
code-creation,BytecodeHandler,0,8667,0x100d95a00,112,JumpIfNotUndefinedConstant
code-creation,BytecodeHandler,0,8667,0x100d95a80,124,JumpIfUndefinedOrNullConstant
code-creation,BytecodeHandler,0,8667,0x100d95b00,112,JumpIfTrueConstant
code-creation,BytecodeHandler,0,8667,0x100d95b80,112,JumpIfFalseConstant
code-creation,BytecodeHandler,0,8667,0x100d95c00,120,JumpIfJSReceiverConstant
code-creation,BytecodeHandler,0,8667,0x100d95c80,208,JumpIfToBooleanTrueConstant
code-creation,BytecodeHandler,0,8667,0x100d95d60,208,JumpIfToBooleanFalseConstant
code-creation,BytecodeHandler,0,8709,0x100d95e40,188,JumpIfToBooleanTrue
code-creation,BytecodeHandler,0,8709,0x100d95f00,188,JumpIfToBooleanFalse
code-creation,BytecodeHandler,0,8709,0x100d95fc0,92,JumpIfTrue
code-creation,BytecodeHandler,0,8709,0x100d96020,92,JumpIfFalse
code-creation,BytecodeHandler,0,8709,0x100d96080,92,JumpIfNull
code-creation,BytecodeHandler,0,8709,0x100d960e0,92,JumpIfNotNull
code-creation,BytecodeHandler,0,8709,0x100d96140,92,JumpIfUndefined
code-creation,BytecodeHandler,0,8709,0x100d961a0,92,JumpIfNotUndefined
code-creation,BytecodeHandler,0,8709,0x100d96200,104,JumpIfUndefinedOrNull
code-creation,BytecodeHandler,0,8709,0x100d96280,100,JumpIfJSReceiver
code-creation,BytecodeHandler,0,8709,0x100d96300,140,SwitchOnSmiNoFeedback
code-creation,BytecodeHandler,0,8750,0x100d963a0,556,ForInEnumerate
code-creation,BytecodeHandler,0,8750,0x100d965e0,272,ForInPrepare
code-creation,BytecodeHandler,0,8750,0x100d96700,76,ForInContinue
code-creation,BytecodeHandler,0,8750,0x100d96760,304,ForInNext
code-creation,BytecodeHandler,0,8750,0x100d968a0,48,ForInStep
code-creation,BytecodeHandler,0,8750,0x100d968e0,36,SetPendingMessage
code-creation,BytecodeHandler,0,8750,0x100d96920,132,Throw
code-creation,BytecodeHandler,0,8750,0x100d969c0,132,ReThrow
code-creation,BytecodeHandler,0,8750,0x100d96a60,132,Return
code-creation,BytecodeHandler,0,8750,0x100d96b00,232,ThrowReferenceErrorIfHole
code-creation,BytecodeHandler,0,8750,0x100d96c00,152,ThrowSuperNotCalledIfHole
code-creation,BytecodeHandler,0,8792,0x100d96ca0,152,ThrowSuperAlreadyCalledIfNotHole
code-creation,BytecodeHandler,0,8792,0x100d96d40,176,ThrowIfNotSuperConstructor
code-creation,BytecodeHandler,0,8792,0x100d96e00,148,SwitchOnGeneratorState
code-creation,BytecodeHandler,0,8792,0x100d96ea0,552,SuspendGenerator
code-creation,BytecodeHandler,0,8792,0x100d970e0,160,ResumeGenerator
code-creation,BytecodeHandler,0,8792,0x100d971a0,172,GetIterator
code-creation,BytecodeHandler,0,8792,0x100d97260,128,Debugger
code-creation,BytecodeHandler,0,8792,0x100d97300,136,IncBlockCounter
code-creation,BytecodeHandler,0,8792,0x100d973a0,76,Abort
code-creation,BytecodeHandler,0,8792,0x100d97400,44,Star0
code-creation,BytecodeHandler,0,8834,0x100d97440,72,Illegal
code-creation,BytecodeHandler,0,8834,0x100d974a0,128,DebugBreak1.Wide
code-creation,BytecodeHandler,0,8834,0x100d97540,128,DebugBreak2.Wide
code-creation,BytecodeHandler,0,8834,0x100d975e0,128,DebugBreak3.Wide
code-creation,BytecodeHandler,0,8834,0x100d97680,128,DebugBreak4.Wide
code-creation,BytecodeHandler,0,8834,0x100d97720,128,DebugBreak5.Wide
code-creation,BytecodeHandler,0,8834,0x100d977c0,128,DebugBreak6.Wide
code-creation,BytecodeHandler,0,8834,0x100d97860,44,Ldar.Wide
code-creation,BytecodeHandler,0,8834,0x100d978a0,40,LdaSmi.Wide
code-creation,BytecodeHandler,0,8834,0x100d978e0,48,LdaConstant.Wide
code-creation,BytecodeHandler,0,8834,0x100d97920,128,LdaContextSlot.Wide
code-creation,BytecodeHandler,0,8875,0x100d979c0,128,LdaImmutableContextSlot.Wide
code-creation,BytecodeHandler,0,8875,0x100d97a60,72,LdaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,8875,0x100d97ac0,72,LdaImmutableCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,8875,0x100d97b20,40,Star.Wide
tick,0x1bfd70f34,8875,0,0x0,6
code-creation,BytecodeHandler,0,8875,0x100d97b60,52,Mov.Wide
code-creation,BytecodeHandler,0,8875,0x100d97ba0,48,PushContext.Wide
code-creation,BytecodeHandler,0,8875,0x100d97be0,44,PopContext.Wide
code-creation,BytecodeHandler,0,8917,0x100d97c20,64,TestReferenceEqual.Wide
code-creation,BytecodeHandler,0,8917,0x100d97c80,4748,LdaGlobal.Wide
code-creation,BytecodeHandler,0,8917,0x100d98f20,4648,LdaGlobalInsideTypeof.Wide
code-creation,BytecodeHandler,0,8917,0x100d9a160,188,StaGlobal.Wide
code-creation,BytecodeHandler,0,8917,0x100d9a220,200,StaContextSlot.Wide
code-creation,BytecodeHandler,0,8917,0x100d9a300,144,StaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,8917,0x100d9a3a0,156,LdaLookupSlot.Wide
code-creation,BytecodeHandler,0,8917,0x100d9a440,312,LdaLookupContextSlot.Wide
code-creation,BytecodeHandler,0,8917,0x100d9a580,4996,LdaLookupGlobalSlot.Wide
code-creation,BytecodeHandler,0,8917,0x100d9b920,156,LdaLookupSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,8917,0x100d9b9c0,312,LdaLookupContextSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,8959,0x100d9bb00,4920,LdaLookupGlobalSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,8959,0x100d9ce40,252,StaLookupSlot.Wide
code-creation,BytecodeHandler,0,8959,0x100d9cf40,5128,LdaNamedProperty.Wide
code-creation,BytecodeHandler,0,8959,0x100d9e360,212,LdaNamedPropertyFromSuper.Wide
code-creation,BytecodeHandler,0,8959,0x100d9e440,188,LdaKeyedProperty.Wide
code-creation,BytecodeHandler,0,8959,0x100d9e500,216,LdaModuleVariable.Wide
code-creation,BytecodeHandler,0,8959,0x100d9e5e0,360,StaModuleVariable.Wide
code-creation,BytecodeHandler,0,8959,0x100d9e760,204,StaNamedProperty.Wide
code-creation,BytecodeHandler,0,8959,0x100d9e840,204,StaNamedOwnProperty.Wide
code-creation,BytecodeHandler,0,8959,0x100d9e920,196,StaKeyedProperty.Wide
code-creation,BytecodeHandler,0,9000,0x100d9ea00,196,StaInArrayLiteral.Wide
code-creation,BytecodeHandler,0,9000,0x100d9eae0,232,StaDataPropertyInLiteral.Wide
code-creation,BytecodeHandler,0,9000,0x100d9ebe0,192,CollectTypeProfile.Wide
code-creation,BytecodeHandler,0,9000,0x100d9ecc0,944,Add.Wide
code-creation,BytecodeHandler,0,9000,0x100d9f080,988,Sub.Wide
code-creation,BytecodeHandler,0,9000,0x100d9f460,936,Mul.Wide
code-creation,BytecodeHandler,0,9000,0x100d9f820,944,Div.Wide
code-creation,BytecodeHandler,0,9000,0x100d9fbe0,860,Mod.Wide
code-creation,BytecodeHandler,0,9000,0x100d9ff40,904,Exp.Wide
code-creation,BytecodeHandler,0,9000,0x100da02e0,796,BitwiseOr.Wide
code-creation,BytecodeHandler,0,9000,0x100da0600,808,BitwiseXor.Wide
code-creation,BytecodeHandler,0,9042,0x100da0940,808,BitwiseAnd.Wide
code-creation,BytecodeHandler,0,9042,0x100da0c80,808,ShiftLeft.Wide
code-creation,BytecodeHandler,0,9042,0x100da0fc0,808,ShiftRight.Wide
code-creation,BytecodeHandler,0,9042,0x100da1300,916,ShiftRightLogical.Wide
code-creation,BytecodeHandler,0,9042,0x100da16a0,924,AddSmi.Wide
code-creation,BytecodeHandler,0,9042,0x100da1a40,956,SubSmi.Wide
code-creation,BytecodeHandler,0,9042,0x100da1e00,908,MulSmi.Wide
code-creation,BytecodeHandler,0,9042,0x100da21a0,992,DivSmi.Wide
code-creation,BytecodeHandler,0,9042,0x100da25a0,792,ModSmi.Wide
code-creation,BytecodeHandler,0,9042,0x100da28c0,796,ExpSmi.Wide
code-creation,BytecodeHandler,0,9042,0x100da2be0,476,BitwiseOrSmi.Wide
code-creation,BytecodeHandler,0,9042,0x100da2dc0,476,BitwiseXorSmi.Wide
code-creation,BytecodeHandler,0,9084,0x100da2fa0,476,BitwiseAndSmi.Wide
code-creation,BytecodeHandler,0,9084,0x100da3180,476,ShiftLeftSmi.Wide
code-creation,BytecodeHandler,0,9084,0x100da3360,476,ShiftRightSmi.Wide
code-creation,BytecodeHandler,0,9084,0x100da3540,612,ShiftRightLogicalSmi.Wide
code-creation,BytecodeHandler,0,9084,0x100da37c0,624,Inc.Wide
code-creation,BytecodeHandler,0,9084,0x100da3a40,624,Dec.Wide
code-creation,BytecodeHandler,0,9084,0x100da3cc0,632,Negate.Wide
code-creation,BytecodeHandler,0,9084,0x100da3f40,460,BitwiseNot.Wide
code-creation,BytecodeHandler,0,9084,0x100da4120,136,DeletePropertyStrict.Wide
code-creation,BytecodeHandler,0,9084,0x100da41c0,136,DeletePropertySloppy.Wide
code-creation,BytecodeHandler,0,9084,0x100da4260,48,GetSuperConstructor.Wide
code-creation,BytecodeHandler,0,9125,0x100da42a0,976,CallAnyReceiver.Wide
code-creation,BytecodeHandler,0,9125,0x100da4680,976,CallProperty.Wide
code-creation,BytecodeHandler,0,9125,0x100da4a60,984,CallProperty0.Wide
code-creation,BytecodeHandler,0,9125,0x100da4e40,996,CallProperty1.Wide
code-creation,BytecodeHandler,0,9125,0x100da5240,1016,CallProperty2.Wide
code-creation,BytecodeHandler,0,9125,0x100da5640,964,CallUndefinedReceiver.Wide
code-creation,BytecodeHandler,0,9125,0x100da5a20,960,CallUndefinedReceiver0.Wide
code-creation,BytecodeHandler,0,9125,0x100da5e00,972,CallUndefinedReceiver1.Wide
code-creation,BytecodeHandler,0,9125,0x100da61e0,992,CallUndefinedReceiver2.Wide
code-creation,BytecodeHandler,0,9125,0x100da65e0,976,CallWithSpread.Wide
code-creation,BytecodeHandler,0,9125,0x100da69c0,144,CallRuntime.Wide
code-creation,BytecodeHandler,0,9167,0x100da6a60,184,CallRuntimeForPair.Wide
code-creation,BytecodeHandler,0,9167,0x100da6b20,104,CallJSRuntime.Wide
code-creation,BytecodeHandler,0,9167,0x100da6ba0,1388,InvokeIntrinsic.Wide
code-creation,BytecodeHandler,0,9167,0x100da7120,944,Construct.Wide
code-creation,BytecodeHandler,0,9167,0x100da74e0,460,ConstructWithSpread.Wide
code-creation,BytecodeHandler,0,9167,0x100da76c0,2008,TestEqual.Wide
code-creation,BytecodeHandler,0,9167,0x100da7ea0,960,TestEqualStrict.Wide
code-creation,BytecodeHandler,0,9167,0x100da8280,1628,TestLessThan.Wide
code-creation,BytecodeHandler,0,9167,0x100da88e0,1628,TestGreaterThan.Wide
code-creation,BytecodeHandler,0,9167,0x100da8f40,1628,TestLessThanOrEqual.Wide
code-creation,BytecodeHandler,0,9167,0x100da95a0,1628,TestGreaterThanOrEqual.Wide
code-creation,BytecodeHandler,0,9167,0x100da9c00,880,TestInstanceOf.Wide
code-creation,BytecodeHandler,0,9209,0x100da9f80,188,TestIn.Wide
code-creation,BytecodeHandler,0,9209,0x100daa040,132,ToName.Wide
code-creation,BytecodeHandler,0,9209,0x100daa0e0,248,ToNumber.Wide
code-creation,BytecodeHandler,0,9209,0x100daa1e0,268,ToNumeric.Wide
code-creation,BytecodeHandler,0,9209,0x100daa300,132,ToObject.Wide
code-creation,BytecodeHandler,0,9209,0x100daa3a0,468,CreateRegExpLiteral.Wide
code-creation,BytecodeHandler,0,9209,0x100daa580,1344,CreateArrayLiteral.Wide
code-creation,BytecodeHandler,0,9209,0x100daaae0,860,CreateEmptyArrayLiteral.Wide
code-creation,BytecodeHandler,0,9209,0x100daae40,2052,CreateObjectLiteral.Wide
code-creation,BytecodeHandler,0,9250,0x100dab660,196,CloneObject.Wide
code-creation,BytecodeHandler,0,9250,0x100dab740,188,GetTemplateObject.Wide
code-creation,BytecodeHandler,0,9250,0x100dab800,376,CreateClosure.Wide
code-creation,BytecodeHandler,0,9250,0x100dab980,144,CreateBlockContext.Wide
code-creation,BytecodeHandler,0,9250,0x100daba20,152,CreateCatchContext.Wide
code-creation,BytecodeHandler,0,9250,0x100dabac0,304,CreateFunctionContext.Wide
code-creation,BytecodeHandler,0,9250,0x100dabc00,304,CreateEvalContext.Wide
code-creation,BytecodeHandler,0,9250,0x100dabd40,152,CreateWithContext.Wide
code-creation,BytecodeHandler,0,9250,0x100dabde0,484,JumpLoop.Wide
code-creation,BytecodeHandler,0,9292,0x100dabfe0,60,Jump.Wide
code-creation,BytecodeHandler,0,9292,0x100dac020,80,JumpConstant.Wide
code-creation,BytecodeHandler,0,9292,0x100dac080,112,JumpIfNullConstant.Wide
code-creation,BytecodeHandler,0,9292,0x100dac100,112,JumpIfNotNullConstant.Wide
code-creation,BytecodeHandler,0,9292,0x100dac180,112,JumpIfUndefinedConstant.Wide
code-creation,BytecodeHandler,0,9292,0x100dac200,112,JumpIfNotUndefinedConstant.Wide
code-creation,BytecodeHandler,0,9292,0x100dac280,124,JumpIfUndefinedOrNullConstant.Wide
code-creation,BytecodeHandler,0,9292,0x100dac300,112,JumpIfTrueConstant.Wide
code-creation,BytecodeHandler,0,9292,0x100dac380,112,JumpIfFalseConstant.Wide
code-creation,BytecodeHandler,0,9292,0x100dac400,120,JumpIfJSReceiverConstant.Wide
code-creation,BytecodeHandler,0,9334,0x100dac480,208,JumpIfToBooleanTrueConstant.Wide
code-creation,BytecodeHandler,0,9334,0x100dac560,208,JumpIfToBooleanFalseConstant.Wide
code-creation,BytecodeHandler,0,9334,0x100dac640,188,JumpIfToBooleanTrue.Wide
code-creation,BytecodeHandler,0,9334,0x100dac700,188,JumpIfToBooleanFalse.Wide
code-creation,BytecodeHandler,0,9334,0x100dac7c0,92,JumpIfTrue.Wide
code-creation,BytecodeHandler,0,9334,0x100dac820,92,JumpIfFalse.Wide
code-creation,BytecodeHandler,0,9334,0x100dac880,92,JumpIfNull.Wide
code-creation,BytecodeHandler,0,9334,0x100dac8e0,92,JumpIfNotNull.Wide
code-creation,BytecodeHandler,0,9334,0x100dac940,92,JumpIfUndefined.Wide
code-creation,BytecodeHandler,0,9334,0x100dac9a0,92,JumpIfNotUndefined.Wide
code-creation,BytecodeHandler,0,9375,0x100daca00,104,JumpIfUndefinedOrNull.Wide
code-creation,BytecodeHandler,0,9375,0x100daca80,100,JumpIfJSReceiver.Wide
code-creation,BytecodeHandler,0,9375,0x100dacb00,140,SwitchOnSmiNoFeedback.Wide
code-creation,BytecodeHandler,0,9375,0x100dacba0,560,ForInEnumerate.Wide
code-creation,BytecodeHandler,0,9375,0x100dacde0,272,ForInPrepare.Wide
code-creation,BytecodeHandler,0,9375,0x100dacf00,76,ForInContinue.Wide
code-creation,BytecodeHandler,0,9375,0x100dacf60,308,ForInNext.Wide
code-creation,BytecodeHandler,0,9375,0x100dad0a0,48,ForInStep.Wide
code-creation,BytecodeHandler,0,9375,0x100dad0e0,192,ThrowReferenceErrorIfHole.Wide
code-creation,BytecodeHandler,0,9375,0x100dad1c0,180,ThrowIfNotSuperConstructor.Wide
code-creation,BytecodeHandler,0,9417,0x100dad280,148,SwitchOnGeneratorState.Wide
code-creation,BytecodeHandler,0,9417,0x100dad320,556,SuspendGenerator.Wide
code-creation,BytecodeHandler,0,9417,0x100dad560,160,ResumeGenerator.Wide
code-creation,BytecodeHandler,0,9417,0x100dad620,176,GetIterator.Wide
code-creation,BytecodeHandler,0,9417,0x100dad6e0,140,IncBlockCounter.Wide
code-creation,BytecodeHandler,0,9417,0x100dad780,80,Abort.Wide
code-creation,BytecodeHandler,0,9417,0x100dad7e0,128,DebugBreak1.ExtraWide
code-creation,BytecodeHandler,0,9417,0x100dad880,128,DebugBreak2.ExtraWide
code-creation,BytecodeHandler,0,9417,0x100dad920,128,DebugBreak3.ExtraWide
code-creation,BytecodeHandler,0,9417,0x100dad9c0,128,DebugBreak4.ExtraWide
code-creation,BytecodeHandler,0,9417,0x100dada60,128,DebugBreak5.ExtraWide
code-creation,BytecodeHandler,0,9459,0x100dadb00,128,DebugBreak6.ExtraWide
code-creation,BytecodeHandler,0,9459,0x100dadba0,44,Ldar.ExtraWide
code-creation,BytecodeHandler,0,9459,0x100dadbe0,40,LdaSmi.ExtraWide
code-creation,BytecodeHandler,0,9459,0x100dadc20,48,LdaConstant.ExtraWide
code-creation,BytecodeHandler,0,9459,0x100dadc60,128,LdaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,9459,0x100dadd00,128,LdaImmutableContextSlot.ExtraWide
code-creation,BytecodeHandler,0,9459,0x100dadda0,72,LdaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,9459,0x100dade00,72,LdaImmutableCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,9500,0x100dade60,40,Star.ExtraWide
code-creation,BytecodeHandler,0,9500,0x100dadea0,52,Mov.ExtraWide
code-creation,BytecodeHandler,0,9500,0x100dadee0,48,PushContext.ExtraWide
code-creation,BytecodeHandler,0,9500,0x100dadf20,44,PopContext.ExtraWide
code-creation,BytecodeHandler,0,9500,0x100dadf60,64,TestReferenceEqual.ExtraWide
code-creation,BytecodeHandler,0,9500,0x100dadfc0,4748,LdaGlobal.ExtraWide
code-creation,BytecodeHandler,0,9500,0x100daf260,4648,LdaGlobalInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,9500,0x100db04a0,188,StaGlobal.ExtraWide
code-creation,BytecodeHandler,0,9500,0x100db0560,200,StaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,9500,0x100db0640,144,StaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,9542,0x100db06e0,156,LdaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,9542,0x100db0780,312,LdaLookupContextSlot.ExtraWide
code-creation,BytecodeHandler,0,9542,0x100db08c0,4996,LdaLookupGlobalSlot.ExtraWide
code-creation,BytecodeHandler,0,9542,0x100db1c60,156,LdaLookupSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,9542,0x100db1d00,312,LdaLookupContextSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,9542,0x100db1e40,4920,LdaLookupGlobalSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,9542,0x100db3180,252,StaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,9542,0x100db3280,5128,LdaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,9542,0x100db46a0,212,LdaNamedPropertyFromSuper.ExtraWide
code-creation,BytecodeHandler,0,9584,0x100db4780,188,LdaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,9584,0x100db4840,216,LdaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,9584,0x100db4920,360,StaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,9584,0x100db4aa0,204,StaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,9584,0x100db4b80,204,StaNamedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,9584,0x100db4c60,196,StaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,9584,0x100db4d40,196,StaInArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,9584,0x100db4e20,232,StaDataPropertyInLiteral.ExtraWide
code-creation,BytecodeHandler,0,9584,0x100db4f20,192,CollectTypeProfile.ExtraWide
code-creation,BytecodeHandler,0,9584,0x100db5000,944,Add.ExtraWide
code-creation,BytecodeHandler,0,9625,0x100db53c0,988,Sub.ExtraWide
code-creation,BytecodeHandler,0,9625,0x100db57a0,936,Mul.ExtraWide
code-creation,BytecodeHandler,0,9625,0x100db5b60,944,Div.ExtraWide
code-creation,BytecodeHandler,0,9625,0x100db5f20,860,Mod.ExtraWide
code-creation,BytecodeHandler,0,9625,0x100db6280,904,Exp.ExtraWide
code-creation,BytecodeHandler,0,9625,0x100db6620,796,BitwiseOr.ExtraWide
code-creation,BytecodeHandler,0,9625,0x100db6940,808,BitwiseXor.ExtraWide
code-creation,BytecodeHandler,0,9625,0x100db6c80,808,BitwiseAnd.ExtraWide
code-creation,BytecodeHandler,0,9625,0x100db6fc0,808,ShiftLeft.ExtraWide
code-creation,BytecodeHandler,0,9625,0x100db7300,808,ShiftRight.ExtraWide
code-creation,BytecodeHandler,0,9625,0x100db7640,916,ShiftRightLogical.ExtraWide
code-creation,BytecodeHandler,0,9667,0x100db79e0,924,AddSmi.ExtraWide
code-creation,BytecodeHandler,0,9667,0x100db7d80,956,SubSmi.ExtraWide
code-creation,BytecodeHandler,0,9667,0x100db8140,908,MulSmi.ExtraWide
code-creation,BytecodeHandler,0,9667,0x100db84e0,992,DivSmi.ExtraWide
code-creation,BytecodeHandler,0,9667,0x100db88e0,792,ModSmi.ExtraWide
code-creation,BytecodeHandler,0,9667,0x100db8c00,796,ExpSmi.ExtraWide
code-creation,BytecodeHandler,0,9667,0x100db8f20,476,BitwiseOrSmi.ExtraWide
code-creation,BytecodeHandler,0,9667,0x100db9100,476,BitwiseXorSmi.ExtraWide
code-creation,BytecodeHandler,0,9667,0x100db92e0,476,BitwiseAndSmi.ExtraWide
code-creation,BytecodeHandler,0,9709,0x100db94c0,476,ShiftLeftSmi.ExtraWide
code-creation,BytecodeHandler,0,9709,0x100db96a0,476,ShiftRightSmi.ExtraWide
code-creation,BytecodeHandler,0,9709,0x100db9880,612,ShiftRightLogicalSmi.ExtraWide
code-creation,BytecodeHandler,0,9709,0x100db9b00,624,Inc.ExtraWide
code-creation,BytecodeHandler,0,9709,0x100db9d80,624,Dec.ExtraWide
code-creation,BytecodeHandler,0,9709,0x100dba000,632,Negate.ExtraWide
code-creation,BytecodeHandler,0,9709,0x100dba280,460,BitwiseNot.ExtraWide
code-creation,BytecodeHandler,0,9709,0x100dba460,136,DeletePropertyStrict.ExtraWide
code-creation,BytecodeHandler,0,9709,0x100dba500,136,DeletePropertySloppy.ExtraWide
code-creation,BytecodeHandler,0,9709,0x100dba5a0,48,GetSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,9709,0x100dba5e0,976,CallAnyReceiver.ExtraWide
code-creation,BytecodeHandler,0,9750,0x100dba9c0,976,CallProperty.ExtraWide
code-creation,BytecodeHandler,0,9750,0x100dbada0,984,CallProperty0.ExtraWide
code-creation,BytecodeHandler,0,9750,0x100dbb180,996,CallProperty1.ExtraWide
code-creation,BytecodeHandler,0,9750,0x100dbb580,1016,CallProperty2.ExtraWide
code-creation,BytecodeHandler,0,9750,0x100dbb980,964,CallUndefinedReceiver.ExtraWide
code-creation,BytecodeHandler,0,9750,0x100dbbd60,960,CallUndefinedReceiver0.ExtraWide
code-creation,BytecodeHandler,0,9750,0x100dbc140,972,CallUndefinedReceiver1.ExtraWide
code-creation,BytecodeHandler,0,9750,0x100dbc520,992,CallUndefinedReceiver2.ExtraWide
code-creation,BytecodeHandler,0,9750,0x100dbc920,976,CallWithSpread.ExtraWide
code-creation,BytecodeHandler,0,9750,0x100dbcd00,144,CallRuntime.ExtraWide
code-creation,BytecodeHandler,0,9792,0x100dbcda0,184,CallRuntimeForPair.ExtraWide
code-creation,BytecodeHandler,0,9792,0x100dbce60,104,CallJSRuntime.ExtraWide
code-creation,BytecodeHandler,0,9792,0x100dbcee0,1388,InvokeIntrinsic.ExtraWide
code-creation,BytecodeHandler,0,9792,0x100dbd460,944,Construct.ExtraWide
code-creation,BytecodeHandler,0,9792,0x100dbd820,460,ConstructWithSpread.ExtraWide
code-creation,BytecodeHandler,0,9792,0x100dbda00,2008,TestEqual.ExtraWide
code-creation,BytecodeHandler,0,9792,0x100dbe1e0,960,TestEqualStrict.ExtraWide
code-creation,BytecodeHandler,0,9792,0x100dbe5c0,1628,TestLessThan.ExtraWide
code-creation,BytecodeHandler,0,9792,0x100dbec20,1628,TestGreaterThan.ExtraWide
code-creation,BytecodeHandler,0,9792,0x100dbf280,1628,TestLessThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,9834,0x100dbf8e0,1628,TestGreaterThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,9834,0x100dbff40,880,TestInstanceOf.ExtraWide
code-creation,BytecodeHandler,0,9834,0x100dc02c0,188,TestIn.ExtraWide
code-creation,BytecodeHandler,0,9834,0x100dc0380,132,ToName.ExtraWide
code-creation,BytecodeHandler,0,9834,0x100dc0420,248,ToNumber.ExtraWide
code-creation,BytecodeHandler,0,9834,0x100dc0520,268,ToNumeric.ExtraWide
code-creation,BytecodeHandler,0,9834,0x100dc0640,132,ToObject.ExtraWide
code-creation,BytecodeHandler,0,9834,0x100dc06e0,468,CreateRegExpLiteral.ExtraWide
code-creation,BytecodeHandler,0,9834,0x100dc08c0,1344,CreateArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,9834,0x100dc0e20,860,CreateEmptyArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,9875,0x100dc1180,2052,CreateObjectLiteral.ExtraWide
code-creation,BytecodeHandler,0,9875,0x100dc19a0,196,CloneObject.ExtraWide
code-creation,BytecodeHandler,0,9875,0x100dc1a80,188,GetTemplateObject.ExtraWide
code-creation,BytecodeHandler,0,9875,0x100dc1b40,376,CreateClosure.ExtraWide
code-creation,BytecodeHandler,0,9875,0x100dc1cc0,144,CreateBlockContext.ExtraWide
code-creation,BytecodeHandler,0,9875,0x100dc1d60,152,CreateCatchContext.ExtraWide
code-creation,BytecodeHandler,0,9875,0x100dc1e00,304,CreateFunctionContext.ExtraWide
code-creation,BytecodeHandler,0,9875,0x100dc1f40,304,CreateEvalContext.ExtraWide
code-creation,BytecodeHandler,0,9875,0x100dc2080,152,CreateWithContext.ExtraWide
code-creation,BytecodeHandler,0,9917,0x100dc2120,484,JumpLoop.ExtraWide
code-creation,BytecodeHandler,0,9917,0x100dc2320,60,Jump.ExtraWide
code-creation,BytecodeHandler,0,9917,0x100dc2360,80,JumpConstant.ExtraWide
code-creation,BytecodeHandler,0,9917,0x100dc23c0,112,JumpIfNullConstant.ExtraWide
code-creation,BytecodeHandler,0,9917,0x100dc2440,112,JumpIfNotNullConstant.ExtraWide
code-creation,BytecodeHandler,0,9917,0x100dc24c0,112,JumpIfUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,9917,0x100dc2540,112,JumpIfNotUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,9917,0x100dc25c0,124,JumpIfUndefinedOrNullConstant.ExtraWide
code-creation,BytecodeHandler,0,9917,0x100dc2640,112,JumpIfTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,9959,0x100dc26c0,112,JumpIfFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,9959,0x100dc2740,120,JumpIfJSReceiverConstant.ExtraWide
code-creation,BytecodeHandler,0,9959,0x100dc27c0,208,JumpIfToBooleanTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,9959,0x100dc28a0,208,JumpIfToBooleanFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,9959,0x100dc2980,188,JumpIfToBooleanTrue.ExtraWide
code-creation,BytecodeHandler,0,9959,0x100dc2a40,188,JumpIfToBooleanFalse.ExtraWide
code-creation,BytecodeHandler,0,9959,0x100dc2b00,92,JumpIfTrue.ExtraWide
code-creation,BytecodeHandler,0,9959,0x100dc2b60,92,JumpIfFalse.ExtraWide
code-creation,BytecodeHandler,0,9959,0x100dc2bc0,92,JumpIfNull.ExtraWide
code-creation,BytecodeHandler,0,10000,0x100dc2c20,92,JumpIfNotNull.ExtraWide
code-creation,BytecodeHandler,0,10000,0x100dc2c80,92,JumpIfUndefined.ExtraWide
code-creation,BytecodeHandler,0,10000,0x100dc2ce0,92,JumpIfNotUndefined.ExtraWide
code-creation,BytecodeHandler,0,10000,0x100dc2d40,104,JumpIfUndefinedOrNull.ExtraWide
code-creation,BytecodeHandler,0,10000,0x100dc2dc0,100,JumpIfJSReceiver.ExtraWide
code-creation,BytecodeHandler,0,10000,0x100dc2e40,140,SwitchOnSmiNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,10000,0x100dc2ee0,560,ForInEnumerate.ExtraWide
code-creation,BytecodeHandler,0,10000,0x100dc3120,272,ForInPrepare.ExtraWide
code-creation,BytecodeHandler,0,10000,0x100dc3240,76,ForInContinue.ExtraWide
code-creation,BytecodeHandler,0,10000,0x100dc32a0,308,ForInNext.ExtraWide
code-creation,BytecodeHandler,0,10042,0x100dc33e0,48,ForInStep.ExtraWide
code-creation,BytecodeHandler,0,10042,0x100dc3420,192,ThrowReferenceErrorIfHole.ExtraWide
code-creation,BytecodeHandler,0,10042,0x100dc3500,180,ThrowIfNotSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,10042,0x100dc35c0,148,SwitchOnGeneratorState.ExtraWide
code-creation,BytecodeHandler,0,10042,0x100dc3660,556,SuspendGenerator.ExtraWide
code-creation,BytecodeHandler,0,10042,0x100dc38a0,160,ResumeGenerator.ExtraWide
code-creation,BytecodeHandler,0,10042,0x100dc3960,176,GetIterator.ExtraWide
code-creation,BytecodeHandler,0,10042,0x100dc3a20,140,IncBlockCounter.ExtraWide
code-creation,BytecodeHandler,0,10042,0x100dc3ac0,80,Abort.ExtraWide
tick,0x1bfc4760c,10084,0,0x0,6
new,MemoryChunk,0x216d66740000,262144
new,MemoryChunk,0xe3bc6f40000,262144
tick,0x1012c63d8,10500,0,0x0,5
new,MemoryChunk,0x29e8d69c0000,262144
tick,0x1bfd8ced4,11750,0,0x0,5
new,MemoryChunk,0x8332f340000,262144
new,MemoryChunk,0x3172a1b00000,262144
code-creation,Eval,10,12584,0x3172a1b05a36,5, node:internal/main/run_main_module:1:1,0x3172a1b058f0,~
script-source,95,node:internal/main/run_main_module,'use strict';\n\nconst {\n  prepareMainThreadExecution\n} = require('internal/bootstrap/pre_execution');\n\nprepareMainThreadExecution(true);\n\nmarkBootstrapComplete();\n\n// Note: this loads the module through the ESM loader if the module is\n// determined to be an ES module. This hangs from the CJS module loader\n// because we currently allow monkey-patching of the module loaders\n// in the preloaded scripts through require('module').\n// runMain here might be monkey-patched by users in --require.\n// XXX: the monkey-patchability here should probably be deprecated.\nrequire('internal/modules/cjs/loader').Module.runMain(process.argv[1]);\n
code-source-info,0x3172a1b05a36,95,0,632,C0O0C4O632,,
code-creation,Function,10,12625,0x3172a1b05ade,58, node:internal/main/run_main_module:1:1,0x3172a1b059b0,~
code-source-info,0x3172a1b05ade,95,0,632,C0O56C3O56C8O25C13O102C15O102C19O137C22O560C25O560C30O598C35O605C40O622C47O626C51O606C57O631,,
code-creation,LazyCompile,10,12792,0x3172a1b05d1e,76,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x2b48e0c4fda8,~
script-source,9,node:internal/bootstrap/loaders,// This file creates the internal module & binding loaders used by built-in\n// modules. In contrast\x2C user land modules are loaded using\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\n// lib/internal/modules/esm/* (ES Modules).\n//\n// This file is compiled and run by node.cc before bootstrap/node.js\n// was called\x2C therefore the loaders are bootstrapped before we start to\n// actually bootstrap Node.js. It creates the following objects:\n//\n// C++ binding loaders:\n// - process.binding(): the legacy C++ binding loader\x2C accessible from user land\n//   because it is an object attached to the global process object.\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\n//   about the stability of these bindings\x2C but still have to take care of\n//   compatibility issues caused by them from time to time.\n// - process._linkedBinding(): intended to be used by embedders to add\n//   additional C++ bindings in their applications. These C++ bindings\n//   can be created using NODE_MODULE_CONTEXT_AWARE_CPP() with the flag\n//   NM_F_LINKED.\n// - internalBinding(): the private internal C++ binding loader\x2C inaccessible\n//   from user land unless through `require('internal/test/binding')`.\n//   These C++ bindings are created using NODE_MODULE_CONTEXT_AWARE_INTERNAL()\n//   and have their nm_flags set to NM_F_INTERNAL.\n//\n// Internal JavaScript module loader:\n// - NativeModule: a minimal module system used to load the JavaScript core\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\n//   compiled into the node binary via node_javascript.cc generated by js2c.py\x2C\n//   so they can be loaded faster without the cost of I/O. This class makes the\n//   lib/internal/*\x2C deps/internal/* modules and internalBinding() available by\n//   default to core modules\x2C and lets the core modules require itself via\n//   require('internal/bootstrap/loaders') even when this file is not written in\n//   CommonJS style.\n//\n// Other objects:\n// - process.moduleLoadList: an array recording the bindings and the modules\n//   loaded in the process and the order in which they are loaded.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C getLinkedBinding\x2C getInternalBinding\x2C primordials */\n\nconst {\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ReflectGet\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeStartsWith\x2C\n  TypeError\x2C\n} = primordials;\n\n// Set up process.moduleLoadList.\nconst moduleLoadList = [];\nObjectDefineProperty(process\x2C 'moduleLoadList'\x2C {\n  value: moduleLoadList\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  writable: false\n});\n\n\n// internalBindingAllowlist contains the name of internalBinding modules\n// that are allowed for access via process.binding()... This is used\n// to provide a transition path for modules that are being moved over to\n// internalBinding.\nconst internalBindingAllowlist = new SafeSet([\n  'async_wrap'\x2C\n  'buffer'\x2C\n  'cares_wrap'\x2C\n  'config'\x2C\n  'constants'\x2C\n  'contextify'\x2C\n  'crypto'\x2C\n  'fs'\x2C\n  'fs_event_wrap'\x2C\n  'http_parser'\x2C\n  'icu'\x2C\n  'inspector'\x2C\n  'js_stream'\x2C\n  'natives'\x2C\n  'os'\x2C\n  'pipe_wrap'\x2C\n  'process_wrap'\x2C\n  'signal_wrap'\x2C\n  'spawn_sync'\x2C\n  'stream_wrap'\x2C\n  'tcp_wrap'\x2C\n  'tls_wrap'\x2C\n  'tty_wrap'\x2C\n  'udp_wrap'\x2C\n  'url'\x2C\n  'util'\x2C\n  'uv'\x2C\n  'v8'\x2C\n  'zlib'\x2C\n]);\n\nconst runtimeDeprecatedList = new SafeSet([\n  'async_wrap'\x2C\n  'crypto'\x2C\n  'http_parser'\x2C\n  'signal_wrap'\x2C\n  'url'\x2C\n  'v8'\x2C\n]);\n\nconst legacyWrapperList = new SafeSet([\n  'util'\x2C\n]);\n\n// Set up process.binding() and process._linkedBinding().\n{\n  const bindingObj = ObjectCreate(null);\n\n  process.binding = function binding(module) {\n    module = String(module);\n    // Deprecated specific process.binding() modules\x2C but not all\x2C allow\n    // selective fallback to internalBinding for the deprecated ones.\n    if (internalBindingAllowlist.has(module)) {\n      if (runtimeDeprecatedList.has(module)) {\n        runtimeDeprecatedList.delete(module);\n        process.emitWarning(\n          `Access to process.binding('${module}') is deprecated.`\x2C\n          'DeprecationWarning'\x2C\n          'DEP0111');\n      }\n      if (legacyWrapperList.has(module)) {\n        return nativeModuleRequire('internal/legacy/processbinding')[module]();\n      }\n      return internalBinding(module);\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`No such module: ${module}`);\n  };\n\n  process._linkedBinding = function _linkedBinding(module) {\n    module = String(module);\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object')\n      mod = bindingObj[module] = getLinkedBinding(module);\n    return mod;\n  };\n}\n\n// Set up internalBinding() in the closure.\n/**\n * @type {InternalBinding}\n */\nlet internalBinding;\n{\n  const bindingObj = ObjectCreate(null);\n  // eslint-disable-next-line no-global-assign\n  internalBinding = function internalBinding(module) {\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object') {\n      mod = bindingObj[module] = getInternalBinding(module);\n      ArrayPrototypePush(moduleLoadList\x2C `Internal Binding ${module}`);\n    }\n    return mod;\n  };\n}\n\nconst loaderId = 'internal/bootstrap/loaders';\nconst {\n  moduleIds\x2C\n  compileFunction\n} = internalBinding('native_module');\n\nconst getOwn = (target\x2C property\x2C receiver) => {\n  return ObjectPrototypeHasOwnProperty(target\x2C property) ?\n    ReflectGet(target\x2C property\x2C receiver) :\n    undefined;\n};\n\n/**\n * An internal abstraction for the built-in JavaScript modules of Node.js.\n * Be careful not to expose this to user land unless --expose-internals is\n * used\x2C in which case there is no compatibility guarantee about this class.\n */\nclass NativeModule {\n  /**\n   * A map from the module IDs to the module instances.\n   * @type {Map<string\x2C NativeModule>}\n   */\n  static map = new SafeMap(\n    ArrayPrototypeMap(moduleIds\x2C (id) => [id\x2C new NativeModule(id)])\n  );\n\n  constructor(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.canBeRequiredByUsers = !StringPrototypeStartsWith(id\x2C 'internal/');\n\n    // The CJS exports object of the module.\n    this.exports = {};\n    // States used to work around circular dependencies.\n    this.loaded = false;\n    this.loading = false;\n\n    // The following properties are used by the ESM implementation and only\n    // initialized when the native module is loaded by users.\n    /**\n     * The C++ ModuleWrap binding used to interface with the ESM implementation.\n     * @type {ModuleWrap|undefined}\n     */\n    this.module = undefined;\n    /**\n     * Exported names for the ESM imports.\n     * @type {string[]|undefined}\n     */\n    this.exportKeys = undefined;\n  }\n\n  // To be called during pre-execution when --expose-internals is on.\n  // Enables the user-land module loader to access internal modules.\n  static exposeInternals() {\n    for (const { 0: id\x2C 1: mod } of NativeModule.map) {\n      // Do not expose this to user land even with --expose-internals.\n      if (id !== loaderId) {\n        mod.canBeRequiredByUsers = true;\n      }\n    }\n  }\n\n  static exists(id) {\n    return NativeModule.map.has(id);\n  }\n\n  static canBeRequiredByUsers(id) {\n    const mod = NativeModule.map.get(id);\n    return mod && mod.canBeRequiredByUsers;\n  }\n\n  // Used by user-land module loaders to compile and load builtins.\n  compileForPublicLoader() {\n    if (!this.canBeRequiredByUsers) {\n      // No code because this is an assertion against bugs\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not compile ${this.id} for public use`);\n    }\n    this.compileForInternalLoader();\n    if (!this.exportKeys) {\n      // When using --expose-internals\x2C we do not want to reflect the named\n      // exports from core modules as this can trigger unnecessary getters.\n      const internal = StringPrototypeStartsWith(this.id\x2C 'internal/');\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\n    }\n    this.getESMFacade();\n    this.syncExports();\n    return this.exports;\n  }\n\n  getESMFacade() {\n    if (this.module) return this.module;\n    const { ModuleWrap } = internalBinding('module_wrap');\n    const url = `node:${this.id}`;\n    const nativeModule = this;\n    const exportsKeys = ArrayPrototypeSlice(this.exportKeys);\n    ArrayPrototypePush(exportsKeys\x2C 'default');\n    this.module = new ModuleWrap(\n      url\x2C undefined\x2C exportsKeys\x2C\n      function() {\n        nativeModule.syncExports();\n        this.setExport('default'\x2C nativeModule.exports);\n      });\n    // Ensure immediate sync execution to capture exports now\n    this.module.instantiate();\n    this.module.evaluate(-1\x2C false);\n    return this.module;\n  }\n\n  // Provide named exports for all builtin libraries so that the libraries\n  // may be imported in a nicer way for ESM users. The default export is left\n  // as the entire namespace (module.exports) and updates when this function is\n  // called so that APMs and other behavior are supported.\n  syncExports() {\n    const names = this.exportKeys;\n    if (this.module) {\n      for (let i = 0; i < names.length; i++) {\n        const exportName = names[i];\n        if (exportName === 'default') continue;\n        this.module.setExport(exportName\x2C\n                              getOwn(this.exports\x2C exportName\x2C this.exports));\n      }\n    }\n  }\n\n  compileForInternalLoader() {\n    if (this.loaded || this.loading) {\n      return this.exports;\n    }\n\n    const id = this.id;\n    this.loading = true;\n\n    try {\n      const requireFn = StringPrototypeStartsWith(this.id\x2C 'internal/deps/') ?\n        requireWithFallbackInDeps : nativeModuleRequire;\n\n      const fn = compileFunction(id);\n      fn(this.exports\x2C requireFn\x2C this\x2C process\x2C internalBinding\x2C primordials);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n\n    ArrayPrototypePush(moduleLoadList\x2C `NativeModule ${id}`);\n    return this.exports;\n  }\n}\n\n// Think of this as module.exports in this file even though it is not\n// written in CommonJS style.\nconst loaderExports = {\n  internalBinding\x2C\n  NativeModule\x2C\n  require: nativeModuleRequire\n};\n\nfunction nativeModuleRequire(id) {\n  if (id === loaderId) {\n    return loaderExports;\n  }\n\n  const mod = NativeModule.map.get(id);\n  // Can't load the internal errors module from here\x2C have to use a raw error.\n  // eslint-disable-next-line no-restricted-syntax\n  if (!mod) throw new TypeError(`Missing internal module '${id}'`);\n  return mod.compileForInternalLoader();\n}\n\n// Allow internal modules from dependencies to require\n// other modules from dependencies by providing fallbacks.\nfunction requireWithFallbackInDeps(request) {\n  if (!NativeModule.map.has(request)) {\n    request = `internal/deps/${request}`;\n  }\n  return nativeModuleRequire(request);\n}\n\n// Pass the exports back to C++ land for C++ internals to use.\nreturn loaderExports;\n
code-source-info,0x3172a1b05d1e,9,10316,10659,C0O10325C2O10336C4O10332C9O10352C13O10373C14O10393C19O10406C24O10410C29O10410C35O10551C37O10561C47O10609C60O10567C65O10561C66O10630C71O10630C75O10657,,
tick,0x1bfc3b518,13209,0,0x0,3,0x0,0x3172a1b05ae1
code-creation,LazyCompile,10,13250,0x3172a1b06a2e,175,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x2b48e0c4fcd8,~
code-source-info,0x3172a1b06a2e,9,9529,10090,C0O9547C6O9562C12O9591C16O9599C17O9627C22O9635C23O9648C30O9691C37O9722C45O9691C63O9821C70O9821C75O9856C89O9891C103O9848C108O9929C109O9941C124O9971C126O9984C141O10004C152O10023C160O10055C165O10004C170O10078C174O10086,,
code-creation,Eval,10,13417,0x3172a1b07a2e,5, node:internal/bootstrap/pre_execution:1:1,0x3172a1b07658,~
script-source,96,node:internal/bootstrap/pre_execution,'use strict';\n\nconst {\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  StringPrototypeStartsWith\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  getOptionValue\x2C\n  getEmbedderOptions\x2C\n} = require('internal/options');\nconst { reconnectZeroFillToggle } = require('internal/buffer');\nconst {\n  emitExperimentalWarning\x2C\n} = require('internal/util');\n\nconst { Buffer } = require('buffer');\nconst { ERR_MANIFEST_ASSERT_INTEGRITY } = require('internal/errors').codes;\nconst assert = require('internal/assert');\n\nfunction prepareMainThreadExecution(expandArgv1 = false) {\n  // TODO(joyeecheung): this is also necessary for workers when they deserialize\n  // this toggle from the snapshot.\n  reconnectZeroFillToggle();\n\n  // Patch the process object with legacy properties and normalizations\n  patchProcessObject(expandArgv1);\n  setupTraceCategoryState();\n  setupPerfHooks();\n  setupInspectorHooks();\n  setupWarningHandler();\n  setupFetch();\n  setupWebCrypto();\n\n  // Resolve the coverage directory to an absolute path\x2C and\n  // overwrite process.env so that the original path gets passed\n  // to child processes even when they switch cwd.\n  if (process.env.NODE_V8_COVERAGE) {\n    process.env.NODE_V8_COVERAGE =\n      setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n  }\n\n\n  setupDebugEnv();\n\n  // Print stack trace on `SIGINT` if option `--trace-sigint` presents.\n  setupStacktracePrinterOnSigint();\n\n  // Process initial diagnostic reporting configuration\x2C if present.\n  initializeReport();\n  initializeReportSignalHandlers();  // Main-thread-only.\n\n  initializeHeapSnapshotSignalHandlers();\n\n  // If the process is spawned with env NODE_CHANNEL_FD\x2C it's probably\n  // spawned by our child_process module\x2C then initialize IPC.\n  // This attaches some internal event listeners and creates:\n  // process.send()\x2C process.channel\x2C process.connected\x2C\n  // process.disconnect().\n  setupChildProcessIpcChannel();\n\n  // Load policy from disk and parse it.\n  initializePolicy();\n\n  // If this is a worker in cluster mode\x2C start up the communication\n  // channel. This needs to be done before any user code gets executed\n  // (including preload modules).\n  initializeClusterIPC();\n\n  initializeSourceMapsHandlers();\n  initializeDeprecations();\n  initializeWASI();\n  initializeCJSLoader();\n  initializeESMLoader();\n\n  const CJSLoader = require('internal/modules/cjs/loader');\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n  loadPreloadModules();\n  initializeFrozenIntrinsics();\n}\n\nfunction patchProcessObject(expandArgv1) {\n  const binding = internalBinding('process_methods');\n  binding.patchProcessObject(process);\n\n  require('internal/process/per_thread').refreshHrtimeBuffer();\n\n  ObjectDefineProperty(process\x2C 'argv0'\x2C {\n    enumerable: true\x2C\n    configurable: false\x2C\n    value: process.argv[0]\n  });\n  process.argv[0] = process.execPath;\n\n  if (expandArgv1 && process.argv[1] &&\n      !StringPrototypeStartsWith(process.argv[1]\x2C '-')) {\n    // Expand process.argv[1] into a full path.\n    const path = require('path');\n    try {\n      process.argv[1] = path.resolve(process.argv[1]);\n    } catch {\n      // Continue regardless of error.\n    }\n  }\n\n  // TODO(joyeecheung): most of these should be deprecated and removed\x2C\n  // except some that we need to be able to mutate during run time.\n  addReadOnlyProcessAlias('_eval'\x2C '--eval');\n  addReadOnlyProcessAlias('_print_eval'\x2C '--print');\n  addReadOnlyProcessAlias('_syntax_check_only'\x2C '--check');\n  addReadOnlyProcessAlias('_forceRepl'\x2C '--interactive');\n  addReadOnlyProcessAlias('_preload_modules'\x2C '--require');\n  addReadOnlyProcessAlias('noDeprecation'\x2C '--no-deprecation');\n  addReadOnlyProcessAlias('noProcessWarnings'\x2C '--no-warnings');\n  addReadOnlyProcessAlias('traceProcessWarnings'\x2C '--trace-warnings');\n  addReadOnlyProcessAlias('throwDeprecation'\x2C '--throw-deprecation');\n  addReadOnlyProcessAlias('profProcess'\x2C '--prof-process');\n  addReadOnlyProcessAlias('traceDeprecation'\x2C '--trace-deprecation');\n  addReadOnlyProcessAlias('_breakFirstLine'\x2C '--inspect-brk'\x2C false);\n  addReadOnlyProcessAlias('_breakNodeFirstLine'\x2C '--inspect-brk-node'\x2C false);\n}\n\nfunction addReadOnlyProcessAlias(name\x2C option\x2C enumerable = true) {\n  const value = getOptionValue(option);\n  if (value) {\n    ObjectDefineProperty(process\x2C name\x2C {\n      writable: false\x2C\n      configurable: true\x2C\n      enumerable\x2C\n      value\n    });\n  }\n}\n\nfunction setupWarningHandler() {\n  const {\n    onWarning\n  } = require('internal/process/warning');\n  if (getOptionValue('--warnings') &&\n    process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning'\x2C onWarning);\n  }\n}\n\n// https://fetch.spec.whatwg.org/\nfunction setupFetch() {\n  if (process.config.variables.node_no_browser_globals ||\n      !getOptionValue('--experimental-fetch')) {\n    return;\n  }\n\n  emitExperimentalWarning('Fetch');\n\n  const undici = require('internal/deps/undici/undici');\n  ObjectDefineProperty(globalThis\x2C 'fetch'\x2C {\n    writable: true\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    value: undici.fetch\n  });\n  ObjectDefineProperty(globalThis\x2C 'FormData'\x2C {\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: undici.FormData\n  });\n  ObjectDefineProperty(globalThis\x2C 'Headers'\x2C {\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: undici.Headers\n  });\n  ObjectDefineProperty(globalThis\x2C 'Request'\x2C {\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: undici.Request\n  });\n  ObjectDefineProperty(globalThis\x2C 'Response'\x2C {\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: undici.Response\n  });\n}\n\n// TODO(aduh95): move this to internal/bootstrap/browser when the CLI flag is\n//               removed.\nfunction setupWebCrypto() {\n  if (process.config.variables.node_no_browser_globals ||\n      !getOptionValue('--experimental-global-webcrypto')) {\n    return;\n  }\n\n  let webcrypto;\n  ObjectDefineProperty(globalThis\x2C 'crypto'\x2C\n                       ObjectGetOwnPropertyDescriptor({\n                         get crypto() {\n                           webcrypto ??= require('internal/crypto/webcrypto');\n                           return webcrypto.crypto;\n                         }\n                       }\x2C 'crypto'));\n  if (internalBinding('config').hasOpenSSL) {\n    webcrypto ??= require('internal/crypto/webcrypto');\n    ObjectDefineProperty(globalThis\x2C 'Crypto'\x2C {\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: webcrypto.Crypto\n    });\n    ObjectDefineProperty(globalThis\x2C 'CryptoKey'\x2C {\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: webcrypto.CryptoKey\n    });\n    ObjectDefineProperty(globalThis\x2C 'SubtleCrypto'\x2C {\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: webcrypto.SubtleCrypto\n    });\n  }\n}\n\n// Setup User-facing NODE_V8_COVERAGE environment variable that writes\n// ScriptCoverage to a specified file.\nfunction setupCoverageHooks(dir) {\n  const cwd = require('internal/process/execution').tryGetCwd();\n  const { resolve } = require('path');\n  const coverageDirectory = resolve(cwd\x2C dir);\n  const { sourceMapCacheToObject } =\n    require('internal/source_map/source_map_cache');\n\n  if (process.features.inspector) {\n    internalBinding('profiler').setCoverageDirectory(coverageDirectory);\n    internalBinding('profiler').setSourceMapCacheGetter(sourceMapCacheToObject);\n  } else {\n    process.emitWarning('The inspector is disabled\x2C ' +\n                        'coverage could not be collected'\x2C\n                        'Warning');\n    return '';\n  }\n  return coverageDirectory;\n}\n\nfunction setupStacktracePrinterOnSigint() {\n  if (!getOptionValue('--trace-sigint')) {\n    return;\n  }\n  const { SigintWatchdog } = require('internal/watchdog');\n\n  const watchdog = new SigintWatchdog();\n  watchdog.start();\n}\n\nfunction initializeReport() {\n  const { report } = require('internal/process/report');\n  ObjectDefineProperty(process\x2C 'report'\x2C {\n    enumerable: true\x2C\n    configurable: true\x2C\n    get() {\n      return report;\n    }\n  });\n}\n\nfunction setupDebugEnv() {\n  require('internal/util/debuglog').initializeDebugEnv(process.env.NODE_DEBUG);\n  if (getOptionValue('--expose-internals')) {\n    require('internal/bootstrap/loaders').NativeModule.exposeInternals();\n  }\n}\n\n// This has to be called after initializeReport() is called\nfunction initializeReportSignalHandlers() {\n  const { addSignalHandler } = require('internal/process/report');\n\n  addSignalHandler();\n}\n\nfunction initializeHeapSnapshotSignalHandlers() {\n  const signal = getOptionValue('--heapsnapshot-signal');\n\n  if (!signal)\n    return;\n\n  require('internal/validators').validateSignalName(signal);\n  const { writeHeapSnapshot } = require('v8');\n\n  process.on(signal\x2C () => {\n    writeHeapSnapshot();\n  });\n}\n\nfunction setupTraceCategoryState() {\n  const { isTraceCategoryEnabled } = internalBinding('trace_events');\n  const { toggleTraceCategoryState } = require('internal/process/per_thread');\n  toggleTraceCategoryState(isTraceCategoryEnabled('node.async_hooks'));\n}\n\nfunction setupPerfHooks() {\n  require('internal/perf/performance').refreshTimeOrigin();\n  require('internal/perf/utils').refreshTimeOrigin();\n}\n\nfunction setupInspectorHooks() {\n  // If Debugger.setAsyncCallStackDepth is sent during bootstrap\x2C\n  // we cannot immediately call into JS to enable the hooks\x2C which could\n  // interrupt the JS execution of bootstrap. So instead we save the\n  // notification in the inspector agent if it's sent in the middle of\n  // bootstrap\x2C and process the notification later here.\n  if (internalBinding('config').hasInspector) {\n    const {\n      enable\x2C\n      disable\n    } = require('internal/inspector_async_hook');\n    internalBinding('inspector').registerAsyncHook(enable\x2C disable);\n  }\n}\n\n// In general deprecations are initialized wherever the APIs are implemented\x2C\n// this is used to deprecate APIs implemented in C++ where the deprecation\n// utilities are not easily accessible.\nfunction initializeDeprecations() {\n  const { deprecate } = require('internal/util');\n  const pendingDeprecation = getOptionValue('--pending-deprecation');\n\n  // DEP0103: access to `process.binding('util').isX` type checkers\n  // TODO(addaleax): Turn into a full runtime deprecation.\n  const utilBinding = internalBinding('util');\n  const types = require('internal/util/types');\n  for (const name of [\n    'isArrayBuffer'\x2C\n    'isArrayBufferView'\x2C\n    'isAsyncFunction'\x2C\n    'isDataView'\x2C\n    'isDate'\x2C\n    'isExternal'\x2C\n    'isMap'\x2C\n    'isMapIterator'\x2C\n    'isNativeError'\x2C\n    'isPromise'\x2C\n    'isRegExp'\x2C\n    'isSet'\x2C\n    'isSetIterator'\x2C\n    'isTypedArray'\x2C\n    'isUint8Array'\x2C\n    'isAnyArrayBuffer'\x2C\n  ]) {\n    utilBinding[name] = pendingDeprecation ?\n      deprecate(types[name]\x2C\n                'Accessing native typechecking bindings of Node ' +\n                'directly is deprecated. ' +\n                `Please use \\`util.types.${name}\\` instead.`\x2C\n                'DEP0103') :\n      types[name];\n  }\n\n  // TODO(joyeecheung): this is a legacy property exposed to process.\n  // Now that we use the config binding to carry this information\x2C remove\n  // it from the process. We may consider exposing it properly in\n  // process.features.\n  const { noBrowserGlobals } = internalBinding('config');\n  if (noBrowserGlobals) {\n    ObjectDefineProperty(process\x2C '_noBrowserGlobals'\x2C {\n      writable: false\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: noBrowserGlobals\n    });\n  }\n\n  if (pendingDeprecation) {\n    process.binding = deprecate(process.binding\x2C\n                                'process.binding() is deprecated. ' +\n                                'Please use public APIs instead.'\x2C 'DEP0111');\n\n    process._tickCallback = deprecate(process._tickCallback\x2C\n                                      'process._tickCallback() is deprecated'\x2C\n                                      'DEP0134');\n  }\n\n  // Create global.process and global.Buffer as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _process = process;\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\n    get() {\n      return _process;\n    }\x2C\n    set(value) {\n      _process = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n\n  let _Buffer = Buffer;\n  ObjectDefineProperty(globalThis\x2C 'Buffer'\x2C {\n    get() {\n      return _Buffer;\n    }\x2C\n    set(value) {\n      _Buffer = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n}\n\nfunction setupChildProcessIpcChannel() {\n  if (process.env.NODE_CHANNEL_FD) {\n    const assert = require('internal/assert');\n\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD\x2C 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const serializationMode =\n      process.env.NODE_CHANNEL_SERIALIZATION_MODE || 'json';\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\n\n    require('child_process')._forkChild(fd\x2C serializationMode);\n    assert(process.send);\n  }\n}\n\nfunction initializeClusterIPC() {\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n    const cluster = require('cluster');\n    cluster._setupWorker();\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_UNIQUE_ID;\n  }\n}\n\nfunction initializePolicy() {\n  const experimentalPolicy = getOptionValue('--experimental-policy');\n  if (experimentalPolicy) {\n    process.emitWarning('Policies are experimental.'\x2C\n                        'ExperimentalWarning');\n    const { pathToFileURL\x2C URL } = require('internal/url');\n    // URL here as it is slightly different parsing\n    // no bare specifiers for now\n    let manifestURL;\n    if (require('path').isAbsolute(experimentalPolicy)) {\n      manifestURL = new URL(`file://${experimentalPolicy}`);\n    } else {\n      const cwdURL = pathToFileURL(process.cwd());\n      cwdURL.pathname += '/';\n      manifestURL = new URL(experimentalPolicy\x2C cwdURL);\n    }\n    const fs = require('fs');\n    const src = fs.readFileSync(manifestURL\x2C 'utf8');\n    const experimentalPolicyIntegrity = getOptionValue('--policy-integrity');\n    if (experimentalPolicyIntegrity) {\n      const SRI = require('internal/policy/sri');\n      const { createHash\x2C timingSafeEqual } = require('crypto');\n      const realIntegrities = new SafeMap();\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\n      let foundMatch = false;\n      for (let i = 0; i < integrityEntries.length; i++) {\n        const {\n          algorithm\x2C\n          value: expected\n        } = integrityEntries[i];\n        const hash = createHash(algorithm);\n        hash.update(src);\n        const digest = hash.digest();\n        if (digest.length === expected.length &&\n          timingSafeEqual(digest\x2C expected)) {\n          foundMatch = true;\n          break;\n        }\n        realIntegrities.set(algorithm\x2C digest.toString('base64'));\n      }\n      if (!foundMatch) {\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL\x2C realIntegrities);\n      }\n    }\n    require('internal/process/policy')\n      .setup(src\x2C manifestURL.href);\n  }\n}\n\nfunction initializeWASI() {\n  const { NativeModule } = require('internal/bootstrap/loaders');\n  const mod = NativeModule.map.get('wasi');\n  mod.canBeRequiredByUsers =\n    getOptionValue('--experimental-wasi-unstable-preview1');\n}\n\nfunction initializeCJSLoader() {\n  const CJSLoader = require('internal/modules/cjs/loader');\n  if (!getEmbedderOptions().noGlobalSearchPaths) {\n    CJSLoader.Module._initPaths();\n  }\n  // TODO(joyeecheung): deprecate this in favor of a proper hook?\n  CJSLoader.Module.runMain =\n    require('internal/modules/run_main').executeUserEntryPoint;\n}\n\nfunction initializeESMLoader() {\n  // Create this WeakMap in js-land because V8 has no C++ API for WeakMap.\n  internalBinding('module_wrap').callbackMap = new SafeWeakMap();\n\n  if (getEmbedderOptions().shouldNotRegisterESMLoader) return;\n\n  const {\n    setImportModuleDynamicallyCallback\x2C\n    setInitializeImportMetaObjectCallback\n  } = internalBinding('module_wrap');\n  const esm = require('internal/process/esm_loader');\n  // Setup per-isolate callbacks that locate data or callbacks that we keep\n  // track of for different ESM modules.\n  setInitializeImportMetaObjectCallback(esm.initializeImportMetaObject);\n  setImportModuleDynamicallyCallback(esm.importModuleDynamicallyCallback);\n\n  // Patch the vm module when --experimental-vm-modules is on.\n  // Please update the comments in vm.js when this block changes.\n  if (getOptionValue('--experimental-vm-modules')) {\n    const {\n      Module\x2C SourceTextModule\x2C SyntheticModule\x2C\n    } = require('internal/vm/module');\n    const vm = require('vm');\n    vm.Module = Module;\n    vm.SourceTextModule = SourceTextModule;\n    vm.SyntheticModule = SyntheticModule;\n  }\n}\n\nfunction initializeSourceMapsHandlers() {\n  const { setSourceMapsEnabled } =\n    require('internal/source_map/source_map_cache');\n  process.setSourceMapsEnabled = setSourceMapsEnabled;\n}\n\nfunction initializeFrozenIntrinsics() {\n  if (getOptionValue('--frozen-intrinsics')) {\n    process.emitWarning('The --frozen-intrinsics flag is experimental'\x2C\n                        'ExperimentalWarning');\n    require('internal/freeze_intrinsics')();\n  }\n}\n\nfunction loadPreloadModules() {\n  // For user code\x2C we preload modules if `-r` is passed\n  const preloadModules = getOptionValue('--require');\n  if (preloadModules && preloadModules.length > 0) {\n    const {\n      Module: {\n        _preloadModules\n      }\x2C\n    } = require('internal/modules/cjs/loader');\n    _preloadModules(preloadModules);\n  }\n}\n\nmodule.exports = {\n  patchProcessObject\x2C\n  setupCoverageHooks\x2C\n  setupWarningHandler\x2C\n  setupFetch\x2C\n  setupWebCrypto\x2C\n  setupDebugEnv\x2C\n  setupPerfHooks\x2C\n  prepareMainThreadExecution\x2C\n  initializeDeprecations\x2C\n  initializeESMLoader\x2C\n  initializeFrozenIntrinsics\x2C\n  initializeSourceMapsHandlers\x2C\n  loadPreloadModules\x2C\n  setupTraceCategoryState\x2C\n  setupInspectorHooks\x2C\n  initializeReport\x2C\n  initializeCJSLoader\x2C\n  initializeWASI\n};\n
code-source-info,0x3172a1b07a2e,96,0,18164,C0O0C4O18164,,
code-creation,Function,10,14084,0x3172a1b0864e,479, node:internal/bootstrap/pre_execution:1:1,0x3172a1b079a8,~
code-source-info,0x3172a1b0864e,96,0,18164,C0O0C208O25C214O43C220O67C226O101C232O112C238O127C244O156C250O238C256O238C261O196C267O214C273O303C279O303C284O275C290O370C296O370C301O341C307O416C313O416C318O405C324O477C330O477C335O503C340O443C346O526C352O526C356O526C358O17735C365O17756C371O17778C377O17800C383O17823C389O17837C395O17855C401O17872C407O17890C413O17920C419O17946C425O17969C431O17999C437O18031C443O18053C449O18080C455O18103C461O18123C467O18146C473O17750C478O18163,,
code-creation,Eval,10,14209,0x3172a1b0a2f6,5, node:internal/options:1:1,0x3172a1b0a120,~
script-source,97,node:internal/options,'use strict';\n\nconst {\n  getCLIOptions\x2C\n  getEmbedderOptions: getEmbedderOptionsFromBinding\x2C\n} = internalBinding('options');\n\nlet warnOnAllowUnauthorized = true;\n\nlet optionsMap;\nlet aliasesMap;\nlet embedderOptions;\n\n// getCLIOptions() would serialize the option values from C++ land.\n// It would error if the values are queried before bootstrap is\n// complete so that we don't accidentally include runtime-dependent\n// states into a runtime-independent snapshot.\nfunction getCLIOptionsFromBinding() {\n  if (!optionsMap) {\n    ({ options: optionsMap } = getCLIOptions());\n  }\n  return optionsMap;\n}\n\nfunction getAliasesFromBinding() {\n  if (!aliasesMap) {\n    ({ aliases: aliasesMap } = getCLIOptions());\n  }\n  return aliasesMap;\n}\n\nfunction getEmbedderOptions() {\n  if (!embedderOptions) {\n    embedderOptions = getEmbedderOptionsFromBinding();\n  }\n  return embedderOptions;\n}\n\nfunction getOptionValue(optionName) {\n  const options = getCLIOptionsFromBinding();\n  if (optionName.startsWith('--no-')) {\n    const option = options.get('--' + optionName.slice(5));\n    return option && !option.value;\n  }\n  return options.get(optionName)?.value;\n}\n\nfunction getAllowUnauthorized() {\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';\n\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\n    warnOnAllowUnauthorized = false;\n    process.emitWarning(\n      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +\n      'environment variable to \\'0\\' makes TLS connections ' +\n      'and HTTPS requests insecure by disabling ' +\n      'certificate verification.');\n  }\n  return allowUnauthorized;\n}\n\nmodule.exports = {\n  get options() {\n    return getCLIOptionsFromBinding();\n  }\x2C\n  get aliases() {\n    return getAliasesFromBinding();\n  }\x2C\n  getOptionValue\x2C\n  getAllowUnauthorized\x2C\n  getEmbedderOptions\n};\n
code-source-info,0x3172a1b0a2f6,97,0,1820,C0O0C4O1820,,
code-creation,Function,10,14292,0x3172a1b0a6c6,154, node:internal/options:1:1,0x3172a1b0a270,~
code-source-info,0x3172a1b0a6c6,97,0,1820,C0O0C54O97C57O97C62O25C68O62C74O156C75O156C77O167C78O167C80O183C81O183C83O199C84O199C86O1614C93O1756C99O1774C105O1798C148O1629C153O1819,,
tick,0x1bfc3b510,14292,1,0x10041f4d8,3,0x0,0x3172a1b06a74,0x3172a1b05d65,0x3172a1b0874e,0x3172a1b06a95,0x3172a1b05d65,0x3172a1b05ae1
code-creation,LazyCompile,10,14334,0x3172a1b0abd6,69,internalBinding node:internal/bootstrap/loaders:164:45,0x2b48e0c4f828,~
code-source-info,0x3172a1b0abd6,9,5115,5353,C0O5140C7O5150C11O5164C15O5201C25O5228C30O5226C37O5262C48O5281C56O5317C61O5262C66O5338C68O5349,,
code-creation,LazyCompile,10,14417,0x3172a1b0b3c6,225,prepareMainThreadExecution node:internal/bootstrap/pre_execution:26:36,0x3172a1b07a60,~
code-source-info,0x3172a1b0b3c6,96,590,2515,C10O733C15O733C18O835C21O835C25O870C28O870C31O899C34O899C37O919C40O919C43O944C46O944C49O969C52O969C55O985C58O985C61O1183C64O1195C69O1199C75O1223C78O1231C89O1287C94O1291C99O1260C103O1252C107O1318C110O1318C113O1410C116O1410C119O1516C122O1516C125O1538C128O1538C131O1597C134O1597C137O1920C140O1920C143O1995C146O1995C149O2192C152O2192C155O2219C158O2219C161O2253C164O2253C167O2281C170O2281C173O2301C176O2301C179O2326C182O2326C185O2370C191O2370C196O2412C201O2430C207O2412C211O2460C214O2460C217O2484C220O2484C224O2514,,
code-creation,LazyCompile,10,14500,0x3172a1b0c896,19,reconnectZeroFillToggle node:internal/buffer:1072:33,0x232faba3eed0,~
script-source,25,node:internal/buffer,'use strict';\n\nconst {\n  BigInt\x2C\n  Float32Array\x2C\n  Float64Array\x2C\n  MathFloor\x2C\n  Number\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\n} = require('internal/errors').codes;\nconst { validateNumber } = require('internal/validators');\nconst {\n  asciiSlice\x2C\n  base64Slice\x2C\n  base64urlSlice\x2C\n  latin1Slice\x2C\n  hexSlice\x2C\n  ucs2Slice\x2C\n  utf8Slice\x2C\n  asciiWrite\x2C\n  base64Write\x2C\n  base64urlWrite\x2C\n  latin1Write\x2C\n  hexWrite\x2C\n  ucs2Write\x2C\n  utf8Write\x2C\n  getZeroFillToggle\n} = internalBinding('buffer');\nconst {\n  untransferable_object_private_symbol\x2C\n  setHiddenValue\x2C\n} = internalBinding('util');\n\n// Temporary buffers to convert numbers.\nconst float32Array = new Float32Array(1);\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\n\n// Check endianness.\nfloat32Array[0] = -1; // 0xBF800000\n// Either it is [0\x2C 0\x2C 128\x2C 191] or [191\x2C 128\x2C 0\x2C 0]. It is not possible to\n// check this with `os.endianness()` because that is determined at compile time.\nconst bigEndian = uInt8Float32Array[3] === 0;\n\nfunction checkBounds(buf\x2C offset\x2C byteLength) {\n  validateNumber(offset\x2C 'offset');\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\n    boundsError(offset\x2C buf.length - (byteLength + 1));\n}\n\nfunction checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === 0n) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` +\n                `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new ERR_OUT_OF_RANGE('value'\x2C range\x2C value);\n  }\n  checkBounds(buf\x2C offset\x2C byteLength);\n}\n\nfunction boundsError(value\x2C length\x2C type) {\n  if (MathFloor(value) !== value) {\n    validateNumber(value\x2C type);\n    throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C 'an integer'\x2C value);\n  }\n\n  if (length < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n  throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C\n                             `>= ${type ? 1 : 0} and <= ${length}`\x2C\n                             value);\n}\n\n// Read integers.\nfunction readBigUInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24;\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n\n  return BigInt(lo) + (BigInt(hi) << 32n);\n}\n\nfunction readBigUInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n\n  return (BigInt(hi) << 32n) + BigInt(lo);\n}\n\nfunction readBigInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24); // Overflow\n  return (BigInt(val) << 32n) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24);\n}\n\nfunction readBigInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n  return (BigInt(val) << 32n) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last);\n}\n\nfunction readUIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32LE(offset);\n  if (byteLength === 2)\n    return this.readUInt16LE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n}\n\nfunction readUInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    last * 2 ** 32;\n}\n\nfunction readUInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n}\n\nfunction readUInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n}\n\nfunction readUInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first + last * 2 ** 8;\n}\n\nfunction readUInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val;\n}\n\nfunction readUIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32BE(offset);\n  if (byteLength === 2)\n    return this.readUInt16BE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\n\nfunction readUInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first * 2 ** 8 + last;\n}\n\nfunction readIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32LE(offset);\n  if (byteLength === 2)\n    return this.readInt16LE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[offset + 4] + last * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    (last << 24); // Overflow\n}\n\nfunction readInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first + last * 2 ** 8;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\nfunction readInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val | (val & 2 ** 7) * 0x1fffffe;\n}\n\nfunction readIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32BE(offset);\n  if (byteLength === 2)\n    return this.readInt16BE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[++offset] + first * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first * 2 ** 8 + last;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\n// Read floats\nfunction readFloatBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[3] = first;\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[0] = last;\n  return float32Array[0];\n}\n\nfunction readFloatForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[0] = first;\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[3] = last;\n  return float32Array[0];\n}\n\nfunction readDoubleBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[7] = first;\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[0] = last;\n  return float64Array[0];\n}\n\nfunction readDoubleForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[0] = first;\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[7] = last;\n  return float64Array[0];\n}\n\n// Write integers.\nfunction writeBigU_Int64LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction writeBigUInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigU_Int64BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nfunction writeBigUInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeBigInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeUIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = newVal;\n  buf[offset++] = (newVal >>> 8);\n  return offset;\n}\n\nfunction writeU_Int40LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  const newVal = value;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\n  return offset;\n}\n\nfunction writeU_Int32LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeU_Int16LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = value;\n  buf[offset++] = (value >>> 8);\n  return offset;\n}\n\nfunction writeUInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeU_Int8(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  // `checkInt()` can not be used here because it checks two entries.\n  validateNumber(offset\x2C 'offset');\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE('value'\x2C `>= ${min} and <= ${max}`\x2C value);\n  }\n  if (buf[offset] === undefined)\n    boundsError(offset\x2C buf.length - 1);\n\n  buf[offset] = value;\n  return offset + 1;\n}\n\nfunction writeUInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n}\n\nfunction writeUIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = (newVal >>> 8);\n  buf[offset++] = newVal;\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int40BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  buf[offset++] = MathFloor(value * 2 ** -32);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int32BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeUInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 3;\n}\n\nfunction writeU_Int16BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\nfunction writeInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n}\n\nfunction writeIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\n// Write floats.\nfunction writeDoubleForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[0];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[7];\n  return offset;\n}\n\nfunction writeDoubleBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[7];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[0];\n  return offset;\n}\n\nfunction writeFloatForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[0];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[3];\n  return offset;\n}\n\nfunction writeFloatBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[3];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[0];\n  return offset;\n}\n\nclass FastBuffer extends Uint8Array {\n  // Using an explicit constructor here is necessary to avoid relying on\n  // `Array.prototype[Symbol.iterator]`\x2C which can be mutated by users.\n  // eslint-disable-next-line no-useless-constructor\n  constructor(bufferOrLength\x2C byteOffset\x2C length) {\n    super(bufferOrLength\x2C byteOffset\x2C length);\n  }\n}\n\nfunction addBufferPrototypeMethods(proto) {\n  proto.readBigUInt64LE = readBigUInt64LE;\n  proto.readBigUInt64BE = readBigUInt64BE;\n  proto.readBigUint64LE = readBigUInt64LE;\n  proto.readBigUint64BE = readBigUInt64BE;\n  proto.readBigInt64LE = readBigInt64LE;\n  proto.readBigInt64BE = readBigInt64BE;\n  proto.writeBigUInt64LE = writeBigUInt64LE;\n  proto.writeBigUInt64BE = writeBigUInt64BE;\n  proto.writeBigUint64LE = writeBigUInt64LE;\n  proto.writeBigUint64BE = writeBigUInt64BE;\n  proto.writeBigInt64LE = writeBigInt64LE;\n  proto.writeBigInt64BE = writeBigInt64BE;\n\n  proto.readUIntLE = readUIntLE;\n  proto.readUInt32LE = readUInt32LE;\n  proto.readUInt16LE = readUInt16LE;\n  proto.readUInt8 = readUInt8;\n  proto.readUIntBE = readUIntBE;\n  proto.readUInt32BE = readUInt32BE;\n  proto.readUInt16BE = readUInt16BE;\n  proto.readUintLE = readUIntLE;\n  proto.readUint32LE = readUInt32LE;\n  proto.readUint16LE = readUInt16LE;\n  proto.readUint8 = readUInt8;\n  proto.readUintBE = readUIntBE;\n  proto.readUint32BE = readUInt32BE;\n  proto.readUint16BE = readUInt16BE;\n  proto.readIntLE = readIntLE;\n  proto.readInt32LE = readInt32LE;\n  proto.readInt16LE = readInt16LE;\n  proto.readInt8 = readInt8;\n  proto.readIntBE = readIntBE;\n  proto.readInt32BE = readInt32BE;\n  proto.readInt16BE = readInt16BE;\n\n  proto.writeUIntLE = writeUIntLE;\n  proto.writeUInt32LE = writeUInt32LE;\n  proto.writeUInt16LE = writeUInt16LE;\n  proto.writeUInt8 = writeUInt8;\n  proto.writeUIntBE = writeUIntBE;\n  proto.writeUInt32BE = writeUInt32BE;\n  proto.writeUInt16BE = writeUInt16BE;\n  proto.writeUintLE = writeUIntLE;\n  proto.writeUint32LE = writeUInt32LE;\n  proto.writeUint16LE = writeUInt16LE;\n  proto.writeUint8 = writeUInt8;\n  proto.writeUintBE = writeUIntBE;\n  proto.writeUint32BE = writeUInt32BE;\n  proto.writeUint16BE = writeUInt16BE;\n  proto.writeIntLE = writeIntLE;\n  proto.writeInt32LE = writeInt32LE;\n  proto.writeInt16LE = writeInt16LE;\n  proto.writeInt8 = writeInt8;\n  proto.writeIntBE = writeIntBE;\n  proto.writeInt32BE = writeInt32BE;\n  proto.writeInt16BE = writeInt16BE;\n\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\n\n  proto.asciiSlice = asciiSlice;\n  proto.base64Slice = base64Slice;\n  proto.base64urlSlice = base64urlSlice;\n  proto.latin1Slice = latin1Slice;\n  proto.hexSlice = hexSlice;\n  proto.ucs2Slice = ucs2Slice;\n  proto.utf8Slice = utf8Slice;\n  proto.asciiWrite = asciiWrite;\n  proto.base64Write = base64Write;\n  proto.base64urlWrite = base64urlWrite;\n  proto.latin1Write = latin1Write;\n  proto.hexWrite = hexWrite;\n  proto.ucs2Write = ucs2Write;\n  proto.utf8Write = utf8Write;\n}\n\n// This would better be placed in internal/worker/io.js\x2C but that doesn't work\n// because Buffer needs this and that would introduce a cyclic dependency.\nfunction markAsUntransferable(obj) {\n  if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null)\n    return;  // This object is a primitive and therefore already untransferable.\n  setHiddenValue(obj\x2C untransferable_object_private_symbol\x2C true);\n}\n\n// A toggle used to access the zero fill setting of the array buffer allocator\n// in C++.\n// |zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nlet zeroFill = getZeroFillToggle();\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\n// The connection between the JS land zero fill toggle and the\n// C++ one in the NodeArrayBufferAllocator gets lost if the toggle\n// is deserialized from the snapshot\x2C because V8 owns the underlying\n// memory of this toggle. This resets the connection.\nfunction reconnectZeroFillToggle() {\n  zeroFill = getZeroFillToggle();\n}\n\nmodule.exports = {\n  FastBuffer\x2C\n  addBufferPrototypeMethods\x2C\n  markAsUntransferable\x2C\n  createUnsafeBuffer\x2C\n  readUInt16BE\x2C\n  readUInt32BE\x2C\n  reconnectZeroFillToggle\n};\n
code-source-info,0x3172a1b0c896,25,30717,30757,C0O30724C5O30735C11O30733C18O30756,,
tick,0x1bfd39474,15625,0,0x0,3,0x0,0x3172a1b0b3d5,0x3172a1b05aed
code-creation,LazyCompile,10,15667,0x3172a1b0f0ce,397,patchProcessObject node:internal/bootstrap/pre_execution:87:28,0x3172a1b07ab0,~
code-source-info,0x3172a1b0f0ce,96,2544,4157,C0O2578C6O2578C11O2624C19O2624C24O2656C30O2656C35O2694C40O2695C44O2721C55O2742C63O2828C69O2832C76O2721C81O2844C84O2852C94O2870C98O2860C102O2883C109O2910C116O2914C123O2928C129O2962C136O2966C143O2928C150O3044C156O3044C164O3077C167O3085C175O3100C183O3116C190O3120C194O3100C199O3093C209O3332C218O3332C223O3378C232O3378C237O3431C246O3431C251O3491C260O3491C265O3549C274O3549C279O3609C288O3609C293O3673C302O3673C307O3738C316O3738C321O3809C330O3809C335O3879C344O3879C349O3939C358O3939C363O4009C374O4009C379O4079C390O4079C396O4156,,
code-creation,LazyCompile,10,15709,0x3172a1b0f57e,69,refreshHrtimeBuffer node:internal/process/per_thread:66:29,0x815de60d268,~
script-source,30,node:internal/process/per_thread,'use strict';\n\n// This files contains process bootstrappers that can be\n// run when setting up each thread\x2C including the main\n// thread and the worker threads.\n\nconst {\n  ArrayPrototypeEvery\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  BigUint64Array\x2C\n  Float64Array\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  ObjectFreeze\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  Set\x2C\n  SetPrototypeEntries\x2C\n  SetPrototypeValues\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  Uint32Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_ASSERTION\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\n} = require('internal/errors');\nconst format = require('internal/util/inspect').format;\nconst {\n  validateArray\x2C\n  validateNumber\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst constants = internalBinding('constants').os.signals;\n\nconst {\n  handleProcessExit\x2C\n} = require('internal/modules/esm/handle_process_exit');\n\nconst kInternal = Symbol('internal properties');\n\nfunction assert(x\x2C msg) {\n  if (!x) throw new ERR_ASSERTION(msg || 'assertion error');\n}\n\nconst binding = internalBinding('process_methods');\n\nlet hrValues;\nlet hrBigintValues;\n\nfunction refreshHrtimeBuffer() {\n  // The 3 entries filled in by the original process.hrtime contains\n  // the upper/lower 32 bits of the second part of the value\x2C\n  // and the remaining nanoseconds of the value.\n  hrValues = new Uint32Array(binding.hrtimeBuffer);\n  // Use a BigUint64Array in the closure because this is actually a bit\n  // faster than simply returning a BigInt from C++ in V8 7.1.\n  hrBigintValues = new BigUint64Array(binding.hrtimeBuffer\x2C 0\x2C 1);\n}\n\n// Create the buffers.\nrefreshHrtimeBuffer();\n\nfunction hrtime(time) {\n  binding.hrtime();\n\n  if (time !== undefined) {\n    validateArray(time\x2C 'time');\n    if (time.length !== 2) {\n      throw new ERR_OUT_OF_RANGE('time'\x2C 2\x2C time.length);\n    }\n\n    const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n    const nsec = hrValues[2] - time[1];\n    const needsBorrow = nsec < 0;\n    return [needsBorrow ? sec - 1 : sec\x2C needsBorrow ? nsec + 1e9 : nsec];\n  }\n\n  return [\n    hrValues[0] * 0x100000000 + hrValues[1]\x2C\n    hrValues[2]\x2C\n  ];\n}\n\nfunction hrtimeBigInt() {\n  binding.hrtimeBigInt();\n  return hrBigintValues[0];\n}\n\n// The execution of this function itself should not cause any side effects.\nfunction wrapProcessMethods(binding) {\n  const {\n    cpuUsage: _cpuUsage\x2C\n    memoryUsage: _memoryUsage\x2C\n    rss\x2C\n    resourceUsage: _resourceUsage\n  } = binding;\n\n  function _rawDebug(...args) {\n    binding._rawDebug(ReflectApply(format\x2C null\x2C args));\n  }\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  function cpuUsage(prevValue) {\n    // If a previous value was passed in\x2C ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        validateObject(prevValue\x2C 'prevValue');\n\n        validateNumber(prevValue.user\x2C 'prevValue.user');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.user'\x2C\n                                                   prevValue.user);\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        validateNumber(prevValue.system\x2C 'prevValue.system');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.system'\x2C\n                                                   prevValue.system);\n      }\n    }\n\n    // Call the native function to get the current values.\n    _cpuUsage(cpuValues);\n\n    // If a previous value was passed in\x2C return diff of current from previous.\n    if (prevValue) {\n      return {\n        user: cpuValues[0] - prevValue.user\x2C\n        system: cpuValues[1] - prevValue.system\n      };\n    }\n\n    // If no previous value passed in\x2C return current value.\n    return {\n      user: cpuValues[0]\x2C\n      system: cpuValues[1]\n    };\n  }\n\n  // Ensure that a previously passed in value is valid. Currently\x2C the native\n  // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n  function previousValueIsValid(num) {\n    return typeof num === 'number' &&\n        num <= NumberMAX_SAFE_INTEGER &&\n        num >= 0;\n  }\n\n  const memValues = new Float64Array(5);\n  function memoryUsage() {\n    _memoryUsage(memValues);\n    return {\n      rss: memValues[0]\x2C\n      heapTotal: memValues[1]\x2C\n      heapUsed: memValues[2]\x2C\n      external: memValues[3]\x2C\n      arrayBuffers: memValues[4]\n    };\n  }\n\n  memoryUsage.rss = rss;\n\n  function exit(code) {\n    process.off('exit'\x2C handleProcessExit);\n\n    if (code || code === 0)\n      process.exitCode = code;\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit'\x2C process.exitCode || 0);\n    }\n    // FIXME(joyeecheung): This is an undocumented API that gets monkey-patched\n    // in the user land. Either document it\x2C or deprecate it in favor of a\n    // better public alternative.\n    process.reallyExit(process.exitCode || 0);\n  }\n\n  function kill(pid\x2C sig) {\n    let err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new ERR_INVALID_ARG_TYPE('pid'\x2C 'number'\x2C pid);\n    }\n\n    // Preserve null signal\n    if (sig === (sig | 0)) {\n      // XXX(joyeecheung): we have to use process._kill here because\n      // it's monkey-patched by tests.\n      err = process._kill(pid\x2C sig);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (constants[sig]) {\n        err = process._kill(pid\x2C constants[sig]);\n      } else {\n        throw new ERR_UNKNOWN_SIGNAL(sig);\n      }\n    }\n\n    if (err)\n      throw errnoException(err\x2C 'kill');\n\n    return true;\n  }\n\n  const resourceValues = new Float64Array(16);\n  function resourceUsage() {\n    _resourceUsage(resourceValues);\n    return {\n      userCPUTime: resourceValues[0]\x2C\n      systemCPUTime: resourceValues[1]\x2C\n      maxRSS: resourceValues[2]\x2C\n      sharedMemorySize: resourceValues[3]\x2C\n      unsharedDataSize: resourceValues[4]\x2C\n      unsharedStackSize: resourceValues[5]\x2C\n      minorPageFault: resourceValues[6]\x2C\n      majorPageFault: resourceValues[7]\x2C\n      swappedOut: resourceValues[8]\x2C\n      fsRead: resourceValues[9]\x2C\n      fsWrite: resourceValues[10]\x2C\n      ipcSent: resourceValues[11]\x2C\n      ipcReceived: resourceValues[12]\x2C\n      signalsCount: resourceValues[13]\x2C\n      voluntaryContextSwitches: resourceValues[14]\x2C\n      involuntaryContextSwitches: resourceValues[15]\n    };\n  }\n\n\n  return {\n    _rawDebug\x2C\n    cpuUsage\x2C\n    resourceUsage\x2C\n    memoryUsage\x2C\n    kill\x2C\n    exit\n  };\n}\n\nconst replaceUnderscoresRegex = /_/g;\nconst leadingDashesRegex = /^--?/;\nconst trailingValuesRegex = /=.*$/;\n\n// This builds the initial process.allowedNodeEnvironmentFlags\n// from data in the config binding.\nfunction buildAllowedFlags() {\n  const {\n    envSettings: { kAllowedInEnvironment }\x2C\n    types: { kBoolean }\x2C\n  } = internalBinding('options');\n  const { options\x2C aliases } = require('internal/options');\n\n  const allowedNodeEnvironmentFlags = [];\n  for (const { 0: name\x2C 1: info } of options) {\n    if (info.envVarSettings === kAllowedInEnvironment) {\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C name);\n      if (info.type === kBoolean) {\n        const negatedName = `--no-${name.slice(2)}`;\n        ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C negatedName);\n      }\n    }\n  }\n\n  function isAccepted(to) {\n    if (!StringPrototypeStartsWith(to\x2C '-') || to === '--') return true;\n    const recursiveExpansion = aliases.get(to);\n    if (recursiveExpansion) {\n      if (recursiveExpansion[0] === to)\n        ArrayPrototypeSplice(recursiveExpansion\x2C 0\x2C 1);\n      return ArrayPrototypeEvery(recursiveExpansion\x2C isAccepted);\n    }\n    return options.get(to).envVarSettings === kAllowedInEnvironment;\n  }\n  for (const { 0: from\x2C 1: expansion } of aliases) {\n    if (ArrayPrototypeEvery(expansion\x2C isAccepted)) {\n      let canonical = from;\n      if (StringPrototypeEndsWith(canonical\x2C '='))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 1);\n      if (StringPrototypeEndsWith(canonical\x2C ' <arg>'))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 4);\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C canonical);\n    }\n  }\n\n  const trimLeadingDashes =\n    (flag) => StringPrototypeReplace(flag\x2C leadingDashesRegex\x2C '');\n\n  // Save these for comparison against flags provided to\n  // process.allowedNodeEnvironmentFlags.has() which lack leading dashes.\n  const nodeFlags = ArrayPrototypeMap(allowedNodeEnvironmentFlags\x2C\n                                      trimLeadingDashes);\n\n  class NodeEnvironmentFlagsSet extends Set {\n    constructor(array) {\n      super();\n      this[kInternal] = { array };\n    }\n\n    add() {\n      // No-op\x2C `Set` API compatible\n      return this;\n    }\n\n    delete() {\n      // No-op\x2C `Set` API compatible\n      return false;\n    }\n\n    clear() {\n      // No-op\x2C `Set` API compatible\n    }\n\n    has(key) {\n      // This will return `true` based on various possible\n      // permutations of a flag\x2C including present/missing leading\n      // dash(es) and/or underscores-for-dashes.\n      // Strips any values after `=`\x2C inclusive.\n      // TODO(addaleax): It might be more flexible to run the option parser\n      // on a dummy option set and see whether it rejects the argument or\n      // not.\n      if (typeof key === 'string') {\n        key = StringPrototypeReplace(key\x2C replaceUnderscoresRegex\x2C '-');\n        if (RegExpPrototypeTest(leadingDashesRegex\x2C key)) {\n          key = StringPrototypeReplace(key\x2C trailingValuesRegex\x2C '');\n          return ArrayPrototypeIncludes(this[kInternal].array\x2C key);\n        }\n        return ArrayPrototypeIncludes(nodeFlags\x2C key);\n      }\n      return false;\n    }\n\n    entries() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeEntries(this[kInternal].set);\n    }\n\n    forEach(callback\x2C thisArg = undefined) {\n      ArrayPrototypeForEach(\n        this[kInternal].array\x2C\n        (v) => ReflectApply(callback\x2C thisArg\x2C [v\x2C v\x2C this])\n      );\n    }\n\n    get size() {\n      return this[kInternal].array.length;\n    }\n\n    values() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeValues(this[kInternal].set);\n    }\n  }\n  NodeEnvironmentFlagsSet.prototype.keys =\n  NodeEnvironmentFlagsSet.prototype[SymbolIterator] =\n    NodeEnvironmentFlagsSet.prototype.values;\n\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\n\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(\n    allowedNodeEnvironmentFlags\n  ));\n}\n\n// Lazy load internal/trace_events_async_hooks only if the async_hooks\n// trace event category is enabled.\nlet traceEventsAsyncHook;\n// Dynamically enable/disable the traceEventsAsyncHook\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\n  if (asyncHooksEnabled) {\n    if (!traceEventsAsyncHook) {\n      traceEventsAsyncHook =\n        require('internal/trace_events_async_hooks').createHook();\n    }\n    traceEventsAsyncHook.enable();\n  } else if (traceEventsAsyncHook) {\n    traceEventsAsyncHook.disable();\n  }\n}\n\nmodule.exports = {\n  toggleTraceCategoryState\x2C\n  assert\x2C\n  buildAllowedFlags\x2C\n  wrapProcessMethods\x2C\n  hrtime\x2C\n  hrtimeBigInt\x2C\n  refreshHrtimeBuffer\x2C\n};\n
code-source-info,0x3172a1b0f57e,30,1412,1852,C0O1599C7O1626C10O1634C17O1610C25O1608C31O1786C38O1822C41O1830C53O1803C61O1801C68O1851,,
code-creation,LazyCompile,10,16209,0x3172a1b10506,175,resolve node:path:1091:10,0x815de63ad08,~
script-source,41,node:path,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst {\n  CHAR_UPPERCASE_A\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_UPPERCASE_Z\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_QUESTION_MARK\x2C\n} = require('internal/constants');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path\x2C allowAboveRoot\x2C separator\x2C isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path\x2C i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 1) !== CHAR_DOT ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res\x2C separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res\x2C 0\x2C lastSlashIndex);\n              lastSegmentLength =\n                res.length - 1 - StringPrototypeLastIndexOf(res\x2C separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path\x2C lastSlash + 1\x2C i)}`;\n        else\n          res = StringPrototypeSlice(path\x2C lastSlash + 1\x2C i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n/**\n * @param {string} sep\n * @param {{\n *  dir?: string;\n *  root?: string;\n *  base?: string;\n *  name?: string;\n *  ext?: string;\n *  }} pathObject\n * @returns {string}\n */\nfunction _format(sep\x2C pathObject) {\n  validateObject(pathObject\x2C 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path\x2C 'path');\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path\x2C get cwd for that drive\x2C or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points\x2C because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not\x2C default to the drive's root.\n        if (path === undefined ||\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path\x2C 0\x2C 2)) !==\n            StringPrototypeToLowerCase(resolvedDevice) &&\n            StringPrototypeCharCodeAt(path\x2C 2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator\x2C we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len &&\n                 !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len &&\n                   isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len &&\n                     !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device =\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n        // Possible device root\n        device = StringPrototypeSlice(path\x2C 0\x2C 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !==\n              StringPrototypeToLowerCase(resolvedDevice))\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail =\n          `${StringPrototypeSlice(path\x2C rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail\x2C !resolvedAbsolute\x2C '\\\\'\x2C\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char\x2C exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator\x2C we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device =\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      device = StringPrototypeSlice(path\x2C 0\x2C 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(StringPrototypeSlice(path\x2C rootEnd)\x2C\n                      !isAbsolute\x2C '\\\\'\x2C isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 &&\n        isPathSeparator(StringPrototypeCharCodeAt(path\x2C len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n      isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)));\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes\x2C because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components\x2C so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server'\x2C 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 &&\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(StringPrototypeCharCodeAt(joined\x2C slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined\x2C slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  }\x2C\n\n  /**\n   * It will solve the relative path from `from` to `to`\x2C for instance\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           StringPrototypeCharCodeAt(from\x2C fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (\n      fromEnd - 1 > fromStart &&\n      StringPrototypeCharCodeAt(from\x2C fromEnd - 1) === CHAR_BACKWARD_SLASH\n    ) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           StringPrototypeCharCodeAt(to\x2C toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           StringPrototypeCharCodeAt(to\x2C toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen\x2C so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return StringPrototypeSlice(toOrig\x2C toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return StringPrototypeSlice(toOrig\x2C toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd)}`;\n\n    if (StringPrototypeCharCodeAt(toOrig\x2C toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string' || path.length === 0)\n      return path;\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (StringPrototypeCharCodeAt(resolvedPath\x2C 0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath\x2C 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root\x2C convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath\x2C 2)}`;\n        }\n      }\n    } else if (\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath\x2C 0)) &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_COLON &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 2) === CHAR_BACKWARD_SLASH\n    ) {\n      // Matched device root\x2C convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      // `path` contains just a path separator\x2C exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a "normal root" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      rootEnd =\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0)) &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '\\\\')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *  dir: string;\n   *  root: string;\n   *  base: string;\n   *  name: string;\n   *  ext: string;\n   *  }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        if (len === 3) {\n          // `path` contains just a drive root\x2C exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path\x2C 0\x2C rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C startPart\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C startPart\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C startPart\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    // If the directory is the root\x2C use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise\x2C strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  }\x2C\n\n  sep: '\\\\'\x2C\n  delimiter: ';'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    // Converts Windows' backslash path separators to POSIX forward slashes\n    // and truncates any drive indicator\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd()\x2C regexp\x2C '/');\n      return StringPrototypeSlice(cwd\x2C StringPrototypeIndexOf(cwd\x2C '/'));\n    };\n  }\n\n  // We're already on POSIX\x2C no need for any transformations\n  return () => process.cwd();\n})();\n\nconst posix = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n\n      validateString(path\x2C 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute =\n        StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath\x2C !resolvedAbsolute\x2C '/'\x2C\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      StringPrototypeCharCodeAt(path\x2C path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path\x2C !isAbsolute\x2C '/'\x2C isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    return path.length > 0 &&\n           StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  }\x2C\n\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return StringPrototypeSlice(to\x2C toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return StringPrototypeSlice(to\x2C toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${StringPrototypeSlice(to\x2C toStart + lastCommonSep)}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '/')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *   dir: string;\n   *   root: string;\n   *   base: string;\n   *   name: string;\n   *   ext: string;\n   *   }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C start\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C start\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C start\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  }\x2C\n\n  sep: '/'\x2C\n  delimiter: ':'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API\x2C docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = platformIsWin32 ? win32 : posix;\n
code-source-info,0x3172a1b10506,41,33781,34691,C0O33781C3O33816C6O33847C8O33877C12O33884C16O33897C18O33891C25O33901C27O33945C28O33947C35O33958C42O33964C45O33964C49O33983C57O33983C62O34057C68O34064C73O34081C75O34106C87O34132C92O34154C99O34181C107O34220C109O34216C113O33920C118O33859C121O34436C126O34482C137O34451C143O34568C147O34598C152O34609C156O34624C157O34655C163O34662C174O34687,,
tick,0x1bfc3b854,17875,0,0x0,3,0x0,0x3172a1b0f190,0x3172a1b0b3db,0x3172a1b05aed
code-creation,LazyCompile,10,17875,0x3172a1b1373e,30,validateString node:internal/validators:118:24,0x2b48e0c7bfe8,~
script-source,15,node:internal/validators,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  NumberIsInteger\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  NumberParseInt\x2C\n  RegExpPrototypeTest\x2C\n  String\x2C\n  StringPrototypeToUpperCase\x2C\n  StringPrototypeTrim\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_SOCKET_BAD_PORT\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n    ERR_INVALID_CALLBACK\x2C\n  }\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isAsyncFunction\x2C\n  isArrayBufferView\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land\x2C but any value higher than 0o777 will result in platform-specific\n * behaviors.\n *\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified\x2C will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value\x2C name\x2C def) {\n  value ??= def;\n  if (typeof value === 'string') {\n    if (!RegExpPrototypeTest(octalReg\x2C value)) {\n      throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C modeDesc);\n    }\n    value = NumberParseInt(value\x2C 8);\n  }\n\n  validateInt32(value\x2C name\x2C 0\x2C 2 ** 32 - 1);\n  return value;\n}\n\nconst validateInteger = hideStackFrames(\n  (value\x2C name\x2C min = NumberMIN_SAFE_INTEGER\x2C max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\n);\n\nconst validateInt32 = hideStackFrames(\n  (value\x2C name\x2C min = -2147483648\x2C max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (!isInt32(value)) {\n      if (typeof value !== 'number') {\n        throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n      }\n      if (!NumberIsInteger(value)) {\n        throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n      }\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n  }\n);\n\nconst validateUint32 = hideStackFrames((value\x2C name\x2C positive) => {\n  if (!isUint32(value)) {\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    }\n    const min = positive ? 1 : 0;\n    // 2 ** 32 === 4294967296\n    throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && < 4294967296`\x2C value);\n  }\n  if (positive && value === 0) {\n    throw new ERR_OUT_OF_RANGE(name\x2C '>= 1 && < 4294967296'\x2C value);\n  }\n});\n\nfunction validateString(value\x2C name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'string'\x2C value);\n}\n\nfunction validateNumber(value\x2C name) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n}\n\nconst validateOneOf = hideStackFrames((value\x2C name\x2C oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf\x2C value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf\x2C (v) =>\n        (typeof v === 'string' ? `'${v}'` : String(v)))\x2C\n      '\x2C ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateBoolean(value\x2C name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'boolean'\x2C value);\n}\n\n/**\n * @param {unknown} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean\x2C\n *   allowFunction?: boolean\x2C\n *   nullable?: boolean\n * }} [options]\n */\nconst validateObject = hideStackFrames(\n  (value\x2C name\x2C options) => {\n    const useDefaultOptions = options == null;\n    const allowArray = useDefaultOptions ? false : options.allowArray;\n    const allowFunction = useDefaultOptions ? false : options.allowFunction;\n    const nullable = useDefaultOptions ? false : options.nullable;\n    if ((!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== 'object' && (\n          !allowFunction || typeof value !== 'function'\n        ))) {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n    }\n  });\n\nconst validateArray = hideStackFrames((value\x2C name\x2C minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Array'\x2C value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateSignalName(signal\x2C name = 'signal') {\n  validateString(signal\x2C name);\n\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\nconst validateBuffer = hideStackFrames((buffer\x2C name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buffer);\n  }\n});\n\nfunction validateEncoding(data\x2C encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding'\x2C encoding\x2C\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n// Check that the port number is not NaN when coerced to a number\x2C\n// is an integer and that it falls within the legal range of port numbers.\nfunction validatePort(port\x2C name = 'Port'\x2C allowZero = true) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name\x2C port\x2C allowZero);\n  }\n  return port | 0;\n}\n\nconst validateCallback = hideStackFrames((callback) => {\n  if (typeof callback !== 'function')\n    throw new ERR_INVALID_CALLBACK(callback);\n});\n\nconst validateAbortSignal = hideStackFrames((signal\x2C name) => {\n  if (signal !== undefined &&\n      (signal === null ||\n       typeof signal !== 'object' ||\n       !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\n  }\n});\n\nconst validateFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\nconst validatePlainFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value))\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\nconst validateUndefined = hideStackFrames((value\x2C name) => {\n  if (value !== undefined)\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'undefined'\x2C value);\n});\n\nmodule.exports = {\n  isInt32\x2C\n  isUint32\x2C\n  parseFileMode\x2C\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateNumber\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validatePlainFunction\x2C\n  validatePort\x2C\n  validateSignalName\x2C\n  validateString\x2C\n  validateUint32\x2C\n  validateUndefined\x2C\n  validateCallback\x2C\n  validateAbortSignal\x2C\n};\n
code-source-info,0x3172a1b1373e,15,3417,3526,C0O3435C6O3470C22O3476C27O3470C29O3525,,
code-creation,LazyCompile,10,18209,0x3172a1b140d6,13, node:path:1082:10,0x815de63acb8,~
code-source-info,0x3172a1b140d6,41,33630,33649,C0O33644C3O33644C8O33644C12O33649,,
tick,0x1bfc3b5e0,18250,0,0x0,3,0x0,0x3172a1b1053f,0x3172a1b0f190,0x3172a1b0b3db,0x3172a1b05aed
code-creation,LazyCompile,10,18250,0x3172a1b141d6,40,wrappedCwd node:internal/bootstrap/switches/does_own_process_state:124:20,0x3beccadcaa0,~
script-source,94,node:internal/bootstrap/switches/does_own_process_state,'use strict';\n\nconst credentials = internalBinding('credentials');\nconst rawMethods = internalBinding('process_methods');\n\nprocess.abort = rawMethods.abort;\nprocess.umask = wrappedUmask;\nprocess.chdir = wrappedChdir;\nprocess.cwd = wrappedCwd;\n\nif (credentials.implementsPosixCredentials) {\n  const wrapped = wrapPosixCredentialSetters(credentials);\n\n  process.initgroups = wrapped.initgroups;\n  process.setgroups = wrapped.setgroups;\n  process.setegid = wrapped.setegid;\n  process.seteuid = wrapped.seteuid;\n  process.setgid = wrapped.setgid;\n  process.setuid = wrapped.setuid;\n}\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst {\n  parseFileMode\x2C\n  validateArray\x2C\n  validateString\n} = require('internal/validators');\n\nfunction wrapPosixCredentialSetters(credentials) {\n  const {\n    codes: {\n      ERR_INVALID_ARG_TYPE\x2C\n      ERR_UNKNOWN_CREDENTIAL\n    }\n  } = require('internal/errors');\n  const {\n    validateUint32\n  } = require('internal/validators');\n\n  const {\n    initgroups: _initgroups\x2C\n    setgroups: _setgroups\x2C\n    setegid: _setegid\x2C\n    seteuid: _seteuid\x2C\n    setgid: _setgid\x2C\n    setuid: _setuid\n  } = credentials;\n\n  function initgroups(user\x2C extraGroup) {\n    validateId(user\x2C 'user');\n    validateId(extraGroup\x2C 'extraGroup');\n    // Result is 0 on success\x2C 1 if user is unknown\x2C 2 if group is unknown.\n    const result = _initgroups(user\x2C extraGroup);\n    if (result === 1) {\n      throw new ERR_UNKNOWN_CREDENTIAL('User'\x2C user);\n    } else if (result === 2) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C extraGroup);\n    }\n  }\n\n  function setgroups(groups) {\n    validateArray(groups\x2C 'groups');\n    for (let i = 0; i < groups.length; i++) {\n      validateId(groups[i]\x2C `groups[${i}]`);\n    }\n    // Result is 0 on success. A positive integer indicates that the\n    // corresponding group was not found.\n    const result = _setgroups(groups);\n    if (result > 0) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C groups[result - 1]);\n    }\n  }\n\n  function wrapIdSetter(type\x2C method) {\n    return function(id) {\n      validateId(id\x2C 'id');\n      if (typeof id === 'number') id |= 0;\n      // Result is 0 on success\x2C 1 if credential is unknown.\n      const result = method(id);\n      if (result === 1) {\n        throw new ERR_UNKNOWN_CREDENTIAL(type\x2C id);\n      }\n    };\n  }\n\n  function validateId(id\x2C name) {\n    if (typeof id === 'number') {\n      validateUint32(id\x2C name);\n    } else if (typeof id !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C ['number'\x2C 'string']\x2C id);\n    }\n  }\n\n  return {\n    initgroups\x2C\n    setgroups\x2C\n    setegid: wrapIdSetter('Group'\x2C _setegid)\x2C\n    seteuid: wrapIdSetter('User'\x2C _seteuid)\x2C\n    setgid: wrapIdSetter('Group'\x2C _setgid)\x2C\n    setuid: wrapIdSetter('User'\x2C _setuid)\n  };\n}\n\n// Cache the working directory to prevent lots of lookups. If the working\n// directory is changed by `chdir`\x2C it'll be updated.\nlet cachedCwd = '';\n\nfunction wrappedChdir(directory) {\n  validateString(directory\x2C 'directory');\n  rawMethods.chdir(directory);\n  // Mark cache that it requires an update.\n  cachedCwd = '';\n}\n\nfunction wrappedUmask(mask) {\n  if (mask !== undefined) {\n    mask = parseFileMode(mask\x2C 'mask');\n  }\n  return rawMethods.umask(mask);\n}\n\nfunction wrappedCwd() {\n  if (cachedCwd === '')\n    cachedCwd = rawMethods.cwd();\n  return cachedCwd;\n}\n
code-source-info,0x3172a1b141d6,94,3341,3425,C0O3348C7O3362C12O3374C17O3397C22O3397C29O3384C35O3406C39O3423,,
code-creation,LazyCompile,10,18459,0x3172a1b1483e,442,normalizeString node:path:66:25,0x815de63a820,~
code-source-info,0x3172a1b1483e,41,2161,4085,C0O2226C3O2256C5O2277C8O2294C10O2310C12O2328C14O2341C18O2333C23O2373C27O2366C32O2387C37O2394C45O2443C51O2472C53O2494C58O2530C64O2561C66O2581C69O2575C76O2593C83O2631C85O2640C90O2665C97O2672C104O2697C111O2718C114O2753C118O2760C122O2718C130O2769C132O2765C139O2793C142O2828C146O2835C150O2793C158O2844C160O2840C165O2874C172O2881C177O2923C182O2923C188O2979C190O2998C195O3022C198O3046C202O3104C215O3110C221O3210C225O3217C231O3223C234O3223C239O3221C243O3293C246O3320C248O3342C250O3377C256O3384C261O3405C264O3427C266O3462C269O3489C271O3511C273O3551C277O3594C283O3601C293O3610C308O3642C313O3706C319O3713C324O3728C326O3738C330O3750C335O3787C345O3750C363O3821C370O3864C380O3827C386O3881C388O3903C391O3915C395O3934C398O3955C402O3976C404O3989C406O3985C413O4006C418O4022C425O4049C428O2351C433O2315C439O4072C441O4083,,
code-creation,LazyCompile,10,18500,0x3172a1b14bbe,8,isPosixPathSeparator node:path:56:30,0x815de63a780,~
code-source-info,0x3172a1b14bbe,41,1854,1902,C0O1865C2O1881C4O1877C7O1900,,
code-creation,LazyCompile,10,18542,0x3172a1b14e5e,63,addReadOnlyProcessAlias node:internal/bootstrap/pre_execution:128:33,0x3172a1b07b00,~
code-source-info,0x3172a1b14e5e,96,4191,4416,C16O4243C21O4243C26O4269C28O4286C36O4316C43O4379C49O4397C56O4286C62O4415,,
code-creation,LazyCompile,10,18584,0x3172a1b14fde,82,getOptionValue node:internal/options:39:24,0x3172a1b0a418,~
code-source-info,0x3172a1b14fde,97,902,1145,C0O935C3O935C7O980C15O980C22O1030C30O1052C38O1052C43O1039C47O1030C53O1067C55O1092C60O1098C61O1120C66O1120C74O1135C81O1143,,
code-creation,LazyCompile,10,18584,0x3172a1b1538e,33,getCLIOptionsFromBinding node:internal/options:18:34,0x3172a1b0a328,~
code-source-info,0x3172a1b1538e,97,497,598,C0O504C6O527C11O554C15O539C28O578C32O596,,
code-creation,LazyCompile,10,18709,0x3172a1b1554e,46,setupTraceCategoryState node:internal/bootstrap/pre_execution:301:33,0x3172a1b07e70,~
code-source-info,0x3172a1b1554e,96,8899,9126,C0O8941C6O8941C11O8914C16O9013C22O9013C27O8984C32O9055C35O9080C40O9055C45O9125,,
code-creation,LazyCompile,10,18750,0x3172a1b156e6,77,toggleTraceCategoryState node:internal/process/per_thread:390:34,0x815de60d988,~
code-source-info,0x3172a1b156e6,30,11159,11456,C0O11183C4O11212C10O11247C16O11278C21O11322C26O11323C33O11268C39O11347C44O11368C49O11368C55O11387C61O11419C66O11440C71O11440C76O11455,,
code-creation,LazyCompile,10,18750,0x3172a1b15896,42,setupPerfHooks node:internal/bootstrap/pre_execution:307:24,0x3172a1b07ec0,~
code-source-info,0x3172a1b15896,96,9151,9271,C0O9158C6O9158C11O9194C16O9195C20O9218C26O9218C31O9248C36O9249C41O9270,,
code-creation,LazyCompile,10,18792,0x3172a1b15a16,42,refreshTimeOrigin node:internal/perf/performance:181:27,0xd2efcc15e60,~
script-source,74,node:internal/perf/performance,'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_MISSING_ARGS\n  }\n} = require('internal/errors');\n\nconst {\n  EventTarget\x2C\n} = require('internal/event_target');\n\nconst { now } = require('internal/perf/utils');\n\nconst {\n  mark\x2C\n  measure\x2C\n  clearMarkTimings\x2C\n} = require('internal/perf/usertiming');\nconst {\n  clearEntriesFromBuffer\x2C\n  filterBufferMapByNameAndType\x2C\n} = require('internal/perf/observe');\n\nconst eventLoopUtilization = require('internal/perf/event_loop_utilization');\nconst nodeTiming = require('internal/perf/nodetiming');\nconst timerify = require('internal/perf/timerify');\nconst { customInspectSymbol: kInspect } = require('internal/util');\nconst { inspect } = require('util');\n\nconst {\n  getTimeOriginTimestamp\n} = internalBinding('performance');\n\nclass Performance extends EventTarget {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0) return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `Performance ${inspect({\n      nodeTiming: this.nodeTiming\x2C\n      timeOrigin: this.timeOrigin\x2C\n    }\x2C opts)}`;\n  }\n}\n\nfunction toJSON() {\n  return {\n    nodeTiming: this.nodeTiming\x2C\n    timeOrigin: this.timeOrigin\x2C\n    eventLoopUtilization: this.eventLoopUtilization()\n  };\n}\n\nfunction clearMarks(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearMarkTimings(name);\n  clearEntriesFromBuffer('mark'\x2C name);\n}\n\nfunction clearMeasures(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearEntriesFromBuffer('measure'\x2C name);\n}\n\nfunction getEntries() {\n  return filterBufferMapByNameAndType();\n}\n\nfunction getEntriesByName(name) {\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('name');\n  }\n  name = `${name}`;\n  return filterBufferMapByNameAndType(name\x2C undefined);\n}\n\nfunction getEntriesByType(type) {\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('type');\n  }\n  type = `${type}`;\n  return filterBufferMapByNameAndType(undefined\x2C type);\n}\n\nclass InternalPerformance extends EventTarget {}\nInternalPerformance.prototype.constructor = Performance.prototype.constructor;\nObjectSetPrototypeOf(InternalPerformance.prototype\x2C Performance.prototype);\n\nObjectDefineProperties(Performance.prototype\x2C {\n  clearMarks: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMarks\x2C\n  }\x2C\n  clearMeasures: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMeasures\x2C\n  }\x2C\n  eventLoopUtilization: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: eventLoopUtilization\x2C\n  }\x2C\n  getEntries: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntries\x2C\n  }\x2C\n  getEntriesByName: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByName\x2C\n  }\x2C\n  getEntriesByType: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByType\x2C\n  }\x2C\n  mark: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: mark\x2C\n  }\x2C\n  measure: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: measure\x2C\n  }\x2C\n  nodeTiming: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: nodeTiming\x2C\n  }\x2C\n  now: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: now\x2C\n  }\x2C\n  timerify: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: timerify\x2C\n  }\x2C\n  // This would be updated during pre-execution in case\n  // the process is launched from a snapshot.\n  // TODO(joyeecheung): we may want to warn about access to\n  // this during snapshot building.\n  timeOrigin: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  }\x2C\n  toJSON: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: toJSON\x2C\n  }\n});\n\nfunction refreshTimeOrigin() {\n  ObjectDefineProperty(Performance.prototype\x2C 'timeOrigin'\x2C {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  });\n}\n\nmodule.exports = {\n  InternalPerformance\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0x3172a1b15a16,74,3860,4017,C0O3867C7O3888C10O3900C25O3984C28O3984C35O3867C41O4016,,
code-creation,LazyCompile,10,18959,0x3172a1b1613e,19,refreshTimeOrigin node:internal/perf/utils:25:27,0x174551ed0b28,~
script-source,46,node:internal/perf/utils,'use strict';\n\nconst binding = internalBinding('performance');\nconst {\n  milestones\x2C\n  getTimeOrigin\x2C\n} = binding;\n\n// TODO(joyeecheung): we may want to warn about access to\n// this during snapshot building.\nlet timeOrigin = getTimeOrigin();\n\nfunction now() {\n  const hr = process.hrtime();\n  return (hr[0] * 1000 + hr[1] / 1e6) - timeOrigin;\n}\n\nfunction getMilestoneTimestamp(milestoneIdx) {\n  const ns = milestones[milestoneIdx];\n  if (ns === -1)\n    return ns;\n  return ns / 1e6 - timeOrigin;\n}\n\nfunction refreshTimeOrigin() {\n  timeOrigin = getTimeOrigin();\n}\n\nmodule.exports = {\n  now\x2C\n  getMilestoneTimestamp\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0x3172a1b1613e,46,525,563,C0O532C5O545C11O543C18O562,,
code-creation,LazyCompile,10,19042,0x3172a1b163ae,62,setupInspectorHooks node:internal/bootstrap/pre_execution:312:29,0x3172a1b07f10,~
code-source-info,0x3172a1b163ae,96,9301,9854,C0O9644C6O9648C11O9673C17O9738C23O9738C28O9708C33O9722C38O9784C44O9784C49O9812C54O9813C61O9853,,
code-creation,Eval,10,19084,0x3172a1b1675e,5, node:internal/inspector_async_hook:1:1,0x3172a1b165a8,~
script-source,98,node:internal/inspector_async_hook,'use strict';\n\nlet hook;\nlet config;\n\nconst {\n  SafeSet\x2C\n} = primordials;\n\nfunction lazyHookCreation() {\n  const inspector = internalBinding('inspector');\n  const { createHook } = require('async_hooks');\n  config = internalBinding('config');\n\n  hook = createHook({\n    init(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n    // It's difficult to tell which tasks will be recurring and which won't\x2C\n    // therefore we mark all tasks as recurring. Based on the discussion\n    // in https://github.com/nodejs/node/pull/13870#discussion_r124515293\x2C\n    // this should be fine as long as we call asyncTaskCanceled() too.\n      const recurring = true;\n      if (type === 'PROMISE')\n        this.promiseIds.add(asyncId);\n      else\n        inspector.asyncTaskScheduled(type\x2C asyncId\x2C recurring);\n    }\x2C\n\n    before(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskStarted(asyncId);\n    }\x2C\n\n    after(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskFinished(asyncId);\n    }\x2C\n\n    destroy(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return this.promiseIds.delete(asyncId);\n      inspector.asyncTaskCanceled(asyncId);\n    }\x2C\n  });\n\n  hook.promiseIds = new SafeSet();\n}\n\nfunction enable() {\n  if (hook === undefined) lazyHookCreation();\n  if (config.bits < 64) {\n    // V8 Inspector stores task ids as (void*) pointers.\n    // async_hooks store ids as 64bit numbers.\n    // As a result\x2C we cannot reliably translate async_hook ids to V8 async_task\n    // ids on 32bit platforms.\n    process.emitWarning(\n      'Warning: Async stack traces in debugger are not available ' +\n      `on ${config.bits}bit platforms. The feature is disabled.`\x2C\n      {\n        code: 'INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE'\x2C\n      });\n  } else {\n    hook.enable();\n  }\n}\n\nfunction disable() {\n  if (hook === undefined) lazyHookCreation();\n  hook.disable();\n}\n\nmodule.exports = {\n  enable\x2C\n  disable\n};\n
code-source-info,0x3172a1b1675e,98,0,1972,C0O0C4O1972,,
code-creation,Function,10,19167,0x3172a1b1697e,79, node:internal/inspector_async_hook:1:1,0x3172a1b166d8,~
code-source-info,0x3172a1b1697e,98,0,1972,C0O0C42O19C43O19C45O29C46O29C48O48C54O1930C61O1951C67O1961C73O1945C78O1971,,
code-creation,LazyCompile,10,19209,0x3172a1b16fe6,69,setupWarningHandler node:internal/bootstrap/pre_execution:140:29,0x3172a1b07b50,~
code-source-info,0x3172a1b16fe6,96,4446,4643,C0O4481C6O4481C11O4465C16O4520C24O4524C33O4568C38O4572C45O4589C50O4604C53O4612C61O4612C68O4642,,
code-creation,LazyCompile,10,19250,0x3172a1b17146,20,addListener node:events:618:58,0x232faba26c28,~
script-source,23,node:events,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  Boolean\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  MathMin\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromiseReject\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolAsyncIterator\x2C\n} = primordials;\nconst kRejection = SymbolFor('nodejs.rejection');\nconst { inspect } = require('internal/util/inspect');\n\nlet spliceOne;\n\nconst {\n  AbortError\x2C\n  kEnhanceStackBeforeInspector\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNHANDLED_ERROR\n  }\x2C\n  genericNodeError\x2C\n} = require('internal/errors');\n\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = Symbol('events.errorMonitor');\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\nconst kMaxEventTargetListenersWarned =\n  Symbol('events.maxEventTargetListenersWarned');\n\nlet EventEmitterAsyncResource;\n// The EventEmitterAsyncResource has to be initialized lazily because event.js\n// is loaded so early in the bootstrap process\x2C before async_hooks is available.\n//\n// This implementation was adapted straight from addaleax's\n// eventemitter-asyncresource MIT-licensed userland module.\n// https://github.com/addaleax/eventemitter-asyncresource\nfunction lazyEventEmitterAsyncResource() {\n  if (EventEmitterAsyncResource === undefined) {\n    const {\n      AsyncResource\n    } = require('async_hooks');\n\n    const kEventEmitter = Symbol('kEventEmitter');\n    const kAsyncResource = Symbol('kAsyncResource');\n    class EventEmitterReferencingAsyncResource extends AsyncResource {\n      /**\n       * @param {EventEmitter} ee\n       * @param {string} [type]\n       * @param {{\n       *   triggerAsyncId?: number\x2C\n       *   requireManualDestroy?: boolean\x2C\n       * }} [options]\n       */\n      constructor(ee\x2C type\x2C options) {\n        super(type\x2C options);\n        this[kEventEmitter] = ee;\n      }\n\n      /**\n       * @type {EventEmitter}\n       */\n      get eventEmitter() {\n        if (this[kEventEmitter] === undefined)\n          throw new ERR_INVALID_THIS('EventEmitterReferencingAsyncResource');\n        return this[kEventEmitter];\n      }\n    }\n\n    EventEmitterAsyncResource =\n      class EventEmitterAsyncResource extends EventEmitter {\n        /**\n         * @param {{\n         *   name?: string\x2C\n         *   triggerAsyncId?: number\x2C\n         *   requireManualDestroy?: boolean\x2C\n         * }} [options]\n         */\n        constructor(options = undefined) {\n          let name;\n          if (typeof options === 'string') {\n            name = options;\n            options = undefined;\n          } else {\n            if (new.target === EventEmitterAsyncResource) {\n              validateString(options?.name\x2C 'options.name');\n            }\n            name = options?.name || new.target.name;\n          }\n          super(options);\n\n          this[kAsyncResource] =\n            new EventEmitterReferencingAsyncResource(this\x2C name\x2C options);\n        }\n\n        /**\n         * @param {symbol\x2Cstring} event\n         * @param  {...any} args\n         * @returns {boolean}\n         */\n        emit(event\x2C ...args) {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          const { asyncResource } = this;\n          ArrayPrototypeUnshift(args\x2C super.emit\x2C this\x2C event);\n          return ReflectApply(asyncResource.runInAsyncScope\x2C asyncResource\x2C\n                              args);\n        }\n\n        /**\n         * @returns {void}\n         */\n        emitDestroy() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          this.asyncResource.emitDestroy();\n        }\n\n        /**\n         * @type {number}\n         */\n        get asyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.asyncId();\n        }\n\n        /**\n         * @type {number}\n         */\n        get triggerAsyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.triggerAsyncId();\n        }\n\n        /**\n         * @type {EventEmitterReferencingAsyncResource}\n         */\n        get asyncResource() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this[kAsyncResource];\n        }\n      };\n  }\n  return EventEmitterAsyncResource;\n}\n\n/**\n * Creates a new `EventEmitter` instance.\n * @param {{ captureRejections?: boolean; }} [opts]\n * @constructs {EventEmitter}\n */\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this\x2C opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\nmodule.exports.on = on;\nmodule.exports.getEventListeners = getEventListeners;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter\x2C 'captureRejections'\x2C {\n  get() {\n    return EventEmitter.prototype[kCapture];\n  }\x2C\n  set(value) {\n    validateBoolean(value\x2C 'EventEmitter.captureRejections');\n\n    EventEmitter.prototype[kCapture] = value;\n  }\x2C\n  enumerable: true\n});\n\nObjectDefineProperty(EventEmitter\x2C 'EventEmitterAsyncResource'\x2C {\n  enumerable: true\x2C\n  get: lazyEventEmitterAsyncResource\x2C\n  set: undefined\x2C\n  configurable: true\x2C\n});\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype\x2C kCapture\x2C {\n  value: false\x2C\n  writable: true\x2C\n  enumerable: false\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\nlet isEventTarget;\n\nfunction checkListener(listener) {\n  validateFunction(listener\x2C 'listener');\n}\n\nObjectDefineProperty(EventEmitter\x2C 'defaultMaxListeners'\x2C {\n  enumerable: true\x2C\n  get: function() {\n    return defaultMaxListeners;\n  }\x2C\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new ERR_OUT_OF_RANGE('defaultMaxListeners'\x2C\n                                 'a non-negative number'\x2C\n                                 arg);\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nObjectDefineProperties(EventEmitter\x2C {\n  kMaxEventTargetListeners: {\n    value: kMaxEventTargetListeners\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\x2C\n  kMaxEventTargetListenersWarned: {\n    value: kMaxEventTargetListenersWarned\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\n});\n\n/**\n * Sets the max listeners.\n * @param {number} n\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\n * @returns {void}\n */\nEventEmitter.setMaxListeners =\n  function(n = defaultMaxListeners\x2C ...eventTargets) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n))\n      throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n    if (eventTargets.length === 0) {\n      defaultMaxListeners = n;\n    } else {\n      if (isEventTarget === undefined)\n        isEventTarget = require('internal/event_target').isEventTarget;\n\n      for (let i = 0; i < eventTargets.length; i++) {\n        const target = eventTargets[i];\n        if (isEventTarget(target)) {\n          target[kMaxEventTargetListeners] = n;\n          target[kMaxEventTargetListenersWarned] = false;\n        } else if (typeof target.setMaxListeners === 'function') {\n          target.setMaxListeners(n);\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\n            'eventTargets'\x2C\n            ['EventEmitter'\x2C 'EventTarget']\x2C\n            target);\n        }\n      }\n    }\n  };\n\n// If you're updating this function definition\x2C please also update any\n// re-definitions\x2C such as the one in the Domain module (lib/domain.js).\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections\x2C 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that\x2C promise\x2C type\x2C args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec\x2C then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise\x2C undefined\x2C function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr\x2C that\x2C err\x2C type\x2C args);\n      });\n    }\n  } catch (err) {\n    that.emit('error'\x2C err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee\x2C err\x2C type\x2C args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err\x2C type\x2C ...args);\n  } else {\n    // We have to disable the capture rejections mechanism\x2C otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws\x2C it is not catchable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error'\x2C err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n/**\n * Increases the max listeners of the event emitter.\n * @param {number} n\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\n/**\n * Returns the current max listener value for the event emitter.\n * @returns {number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\n// Returns the length and line number of the first sequence of `a` that fully\n// appears in `b` with a length of at least 4.\nfunction identicalSequenceRange(a\x2C b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    // Find the first entry of b that matches the current entry of a.\n    const pos = ArrayPrototypeIndexOf(b\x2C a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i\x2C rest);\n        // Count the number of consecutive entries.\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return [len\x2C i];\n        }\n      }\n    }\n  }\n\n  return [0\x2C 0];\n}\n\nfunction enhanceStackTrace(err\x2C own) {\n  let ctorInfo = '';\n  try {\n    const { name } = this.constructor;\n    if (name !== 'EventEmitter')\n      ctorInfo = ` on ${name} instance`;\n  } catch {\n    // Continue regardless of error.\n  }\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n  const errStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(err.stack\x2C '\\n')\x2C 1);\n  const ownStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(own.stack\x2C '\\n')\x2C 1);\n\n  const { 0: len\x2C 1: off } = identicalSequenceRange(ownStack\x2C errStack);\n  if (len > 0) {\n    ArrayPrototypeSplice(ownStack\x2C off + 1\x2C len - 2\x2C\n                         '    [... lines matching original stack trace ...]');\n  }\n\n  return err.stack + sep + ArrayPrototypeJoin(ownStack\x2C '\\n');\n}\n\n/**\n * Synchronously calls each of the listeners registered\n * for the event.\n * @param {string | symbol} type\n * @param {...any} [args]\n * @returns {boolean}\n */\nEventEmitter.prototype.emit = function emit(type\x2C ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor\x2C ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture\x2C EventEmitter.prototype.emit);\n        ObjectDefineProperty(er\x2C kEnhanceStackBeforeInspector\x2C {\n          value: FunctionPrototypeBind(enhanceStackTrace\x2C this\x2C er\x2C capture)\x2C\n          configurable: true\n        });\n      } catch {\n        // Continue regardless of error.\n      }\n\n      // Note: The comments on the `throw` lines are intentional\x2C they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = handler.apply(this\x2C args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this\x2C result\x2C type\x2C args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners[i].apply(this\x2C args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this\x2C result\x2C type\x2C args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target\x2C type\x2C listener\x2C prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = ObjectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === "newListener"! Before\n    // adding it to the listeners\x2C first emit "newListener".\n    if (events.newListener !== undefined) {\n      target.emit('newListener'\x2C type\x2C\n                  listener.listener ?? listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element\x2C need to change to array.\n      existing = events[type] =\n        prepend ? [listener\x2C existing] : [existing\x2C listener];\n      // If we've already got an array\x2C just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      const w = genericNodeError(\n        `Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners ` +\n        `added to ${inspect(target\x2C { depth: -1 })}. Use emitter.setMaxListeners() to increase limit`\x2C\n        { name: 'MaxListenersExceededWarning'\x2C emitter: target\x2C type: type\x2C count: existing.length });\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Adds a listener to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener(type\x2C listener) {\n  return _addListener(this\x2C type\x2C listener\x2C false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds the `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependListener =\n    function prependListener(type\x2C listener) {\n      return _addListener(this\x2C type\x2C listener\x2C true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type\x2C this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target\x2C arguments);\n  }\n}\n\nfunction _onceWrap(target\x2C type\x2C listener) {\n  const state = { fired: false\x2C wrapFn: undefined\x2C target\x2C type\x2C listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\n/**\n * Adds a one-time `listener` function to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.once = function once(type\x2C listener) {\n  checkListener(listener);\n\n  this.on(type\x2C _onceWrap(this\x2C type\x2C listener));\n  return this;\n};\n\n/**\n * Adds a one-time `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type\x2C listener) {\n      checkListener(listener);\n\n      this.prependListener(type\x2C _onceWrap(this\x2C type\x2C listener));\n      return this;\n    };\n\n/**\n * Removes the specified `listener` from the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeListener =\n    function removeListener(type\x2C listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = ObjectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener'\x2C type\x2C list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          if (spliceOne === undefined)\n            spliceOne = require('internal/util').spliceOne;\n          spliceOne(list\x2C position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener'\x2C type\x2C listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n/**\n * Removes all listeners from the event emitter. (Only\n * removes listeners for a specific event name if specified\n * as `type`).\n * @param {string | symbol} [type]\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener\x2C no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = ObjectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = ObjectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = ObjectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type\x2C listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type\x2C listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target\x2C type\x2C unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this\x2C type\x2C true);\n};\n\n/**\n * Returns a copy of the array of listeners and wrappers for\n * the event name specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this\x2C type\x2C false);\n};\n\n/**\n * Returns the number of listeners listening to the event name\n * specified as `type`.\n * @deprecated since v3.2.0\n * @param {EventEmitter} emitter\n * @param {string | symbol} type\n * @returns {number}\n */\nEventEmitter.listenerCount = function(emitter\x2C type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return FunctionPrototypeCall(listenerCount\x2C emitter\x2C type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\n/**\n * Returns the number of listeners listening to event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {number}\n */\nfunction listenerCount(type) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Returns an array listing the events for which\n * the emitter has registered listeners.\n * @returns {any[]}\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3\x2C this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0]\x2C arr[1]];\n    case 3: return [arr[0]\x2C arr[1]\x2C arr[2]];\n    case 4: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]];\n    case 5: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]];\n    case 6: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]\x2C arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nfunction getEventListeners(emitterOrTarget\x2C type) {\n  // First check if EventEmitter\n  if (typeof emitterOrTarget.listeners === 'function') {\n    return emitterOrTarget.listeners(type);\n  }\n  // Require event target lazily to avoid always loading it\n  const { isEventTarget\x2C kEvents } = require('internal/event_target');\n  if (isEventTarget(emitterOrTarget)) {\n    const root = emitterOrTarget[kEvents].get(type);\n    const listeners = [];\n    let handler = root?.next;\n    while (handler?.listener !== undefined) {\n      const listener = handler.listener?.deref ?\n        handler.listener.deref() : handler.listener;\n      listeners.push(listener);\n      handler = handler.next;\n    }\n    return listeners;\n  }\n  throw new ERR_INVALID_ARG_TYPE('emitter'\x2C\n                                 ['EventEmitter'\x2C 'EventTarget']\x2C\n                                 emitterOrTarget);\n}\n\n/**\n * Creates a `Promise` that is fulfilled when the emitter\n * emits the given event.\n * @param {EventEmitter} emitter\n * @param {string} name\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {Promise}\n */\nasync function once(emitter\x2C name\x2C options = {}) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n  return new Promise((resolve\x2C reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name\x2C resolver);\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error'\x2C errorListener);\n      }\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      resolve(args);\n    };\n    eventTargetAgnosticAddListener(emitter\x2C name\x2C resolver\x2C { once: true });\n    if (name !== 'error' && typeof emitter.once === 'function') {\n      emitter.once('error'\x2C errorListener);\n    }\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter\x2C name\x2C resolver);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorListener);\n      reject(new AbortError(undefined\x2C { cause: signal?.reason }));\n    }\n    if (signal != null) {\n      eventTargetAgnosticAddListener(\n        signal\x2C 'abort'\x2C abortListener\x2C { once: true });\n    }\n  });\n}\n\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value\x2C done) {\n  return { value\x2C done };\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.removeListener === 'function') {\n    emitter.removeListener(name\x2C listener);\n  } else if (typeof emitter.removeEventListener === 'function') {\n    emitter.removeEventListener(name\x2C listener\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags?.once) {\n      emitter.once(name\x2C listener);\n    } else {\n      emitter.on(name\x2C listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters\x2C we do not listen to `error` events here.\n    emitter.addEventListener(name\x2C (arg) => { listener(arg); }\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\n/**\n * Returns an `AsyncIterator` that iterates `event` events.\n * @param {EventEmitter} emitter\n * @param {string | symbol} event\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {AsyncIterator}\n */\nfunction on(emitter\x2C event\x2C options) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n\n  const unconsumedEvents = [];\n  const unconsumedPromises = [];\n  let error = null;\n  let finished = false;\n\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      // First\x2C we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value) {\n        return PromiseResolve(createIterResult(value\x2C false));\n      }\n\n      // Then we error\x2C if an error happened\n      // This happens one time if at all\x2C because after 'error'\n      // we stop listening\n      if (error) {\n        const p = PromiseReject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished\x2C resolve to done\n      if (finished) {\n        return PromiseResolve(createIterResult(undefined\x2C true));\n      }\n\n      // Wait until an event happens\n      return new Promise(function(resolve\x2C reject) {\n        unconsumedPromises.push({ resolve\x2C reject });\n      });\n    }\x2C\n\n    return() {\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n\n      if (signal) {\n        eventTargetAgnosticRemoveListener(\n          signal\x2C\n          'abort'\x2C\n          abortListener\x2C\n          { once: true });\n      }\n\n      finished = true;\n\n      for (const promise of unconsumedPromises) {\n        promise.resolve(createIterResult(undefined\x2C true));\n      }\n\n      return PromiseResolve(createIterResult(undefined\x2C true));\n    }\x2C\n\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator'\x2C\n                                       'Error'\x2C err);\n      }\n      error = err;\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n    }\x2C\n\n    [SymbolAsyncIterator]() {\n      return this;\n    }\n  }\x2C AsyncIteratorPrototype);\n\n  eventTargetAgnosticAddListener(emitter\x2C event\x2C eventHandler);\n  if (event !== 'error' && typeof emitter.on === 'function') {\n    emitter.on('error'\x2C errorHandler);\n  }\n\n  if (signal) {\n    eventTargetAgnosticAddListener(\n      signal\x2C\n      'abort'\x2C\n      abortListener\x2C\n      { once: true });\n  }\n\n  return iterator;\n\n  function abortListener() {\n    errorHandler(new AbortError(undefined\x2C { cause: signal?.reason }));\n  }\n\n  function eventHandler(...args) {\n    const promise = ArrayPrototypeShift(unconsumedPromises);\n    if (promise) {\n      promise.resolve(createIterResult(args\x2C false));\n    } else {\n      unconsumedEvents.push(args);\n    }\n  }\n\n  function errorHandler(err) {\n    finished = true;\n\n    const toError = ArrayPrototypeShift(unconsumedPromises);\n\n    if (toError) {\n      toError.reject(err);\n    } else {\n      // The next time we call next()\n      error = err;\n    }\n\n    iterator.return();\n  }\n}\n
code-source-info,0x3172a1b17146,23,18237,18309,C0O18258C14O18265C19O18307,,
tick,0x1bfcd7940,20459,0,0x0,3,0x0,0x3172a1b17023,0x3172a1b0b3f4,0x3172a1b05aed
code-creation,LazyCompile,10,20459,0x3172a1b1980e,378,_addListener node:events:555:22,0x232faba26b88,~
code-source-info,0x3172a1b1980e,23,16167,18039,C0O16209C2O16218C4O16232C6O16245C9O16245C13O16289C18O16300C20O16332C22O16358C27O16358C32O16356C39O16382C40O16402C46O16568C52O16610C60O16663C77O16610C82O16842C87O16861C89O16878C93O16893C97O17004C99O17017C103O17033C109O17042C115O17071C121O17176C129O17210C140O17221C149O17231C166O17244C175O17254C182O17200C193O17329C197O17359C202O17359C209O17406C214O17406C219O17464C222O17468C227O17498C228O17504C233O17520C240O17527C245O17544C251O17560C252O17576C256O17654C264O17736C281O17746C284O17746C304O17794C307O17802C312O17794C327O17772C338O17933C344O17947C348O17969C356O17654C362O17986C365O17994C370O17994C375O18023C377O18037,,
code-creation,LazyCompile,10,20500,0x3172a1b19b1e,15,checkListener node:events:258:23,0x232faba264e8,~
code-source-info,0x3172a1b19b1e,23,7627,7683,C0O7642C8O7642C14O7682,,
code-creation,LazyCompile,10,20500,0x3172a1b19c0e,30, node:internal/validators:236:42,0x2b48e0c7c480,~
code-source-info,0x3172a1b19c0e,15,7226,7342,C0O7247C6O7284C22O7290C27O7284C29O7341,,
tick,0x1bfcc6e8c,20584,0,0x0,3,0x0,0x3172a1b19b26,0x3172a1b19817,0x3172a1b17154,0x3172a1b17023,0x3172a1b0b3f4,0x3172a1b05aed
code-creation,LazyCompile,10,20584,0x3172a1b19ea6,380,emit node:events:475:44,0x232faba26ac8,~
code-source-info,0x3172a1b19ea6,23,13881,16143,C0O13881C8O13915C10O13921C14O13958C19O13969C21O14001C27O14023C29O14022C34O14064C41O14069C51O14064C56O14098C60O14127C68O14158C72O14176C73O14189C74O14248C78O14271C80O14288C86O14295C91O14306C92O14315C96O14324C98O14342C100O14331C108O14387C110O14399C120O14444C126O14454C132O14399C137O14469C145O14494C157O14543C174O14543C186O14469C197O14865C199O14865C200O14917C205O14948C211O14964C219O14962C220O14997C225O15094C232O15094C238O15138C240O15150C244O15160C246O15160C247O15221C249O15227C253O15238C255O15269C256O15282C257O15286C263O15350C268O15350C275O15504C281O15557C296O15557C303O15634C308O15664C311O15664C316O15702C318O15707C320O15707C325O15742C327O15751C332O15755C337O15755C344O16017C350O16072C365O16072C370O15716C375O15689C378O16129C379O16141,,
code-creation,LazyCompile,10,20625,0x3172a1b1a246,172,startListeningIfSignal node:internal/process/signal:22:32,0x3beccadb550,~
script-source,93,node:internal/process/signal,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  SafeMap\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n} = require('internal/errors');\n\nconst { signals } = internalBinding('constants').os;\n\nlet Signal;\nconst signalWraps = new SafeMap();\n\nfunction isSignal(event) {\n  return typeof event === 'string' && signals[event] !== undefined;\n}\n\n// Detect presence of a listener for the special signal types\nfunction startListeningIfSignal(type) {\n  if (isSignal(type) && !signalWraps.has(type)) {\n    if (Signal === undefined)\n      Signal = internalBinding('signal_wrap').Signal;\n    const wrap = new Signal();\n\n    wrap.unref();\n\n    wrap.onsignal = FunctionPrototypeBind(process.emit\x2C process\x2C type\x2C type);\n\n    const signum = signals[type];\n    const err = wrap.start(signum);\n    if (err) {\n      wrap.close();\n      throw errnoException(err\x2C 'uv_signal_start');\n    }\n\n    signalWraps.set(type\x2C wrap);\n  }\n}\n\nfunction stopListeningIfSignal(type) {\n  const wrap = signalWraps.get(type);\n  if (wrap !== undefined && process.listenerCount(type) === 0) {\n    wrap.close();\n    signalWraps.delete(type);\n  }\n}\n\nmodule.exports = {\n  startListeningIfSignal\x2C\n  stopListeningIfSignal\n};\n
code-source-info,0x3172a1b1a246,93,429,904,C0O440C3O444C11O463C14O475C19O475C26O492C32O524C38O533C43O563C50O531C56O589C61O589C67O613C72O613C76O627C78O643C84O673C98O643C103O641C107O721C114O728C118O757C123O757C129O776C131O798C136O798C140O813C148O819C153O813C154O870C159O882C164O882C171O903,,
code-creation,LazyCompile,10,20709,0x3172a1b1a606,19,isSignal node:internal/process/signal:17:18,0x3beccadb398,~
code-source-info,0x3172a1b1a606,93,255,334,C0O267C8O303C13O310C17O318C18O332,,
code-creation,LazyCompile,10,20709,0x3172a1b1aa36,215,setupFetch node:internal/bootstrap/pre_execution:151:20,0x3172a1b07ba0,~
code-source-info,0x3172a1b1aa36,96,4698,5656,C0O4705C3O4717C8O4724C13O4734C21O4768C27O4768C33O4814C34O4821C35O4829C43O4829C47O4881C53O4881C58O4923C65O4944C76O5051C84O4923C89O5065C96O5086C107O5197C115O5065C120O5214C127O5235C138O5345C146O5214C151O5361C158O5382C169O5492C177O5361C182O5508C189O5529C200O5640C208O5508C214O5655,,
code-creation,LazyCompile,10,20750,0x3172a1b1ac4e,5,get node:internal/bootstrap/node:135:6,0x2b48e0c54a80,~
script-source,10,node:internal/bootstrap/node,// Hello\x2C and welcome to hacking node.js!\n//\n// This file is invoked by `node::RunBootstrapping()` in `src/node.cc`\x2C and is\n// responsible for setting up node.js core before executing main scripts\n// under `lib/internal/main/`.\n//\n// This file is expected not to perform any asynchronous operations itself\n// when being executed - those should be done in either\n// `lib/internal/bootstrap/pre_execution.js` or in main scripts. The majority\n// of the code here focuses on setting up the global proxy and the process\n// object in a synchronous manner.\n// As special caution is given to the performance of the startup process\x2C\n// many dependencies are invoked lazily.\n//\n// Scripts run before this file:\n// - `lib/internal/per_context/primordials.js`: to save copies of JavaScript\n//   builtins that won't be affected by user land monkey-patching for internal\n//   modules to use.\n// - `lib/internal/bootstrap/loaders.js`: to setup internal binding and\n//   module loaders\x2C including `process.binding()`\x2C `process._linkedBinding()`\x2C\n//   `internalBinding()` and `NativeModule`.\n//\n// This file is run to bootstrap both the main thread and the worker threads.\n// After this file is run\x2C certain properties are setup according to the\n// configuration of the Node.js instance using the files in\n// `lib/internal/bootstrap/switches/`.\n//\n// Then\x2C depending on how the Node.js instance is launched\x2C one of the main\n// scripts in `lib/internal/main` will be selected by C++ to start the actual\n// execution. They may run additional setups exported by\n// `lib/internal/bootstrap/pre_execution.js` depending on the runtime states.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C require\x2C internalBinding\x2C primordials */\n\nsetupPrepareStackTrace();\n\nconst {\n  Array\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeFill\x2C\n  FunctionPrototypeCall\x2C\n  JSONParse\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPreventExtensions\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectGet\x2C\n  ReflectSet\x2C\n  SymbolToStringTag\x2C\n  globalThis\x2C\n} = primordials;\nconst config = internalBinding('config');\nconst internalTimers = require('internal/timers');\nconst { deprecate\x2C lazyDOMExceptionClass } = require('internal/util');\n\nsetupProcessObject();\n\nsetupGlobalProxy();\nsetupBuffer();\n\nprocess.domain = null;\nprocess._exiting = false;\n\n// process.config is serialized config.gypi\nconst nativeModule = internalBinding('native_module');\n\n// TODO(@jasnell): Once this has gone through one full major\n// release cycle\x2C remove the Proxy and setter and update the\n// getter to either return a read-only object or always return\n// a freshly parsed version of nativeModule.config.\n\nconst deprecationHandler = {\n  warned: false\x2C\n  message: 'Setting process.config is deprecated. ' +\n           'In the future the property will be read-only.'\x2C\n  code: 'DEP0150'\x2C\n  maybeWarn() {\n    if (!this.warned) {\n      process.emitWarning(this.message\x2C {\n        type: 'DeprecationWarning'\x2C\n        code: this.code\n      });\n      this.warned = true;\n    }\n  }\x2C\n\n  defineProperty(target\x2C key\x2C descriptor) {\n    this.maybeWarn();\n    return ObjectDefineProperty(target\x2C key\x2C descriptor);\n  }\x2C\n\n  deleteProperty(target\x2C key) {\n    this.maybeWarn();\n    delete target[key];\n  }\x2C\n\n  preventExtensions(target) {\n    this.maybeWarn();\n    return ObjectPreventExtensions(target);\n  }\x2C\n\n  set(target\x2C key\x2C value) {\n    this.maybeWarn();\n    return ReflectSet(target\x2C key\x2C value);\n  }\x2C\n\n  get(target\x2C key\x2C receiver) {\n    const val = ReflectGet(target\x2C key\x2C receiver);\n    if (val != null && typeof val === 'object') {\n      // eslint-disable-next-line node-core/prefer-primordials\n      return new Proxy(val\x2C deprecationHandler);\n    }\n    return val;\n  }\x2C\n\n  setPrototypeOf(target\x2C proto) {\n    this.maybeWarn();\n    return ObjectSetPrototypeOf(target\x2C proto);\n  }\n};\n\n// eslint-disable-next-line node-core/prefer-primordials\nlet processConfig = new Proxy(\n  JSONParse(nativeModule.config)\x2C\n  deprecationHandler);\n\nObjectDefineProperty(process\x2C 'config'\x2C {\n  enumerable: true\x2C\n  configurable: true\x2C\n  get() { return processConfig; }\x2C\n  set(value) {\n    deprecationHandler.maybeWarn();\n    processConfig = value;\n  }\n});\n\nrequire('internal/worker/js_transferable').setup();\n\n// Bootstrappers for all threads\x2C including worker threads and main thread\nconst perThreadSetup = require('internal/process/per_thread');\nconst rawMethods = internalBinding('process_methods');\n\n// Set up methods on the process object for all threads\n{\n  process.dlopen = rawMethods.dlopen;\n  process.uptime = rawMethods.uptime;\n\n  // TODO(joyeecheung): either remove them or make them public\n  process._getActiveRequests = rawMethods._getActiveRequests;\n  process._getActiveHandles = rawMethods._getActiveHandles;\n\n  process.getActiveResourcesInfo = function() {\n    const timerCounts = internalTimers.getTimerCounts();\n    return ArrayPrototypeConcat(\n      rawMethods._getActiveRequestsInfo()\x2C\n      rawMethods._getActiveHandlesInfo()\x2C\n      ArrayPrototypeFill(new Array(timerCounts.timeoutCount)\x2C 'Timeout')\x2C\n      ArrayPrototypeFill(new Array(timerCounts.immediateCount)\x2C 'Immediate'));\n  };\n\n  // TODO(joyeecheung): remove these\n  process.reallyExit = rawMethods.reallyExit;\n  process._kill = rawMethods._kill;\n\n  const wrapped = perThreadSetup.wrapProcessMethods(rawMethods);\n  process._rawDebug = wrapped._rawDebug;\n  process.cpuUsage = wrapped.cpuUsage;\n  process.resourceUsage = wrapped.resourceUsage;\n  process.memoryUsage = wrapped.memoryUsage;\n  process.kill = wrapped.kill;\n  process.exit = wrapped.exit;\n\n  process.hrtime = perThreadSetup.hrtime;\n  process.hrtime.bigint = perThreadSetup.hrtimeBigInt;\n\n  process.openStdin = function() {\n    process.stdin.resume();\n    return process.stdin;\n  };\n}\n\nconst credentials = internalBinding('credentials');\nif (credentials.implementsPosixCredentials) {\n  process.getuid = credentials.getuid;\n  process.geteuid = credentials.geteuid;\n  process.getgid = credentials.getgid;\n  process.getegid = credentials.getegid;\n  process.getgroups = credentials.getgroups;\n}\n\n// Setup the callbacks that node::AsyncWrap will call when there are hooks to\n// process. They use the same functions as the JS embedder API. These callbacks\n// are setup immediately to prevent async_wrap.setupHooks() from being hijacked\n// and the cost of doing so is negligible.\nconst { nativeHooks } = require('internal/async_hooks');\ninternalBinding('async_wrap').setupHooks(nativeHooks);\n\nconst {\n  setupTaskQueue\x2C\n  queueMicrotask\n} = require('internal/process/task_queues');\n\nif (!config.noBrowserGlobals) {\n  // Override global console from the one provided by the VM\n  // to the one implemented by Node.js\n  // https://console.spec.whatwg.org/#console-namespace\n  exposeNamespace(globalThis\x2C 'console'\x2C\n                  createGlobalConsole(globalThis.console));\n\n  const { URL\x2C URLSearchParams } = require('internal/url');\n  // https://url.spec.whatwg.org/#url\n  exposeInterface(globalThis\x2C 'URL'\x2C URL);\n  // https://url.spec.whatwg.org/#urlsearchparams\n  exposeInterface(globalThis\x2C 'URLSearchParams'\x2C URLSearchParams);\n  exposeGetterAndSetter(globalThis\x2C\n                        'DOMException'\x2C\n                        lazyDOMExceptionClass\x2C\n                        (value) => {\n                          exposeInterface(globalThis\x2C 'DOMException'\x2C value);\n                        });\n\n  const {\n    TextEncoder\x2C TextDecoder\n  } = require('internal/encoding');\n  // https://encoding.spec.whatwg.org/#textencoder\n  exposeInterface(globalThis\x2C 'TextEncoder'\x2C TextEncoder);\n  // https://encoding.spec.whatwg.org/#textdecoder\n  exposeInterface(globalThis\x2C 'TextDecoder'\x2C TextDecoder);\n\n  const {\n    AbortController\x2C\n    AbortSignal\x2C\n  } = require('internal/abort_controller');\n  exposeInterface(globalThis\x2C 'AbortController'\x2C AbortController);\n  exposeInterface(globalThis\x2C 'AbortSignal'\x2C AbortSignal);\n\n  const {\n    EventTarget\x2C\n    Event\x2C\n  } = require('internal/event_target');\n  exposeInterface(globalThis\x2C 'EventTarget'\x2C EventTarget);\n  exposeInterface(globalThis\x2C 'Event'\x2C Event);\n  const {\n    MessageChannel\x2C\n    MessagePort\x2C\n    MessageEvent\x2C\n  } = require('internal/worker/io');\n  exposeInterface(globalThis\x2C 'MessageChannel'\x2C MessageChannel);\n  exposeInterface(globalThis\x2C 'MessagePort'\x2C MessagePort);\n  exposeInterface(globalThis\x2C 'MessageEvent'\x2C MessageEvent);\n\n  // https://html.spec.whatwg.org/multipage/webappapis.html#windoworworkerglobalscope\n  const timers = require('timers');\n  defineOperation(globalThis\x2C 'clearInterval'\x2C timers.clearInterval);\n  defineOperation(globalThis\x2C 'clearTimeout'\x2C timers.clearTimeout);\n  defineOperation(globalThis\x2C 'setInterval'\x2C timers.setInterval);\n  defineOperation(globalThis\x2C 'setTimeout'\x2C timers.setTimeout);\n\n  defineOperation(globalThis\x2C 'queueMicrotask'\x2C queueMicrotask);\n\n  // https://www.w3.org/TR/hr-time-2/#the-performance-attribute\n  defineReplacableAttribute(globalThis\x2C 'performance'\x2C\n                            require('perf_hooks').performance);\n\n  // Non-standard extensions:\n  defineOperation(globalThis\x2C 'clearImmediate'\x2C timers.clearImmediate);\n  defineOperation(globalThis\x2C 'setImmediate'\x2C timers.setImmediate);\n\n  const {\n    structuredClone\x2C\n  } = require('internal/structured_clone');\n  defineOperation(globalThis\x2C 'structuredClone'\x2C structuredClone);\n}\n\n// Set the per-Environment callback that will be called\n// when the TrackingTraceStateObserver updates trace state.\n// Note that when NODE_USE_V8_PLATFORM is true\x2C the observer is\n// attached to the per-process TracingController.\nconst { setTraceCategoryStateUpdateHandler } = internalBinding('trace_events');\nsetTraceCategoryStateUpdateHandler(perThreadSetup.toggleTraceCategoryState);\n\n// process.allowedNodeEnvironmentFlags\nObjectDefineProperty(process\x2C 'allowedNodeEnvironmentFlags'\x2C {\n  get() {\n    const flags = perThreadSetup.buildAllowedFlags();\n    process.allowedNodeEnvironmentFlags = flags;\n    return process.allowedNodeEnvironmentFlags;\n  }\x2C\n  // If the user tries to set this to another value\x2C override\n  // this completely to that value.\n  set(value) {\n    ObjectDefineProperty(this\x2C 'allowedNodeEnvironmentFlags'\x2C {\n      value\x2C\n      configurable: true\x2C\n      enumerable: true\x2C\n      writable: true\n    });\n  }\x2C\n  enumerable: true\x2C\n  configurable: true\n});\n\n// process.assert\nprocess.assert = deprecate(\n  perThreadSetup.assert\x2C\n  'process.assert() is deprecated. Please use the `assert` module instead.'\x2C\n  'DEP0100');\n\n// TODO(joyeecheung): this property has not been well-maintained\x2C should we\n// deprecate it in favor of a better API?\nconst { isDebugBuild\x2C hasOpenSSL\x2C hasInspector } = config;\nconst features = {\n  inspector: hasInspector\x2C\n  debug: isDebugBuild\x2C\n  uv: true\x2C\n  ipv6: true\x2C  // TODO(bnoordhuis) ping libuv\n  tls_alpn: hasOpenSSL\x2C\n  tls_sni: hasOpenSSL\x2C\n  tls_ocsp: hasOpenSSL\x2C\n  tls: hasOpenSSL\x2C\n  // This needs to be dynamic because snapshot is built without code cache.\n  // TODO(joyeecheung): https://github.com/nodejs/node/issues/31074\n  // Make it possible to build snapshot with code cache\n  get cached_builtins() {\n    return nativeModule.hasCachedBuiltins();\n  }\n};\n\nObjectDefineProperty(process\x2C 'features'\x2C {\n  enumerable: true\x2C\n  writable: false\x2C\n  configurable: false\x2C\n  value: features\n});\n\n{\n  const {\n    onGlobalUncaughtException\x2C\n    setUncaughtExceptionCaptureCallback\x2C\n    hasUncaughtExceptionCaptureCallback\n  } = require('internal/process/execution');\n\n  // For legacy reasons this is still called `_fatalException`\x2C even\n  // though it is now a global uncaught exception handler.\n  // The C++ land node::errors::TriggerUncaughtException grabs it\n  // from the process object because it has been monkey-patchable.\n  // TODO(joyeecheung): investigate whether process._fatalException\n  // can be deprecated.\n  process._fatalException = onGlobalUncaughtException;\n  process.setUncaughtExceptionCaptureCallback =\n    setUncaughtExceptionCaptureCallback;\n  process.hasUncaughtExceptionCaptureCallback =\n    hasUncaughtExceptionCaptureCallback;\n}\n\nconst { emitWarning } = require('internal/process/warning');\nprocess.emitWarning = emitWarning;\n\n// We initialize the tick callbacks and the timer callbacks last during\n// bootstrap to make sure that any operation done before this are synchronous.\n// If any ticks or timers are scheduled before this they are unlikely to work.\n{\n  const { nextTick\x2C runNextTicks } = setupTaskQueue();\n  process.nextTick = nextTick;\n  // Used to emulate a tick manually in the JS land.\n  // A better name for this function would be `runNextTicks` but\n  // it has been exposed to the process object so we keep this legacy name\n  // TODO(joyeecheung): either remove it or make it public\n  process._tickCallback = runNextTicks;\n\n  const { setupTimers } = internalBinding('timers');\n  const {\n    processImmediate\x2C\n    processTimers\x2C\n  } = internalTimers.getTimerCallbacks(runNextTicks);\n  // Sets two per-Environment callbacks that will be run from libuv:\n  // - processImmediate will be run in the callback of the per-Environment\n  //   check handle.\n  // - processTimers will be run in the callback of the per-Environment timer.\n  setupTimers(processImmediate\x2C processTimers);\n  // Note: only after this point are the timers effective\n}\n\n// Preload modules so that they are included in the builtin snapshot.\nrequire('fs');\nrequire('v8');\nrequire('vm');\nrequire('url');\n\nfunction setupPrepareStackTrace() {\n  const {\n    setEnhanceStackForFatalException\x2C\n    setPrepareStackTraceCallback\n  } = internalBinding('errors');\n  const {\n    prepareStackTrace\x2C\n    fatalExceptionStackEnhancers: {\n      beforeInspector\x2C\n      afterInspector\n    }\n  } = require('internal/errors');\n  // Tell our PrepareStackTraceCallback passed to the V8 API\n  // to call prepareStackTrace().\n  setPrepareStackTraceCallback(prepareStackTrace);\n  // Set the function used to enhance the error stack for printing\n  setEnhanceStackForFatalException(beforeInspector\x2C afterInspector);\n}\n\nfunction setupProcessObject() {\n  const EventEmitter = require('events');\n  const origProcProto = ObjectGetPrototypeOf(process);\n  ObjectSetPrototypeOf(origProcProto\x2C EventEmitter.prototype);\n  FunctionPrototypeCall(EventEmitter\x2C process);\n  ObjectDefineProperty(process\x2C SymbolToStringTag\x2C {\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: false\x2C\n    value: 'process'\n  });\n  // Make process globally available to users by putting it on the global proxy\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\n    value: process\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: true\n  });\n}\n\nfunction setupGlobalProxy() {\n  ObjectDefineProperty(globalThis\x2C SymbolToStringTag\x2C {\n    value: 'global'\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n}\n\nfunction setupBuffer() {\n  const {\n    Buffer\x2C\n    atob\x2C\n    btoa\x2C\n  } = require('buffer');\n  const bufferBinding = internalBinding('buffer');\n\n  // Only after this point can C++ use Buffer::New()\n  bufferBinding.setBufferPrototype(Buffer.prototype);\n  delete bufferBinding.setBufferPrototype;\n  delete bufferBinding.zeroFill;\n\n  ObjectDefineProperties(globalThis\x2C {\n    'Buffer': {\n      value: Buffer\x2C\n      enumerable: false\x2C\n      writable: true\x2C\n      configurable: true\x2C\n    }\x2C\n    'atob': {\n      value: atob\x2C\n      enumerable: false\x2C\n      writable: true\x2C\n      configurable: true\x2C\n    }\x2C\n    'btoa': {\n      value: btoa\x2C\n      enumerable: false\x2C\n      writable: true\x2C\n      configurable: true\x2C\n    }\x2C\n  });\n}\n\nfunction createGlobalConsole(consoleFromVM) {\n  const consoleFromNode =\n    require('internal/console/global');\n  if (config.hasInspector) {\n    const inspector = require('internal/util/inspector');\n    // This will be exposed by `require('inspector').console` later.\n    inspector.consoleFromVM = consoleFromVM;\n    // TODO(joyeecheung): postpone this until the first time inspector\n    // is activated.\n    inspector.wrapConsole(consoleFromNode\x2C consoleFromVM);\n    const { setConsoleExtensionInstaller } = internalBinding('inspector');\n    // Setup inspector command line API.\n    setConsoleExtensionInstaller(inspector.installConsoleExtensions);\n  }\n  return consoleFromNode;\n}\n\n// https://heycam.github.io/webidl/#es-namespaces\nfunction exposeNamespace(target\x2C name\x2C namespaceObject) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: namespaceObject\n  });\n}\n\n// https://heycam.github.io/webidl/#es-interfaces\nfunction exposeInterface(target\x2C name\x2C interfaceObject) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: interfaceObject\n  });\n}\n\nfunction exposeGetterAndSetter(target\x2C name\x2C getter\x2C setter = undefined) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    enumerable: false\x2C\n    configurable: true\x2C\n    get: getter\x2C\n    set: setter\x2C\n  });\n}\n\n// https://heycam.github.io/webidl/#define-the-operations\nfunction defineOperation(target\x2C name\x2C method) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    writable: true\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    value: method\n  });\n}\n\n// https://heycam.github.io/webidl/#Replaceable\nfunction defineReplacableAttribute(target\x2C name\x2C value) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    writable: true\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    value\x2C\n  });\n}\n
code-source-info,0x3172a1b1ac4e,10,4156,4184,C0O4161C4O4182,,
code-creation,LazyCompile,10,21375,0x3172a1b1be56,52,get node:internal/bootstrap/node:112:6,0x2b48e0c549e0,~
code-source-info,0x3172a1b1be56,10,3542,3806,C0O3584C14O3584C20O3623C29O3738C35O3760C43O3745C48O3780C49O3791C51O3802,,
code-creation,LazyCompile,10,21459,0x3172a1b1c356,268,setupWebCrypto node:internal/bootstrap/pre_execution:194:24,0x3172a1b07bf0,~
code-source-info,0x3172a1b1c356,96,5785,6884,C0O5785C8O5792C13O5804C18O5811C23O5821C33O5855C39O5855C45O5912C46O5919C47O5931C48O5931C50O5944C61O5965C71O6010C102O6010C108O5944C113O6281C121O6285C126O6310C132O6329C146O6343C150O6339C152O6385C163O6406C177O6526C185O6385C190O6545C201O6566C215O6689C223O6545C228O6711C239O6732C253O6858C261O6711C267O6883,,
code-creation,LazyCompile,10,21459,0x3172a1b1c6de,75,setupDebugEnv node:internal/bootstrap/pre_execution:273:23,0x3172a1b07d80,~
code-source-info,0x3172a1b1c6de,96,8149,8359,C0O8156C6O8156C11O8189C19O8217C24O8221C29O8190C34O8236C42O8240C48O8284C54O8284C59O8321C64O8334C69O8335C74O8358,,
code-creation,LazyCompile,10,21500,0x3172a1b1cb16,159,initializeDebugEnv node:internal/util/debuglog:22:28,0x232faba1cfa0,~
script-source,22,node:internal/util/debuglog,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst { inspect\x2C format\x2C formatWithOptions } = require('internal/util/inspect');\n\n// `debugImpls` and `testEnabled` are deliberately not initialized so any call\n// to `debuglog()` before `initializeDebugEnv()` is called will throw.\nlet debugImpls;\nlet testEnabled;\n\n\n// `debugEnv` is initial value of process.env.NODE_DEBUG\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = ObjectCreate(null);\n  if (debugEnv) {\n    // This is run before any user code\x2C it's OK not to use primordials.\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g\x2C '\\\\$&')\n      .replaceAll('*'\x2C '.*')\n      .replaceAll('\x2C'\x2C '$|^');\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`\x2C 'i');\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex\x2C str) !== null;\n  } else {\n    testEnabled = () => false;\n  }\n}\n\n// Emits warning when user sets\n// NODE_DEBUG=http or NODE_DEBUG=http2.\nfunction emitWarningIfNeeded(set) {\n  if ('HTTP' === set || 'HTTP2' === set) {\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\n      'to \\'' + StringPrototypeToLowerCase(set) + '\\' can expose sensitive ' +\n      'data (such as passwords\x2C tokens and authentication headers) ' +\n      'in the resulting log.');\n  }\n}\n\nconst noop = () => {};\n\nfunction debuglogImpl(enabled\x2C set) {\n  if (debugImpls[set] === undefined) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = process.stderr.hasColors && process.stderr.hasColors();\n        const msg = formatWithOptions({ colors }\x2C ...args);\n        const coloredPID = inspect(pid\x2C { colors });\n        process.stderr.write(format('%s %s: %s\\n'\x2C set\x2C coloredPID\x2C msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\n\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG\x2C\n// so it needs to be called lazily in top scopes of internal modules\n// that may be loaded before these run time states are allowed to\n// be accessed.\nfunction debuglog(set\x2C cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    // Only invokes debuglogImpl() when the debug function is\n    // called for the first time.\n    debug = debuglogImpl(enabled\x2C set);\n    if (typeof cb === 'function')\n      cb(debug);\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => {\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  ObjectDefineProperty(logger\x2C 'enabled'\x2C {\n    get() {\n      return test();\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n  return logger;\n}\n\nmodule.exports = {\n  debuglog\x2C\n  initializeDebugEnv\n};\n
code-source-info,0x3172a1b1cb16,22,546,991,C0O561C7O574C14O572C20O596C31O709C44O709C51O753C62O754C69O782C80O783C88O833C100O848C116O833C121O833C123O871C132O883C144O959C151O971C158O990,,
code-creation,LazyCompile,10,21667,0x3172a1b1d11e,49,setupStacktracePrinterOnSigint node:internal/bootstrap/pre_execution:252:40,0x3172a1b07cb8,~
code-source-info,0x3172a1b1d11e,96,7714,7900,C0O7721C8O7726C14O7766C15O7773C16O7807C22O7807C27O7788C32O7857C38O7890C43O7890C48O7899,,
code-creation,LazyCompile,10,21667,0x3172a1b1d336,62,initializeReport node:internal/bootstrap/pre_execution:262:26,0x3172a1b07d08,~
code-source-info,0x3172a1b1d336,96,7927,8125,C0O7927C8O7953C16O7953C21O7942C27O7991C42O8012C47O8083C55O7991C61O8124,,
code-creation,Eval,10,21750,0x3172a1b1d8e6,5, node:internal/process/report:1:1,0x3172a1b1d6f0,~
script-source,99,node:internal/process/report,'use strict';\nconst {\n  ERR_SYNTHETIC\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateObject\x2C\n  validateSignalName\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst nr = internalBinding('report');\nconst {\n  JSONParse\x2C\n} = primordials;\nconst report = {\n  writeReport(file\x2C err) {\n    if (typeof file === 'object' && file !== null) {\n      err = file;\n      file = undefined;\n    } else if (file !== undefined) {\n      validateString(file\x2C 'file');\n    }\n\n    if (err === undefined) {\n      err = new ERR_SYNTHETIC();\n    } else {\n      validateObject(err\x2C 'err');\n    }\n\n    return nr.writeReport('JavaScript API'\x2C 'API'\x2C file\x2C err);\n  }\x2C\n  getReport(err) {\n    if (err === undefined)\n      err = new ERR_SYNTHETIC();\n    else\n      validateObject(err\x2C 'err');\n\n    return JSONParse(nr.getReport(err));\n  }\x2C\n  get directory() {\n    return nr.getDirectory();\n  }\x2C\n  set directory(dir) {\n    validateString(dir\x2C 'directory');\n    nr.setDirectory(dir);\n  }\x2C\n  get filename() {\n    return nr.getFilename();\n  }\x2C\n  set filename(name) {\n    validateString(name\x2C 'filename');\n    nr.setFilename(name);\n  }\x2C\n  get compact() {\n    return nr.getCompact();\n  }\x2C\n  set compact(b) {\n    validateBoolean(b\x2C 'compact');\n    nr.setCompact(b);\n  }\x2C\n  get signal() {\n    return nr.getSignal();\n  }\x2C\n  set signal(sig) {\n    validateSignalName(sig\x2C 'signal');\n    removeSignalHandler();\n    addSignalHandler(sig);\n    nr.setSignal(sig);\n  }\x2C\n  get reportOnFatalError() {\n    return nr.shouldReportOnFatalError();\n  }\x2C\n  set reportOnFatalError(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnFatalError(trigger);\n  }\x2C\n  get reportOnSignal() {\n    return nr.shouldReportOnSignal();\n  }\x2C\n  set reportOnSignal(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnSignal(trigger);\n    removeSignalHandler();\n    addSignalHandler();\n  }\x2C\n  get reportOnUncaughtException() {\n    return nr.shouldReportOnUncaughtException();\n  }\x2C\n  set reportOnUncaughtException(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnUncaughtException(trigger);\n  }\n};\n\nfunction addSignalHandler(sig) {\n  if (nr.shouldReportOnSignal()) {\n    if (typeof sig !== 'string')\n      sig = nr.getSignal();\n\n    process.on(sig\x2C signalHandler);\n  }\n}\n\nfunction removeSignalHandler() {\n  const sig = nr.getSignal();\n\n  if (sig)\n    process.removeListener(sig\x2C signalHandler);\n}\n\nfunction signalHandler(sig) {\n  nr.writeReport(sig\x2C 'Signal'\x2C null\x2C '');\n}\n\nmodule.exports = {\n  addSignalHandler\x2C\n  report\n};\n
code-source-info,0x3172a1b1d8e6,99,0,2545,C0O0C4O2545,,
code-creation,Function,10,21875,0x3172a1b1e3f6,306, node:internal/process/report:1:1,0x3172a1b1d860,~
code-source-info,0x3172a1b1e3f6,99,0,2545,C0O0C48O42C51O42C56O68C61O24C67O165C70O165C75O86C81O105C87O123C93O145C99O208C102O208C106O208C108O245C114O288C119O292C127O678C281O2494C288O2515C294O2535C300O2509C305O2544,,
tick,0x1bfcd7960,21875,1,0x10041f4d8,3,0x0,0x3172a1b06a74,0x3172a1b05d65,0x3172a1b1d346,0x3172a1b0b440,0x3172a1b05aed
code-creation,LazyCompile,10,21959,0x3172a1b2008e,21,initializeReportSignalHandlers node:internal/bootstrap/pre_execution:281:40,0x3172a1b07dd0,~
code-source-info,0x3172a1b2008e,96,8460,8556,C0O8496C6O8496C11O8475C16O8535C20O8555,,
code-creation,LazyCompile,10,21959,0x3172a1b20196,57,addSignalHandler node:internal/process/report:98:26,0x3172a1b1d918,~
code-source-info,0x3172a1b20196,99,2144,2290,C0O2154C5O2161C10O2161C16O2191C22O2226C27O2235C32O2235C38O2253C41O2261C49O2261C56O2289,,
code-creation,LazyCompile,10,22000,0x3172a1b2075e,92,initializeHeapSnapshotSignalHandlers node:internal/bootstrap/pre_execution:287:46,0x3172a1b07e20,~
code-source-info,0x3172a1b2075e,96,8603,8865,C0O8603C8O8625C18O8625C23O8669C25O8686C26O8693C27O8697C35O8697C40O8727C45O8728C50O8788C58O8788C63O8766C69O8806C74O8814C79O8817C84O8814C91O8864,,
code-creation,LazyCompile,10,22000,0x3172a1b209ee,138,setupChildProcessIpcChannel node:internal/bootstrap/pre_execution:417:37,0x3172a1b07ff0,~
code-source-info,0x3172a1b209ee,96,12617,13146,C0O12624C3O12636C8O12640C14O12678C20O12678C25O12722C33O12745C38O12749C46O12722C52O12775C53O12785C57O12775C61O12866C64O12881C73O12939C76O12947C81O12951C90O12998C93O13013C102O13055C108O13055C113O13079C118O13080C124O13119C127O13134C132O13119C137O13145,,
code-creation,LazyCompile,10,22084,0x3172a1b20de6,455,initializePolicy node:internal/bootstrap/pre_execution:445:26,0x3172a1b08090,~
code-source-info,0x3172a1b20de6,96,13445,15243,C0O13479C10O13479C15O13522C17O13552C21O13560C35O13560C41O13685C49O13685C55O13662C60O13677C65O13804C67O13821C75O13825C81O13840C87O13841C94O13881C100O13913C108O13895C116O13970C120O13992C126O13992C132O13970C138O14006C149O14022C153O14036C161O14050C167O14108C175O14108C180O14142C190O14142C197O14217C207O14217C212O14259C214O14312C222O14312C227O14390C235O14390C241O14358C246O14370C251O14439C257O14439C263O14489C269O14489C275O14548C277O14574C279O14598C283O14579C288O14688C290O14704C295O14639C300O14667C305O14730C311O14766C317O14766C322O14807C328O14807C334O14836C340O14856C344O14843C349O14876C356O14923C358O14952C360O14993C366O15015C376O15015C383O14993C389O14607C394O14561C397O15050C401O15077C415O15083C420O15077C421O15166C429O15166C435O15207C441O15231C447O15208C454O15242,,
code-creation,LazyCompile,10,22125,0x3172a1b211d6,63,initializeClusterIPC node:internal/bootstrap/pre_execution:436:30,0x3172a1b08040,~
code-source-info,0x3172a1b211d6,96,13177,13418,C0O13184C3O13196C10O13200C18O13215C23O13219C29O13257C35O13257C40O13289C45O13289C49O13378C52O13393C62O13417,,
code-creation,LazyCompile,10,22125,0x3172a1b21346,27,initializeSourceMapsHandlers node:internal/bootstrap/pre_execution:540:38,0x3172a1b081d0,~
code-source-info,0x3172a1b21346,96,16976,17125,C0O17020C6O17020C11O16991C16O17071C21O17100C26O17124,,
code-creation,Eval,10,22250,0x3172a1b21d36,5, node:internal/source_map/source_map_cache:1:1,0x3172a1b219d0,~
script-source,100,node:internal/source_map/source_map_cache,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeSplit\x2C\n} = primordials;\n\nfunction ObjectGetValueSafe(obj\x2C key) {\n  const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'value') ? desc.value : undefined;\n}\n\n// See https://sourcemaps.info/spec.html for SourceMap V3 specification.\nconst { Buffer } = require('buffer');\nlet debug = require('internal/util/debuglog').debuglog('source_map'\x2C (fn) => {\n  debug = fn;\n});\nconst fs = require('fs');\nconst { getOptionValue } = require('internal/options');\nconst { IterableWeakMap } = require('internal/util/iterable_weak_map');\nconst {\n  normalizeReferrerURL\x2C\n} = require('internal/modules/cjs/helpers');\nconst { validateBoolean } = require('internal/validators');\n// Since the CJS module cache is mutable\x2C which leads to memory leaks when\n// modules are deleted\x2C we use a WeakMap so that the source map cache will\n// be purged automatically:\nconst cjsSourceMapCache = new IterableWeakMap();\n// The esm cache is not mutable\x2C so we can use a Map without memory concerns:\nconst esmSourceMapCache = new SafeMap();\nconst { fileURLToPath\x2C pathToFileURL\x2C URL } = require('internal/url');\nlet SourceMap;\n\nlet sourceMapsEnabled;\nfunction getSourceMapsEnabled() {\n  if (sourceMapsEnabled === undefined) {\n    setSourceMapsEnabled(getOptionValue('--enable-source-maps'));\n  }\n  return sourceMapsEnabled;\n}\n\nfunction setSourceMapsEnabled(val) {\n  validateBoolean(val\x2C 'val');\n\n  const {\n    setSourceMapsEnabled\x2C\n    setPrepareStackTraceCallback\n  } = internalBinding('errors');\n  setSourceMapsEnabled(val);\n  if (val) {\n    const {\n      prepareStackTrace\n    } = require('internal/source_map/prepare_stack_trace');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  } else if (sourceMapsEnabled !== undefined) {\n    // Reset prepare stack trace callback only when disabling source maps.\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/errors');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  }\n\n  sourceMapsEnabled = val;\n}\n\nfunction maybeCacheSourceMap(filename\x2C content\x2C cjsModuleInstance) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n  try {\n    filename = normalizeReferrerURL(filename);\n  } catch (err) {\n    // This is most likely an [eval]-wrapper\x2C which is currently not\n    // supported.\n    debug(err);\n    return;\n  }\n  const match = StringPrototypeMatch(\n    content\x2C\n    /\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/\n  );\n  if (match) {\n    const data = dataFromUrl(filename\x2C match.groups.sourceMappingURL);\n    const url = data ? null : match.groups.sourceMappingURL;\n    if (cjsModuleInstance) {\n      cjsSourceMapCache.set(cjsModuleInstance\x2C {\n        filename\x2C\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    } else {\n      // If there is no cjsModuleInstance assume we are in a\n      // "modules/esm" context.\n      esmSourceMapCache.set(filename\x2C {\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    }\n  }\n}\n\nfunction dataFromUrl(sourceURL\x2C sourceMappingURL) {\n  try {\n    const url = new URL(sourceMappingURL);\n    switch (url.protocol) {\n      case 'data:':\n        return sourceMapFromDataUrl(sourceURL\x2C url.pathname);\n      default:\n        debug(`unknown protocol ${url.protocol}`);\n        return null;\n    }\n  } catch (err) {\n    debug(err);\n    // If no scheme is present\x2C we assume we are dealing with a file path.\n    const mapURL = new URL(sourceMappingURL\x2C sourceURL).href;\n    return sourceMapFromFile(mapURL);\n  }\n}\n\n// Cache the length of each line in the file that a source map was extracted\n// from. This allows translation from byte offset V8 coverage reports\x2C\n// to line/column offset Source Map V3.\nfunction lineLengths(content) {\n  // We purposefully keep \\r as part of the line-length calculation\x2C in\n  // cases where there is a \\r\\n separator\x2C so that this can be taken into\n  // account in coverage calculations.\n  return ArrayPrototypeMap(StringPrototypeSplit(content\x2C /\\n|\\u2028|\\u2029/)\x2C (line) => {\n    return line.length;\n  });\n}\n\nfunction sourceMapFromFile(mapURL) {\n  try {\n    const content = fs.readFileSync(fileURLToPath(mapURL)\x2C 'utf8');\n    const data = JSONParse(content);\n    return sourcesToAbsolute(mapURL\x2C data);\n  } catch (err) {\n    debug(err);\n    return null;\n  }\n}\n\n// data:[<mediatype>][;base64]\x2C<data> see:\n// https://tools.ietf.org/html/rfc2397#section-2\nfunction sourceMapFromDataUrl(sourceURL\x2C url) {\n  const { 0: format\x2C 1: data } = StringPrototypeSplit(url\x2C '\x2C');\n  const splitFormat = StringPrototypeSplit(format\x2C ';');\n  const contentType = splitFormat[0];\n  const base64 = splitFormat[splitFormat.length - 1] === 'base64';\n  if (contentType === 'application/json') {\n    const decodedData = base64 ?\n      Buffer.from(data\x2C 'base64').toString('utf8') : data;\n    try {\n      const parsedData = JSONParse(decodedData);\n      return sourcesToAbsolute(sourceURL\x2C parsedData);\n    } catch (err) {\n      debug(err);\n      return null;\n    }\n  } else {\n    debug(`unknown content-type ${contentType}`);\n    return null;\n  }\n}\n\n// If the sources are not absolute URLs after prepending of the "sourceRoot"\x2C\n// the sources are resolved relative to the SourceMap (like resolving script\n// src in a html document).\nfunction sourcesToAbsolute(baseURL\x2C data) {\n  data.sources = data.sources.map((source) => {\n    source = (data.sourceRoot || '') + source;\n    return new URL(source\x2C baseURL).href;\n  });\n  // The sources array is now resolved to absolute URLs\x2C sourceRoot should\n  // be updated to noop.\n  data.sourceRoot = '';\n  return data;\n}\n\n// WARNING: The `sourceMapCacheToObject` and `appendCJSCache` run during\n// shutdown. In particular\x2C they also run when Workers are terminated\x2C making\n// it important that they do not call out to any user-provided code\x2C including\n// built-in prototypes that might have been tampered with.\n\n// Get serialized representation of source-map cache\x2C this is used\n// to persist a cache of source-maps to disk when NODE_V8_COVERAGE is enabled.\nfunction sourceMapCacheToObject() {\n  const obj = ObjectCreate(null);\n\n  for (const { 0: k\x2C 1: v } of esmSourceMapCache) {\n    obj[k] = v;\n  }\n\n  appendCJSCache(obj);\n\n  if (ObjectKeys(obj).length === 0) {\n    return undefined;\n  }\n  return obj;\n}\n\nfunction appendCJSCache(obj) {\n  for (const value of cjsSourceMapCache) {\n    obj[ObjectGetValueSafe(value\x2C 'filename')] = {\n      lineLengths: ObjectGetValueSafe(value\x2C 'lineLengths')\x2C\n      data: ObjectGetValueSafe(value\x2C 'data')\x2C\n      url: ObjectGetValueSafe(value\x2C 'url')\n    };\n  }\n}\n\nfunction findSourceMap(sourceURL) {\n  if (!RegExpPrototypeTest(/^\\w+:\\/\\//\x2C sourceURL)) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  if (!SourceMap) {\n    SourceMap = require('internal/source_map/source_map').SourceMap;\n  }\n  let sourceMap = esmSourceMapCache.get(sourceURL);\n  if (sourceMap === undefined) {\n    for (const value of cjsSourceMapCache) {\n      const filename = ObjectGetValueSafe(value\x2C 'filename');\n      if (sourceURL === filename) {\n        sourceMap = {\n          data: ObjectGetValueSafe(value\x2C 'data')\n        };\n      }\n    }\n  }\n  if (sourceMap && sourceMap.data) {\n    return new SourceMap(sourceMap.data);\n  }\n  return undefined;\n}\n\nmodule.exports = {\n  findSourceMap\x2C\n  getSourceMapsEnabled\x2C\n  setSourceMapsEnabled\x2C\n  maybeCacheSourceMap\x2C\n  sourceMapCacheToObject\x2C\n};\n
code-source-info,0x3172a1b21d36,100,0,7630,C0O0C4O7630,,
code-creation,Function,10,22542,0x3172a1b223ae,435, node:internal/source_map/source_map_cache:1:1,0x3172a1b21cb0,~
code-source-info,0x3172a1b223ae,100,0,7630,C0O0C152O25C158O46C164O59C170O75C176O89C182O123C188O156C194O179C199O190C205O214C211O526C217O526C222O515C228O557C234O557C239O590C252O591C258O557C260O653C266O653C270O653C272O695C278O695C283O676C289O752C295O752C300O732C305O832C311O832C316O806C322O901C328O901C333O881C339O1137C341O1137C346O1137C348O1264C350O1264C355O1264C357O1325C363O1325C368O1287C374O1302C380O1317C386O1354C387O1354C389O1370C390O1370C392O7494C399O7515C405O7532C411O7556C417O7580C423O7603C429O7509C434O7629,,
code-creation,LazyCompile,10,22584,0x3172a1b23196,82,debuglog node:internal/util/debuglog:71:18,0x232faba1d2f0,~
code-source-info,0x3172a1b23196,22,2232,3219,C0O2232C28O2357C32O2357C34O2759C35O2759C37O2781C41O2781C43O2869C48O3068C58O3089C63O3114C74O3068C79O3203C81O3217,,
code-creation,Eval,10,22667,0x3172a1b23716,5, node:internal/util/iterable_weak_map:1:1,0x3172a1b234c8,~
script-source,101,node:internal/util/iterable_weak_map,'use strict';\n\nconst {\n  ObjectFreeze\x2C\n  SafeFinalizationRegistry\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SymbolIterator\x2C\n} = primordials;\n\n// This class is modified from the example code in the WeakRefs specification:\n// https://github.com/tc39/proposal-weakrefs\n// Licensed under ECMA's MIT-style license\x2C see:\n// https://github.com/tc39/ecma262/blob/HEAD/LICENSE.md\nclass IterableWeakMap {\n  #weakMap = new SafeWeakMap();\n  #refSet = new SafeSet();\n  #finalizationGroup = new SafeFinalizationRegistry(cleanup);\n\n  set(key\x2C value) {\n    const entry = this.#weakMap.get(key);\n    if (entry) {\n      // If there's already an entry for the object represented by "key"\x2C\n      // the value can be updated without creating a new WeakRef:\n      this.#weakMap.set(key\x2C { value\x2C ref: entry.ref });\n    } else {\n      const ref = new SafeWeakRef(key);\n      this.#weakMap.set(key\x2C { value\x2C ref });\n      this.#refSet.add(ref);\n      this.#finalizationGroup.register(key\x2C {\n        set: this.#refSet\x2C\n        ref\n      }\x2C ref);\n    }\n  }\n\n  get(key) {\n    return this.#weakMap.get(key)?.value;\n  }\n\n  has(key) {\n    return this.#weakMap.has(key);\n  }\n\n  delete(key) {\n    const entry = this.#weakMap.get(key);\n    if (!entry) {\n      return false;\n    }\n    this.#weakMap.delete(key);\n    this.#refSet.delete(entry.ref);\n    this.#finalizationGroup.unregister(entry.ref);\n    return true;\n  }\n\n  [SymbolIterator]() {\n    const iterator = this.#refSet[SymbolIterator]();\n\n    const next = () => {\n      const result = iterator.next();\n      if (result.done) return result;\n      const key = result.value.deref();\n      if (key == null) return next();\n      const { value } = this.#weakMap.get(key);\n      return { done: false\x2C value };\n    };\n\n    return {\n      [SymbolIterator]() { return this; }\x2C\n      next\x2C\n    };\n  }\n}\n\nfunction cleanup({ set\x2C ref }) {\n  set.delete(ref);\n}\n\nObjectFreeze(IterableWeakMap.prototype);\n\nmodule.exports = {\n  IterableWeakMap\x2C\n};\n
code-source-info,0x3172a1b23716,101,0,1958,C0O0C4O1958,,
code-creation,Function,10,22750,0x3172a1b23e76,196, node:internal/util/iterable_weak_map:1:1,0x3172a1b23690,~
code-source-info,0x3172a1b23e76,101,0,1958,C0O0C26O25C31O41C37O69C43O80C49O95C55O110C134O1392C168O1904C173O1875C177O1917C184O1938C190O1932C195O1957,,
code-creation,Function,10,22792,0x3172a1b23ff6,75,<instance_members_initializer> node:internal/util/iterable_weak_map:17:3,0x3172a1b239a0,~
code-source-info,0x3172a1b23ff6,101,399,516,C3O410C10O410C27O441C34O441C48O479C62O479C74O516,,
code-creation,Eval,10,22917,0x3172a1b24cfe,5, node:internal/modules/cjs/helpers:1:1,0x3172a1b24a48,~
script-source,102,node:internal/modules/cjs/helpers,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeSome\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_UNKNOWN_BUILTIN_MODULE\n} = require('internal/errors').codes;\nconst { NativeModule } = require('internal/bootstrap/loaders');\n\nconst { validateString } = require('internal/validators');\nconst path = require('path');\nconst { pathToFileURL\x2C fileURLToPath\x2C URL } = require('internal/url');\n\nconst { getOptionValue } = require('internal/options');\nconst userConditions = getOptionValue('--conditions');\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\n\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\n// TODO: Use this set when resolving pkg#exports conditions in loader.js.\nconst cjsConditions = new SafeSet([\n  'require'\x2C\n  'node'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nfunction loadNativeModule(filename\x2C request) {\n  const mod = NativeModule.map.get(filename);\n  if (mod?.canBeRequiredByUsers) {\n    debug('load native module %s'\x2C request);\n    // compileForPublicLoader() throws if mod.canBeRequiredByUsers is false:\n    mod.compileForPublicLoader();\n    return mod;\n  }\n}\n\n// Invoke with makeRequireFunction(module) where |module| is the Module object\n// to use as the context for the require() function.\n// Use redirects to set up a mapping from a policy and restrict dependencies\nconst urlToFileCache = new SafeMap();\nfunction makeRequireFunction(mod\x2C redirects) {\n  const Module = mod.constructor;\n\n  let require;\n  if (redirects) {\n    const id = mod.filename || mod.id;\n    const conditions = cjsConditions;\n    const { resolve\x2C reaction } = redirects;\n    require = function require(specifier) {\n      let missing = true;\n      const destination = resolve(specifier\x2C conditions);\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        if (destination.protocol === 'node:') {\n          const specifier = destination.pathname;\n          const mod = loadNativeModule(specifier\x2C href);\n          if (mod && mod.canBeRequiredByUsers) {\n            return mod.exports;\n          }\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier);\n        } else if (destination.protocol === 'file:') {\n          let filepath;\n          if (urlToFileCache.has(href)) {\n            filepath = urlToFileCache.get(href);\n          } else {\n            filepath = fileURLToPath(destination);\n            urlToFileCache.set(href\x2C filepath);\n          }\n          return mod.require(filepath);\n        }\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          id\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C ')\n        ));\n      }\n      return mod.require(specifier);\n    };\n  } else {\n    require = function require(path) {\n      return mod.require(path);\n    };\n  }\n\n  function resolve(request\x2C options) {\n    validateString(request\x2C 'request');\n    return Module._resolveFilename(request\x2C mod\x2C false\x2C options);\n  }\n\n  require.resolve = resolve;\n\n  function paths(request) {\n    validateString(request\x2C 'request');\n    return Module._resolveLookupPaths(request\x2C mod);\n  }\n\n  resolve.paths = paths;\n\n  require.main = process.mainModule;\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF\x2C the UTF-16 BOM.\n */\nfunction stripBOM(content) {\n  if (StringPrototypeCharCodeAt(content) === 0xFEFF) {\n    content = StringPrototypeSlice(content\x2C 1);\n  }\n  return content;\n}\n\nfunction addBuiltinLibsToObject(object\x2C dummyModuleName) {\n  // Make built-in modules available directly (loaded lazily).\n  const Module = require('internal/modules/cjs/loader').Module;\n  const { builtinModules } = Module;\n\n  // To require built-in modules in user-land and ignore modules whose\n  // `canBeRequiredByUsers` is false. So we create a dummy module object and not\n  // use `require()` directly.\n  const dummyModule = new Module(dummyModuleName);\n\n  ArrayPrototypeForEach(builtinModules\x2C (name) => {\n    // Neither add underscored modules\x2C nor ones that contain slashes (e.g.\x2C\n    // 'fs/promises') or ones that are already defined.\n    if (StringPrototypeStartsWith(name\x2C '_') ||\n        StringPrototypeIncludes(name\x2C '/') ||\n        ObjectPrototypeHasOwnProperty(object\x2C name)) {\n      return;\n    }\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    ObjectDefineProperty(object\x2C name\x2C {\n      get: () => {\n        const lib = dummyModule.require(name);\n\n        // Disable the current getter/setter and set up a new\n        // non-enumerable property.\n        delete object[name];\n        ObjectDefineProperty(object\x2C name\x2C {\n          get: () => lib\x2C\n          set: setReal\x2C\n          configurable: true\x2C\n          enumerable: false\n        });\n\n        return lib;\n      }\x2C\n      set: setReal\x2C\n      configurable: true\x2C\n      enumerable: false\n    });\n  });\n}\n\n/**\n *\n * @param {string | URL} referrer\n * @returns {string}\n */\nfunction normalizeReferrerURL(referrer) {\n  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n    return pathToFileURL(referrer).href;\n  }\n  return new URL(referrer).href;\n}\n\n// For error messages only - used to check if ESM syntax is in use.\nfunction hasEsmSyntax(code) {\n  debug('Checking for ESM syntax');\n  const parser = require('internal/deps/acorn/acorn/dist/acorn').Parser;\n  let root;\n  try {\n    root = parser.parse(code\x2C { sourceType: 'module'\x2C ecmaVersion: 'latest' });\n  } catch {\n    return false;\n  }\n\n  return ArrayPrototypeSome(root.body\x2C (stmt) =>\n    stmt.type === 'ExportDefaultDeclaration' ||\n    stmt.type === 'ExportNamedDeclaration' ||\n    stmt.type === 'ImportDeclaration' ||\n    stmt.type === 'ExportAllDeclaration');\n}\n\nmodule.exports = {\n  addBuiltinLibsToObject\x2C\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n};\n
code-source-info,0x3172a1b24cfe,102,0,6812,C0O0C4O6812,,
code-creation,Function,10,23167,0x3172a1b2527e,536, node:internal/modules/cjs/helpers:1:1,0x3172a1b24c78,~
code-source-info,0x3172a1b2527e,102,0,6812,C0O0C104O25C110O50C116O72C122O94C128O118C134O151C139O162C144O173C150O202C156O229C162O253C168O373C174O373C179O399C184O307C190O342C196O432C202O432C207O415C213O499C219O499C224O480C230O544C236O544C240O544C242O607C248O607C253O569C259O584C265O599C271O660C277O660C282O641C287O712C290O712C295O757C301O757C306O790C319O791C325O757C327O856C330O856C335O911C346O1041C353O1083C354O1083C410O1105C465O1041C470O1041C472O1665C474O1665C479O1665C481O6652C488O6673C494O6699C500O6716C506O6732C512O6752C518O6775C524O6799C530O6667C535O6811,,
tick,0x1bfd70c28,23250,1,0x10041f4d8,3,0x0,0x3172a1b06a74,0x3172a1b05d65,0x3172a1b224e5,0x3172a1b06a95,0x3172a1b05d65,0x3172a1b2134c,0x3172a1b0b464,0x3172a1b05aed
code-creation,LazyCompile,10,23250,0x3172a1b25ee6,27,SafeSet node:internal/per_context/primordials:373:16,0x2b48e0c4a088,~
script-source,6,node:internal/per_context/primordials,'use strict';\n\n/* eslint-disable node-core/prefer-primordials */\n\n// This file subclasses and stores the JS builtins that come from the VM\n// so that Node.js's builtin modules do not need to later look these up from\n// the global proxy\x2C which can be mutated by users.\n\n// Use of primordials have sometimes a dramatic impact on performance\x2C please\n// benchmark all changes made in performance-sensitive areas of the codebase.\n// See: https://github.com/nodejs/node/pull/38248\n\nconst {\n  defineProperty: ReflectDefineProperty\x2C\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor\x2C\n  ownKeys: ReflectOwnKeys\x2C\n} = Reflect;\n\n// `uncurryThis` is equivalent to `func => Function.prototype.call.bind(func)`.\n// It is using `bind.bind(call)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.call` after it may have been mutated by users.\nconst { apply\x2C bind\x2C call } = Function.prototype;\nconst uncurryThis = bind.bind(call);\nprimordials.uncurryThis = uncurryThis;\n\n// `applyBind` is equivalent to `func => Function.prototype.apply.bind(func)`.\n// It is using `bind.bind(apply)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.apply` after it may have been mutated by users.\nconst applyBind = bind.bind(apply);\nprimordials.applyBind = applyBind;\n\n// Methods that accept a variable number of arguments\x2C and thus it's useful to\n// also create `${prefix}${key}Apply`\x2C which uses `Function.prototype.apply`\x2C\n// instead of `Function.prototype.call`\x2C and thus doesn't require iterator\n// destructuring.\nconst varargsMethods = [\n  // 'ArrayPrototypeConcat' is omitted\x2C because it performs the spread\n  // on its own for arrays and array-likes with a truthy\n  // @@isConcatSpreadable symbol property.\n  'ArrayOf'\x2C\n  'ArrayPrototypePush'\x2C\n  'ArrayPrototypeUnshift'\x2C\n  // 'FunctionPrototypeCall' is omitted\x2C since there's 'ReflectApply'\n  // and 'FunctionPrototypeApply'.\n  'MathHypot'\x2C\n  'MathMax'\x2C\n  'MathMin'\x2C\n  'StringPrototypeConcat'\x2C\n  'TypedArrayOf'\x2C\n];\n\nfunction getNewKey(key) {\n  return typeof key === 'symbol' ?\n    `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` :\n    `${key[0].toUpperCase()}${key.slice(1)}`;\n}\n\nfunction copyAccessor(dest\x2C prefix\x2C key\x2C { enumerable\x2C get\x2C set }) {\n  ReflectDefineProperty(dest\x2C `${prefix}Get${key}`\x2C {\n    value: uncurryThis(get)\x2C\n    enumerable\n  });\n  if (set !== undefined) {\n    ReflectDefineProperty(dest\x2C `${prefix}Set${key}`\x2C {\n      value: uncurryThis(set)\x2C\n      enumerable\n    });\n  }\n}\n\nfunction copyPropsRenamed(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          // `src` is bound as the `this` so that the static `this` points\n          // to the object it was defined on\x2C\n          // e.g.: `ArrayOfApply` gets a `this` of `Array`:\n          value: applyBind(desc.value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPropsRenamedBound(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = value.bind(src);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          value: applyBind(value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPrototype(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = uncurryThis(value);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          value: applyBind(value)\x2C\n        });\n      }\n    }\n  }\n}\n\n// Create copies of configurable value properties of the global object\n[\n  'Proxy'\x2C\n  'globalThis'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  primordials[name] = globalThis[name];\n});\n\n// Create copies of URI handling functions\n[\n  decodeURI\x2C\n  decodeURIComponent\x2C\n  encodeURI\x2C\n  encodeURIComponent\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of legacy functions\n[\n  escape\x2C\n  eval\x2C\n  unescape\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of the namespace objects\n[\n  'JSON'\x2C\n  'Math'\x2C\n  'Proxy'\x2C\n  'Reflect'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  copyPropsRenamed(globalThis[name]\x2C primordials\x2C name);\n});\n\n// Create copies of intrinsic objects\n[\n  'AggregateError'\x2C\n  'Array'\x2C\n  'ArrayBuffer'\x2C\n  'BigInt'\x2C\n  'BigInt64Array'\x2C\n  'BigUint64Array'\x2C\n  'Boolean'\x2C\n  'DataView'\x2C\n  'Date'\x2C\n  'Error'\x2C\n  'EvalError'\x2C\n  'FinalizationRegistry'\x2C\n  'Float32Array'\x2C\n  'Float64Array'\x2C\n  'Function'\x2C\n  'Int16Array'\x2C\n  'Int32Array'\x2C\n  'Int8Array'\x2C\n  'Map'\x2C\n  'Number'\x2C\n  'Object'\x2C\n  'RangeError'\x2C\n  'ReferenceError'\x2C\n  'RegExp'\x2C\n  'Set'\x2C\n  'String'\x2C\n  'Symbol'\x2C\n  'SyntaxError'\x2C\n  'TypeError'\x2C\n  'URIError'\x2C\n  'Uint16Array'\x2C\n  'Uint32Array'\x2C\n  'Uint8Array'\x2C\n  'Uint8ClampedArray'\x2C\n  'WeakMap'\x2C\n  'WeakRef'\x2C\n  'WeakSet'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = globalThis[name];\n  primordials[name] = original;\n  copyPropsRenamed(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of intrinsic objects that require a valid `this` to call\n// static methods.\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\n[\n  'Promise'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = globalThis[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of abstract intrinsic objects that are not directly exposed\n// on the global object.\n// Refs: https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object\n[\n  { name: 'TypedArray'\x2C original: Reflect.getPrototypeOf(Uint8Array) }\x2C\n  { name: 'ArrayIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n  { name: 'StringIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n].forEach(({ name\x2C original }) => {\n  primordials[name] = original;\n  // The static %TypedArray% methods require a valid `this`\x2C but can't be bound\x2C\n  // as they need a subclass constructor as the receiver:\n  copyPrototype(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n/* eslint-enable node-core/prefer-primordials */\n\nconst {\n  ArrayPrototypeForEach\x2C\n  FinalizationRegistry\x2C\n  FunctionPrototypeCall\x2C\n  Map\x2C\n  ObjectFreeze\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  Set\x2C\n  SymbolIterator\x2C\n  WeakMap\x2C\n  WeakRef\x2C\n  WeakSet\x2C\n} = primordials;\n\n// Because these functions are used by `makeSafe`\x2C which is exposed\n// on the `primordials` object\x2C it's important to use const references\n// to the primordials that they use:\nconst createSafeIterator = (factory\x2C next) => {\n  class SafeIterator {\n    constructor(iterable) {\n      this._iterator = factory(iterable);\n    }\n    next() {\n      return next(this._iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype\x2C null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nprimordials.SafeArrayIterator = createSafeIterator(\n  primordials.ArrayPrototypeSymbolIterator\x2C\n  primordials.ArrayIteratorPrototypeNext\n);\nprimordials.SafeStringIterator = createSafeIterator(\n  primordials.StringPrototypeSymbolIterator\x2C\n  primordials.StringIteratorPrototypeNext\n);\n\nconst copyProps = (src\x2C dest) => {\n  ArrayPrototypeForEach(ReflectOwnKeys(src)\x2C (key) => {\n    if (!ReflectGetOwnPropertyDescriptor(dest\x2C key)) {\n      ReflectDefineProperty(\n        dest\x2C\n        key\x2C\n        ReflectGetOwnPropertyDescriptor(src\x2C key));\n    }\n  });\n};\n\n/**\n * @type {typeof primordials.makeSafe}\n */\nconst makeSafe = (unsafe\x2C safe) => {\n  if (SymbolIterator in unsafe.prototype) {\n    const dummy = new unsafe();\n    let next; // We can reuse the same `next` method.\n\n    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype)\x2C (key) => {\n      if (!ReflectGetOwnPropertyDescriptor(safe.prototype\x2C key)) {\n        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype\x2C key);\n        if (\n          typeof desc.value === 'function' &&\n          desc.value.length === 0 &&\n          SymbolIterator in (FunctionPrototypeCall(desc.value\x2C dummy) ?? {})\n        ) {\n          const createIterator = uncurryThis(desc.value);\n          next ??= uncurryThis(createIterator(dummy).next);\n          const SafeIterator = createSafeIterator(createIterator\x2C next);\n          desc.value = function() {\n            return new SafeIterator(this);\n          };\n        }\n        ReflectDefineProperty(safe.prototype\x2C key\x2C desc);\n      }\n    });\n  } else {\n    copyProps(unsafe.prototype\x2C safe.prototype);\n  }\n  copyProps(unsafe\x2C safe);\n\n  ObjectSetPrototypeOf(safe.prototype\x2C null);\n  ObjectFreeze(safe.prototype);\n  ObjectFreeze(safe);\n  return safe;\n};\nprimordials.makeSafe = makeSafe;\n\n// Subclass the constructors because we need to use their prototype\n// methods later.\n// Defining the `constructor` is necessary here to avoid the default\n// constructor which uses the user-mutable `%ArrayIteratorPrototype%.next`.\nprimordials.SafeMap = makeSafe(\n  Map\x2C\n  class SafeMap extends Map {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakMap = makeSafe(\n  WeakMap\x2C\n  class SafeWeakMap extends WeakMap {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeSet = makeSafe(\n  Set\x2C\n  class SafeSet extends Set {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakSet = makeSafe(\n  WeakSet\x2C\n  class SafeWeakSet extends WeakSet {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeFinalizationRegistry = makeSafe(\n  FinalizationRegistry\x2C\n  class SafeFinalizationRegistry extends FinalizationRegistry {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(cleanupCallback) { super(cleanupCallback); }\n  }\n);\nprimordials.SafeWeakRef = makeSafe(\n  WeakRef\x2C\n  class SafeWeakRef extends WeakRef {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(target) { super(target); }\n  }\n);\n\nconst SafePromise = makeSafe(\n  Promise\x2C\n  class SafePromise extends Promise {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(executor) { super(executor); }\n  }\n);\n\nprimordials.PromisePrototypeCatch = (thisPromise\x2C onRejected) =>\n  PromisePrototypeThen(thisPromise\x2C undefined\x2C onRejected);\n\n/**\n * Attaches a callback that is invoked when the Promise is settled (fulfilled or\n * rejected). The resolved value cannot be modified from the callback.\n * Prefer using async functions when possible.\n * @param {Promise<any>} thisPromise\n * @param {() => void) | undefined | null} onFinally The callback to execute\n *        when the Promise is settled (fulfilled or rejected).\n * @returns {Promise} A Promise for the completion of the callback.\n */\nprimordials.SafePromisePrototypeFinally = (thisPromise\x2C onFinally) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    new SafePromise((a\x2C b) => PromisePrototypeThen(thisPromise\x2C a\x2C b))\n      .finally(onFinally)\n      .then(a\x2C b)\n  );\n\nprimordials.AsyncIteratorPrototype =\n  primordials.ReflectGetPrototypeOf(\n    primordials.ReflectGetPrototypeOf(\n      async function* () {}).prototype);\n\nObjectSetPrototypeOf(primordials\x2C null);\nObjectFreeze(primordials);\n
code-source-info,0x3172a1b25ee6,6,10662,10679,C3O10668C7O10674C11O10668C26O10678,,
code-creation,LazyCompile,10,23750,0x3172a1b26d6e,27,SafeMap node:internal/per_context/primordials:360:16,0x2b48e0c49f00,~
code-source-info,0x3172a1b26d6e,6,10335,10352,C3O10341C7O10347C11O10341C26O10351,,
code-creation,LazyCompile,10,23750,0x3172a1b26e66,16,IterableWeakMap node:internal/util/iterable_weak_map:16:1,0x3172a1b23798,~
code-source-info,0x3172a1b26e66,101,373,373,C0O373C15O373,,
code-creation,LazyCompile,10,23792,0x3172a1b271ee,27,SafeWeakMap node:internal/per_context/primordials:366:16,0x2b48e0c49fc0,~
code-source-info,0x3172a1b271ee,6,10506,10523,C3O10512C7O10518C11O10512C26O10522,,
code-creation,LazyCompile,10,23792,0x3172a1b272f6,27,SafeFinalizationRegistry node:internal/per_context/primordials:387:16,0x2b48e0c4a210,~
code-source-info,0x3172a1b272f6,6,11112,11157,C3O11132C7O11138C11O11132C26O11156,,
code-creation,LazyCompile,10,23834,0x3172a1b27bd6,492,initializeDeprecations node:internal/bootstrap/pre_execution:330:32,0x3172a1b07f60,~
code-source-info,0x3172a1b27bd6,96,10080,12579,C0O10080C11O10109C19O10109C24O10095C29O10164C39O10164C44O10355C52O10355C57O10396C65O10396C70O10449C99O10441C127O10441C130O10767C141O10787C145O10829C156O10903C167O10993C178O10948C187O10814C196O11052C199O10785C203O10430C269O11329C277O11329C282O11308C287O11358C289O11386C304O11407C311O11525C315O11386C320O11557C324O11587C334O11623C344O11700C351O11605C356O11603C360O11786C370O11828C381O11810C386O11808C390O12167C394O12167C396O12178C407O12199C418O12228C426O12270C434O12178C439O12383C445O12383C447O12393C458O12414C469O12442C477O12483C485O12393C491O12578,,
new,MemoryChunk,0x105100000,262144
code-creation,Function,11,23917,0x105108060,512,getCLIOptionsFromBinding node:internal/options:18:34,0x3172a1b0a328,^
code-source-info,0x105108060,97,497,598,,,
code-creation,Function,11,23917,0x1051082c0,152,isPosixPathSeparator node:path:56:30,0x815de63a780,^
code-source-info,0x1051082c0,41,1854,1902,,,
code-creation,Function,11,23959,0x1051083c0,664,getOptionValue node:internal/options:39:24,0x3172a1b0a418,^
code-source-info,0x1051083c0,97,902,1145,,,
code-creation,Function,11,23959,0x1051086c0,768,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x2b48e0c4fda8,^
code-source-info,0x1051086c0,9,10316,10659,,,
code-creation,Function,11,24000,0x105108a20,1448,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x2b48e0c4fcd8,^
code-source-info,0x105108a20,9,9529,10090,,,
code-creation,LazyCompile,10,24042,0x3172a1b28396,53,initializeWASI node:internal/bootstrap/pre_execution:494:24,0x3172a1b080e0,~
code-source-info,0x3172a1b28396,96,15268,15474,C0O15300C6O15300C11O15283C16O15366C21O15370C29O15370C35O15385C37O15416C43O15416C47O15410C52O15473,,
code-creation,LazyCompile,10,24042,0x3172a1b28596,66,initializeCJSLoader node:internal/bootstrap/pre_execution:501:29,0x3172a1b08130,~
code-source-info,0x3172a1b28596,96,15504,15819,C0O15529C6O15529C11O15571C16O15576C20O15596C26O15634C31O15641C36O15641C40O15737C51O15758C56O15794C60O15752C65O15818,,
tick,0x100569e40,24334,1,0x10041f4d8,2,0x0,0x105108c5c,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,Eval,10,24542,0x3172a1b2a55e,5, node:internal/modules/cjs/loader:1:1,0x3172a1b29c78,~
script-source,103,node:internal/modules/cjs/loader,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  ArrayPrototypeUnshiftApply\x2C\n  Boolean\x2C\n  Error\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototype\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Proxy\x2C\n  ReflectApply\x2C\n  ReflectSet\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\n// Map used to store CJS parsing data.\nconst cjsParseCache = new SafeWeakMap();\n\n// Set first due to cycle with ESM loader functions.\nmodule.exports = {\n  wrapSafe\x2C Module\x2C toRealPath\x2C readPackageScope\x2C cjsParseCache\x2C\n  get hasLoadedAnyUserCJSModule() { return hasLoadedAnyUserCJSModule; }\n};\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  maybeCacheSourceMap\x2C\n} = require('internal/source_map/source_map_cache');\nconst { pathToFileURL\x2C fileURLToPath\x2C isURLInstance } = require('internal/url');\nconst { deprecate } = require('internal/util');\nconst vm = require('vm');\nconst assert = require('internal/assert');\nconst fs = require('fs');\nconst internalFS = require('internal/fs/utils');\nconst path = require('path');\nconst { sep } = path;\nconst { internalModuleStat } = internalBinding('fs');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { safeGetenv } = internalBinding('credentials');\nconst {\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst { getOptionValue } = require('internal/options');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\n// Whether any user-provided CJS modules had been loaded (executed).\n// Used for internal assertions.\nlet hasLoadedAnyUserCJSModule = false;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_MODULE_SPECIFIER\x2C\n    ERR_REQUIRE_ESM\x2C\n    ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  }\x2C\n  setArrowMessage\x2C\n} = require('internal/errors');\nconst { validateString } = require('internal/validators');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\n} = require('internal/constants');\n\nconst {\n  isProxy\n} = require('internal/util/types');\n\nconst asyncESM = require('internal/process/esm_loader');\nconst { enrichCJSError } = require('internal/modules/esm/translators');\nconst { kEvaluated } = internalBinding('module_wrap');\nconst {\n  encodedSepRegEx\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\n} = require('internal/modules/esm/resolve');\n\nconst isWindows = process.platform === 'win32';\n\nconst relativeResolveCache = ObjectCreate(null);\n\nlet requireDepth = 0;\nlet statCache = null;\nlet isPreloading = false;\n\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename\x2C result);\n  }\n  return result;\n}\n\nfunction updateChildren(parent\x2C child\x2C scan) {\n  const children = parent?.children;\n  if (children && !(scan && ArrayPrototypeIncludes(children\x2C child)))\n    ArrayPrototypePush(children\x2C child);\n}\n\nconst moduleParentCache = new SafeWeakMap();\nfunction Module(id = ''\x2C parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  this.exports = {};\n  moduleParentCache.set(this\x2C parent);\n  updateChildren(parent\x2C this\x2C false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n\nconst builtinModules = [];\nfor (const { 0: id\x2C 1: mod } of NativeModule.map) {\n  if (mod.canBeRequiredByUsers) {\n    ArrayPrototypePush(builtinModules\x2C id);\n  }\n}\n\nObjectFreeze(builtinModules);\nModule.builtinModules = builtinModules;\n\nModule._cache = ObjectCreate(null);\nModule._pathCache = ObjectCreate(null);\nModule._extensions = ObjectCreate(null);\nlet modulePaths = [];\nModule.globalPaths = [];\n\nlet patched = false;\n\n// eslint-disable-next-line func-style\nlet wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\nconst wrapper = [\n  '(function (exports\x2C require\x2C module\x2C __filename\x2C __dirname) { '\x2C\n  '\\n});'\x2C\n];\n\nlet wrapperProxy = new Proxy(wrapper\x2C {\n  set(target\x2C property\x2C value\x2C receiver) {\n    patched = true;\n    return ReflectSet(target\x2C property\x2C value\x2C receiver);\n  }\x2C\n\n  defineProperty(target\x2C property\x2C descriptor) {\n    patched = true;\n    return ObjectDefineProperty(target\x2C property\x2C descriptor);\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrap'\x2C {\n  get() {\n    return wrap;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrap = value;\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrapper'\x2C {\n  get() {\n    return wrapperProxy;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrapperProxy = value;\n  }\n});\n\nconst isPreloadingDesc = { get() { return isPreloading; } };\nObjectDefineProperty(Module.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\nObjectDefineProperty(NativeModule.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\n\nfunction getModuleParent() {\n  return moduleParentCache.get(this);\n}\n\nfunction setModuleParent(value) {\n  moduleParentCache.set(this\x2C value);\n}\n\nObjectDefineProperty(Module.prototype\x2C 'parent'\x2C {\n  get: pendingDeprecation ? deprecate(\n    getModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : getModuleParent\x2C\n  set: pendingDeprecation ? deprecate(\n    setModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : setModuleParent\x2C\n});\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\nModule._debug = deprecate(debug\x2C 'Module._debug is deprecated.'\x2C 'DEP0077');\n\n// Given a module name\x2C and a list of paths to test\x2C returns the first\n// matching file in the following precedence.\n//\n// require("a.<ext>")\n//   -> a.<ext>\n//\n// require("a")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nconst packageJsonCache = new SafeMap();\n\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath\x2C 'package.json');\n\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== undefined) return existing;\n\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? '{}' : result.string;\n  if (json === undefined) {\n    packageJsonCache.set(jsonPath\x2C false);\n    return false;\n  }\n\n  try {\n    const parsed = JSONParse(json);\n    const filtered = {\n      name: parsed.name\x2C\n      main: parsed.main\x2C\n      exports: parsed.exports\x2C\n      imports: parsed.imports\x2C\n      type: parsed.type\n    };\n    packageJsonCache.set(jsonPath\x2C filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n}\n\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath\x2C sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath\x2C sep);\n    checkPath = StringPrototypeSlice(checkPath\x2C 0\x2C separatorIndex);\n    if (StringPrototypeEndsWith(checkPath\x2C sep + 'node_modules'))\n      return false;\n    const pjson = readPackage(checkPath + sep);\n    if (pjson) return {\n      data: pjson\x2C\n      path: checkPath\x2C\n    };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\nfunction tryPackage(requestPath\x2C exts\x2C isMain\x2C originalPath) {\n  const pkg = readPackage(requestPath)?.main;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n  }\n\n  const filename = path.resolve(requestPath\x2C pkg);\n  let actual = tryFile(filename\x2C isMain) ||\n    tryExtensions(filename\x2C exts\x2C isMain) ||\n    tryExtensions(path.resolve(filename\x2C 'index')\x2C exts\x2C isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid "main" entry'\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath\x2C 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath\x2C 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author'\x2C\n        'DeprecationWarning'\x2C\n        'DEP0128'\n      );\n    }\n  }\n  return actual;\n}\n\n// In order to minimize unnecessary lstat() calls\x2C\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new SafeMap();\n\n// Check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false\x2C\n// keep symlinks intact\x2C otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath\x2C isMain) {\n  const rc = stat(requestPath);\n  if (rc !== 0) return;\n  if (preserveSymlinks && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath\x2C {\n    [internalFS.realpathCacheKey]: realpathCache\n  });\n}\n\n// Given a path\x2C check if the file exists with any of the set extensions\nfunction tryExtensions(p\x2C exts\x2C isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i]\x2C isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\n// Find the longest (possibly multi-dot) extension registered in\n// Module._extensions\nfunction findLongestRegisteredExtension(filename) {\n  const name = path.basename(filename);\n  let currentExtension;\n  let index;\n  let startIndex = 0;\n  while ((index = StringPrototypeIndexOf(name\x2C '.'\x2C startIndex)) !== -1) {\n    startIndex = index + 1;\n    if (index === 0) continue; // Skip dotfiles like .gitignore\n    currentExtension = StringPrototypeSlice(name\x2C index);\n    if (Module._extensions[currentExtension]) return currentExtension;\n  }\n  return '.js';\n}\n\nfunction trySelfParentPath(parent) {\n  if (!parent) return false;\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\nfunction trySelf(parentPath\x2C request) {\n  if (!parentPath) return false;\n\n  const { data: pkg\x2C path: pkgPath } = readPackageScope(parentPath) || {};\n  if (!pkg || pkg.exports === undefined) return false;\n  if (typeof pkg.name !== 'string') return false;\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request\x2C `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request\x2C pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json')\x2C expansion\x2C pkg\x2C\n      pathToFileURL(parentPath)\x2C cjsConditions)\x2C parentPath\x2C pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND')\n      throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n    throw e;\n  }\n}\n\n// This only applies to requests of a specific form:\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\nfunction resolveExports(nmPath\x2C request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const { 1: name\x2C 2: expansion = '' } =\n    StringPrototypeMatch(request\x2C EXPORTS_PATTERN) || [];\n  if (!name)\n    return;\n  const pkgPath = path.resolve(nmPath\x2C name);\n  const pkg = readPackage(pkgPath);\n  if (pkg?.exports != null) {\n    try {\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json')\x2C '.' + expansion\x2C pkg\x2C null\x2C\n        cjsConditions)\x2C null\x2C pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND')\n        throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n      throw e;\n    }\n  }\n}\n\nconst trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\nModule._findPath = function(request\x2C paths\x2C isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths\x2C '\\x00');\n  const entry = Module._pathCache[cacheKey];\n  if (entry)\n    return entry;\n\n  let exts;\n  let trailingSlash = request.length > 0 &&\n    StringPrototypeCharCodeAt(request\x2C request.length - 1) ===\n    CHAR_FORWARD_SLASH;\n  if (!trailingSlash) {\n    trailingSlash = RegExpPrototypeTest(trailingSlashRegex\x2C request);\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1) continue;\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath\x2C request);\n      if (exportsResolved)\n        return exportsResolved;\n    }\n\n    const basePath = path.resolve(curPath\x2C request);\n    let filename;\n\n    const rc = stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (preserveSymlinks) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (preserveSymlinksMain) {\n          // For the main module\x2C we use the preserveSymlinksMain flag instead\n          // mainly for backward compatibility\x2C as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working\x2C as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said\x2C in some use cases following symlinks\n          // causes bigger problems which is why the preserveSymlinksMain option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined)\n          exts = ObjectKeys(Module._extensions);\n        filename = tryExtensions(basePath\x2C exts\x2C isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at "index"\n      if (exts === undefined)\n        exts = ObjectKeys(Module._extensions);\n      filename = tryPackage(basePath\x2C exts\x2C isMain\x2C request);\n    }\n\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n  }\n\n  return false;\n};\n\n// 'node_modules' character codes reversed\nconst nmChars = [ 115\x2C 101\x2C 108\x2C 117\x2C 100\x2C 111\x2C 109\x2C 95\x2C 101\x2C 100\x2C 111\x2C 110 ];\nconst nmLen = nmChars.length;\nif (isWindows) {\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (StringPrototypeCharCodeAt(from\x2C from.length - 1) ===\n          CHAR_BACKWARD_SLASH &&\n        StringPrototypeCharCodeAt(from\x2C from.length - 2) === CHAR_COLON)\n      return [from + 'node_modules'];\n\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === CHAR_BACKWARD_SLASH ||\n          code === CHAR_FORWARD_SLASH ||\n          code === CHAR_COLON) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '\\\\node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work\x2C but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules'\x2C '/node_modules' ]\n    if (from === '/')\n      return ['/node_modules'];\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '/node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    ArrayPrototypePush(paths\x2C '/node_modules');\n\n    return paths;\n  };\n}\n\nModule._resolveLookupPaths = function(request\x2C parent) {\n  if (NativeModule.canBeRequiredByUsers(request)) {\n    debug('looking for %j in []'\x2C request);\n    return null;\n  }\n\n  // Check for node modules paths.\n  if (StringPrototypeCharAt(request\x2C 0) !== '.' ||\n      (request.length > 1 &&\n      StringPrototypeCharAt(request\x2C 1) !== '.' &&\n      StringPrototypeCharAt(request\x2C 1) !== '/' &&\n      (!isWindows || StringPrototypeCharAt(request\x2C 1) !== '\\\\'))) {\n\n    let paths = modulePaths;\n    if (parent?.paths?.length) {\n      paths = ArrayPrototypeConcat(parent.paths\x2C paths);\n    }\n\n    debug('looking for %j in %j'\x2C request\x2C paths);\n    return paths.length > 0 ? paths : null;\n  }\n\n  // In REPL\x2C parent.filename is null.\n  if (!parent || !parent.id || !parent.filename) {\n    // Make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but in REPL there is no filename\n    const mainPaths = ['.'];\n\n    debug('looking for %j in %j'\x2C request\x2C mainPaths);\n    return mainPaths;\n  }\n\n  debug('RELATIVE: requested: %s from parent.id %s'\x2C request\x2C parent.id);\n\n  const parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j'\x2C parentDir);\n  return parentDir;\n};\n\nfunction emitCircularRequireWarning(prop) {\n  process.emitWarning(\n    `Accessing non-existent property '${String(prop)}' of module exports ` +\n    'inside circular dependency'\n  );\n}\n\n// A Proxy that can be used as the prototype of a module.exports object and\n// warns when non-existent properties are accessed.\nconst CircularRequirePrototypeWarningProxy = new Proxy({}\x2C {\n  get(target\x2C prop) {\n    // Allow __esModule access in any case because it is used in the output\n    // of transpiled code to determine whether something comes from an\n    // ES module\x2C and is not used as a regular key of `module.exports`.\n    if (prop in target || prop === '__esModule') return target[prop];\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n\n  getOwnPropertyDescriptor(target\x2C prop) {\n    if (ObjectPrototypeHasOwnProperty(target\x2C prop) || prop === '__esModule')\n      return ObjectGetOwnPropertyDescriptor(target\x2C prop);\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\n});\n\nfunction getExportsForCircularRequire(module) {\n  if (module.exports &&\n      !isProxy(module.exports) &&\n      ObjectGetPrototypeOf(module.exports) === ObjectPrototype &&\n      // Exclude transpiled ES6 modules / TypeScript code because those may\n      // employ unusual patterns for accessing 'module.exports'. That should\n      // be okay because ES6 modules have a different approach to circular\n      // dependencies anyway.\n      !module.exports.__esModule) {\n    // This is later unset once the module is done loading.\n    ObjectSetPrototypeOf(\n      module.exports\x2C CircularRequirePrototypeWarningProxy);\n  }\n\n  return module.exports;\n}\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call\n//    `NativeModule.prototype.compileForPublicLoader()` and return the exports.\n// 3. Otherwise\x2C create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request\x2C parent\x2C isMain) {\n  let relResolveCacheIdentifier;\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s'\x2C request\x2C parent.id);\n    // Fast path for (lazy loaded) modules in the same directory. The indirect\n    // caching is required to allow cache invalidation without changing the old\n    // cache key names.\n    relResolveCacheIdentifier = `${parent.path}\\x00${request}`;\n    const filename = relativeResolveCache[relResolveCacheIdentifier];\n    if (filename !== undefined) {\n      const cachedModule = Module._cache[filename];\n      if (cachedModule !== undefined) {\n        updateChildren(parent\x2C cachedModule\x2C true);\n        if (!cachedModule.loaded)\n          return getExportsForCircularRequire(cachedModule);\n        return cachedModule.exports;\n      }\n      delete relativeResolveCache[relResolveCacheIdentifier];\n    }\n  }\n\n  const filename = Module._resolveFilename(request\x2C parent\x2C isMain);\n  if (StringPrototypeStartsWith(filename\x2C 'node:')) {\n    // Slice 'node:' prefix\n    const id = StringPrototypeSlice(filename\x2C 5);\n\n    const module = loadNativeModule(id\x2C request);\n    if (!module?.canBeRequiredByUsers) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(filename);\n    }\n\n    return module.exports;\n  }\n\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== undefined) {\n    updateChildren(parent\x2C cachedModule\x2C true);\n    if (!cachedModule.loaded) {\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      if (!parseCachedModule || parseCachedModule.loaded)\n        return getExportsForCircularRequire(cachedModule);\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n\n  const mod = loadNativeModule(filename\x2C request);\n  if (mod?.canBeRequiredByUsers) return mod.exports;\n\n  // Don't call updateChildren()\x2C Module constructor already does.\n  const module = cachedModule || new Module(filename\x2C parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n  if (parent !== undefined) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n\n  let threw = true;\n  try {\n    module.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n      if (parent !== undefined) {\n        delete relativeResolveCache[relResolveCacheIdentifier];\n        const children = parent?.children;\n        if (ArrayIsArray(children)) {\n          const index = ArrayPrototypeIndexOf(children\x2C module);\n          if (index !== -1) {\n            ArrayPrototypeSplice(children\x2C index\x2C 1);\n          }\n        }\n      }\n    } else if (module.exports &&\n               !isProxy(module.exports) &&\n               ObjectGetPrototypeOf(module.exports) ===\n                 CircularRequirePrototypeWarningProxy) {\n      ObjectSetPrototypeOf(module.exports\x2C ObjectPrototype);\n    }\n  }\n\n  return module.exports;\n};\n\nModule._resolveFilename = function(request\x2C parent\x2C isMain\x2C options) {\n  if (StringPrototypeStartsWith(request\x2C 'node:') ||\n      NativeModule.canBeRequiredByUsers(request)) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request\x2C './') ||\n          StringPrototypeStartsWith(request\x2C '../') ||\n          ((isWindows && StringPrototypeStartsWith(request\x2C '.\\\\')) ||\n          StringPrototypeStartsWith(request\x2C '..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module(''\x2C null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request\x2C fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths\x2C lookupPaths[j]))\n              ArrayPrototypePush(paths\x2C lookupPaths[j]);\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request\x2C parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE('options.paths'\x2C options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request\x2C parent);\n  }\n\n  if (parent?.filename) {\n    if (request[0] === '#') {\n      const pkg = readPackageScope(parent.filename) || {};\n      if (pkg.data?.imports != null) {\n        try {\n          return finalizeEsmResolution(\n            packageImportsResolve(request\x2C pathToFileURL(parent.filename)\x2C\n                                  cjsConditions)\x2C parent.filename\x2C\n            pkg.path);\n        } catch (e) {\n          if (e.code === 'ERR_MODULE_NOT_FOUND')\n            throw createEsmNotFoundErr(request);\n          throw e;\n        }\n      }\n    }\n  }\n\n  // Try module self resolution first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath\x2C request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths\x2C '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first\x2C since that's the cache key.\n  const filename = Module._findPath(request\x2C paths\x2C isMain\x2C false);\n  if (filename) return filename;\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack\x2C cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' +\n              ArrayPrototypeJoin(requireStack\x2C '\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\nfunction finalizeEsmResolution(resolved\x2C parentPath\x2C pkgPath) {\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved\x2C 'must not include encoded "/" or "\\\\" characters'\x2C parentPath);\n  const filename = fileURLToPath(resolved);\n  const actual = tryFile(filename);\n  if (actual)\n    return actual;\n  const err = createEsmNotFoundErr(filename\x2C\n                                   path.resolve(pkgPath\x2C 'package.json'));\n  throw err;\n}\n\nfunction createEsmNotFoundErr(request\x2C path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path)\n    err.path = path;\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n// Given a file name\x2C pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j'\x2C filename\x2C this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  const extension = findLongestRegisteredExtension(filename);\n  // allow .mjs to be overridden\n  if (StringPrototypeEndsWith(filename\x2C '.mjs') && !Module._extensions['.mjs'])\n    throw new ERR_REQUIRE_ESM(filename\x2C true);\n\n  Module._extensions[extension](this\x2C filename);\n  this.loaded = true;\n\n  const esmLoader = asyncESM.esmLoader;\n  // Create module entry at load time to snapshot exports correctly\n  const exports = this.exports;\n  // Preemptively cache\n  if ((module?.module === undefined ||\n       module.module.getStatus() < kEvaluated) &&\n      !esmLoader.cjsCache.has(this))\n    esmLoader.cjsCache.set(this\x2C exports);\n};\n\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\nModule.prototype.require = function(id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C this\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n};\n\n\n// Resolved path to process.argv[1] will be lazily placed here\n// (needed for setting breakpoint when called with --inspect-brk)\nlet resolvedArgv;\nlet hasPausedEntry = false;\n\nfunction wrapSafe(filename\x2C content\x2C cjsModuleInstance) {\n  if (patched) {\n    const wrapper = Module.wrap(content);\n    return vm.runInThisContext(wrapper\x2C {\n      filename\x2C\n      lineOffset: 0\x2C\n      displayErrors: true\x2C\n      importModuleDynamically: async (specifier\x2C _\x2C importAssertions) => {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C\n                             loader.getBaseURL(normalizeReferrerURL(filename))\x2C\n                             importAssertions);\n      }\x2C\n    });\n  }\n  try {\n    return vm.compileFunction(content\x2C [\n      'exports'\x2C\n      'require'\x2C\n      'module'\x2C\n      '__filename'\x2C\n      '__dirname'\x2C\n    ]\x2C {\n      filename\x2C\n      importModuleDynamically(specifier\x2C _\x2C importAssertions) {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C\n                             loader.getBaseURL(normalizeReferrerURL(filename))\x2C\n                             importAssertions);\n      }\x2C\n    });\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance)\n      enrichCJSError(err\x2C content);\n    throw err;\n  }\n}\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require\x2C module\x2C exports) to\n// the file.\n// Returns exception\x2C if any.\nModule.prototype._compile = function(content\x2C filename) {\n  let moduleURL;\n  let redirects;\n  if (policy?.manifest) {\n    moduleURL = pathToFileURL(filename);\n    redirects = policy.manifest.getDependencyMapper(moduleURL);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  maybeCacheSourceMap(filename\x2C content\x2C this);\n  const compiledWrapper = wrapSafe(filename\x2C content\x2C this);\n\n  let inspectorWrapper = null;\n  if (getOptionValue('--inspect-brk') && process._eval == null) {\n    if (!resolvedArgv) {\n      // We enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        try {\n          resolvedArgv = Module._resolveFilename(process.argv[1]\x2C null\x2C false);\n        } catch {\n          // We only expect this codepath to be reached in the case of a\n          // preloaded module (it will fail earlier with the main entry)\n          assert(ArrayIsArray(getOptionValue('--require')));\n        }\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\n      hasPausedEntry = true;\n      inspectorWrapper = internalBinding('inspector').callAndPauseOnStart;\n    }\n  }\n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this\x2C redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  if (requireDepth === 0) statCache = new SafeMap();\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper\x2C thisValue\x2C exports\x2C\n                              require\x2C module\x2C filename\x2C dirname);\n  } else {\n    result = ReflectApply(compiledWrapper\x2C thisValue\x2C\n                          [exports\x2C require\x2C module\x2C filename\x2C dirname]);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0) statCache = null;\n  return result;\n};\n\n// Native extension for .js\nModule._extensions['.js'] = function(module\x2C filename) {\n  // If already analyzed the source\x2C then it will be cached.\n  const cached = cjsParseCache.get(module);\n  let content;\n  if (cached?.source) {\n    content = cached.source;\n    cached.source = undefined;\n  } else {\n    content = fs.readFileSync(filename\x2C 'utf8');\n  }\n  if (StringPrototypeEndsWith(filename\x2C '.js')) {\n    const pkg = readPackageScope(filename);\n    // Function require shouldn't be used in ES modules.\n    if (pkg?.data?.type === 'module') {\n      const parent = moduleParentCache.get(module);\n      const parentPath = parent?.filename;\n      const packageJsonPath = path.resolve(pkg.path\x2C 'package.json');\n      const usesEsm = hasEsmSyntax(content);\n      const err = new ERR_REQUIRE_ESM(filename\x2C usesEsm\x2C parentPath\x2C\n                                      packageJsonPath);\n      // Attempt to reconstruct the parent require frame.\n      if (Module._cache[parentPath]) {\n        let parentSource;\n        try {\n          parentSource = fs.readFileSync(parentPath\x2C 'utf8');\n        } catch {\n          // Continue regardless of error.\n        }\n        if (parentSource) {\n          const errLine = StringPrototypeSplit(\n            StringPrototypeSlice(err.stack\x2C StringPrototypeIndexOf(\n              err.stack\x2C '    at '))\x2C '\\n'\x2C 1)[0];\n          const { 1: line\x2C 2: col } =\n              RegExpPrototypeExec(/(\\d+):(\\d+)\\)/\x2C errLine) || [];\n          if (line && col) {\n            const srcLine = StringPrototypeSplit(parentSource\x2C '\\n')[line - 1];\n            const frame = `${parentPath}:${line}\\n${srcLine}\\n${\n              StringPrototypeRepeat(' '\x2C col - 1)}^\\n`;\n            setArrowMessage(err\x2C frame);\n          }\n        }\n      }\n      throw err;\n    }\n  }\n  module._compile(content\x2C filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module\x2C filename) {\n  const content = fs.readFileSync(filename\x2C 'utf8');\n\n  if (policy?.manifest) {\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  try {\n    module.exports = JSONParse(stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n\n// Native extension for .node\nModule._extensions['.node'] = function(module\x2C filename) {\n  if (policy?.manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n  // Be aware this doesn't use `content`\n  return process.dlopen(module\x2C path.toNamespacedPath(filename));\n};\n\nfunction createRequireFromPath(filename) {\n  // Allow a directory to be passed as the filename\n  const trailingSlash =\n    StringPrototypeEndsWith(filename\x2C '/') ||\n    (isWindows && StringPrototypeEndsWith(filename\x2C '\\\\'));\n\n  const proxyPath = trailingSlash ?\n    path.join(filename\x2C 'noop.js') :\n    filename;\n\n  const m = new Module(proxyPath);\n  m.filename = proxyPath;\n\n  m.paths = Module._nodeModulePaths(m.path);\n  return makeRequireFunction(m\x2C null);\n}\n\nconst createRequireError = 'must be a file URL object\x2C file URL string\x2C or ' +\n  'absolute path string';\n\nfunction createRequire(filename) {\n  let filepath;\n\n  if (isURLInstance(filename) ||\n      (typeof filename === 'string' && !path.isAbsolute(filename))) {\n    try {\n      filepath = fileURLToPath(filename);\n    } catch {\n      throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C\n                                      createRequireError);\n    }\n  } else if (typeof filename !== 'string') {\n    throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C createRequireError);\n  } else {\n    filepath = filename;\n  }\n  return createRequireFromPath(filepath);\n}\n\nModule.createRequire = createRequire;\n\nModule._initPaths = function() {\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv('HOME');\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv('NODE_PATH');\n\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe where $PREFIX is the root of the Node.js installation.\n  const prefixDir = isWindows ?\n    path.resolve(process.execPath\x2C '..') :\n    path.resolve(process.execPath\x2C '..'\x2C '..');\n\n  const paths = [path.resolve(prefixDir\x2C 'lib'\x2C 'node')];\n\n  if (homeDir) {\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_libraries'));\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_modules'));\n  }\n\n  if (nodePath) {\n    ArrayPrototypeUnshiftApply(paths\x2C ArrayPrototypeFilter(\n      StringPrototypeSplit(nodePath\x2C path.delimiter)\x2C\n      Boolean\n    ));\n  }\n\n  modulePaths = paths;\n\n  // Clone as a shallow copy\x2C for introspection.\n  Module.globalPaths = ArrayPrototypeSlice(modulePaths);\n};\n\nModule._preloadModules = function(requests) {\n  if (!ArrayIsArray(requests))\n    return;\n\n  isPreloading = true;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  const parent = new Module('internal/preload'\x2C null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      isPreloading = false;\n      throw e;\n    }\n  }\n  for (let n = 0; n < requests.length; n++)\n    parent.require(requests[n]);\n  isPreloading = false;\n};\n\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\n  for (const mod of NativeModule.map.values()) {\n    if (mod.canBeRequiredByUsers) {\n      mod.syncExports();\n    }\n  }\n};\n\n// Backwards compatibility\nModule.Module = Module;\n
code-source-info,0x3172a1b2a55e,103,0,40215,C0O0C4O40215,,
code-creation,Function,10,26042,0x3172a1b2c2fe,2547, node:internal/modules/cjs/loader:1:1,0x3172a1b2a4d8,~
code-source-info,0x3172a1b2c2fe,103,0,40215,C0O0C446O1159C452O1175C458O1199C464O1223C470O1249C476O1274C482O1296C488O1318C494O1341C500O1365C506O1390C512O1420C518O1431C524O1440C530O1453C535O1469C541O1493C546O1509C552O1543C558O1567C564O1581C570O1600C576O1633C582O1657C587O1666C593O1682C599O1696C605O1719C611O1742C617O1753C622O1768C628O1778C634O1803C640O1832C646O1859C652O1889C658O1915C664O1939C670O1964C676O1988C682O2012C688O2118C690O2118C695O2118C697O2191C709O2212C715O2222C721O2230C727O2242C733O2260C763O2206C767O2376C771O2376C777O2359C783O2450C787O2450C793O2425C799O2555C803O2555C809O2507C815O2522C821O2537C827O2602C831O2602C837O2588C842O2639C846O2639C850O2639C852O2669C856O2669C860O2669C862O2708C866O2708C870O2708C872O2742C876O2742C880O2742C882O2785C886O2785C890O2785C892O2818C896O2810C902O2855C910O2855C916O2832C922O2904C926O2904C930O2904C932O2976C940O2976C946O2961C952O3132C956O3132C962O3018C968O3035C974O3051C980O3071C986O3094C992O3118C998O3200C1002O3200C1008O3181C1014O3254C1022O3254C1026O3254C1028O3322C1036O3322C1040O3322C1042O3432C1050O3432C1060O3476C1067O3432C1069O3656C1070O3656C1072O3825C1076O3825C1082O3825C1088O3687C1094O3714C1100O3748C1106O3769C1112O3804C1118O3880C1122O3880C1128O3861C1134O3939C1142O3939C1147O4051C1151O4051C1157O3991C1163O4013C1169O4036C1175O4105C1179O4105C1185O4093C1191O4155C1195O4155C1199O4155C1201O4222C1205O4222C1211O4203C1217O4290C1225O4290C1231O4275C1237O4402C1241O4402C1247O4332C1253O4351C1259O4376C1265O4462C1269O4470C1277O4479C1280O4462C1282O4522C1285O4522C1289O4522C1291O4562C1292O4562C1294O4581C1295O4581C1297O4606C1298O4606C1300O5250C1302O5250C1307O5250C1309O5546C1312O5595C1316O5595C1350O5577C1381O5566C1388O5573C1397O5612C1403O5640C1407O5640C1412O5550C1483O5687C1487O5717C1493O5739C1497O5758C1504O5774C1508O5772C1512O5794C1519O5814C1527O5812C1535O5834C1542O5855C1550O5853C1558O5893C1562O5893C1564O5897C1572O5916C1580O5937C1581O5937C1583O5995C1587O5995C1589O6091C1597O6205C1606O6218C1618O6345C1635O6195C1645O6195C1647O6484C1659O6505C1668O6525C1680O6558C1692O6484C1702O6618C1714O6639C1723O6662C1735O6703C1747O6618C1757O6796C1766O6798C1781O6832C1789O6860C1806O6832C1816O6906C1824O6940C1841O6906C1851O7132C1859O7160C1884O7190C1892O7313C1907O7211C1921O7394C1931O7418C1939O7541C1954O7439C1968O7622C1976O7132C1986O7656C1990O7656C2000O7689C2020O7690C2032O7656C2034O7737C2050O7753C2060O7751C2068O8066C2072O8066C2082O8066C2084O10869C2088O10869C2098O10869C2100O13489C2107O13489C2109O14264C2116O14264C2118O14282C2126O14299C2134O16975C2141O16975C2143O17052C2147O17060C2155O17052C2157O17068C2161O17131C2169O17155C2179O18739C2187O18763C2195O19909C2203O19936C2211O21484C2223O21502C2235O21879C2249O21484C2259O21484C2261O23167C2269O23180C2277O26111C2285O26135C2293O29982C2297O29989C2311O30004C2319O30918C2323O30925C2337O30943C2345O31381C2346O31381C2348O31416C2349O31416C2351O32705C2355O32712C2369O32731C2377O34613C2381O34620C2395O34639C2403O36435C2407O36442C2421O36463C2429O36863C2433O36870C2447O36891C2455O37704C2461O37754C2467O37704C2469O38338C2475O38359C2483O38377C2491O38395C2499O39364C2507O39387C2515O39974C2523O40003C2531O40191C2537O40205C2546O40214,,
tick,0x10035a5d4,26167,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,Eval,10,26250,0x3172a1b3036e,5, node:internal/modules/package_json_reader:1:1,0x3172a1b301c8,~
script-source,104,node:internal/modules/package_json_reader,'use strict';\n\nconst { SafeMap } = primordials;\nconst { internalModuleReadJSON } = internalBinding('fs');\nconst { pathToFileURL } = require('url');\nconst { toNamespacedPath } = require('path');\n\nconst cache = new SafeMap();\n\nlet manifest;\n\n/**\n *\n * @param {string} jsonPath\n */\nfunction read(jsonPath) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n\n  const { 0: string\x2C 1: containsKeys } = internalModuleReadJSON(\n    toNamespacedPath(jsonPath)\n  );\n  const result = { string\x2C containsKeys };\n  const { getOptionValue } = require('internal/options');\n  if (string !== undefined) {\n    if (manifest === undefined) {\n      manifest = getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').manifest :\n        null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL\x2C string);\n    }\n  }\n  cache.set(jsonPath\x2C result);\n  return result;\n}\n\nmodule.exports = { read };\n
code-source-info,0x3172a1b3036e,104,0,983,C0O0C4O983,,
code-creation,Function,10,26292,0x3172a1b304be,113, node:internal/modules/package_json_reader:1:1,0x3172a1b302e8,~
code-source-info,0x3172a1b304be,104,0,983,C0O0C29O23C34O83C37O83C42O56C48O132C54O132C59O114C65O177C71O177C76O156C82O209C84O209C89O209C91O229C92O229C94O956C101O975C107O971C112O982,,
code-creation,Eval,10,26375,0x3172a1b30c3e,5, node:internal/process/esm_loader:1:1,0x3172a1b30a48,~
script-source,105,node:internal/process/esm_loader,'use strict';\n\nconst {\n  ObjectCreate\x2C\n} = primordials;\n\nconst {\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\x2C\n} = require('internal/errors').codes;\nconst { ESMLoader } = require('internal/modules/esm/loader');\nconst {\n  hasUncaughtExceptionCaptureCallback\x2C\n} = require('internal/process/execution');\nconst { pathToFileURL } = require('internal/url');\nconst {\n  getModuleFromWrap\x2C\n} = require('internal/vm/module');\n\nexports.initializeImportMetaObject = function(wrap\x2C meta) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { initializeImportMeta } = callbackMap.get(wrap);\n    if (initializeImportMeta !== undefined) {\n      initializeImportMeta(meta\x2C getModuleFromWrap(wrap) || wrap);\n    }\n  }\n};\n\nexports.importModuleDynamicallyCallback =\nasync function importModuleDynamicallyCallback(wrap\x2C specifier\x2C assertions) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { importModuleDynamically } = callbackMap.get(wrap);\n    if (importModuleDynamically !== undefined) {\n      return importModuleDynamically(\n        specifier\x2C getModuleFromWrap(wrap) || wrap\x2C assertions);\n    }\n  }\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n};\n\nconst esmLoader = new ESMLoader();\n\nexports.esmLoader = esmLoader;\n\n/**\n * Causes side-effects: user-defined loader hooks are added to esmLoader.\n * @returns {void}\n */\nasync function initializeLoader() {\n  const { getOptionValue } = require('internal/options');\n  // customLoaders CURRENTLY can be only 1 (a string)\n  // Once chaining is implemented\x2C it will be string[]\n  const customLoaders = getOptionValue('--experimental-loader');\n\n  if (!customLoaders.length) return;\n\n  const { emitExperimentalWarning } = require('internal/util');\n  emitExperimentalWarning('--experimental-loader');\n\n  let cwd;\n  try {\n    cwd = process.cwd() + '/';\n  } catch {\n    cwd = 'file:///';\n  }\n\n  // A separate loader instance is necessary to avoid cross-contamination\n  // between internal Node.js and userland. For example\x2C a module with internal\n  // state (such as a counter) should be independent.\n  const internalEsmLoader = new ESMLoader();\n\n  // Importation must be handled by internal loader to avoid poluting userland\n  const exports = await internalEsmLoader.import(\n    customLoaders\x2C\n    pathToFileURL(cwd).href\x2C\n    ObjectCreate(null)\x2C\n  );\n\n  // Hooks must then be added to external/public loader\n  // (so they're triggered in userland)\n  await esmLoader.addCustomLoaders(exports);\n}\n\nexports.loadESM = async function loadESM(callback) {\n  try {\n    await initializeLoader();\n    await callback(esmLoader);\n  } catch (err) {\n    if (hasUncaughtExceptionCaptureCallback()) {\n      process._fatalException(err);\n      return;\n    }\n    internalBinding('errors').triggerUncaughtException(\n      err\x2C\n      true /* fromPromise */\n    );\n  }\n};\n
code-source-info,0x3172a1b30c3e,105,0,2883,C0O0C4O2883,,
code-creation,Function,10,26500,0x3172a1b30ede,182, node:internal/process/esm_loader:1:1,0x3172a1b30bb8,~
code-source-info,0x3172a1b30ede,105,0,2883,C0O0C44O25C50O111C56O111C61O137C66O67C72O167C78O167C83O153C89O258C95O258C100O217C106O323C112O323C117O305C123O381C129O381C134O358C140O413C144O448C148O749C152O789C156O1259C159O1259C164O1259C166O1277C168O1295C172O2528C176O2544C181O2882,,
code-creation,Eval,10,26667,0x3172a1b3222e,5, node:internal/modules/esm/loader:1:1,0x3172a1b31da0,~
script-source,106,node:internal/modules/esm/loader,'use strict';\n\n// This is needed to avoid cycles in esm/resolve <-> cjs/loader\nrequire('internal/modules/cjs/loader');\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  SafeWeakMap\x2C\n  StringPrototypeStartsWith\x2C\n  globalThis\x2C\n} = primordials;\nconst { MessageChannel } = require('internal/worker/io');\n\nconst {\n  ERR_INTERNAL_ASSERTION\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x2C\n  ERR_INVALID_RETURN_VALUE\x2C\n  ERR_UNKNOWN_MODULE_FORMAT\n} = require('internal/errors').codes;\nconst { pathToFileURL\x2C isURLInstance\x2C URL } = require('internal/url');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst ModuleMap = require('internal/modules/esm/module_map');\nconst ModuleJob = require('internal/modules/esm/module_job');\n\nconst {\n  defaultResolve\x2C\n  DEFAULT_CONDITIONS\x2C\n} = require('internal/modules/esm/resolve');\nconst {\n  initializeImportMeta\n} = require('internal/modules/esm/initialize_import_meta');\nconst { defaultLoad } = require('internal/modules/esm/load');\nconst { translators } = require(\n  'internal/modules/esm/translators');\nconst { getOptionValue } = require('internal/options');\nconst {\n  fetchModule\x2C\n} = require('internal/modules/esm/fetch_module');\n\n/**\n * An ESMLoader instance is used as the main entry point for loading ES modules.\n * Currently\x2C this is a singleton -- there is only one used for loading\n * the main module and everything in its dependency graph.\n */\nclass ESMLoader {\n  /**\n   * Prior to ESM loading. These are called once before any modules are started.\n   * @private\n   * @property {Function[]} globalPreloaders First-in-first-out list of\n   * preload hooks.\n   */\n  #globalPreloaders = [];\n\n  /**\n   * Phase 2 of 2 in ESM loading.\n   * @private\n   * @property {Function[]} loaders First-in-first-out list of loader hooks.\n   */\n  #loaders = [\n    defaultLoad\x2C\n  ];\n\n  /**\n   * Phase 1 of 2 in ESM loading.\n   * @private\n   * @property {Function[]} resolvers First-in-first-out list of resolver hooks\n   */\n  #resolvers = [\n    defaultResolve\x2C\n  ];\n\n  #importMetaInitializer = initializeImportMeta;\n\n  /**\n   * Map of already-loaded CJS modules to use\n   */\n  cjsCache = new SafeWeakMap();\n\n  /**\n   * The index for assigning unique URLs to anonymous module evaluation\n   */\n  evalIndex = 0;\n\n  /**\n   * Registry of loaded modules\x2C akin to `require.cache`\n   */\n  moduleMap = new ModuleMap();\n\n  /**\n   * Methods which translate input code or other information into ES modules\n   */\n  translators = translators;\n\n  static pluckHooks({\n    globalPreload\x2C\n    resolve\x2C\n    load\x2C\n    // obsolete hooks:\n    dynamicInstantiate\x2C\n    getFormat\x2C\n    getGlobalPreloadCode\x2C\n    getSource\x2C\n    transformSource\x2C\n  }) {\n    const obsoleteHooks = [];\n    const acceptedHooks = ObjectCreate(null);\n\n    if (getGlobalPreloadCode) {\n      globalPreload ??= getGlobalPreloadCode;\n\n      process.emitWarning(\n        'Loader hook "getGlobalPreloadCode" has been renamed to "globalPreload"'\n      );\n    }\n    if (dynamicInstantiate) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'dynamicInstantiate'\n    );\n    if (getFormat) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getFormat'\x2C\n    );\n    if (getSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getSource'\x2C\n    );\n    if (transformSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'transformSource'\x2C\n    );\n\n    if (obsoleteHooks.length) process.emitWarning(\n      `Obsolete loader hook(s) supplied and will be ignored: ${\n        ArrayPrototypeJoin(obsoleteHooks\x2C '\x2C ')\n      }`\x2C\n      'DeprecationWarning'\x2C\n    );\n\n    // Use .bind() to avoid giving access to the Loader instance when called.\n    if (globalPreload) {\n      acceptedHooks.globalPreloader =\n        FunctionPrototypeBind(globalPreload\x2C null);\n    }\n    if (resolve) {\n      acceptedHooks.resolver = FunctionPrototypeBind(resolve\x2C null);\n    }\n    if (load) {\n      acceptedHooks.loader = FunctionPrototypeBind(load\x2C null);\n    }\n\n    return acceptedHooks;\n  }\n\n  /**\n   * Collect custom/user-defined hook(s). After all hooks have been collected\x2C\n   * calls global preload hook(s).\n   * @param {object | object[]} customLoaders A list of exports from\n   * user-defined loaders (as returned by ESMLoader.import()).\n   */\n  async addCustomLoaders(\n    customLoaders = []\x2C\n  ) {\n    if (!ArrayIsArray(customLoaders)) customLoaders = [customLoaders];\n\n    for (let i = 0; i < customLoaders.length; i++) {\n      const exports = customLoaders[i];\n      const {\n        globalPreloader\x2C\n        resolver\x2C\n        loader\x2C\n      } = ESMLoader.pluckHooks(exports);\n\n      if (globalPreloader) ArrayPrototypePush(\n        this.#globalPreloaders\x2C\n        FunctionPrototypeBind(globalPreloader\x2C null)\x2C // [1]\n      );\n      if (resolver) ArrayPrototypePush(\n        this.#resolvers\x2C\n        FunctionPrototypeBind(resolver\x2C null)\x2C // [1]\n      );\n      if (loader) ArrayPrototypePush(\n        this.#loaders\x2C\n        FunctionPrototypeBind(loader\x2C null)\x2C // [1]\n      );\n    }\n\n    // [1] ensure hook function is not bound to ESMLoader instance\n\n    this.preload();\n  }\n\n  async eval(\n    source\x2C\n    url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href\n  ) {\n    const evalInstance = (url) => {\n      const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n      const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n      callbackMap.set(module\x2C {\n        importModuleDynamically: (specifier\x2C { url }\x2C importAssertions) => {\n          return this.import(specifier\x2C\n                             this.getBaseURL(url)\x2C\n                             importAssertions);\n        }\n      });\n\n      return module;\n    };\n    const job = new ModuleJob(\n      this\x2C url\x2C undefined\x2C evalInstance\x2C false\x2C false);\n    this.moduleMap.set(url\x2C undefined\x2C job);\n    const { module } = await job.run();\n\n    return {\n      namespace: module.getNamespace()\x2C\n    };\n  }\n\n  /**\n   * Returns the url to use for the resolution of a given cache key url\n   * These are not guaranteed to be the same.\n   *\n   * In WHATWG HTTP spec for ESM the cache key is the non-I/O bound\n   * synchronous resolution using only string operations\n   *   ~= resolveImportMap(new URL(specifier\x2C importerHREF))\n   *\n   * The url used for subsequent resolution is the response URL after\n   * all redirects have been resolved.\n   *\n   * https://example.com/foo redirecting to https://example.com/bar\n   * would have a cache key of https://example.com/foo and baseURL\n   * of https://example.com/bar\n   *\n   * MUST BE SYNCHRONOUS for import.meta initialization\n   * MUST BE CALLED AFTER receiving the url body due to I/O\n   * @param {string} url\n   * @returns {string}\n   */\n  getBaseURL(url) {\n    if (\n      StringPrototypeStartsWith(url\x2C 'http:') ||\n      StringPrototypeStartsWith(url\x2C 'https:')\n    ) {\n      // The request & response have already settled\x2C so they are in\n      // fetchModule's cache\x2C in which case\x2C fetchModule returns\n      // immediately and synchronously\n      url = fetchModule(new URL(url)\x2C { parentURL: url }).resolvedHREF;\n      // This should only occur if the module hasn't been fetched yet\n      if (typeof url !== 'string') {\n        throw new ERR_INTERNAL_ASSERTION(`Base url for module ${url} not loaded.`);\n      }\n    }\n    return url;\n  }\n\n  /**\n   * Get a (possibly still pending) module job from the cache\x2C\n   * or create one and return its Promise.\n   * @param {string} specifier The string after `from` in an `import` statement\x2C\n   *                           or the first parameter of an `import()`\n   *                           expression\n   * @param {string | undefined} parentURL The URL of the module importing this\n   *                                     one\x2C unless this is the Node.js entry\n   *                                     point.\n   * @param {Record<string\x2C string>} importAssertions Validations for the\n   *                                                  module import.\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\n   */\n  async getModuleJob(specifier\x2C parentURL\x2C importAssertions) {\n    let importAssertionsForResolve;\n    if (this.#loaders.length !== 1) {\n      // We can skip cloning if there are no user provided loaders because\n      // the Node.js default resolve hook does not use import assertions.\n      importAssertionsForResolve =\n        ObjectAssign(ObjectCreate(null)\x2C importAssertions);\n    }\n    const { format\x2C url } =\n      await this.resolve(specifier\x2C parentURL\x2C importAssertionsForResolve);\n\n    let job = this.moduleMap.get(url\x2C importAssertions.type);\n\n    // CommonJS will set functions for lazy job evaluation.\n    if (typeof job === 'function') {\n      this.moduleMap.set(url\x2C undefined\x2C job = job());\n    }\n\n    if (job === undefined) {\n      job = this.#createModuleJob(url\x2C importAssertions\x2C parentURL\x2C format);\n    }\n\n    return job;\n  }\n\n  /**\n   * Create and cache an object representing a loaded module.\n   * @param {string} url The absolute URL that was resolved for this module\n   * @param {Record<string\x2C string>} importAssertions Validations for the\n   *                                                  module import.\n   * @param {string} [parentURL] The absolute URL of the module importing this\n   *                             one\x2C unless this is the Node.js entry point\n   * @param {string} [format] The format hint possibly returned by the\n   *                          `resolve` hook\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\n   */\n  #createModuleJob(url\x2C importAssertions\x2C parentURL\x2C format) {\n    const moduleProvider = async (url\x2C isMain) => {\n      const {\n        format: finalFormat\x2C\n        source\x2C\n      } = await this.load(url\x2C {\n        format\x2C\n        importAssertions\x2C\n      });\n\n      const translator = translators.get(finalFormat);\n\n      if (!translator) {\n        throw new ERR_UNKNOWN_MODULE_FORMAT(finalFormat\x2C url);\n      }\n\n      return FunctionPrototypeCall(translator\x2C this\x2C url\x2C source\x2C isMain);\n    };\n\n    const inspectBrk = (\n      parentURL === undefined &&\n      getOptionValue('--inspect-brk')\n    );\n\n    const job = new ModuleJob(\n      this\x2C\n      url\x2C\n      importAssertions\x2C\n      moduleProvider\x2C\n      parentURL === undefined\x2C\n      inspectBrk\n    );\n\n    this.moduleMap.set(url\x2C importAssertions.type\x2C job);\n\n    return job;\n  }\n\n  /**\n   * This method is usually called indirectly as part of the loading processes.\n   * Internally\x2C it is used directly to add loaders. Use directly with caution.\n   *\n   * This method must NOT be renamed: it functions as a dynamic import on a\n   * loader module.\n   *\n   * @param {string | string[]} specifiers Path(s) to the module.\n   * @param {string} parentURL Path of the parent importing the module.\n   * @param {Record<string\x2C string>} importAssertions Validations for the\n   *                                                  module import.\n   * @returns {Promise<object | object[]>} A list of module export(s).\n   */\n  async import(specifiers\x2C parentURL\x2C importAssertions) {\n    const wasArr = ArrayIsArray(specifiers);\n    if (!wasArr) specifiers = [specifiers];\n\n    const count = specifiers.length;\n    const jobs = new Array(count);\n\n    for (let i = 0; i < count; i++) {\n      jobs[i] = this.getModuleJob(specifiers[i]\x2C parentURL\x2C importAssertions)\n        .then((job) => job.run())\n        .then(({ module }) => module.getNamespace());\n    }\n\n    const namespaces = await PromiseAll(new SafeArrayIterator(jobs));\n\n    return wasArr ?\n      namespaces :\n      namespaces[0];\n  }\n\n  /**\n   * Provide source that is understood by one of Node's translators.\n   *\n   * The internals of this WILL change when chaining is implemented\x2C\n   * depending on the resolution/consensus from #36954\n   * @param {string} url The URL/path of the module to be loaded\n   * @param {object} context Metadata about the module\n   * @returns {object}\n   */\n  async load(url\x2C context = {}) {\n    const defaultLoader = this.#loaders[0];\n\n    const loader = this.#loaders.length === 1 ?\n      defaultLoader :\n      this.#loaders[1];\n    const loaded = await loader(url\x2C context\x2C defaultLoader);\n\n    if (typeof loaded !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object'\x2C\n        'loader load'\x2C\n        loaded\x2C\n      );\n    }\n\n    const {\n      format\x2C\n      source\x2C\n    } = loaded;\n\n    if (format == null) {\n      const dataUrl = RegExpPrototypeExec(\n        /^data:([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n        url\x2C\n      );\n\n      throw new ERR_UNKNOWN_MODULE_FORMAT(\n        dataUrl ? dataUrl[1] : format\x2C\n        url);\n    }\n\n    if (typeof format !== 'string') {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n\n    if (\n      source != null &&\n      typeof source !== 'string' &&\n      !isAnyArrayBuffer(source) &&\n      !isArrayBufferView(source)\n    ) throw ERR_INVALID_RETURN_PROPERTY_VALUE(\n      'string\x2C an ArrayBuffer\x2C or a TypedArray'\x2C\n      'loader load'\x2C\n      'source'\x2C\n      source\n    );\n\n    return {\n      format\x2C\n      source\x2C\n    };\n  }\n\n  preload() {\n    const count = this.#globalPreloaders.length;\n    if (!count) return;\n\n    for (let i = 0; i < count; i++) {\n      const channel = new MessageChannel();\n      const {\n        port1: insidePreload\x2C\n        port2: insideLoader\x2C\n      } = channel;\n\n      insidePreload.unref();\n      insideLoader.unref();\n\n      const preload = this.#globalPreloaders[i]({\n        port: insideLoader\n      });\n\n      if (preload == null) return;\n\n      if (typeof preload !== 'string') {\n        throw new ERR_INVALID_RETURN_VALUE(\n          'string'\x2C\n          'loader globalPreloadCode'\x2C\n          preload\x2C\n        );\n      }\n      const { compileFunction } = require('vm');\n      const preloadInit = compileFunction(\n        preload\x2C\n        ['getBuiltin'\x2C 'port'\x2C 'setImportMetaCallback']\x2C\n        {\n          filename: '<preload>'\x2C\n        }\n      );\n      const { NativeModule } = require('internal/bootstrap/loaders');\n      // We only allow replacing the importMetaInitializer during preload\x2C\n      // after preload is finished\x2C we disable the ability to replace it\n      //\n      // This exposes accidentally setting the initializer too late by\n      // throwing an error.\n      let finished = false;\n      let replacedImportMetaInitializer = false;\n      let next = this.#importMetaInitializer;\n      try {\n        // Calls the compiled preload source text gotten from the hook\n        // Since the parameters are named we use positional parameters\n        // see compileFunction above to cross reference the names\n        FunctionPrototypeCall(\n          preloadInit\x2C\n          globalThis\x2C\n          // Param getBuiltin\n          (builtinName) => {\n            if (NativeModule.canBeRequiredByUsers(builtinName)) {\n              return require(builtinName);\n            }\n            throw new ERR_INVALID_ARG_VALUE('builtinName'\x2C builtinName);\n          }\x2C\n          // Param port\n          insidePreload\x2C\n          // Param setImportMetaCallback\n          (fn) => {\n            if (finished || typeof fn !== 'function') {\n              throw new ERR_INVALID_ARG_TYPE('fn'\x2C fn);\n            }\n            replacedImportMetaInitializer = true;\n            const parent = next;\n            next = (meta\x2C context) => {\n              return fn(meta\x2C context\x2C parent);\n            };\n          });\n      } finally {\n        finished = true;\n        if (replacedImportMetaInitializer) {\n          this.#importMetaInitializer = next;\n        }\n      }\n    }\n  }\n\n  importMetaInitialize(meta\x2C context) {\n    this.#importMetaInitializer(meta\x2C context);\n  }\n\n  /**\n   * Resolve the location of the module.\n   *\n   * The internals of this WILL change when chaining is implemented\x2C\n   * depending on the resolution/consensus from #36954.\n   * @param {string} originalSpecifier The specified URL path of the module to\n   *                                   be resolved.\n   * @param {string} [parentURL] The URL path of the module's parent.\n   * @param {ImportAssertions} [importAssertions] Assertions from the import\n   *                                              statement or expression.\n   * @returns {{ url: string }}\n   */\n  async resolve(\n    originalSpecifier\x2C\n    parentURL\x2C\n    importAssertions = ObjectCreate(null)\n  ) {\n    const isMain = parentURL === undefined;\n\n    if (\n      !isMain &&\n      typeof parentURL !== 'string' &&\n      !isURLInstance(parentURL)\n    ) throw new ERR_INVALID_ARG_TYPE(\n      'parentURL'\x2C\n      ['string'\x2C 'URL']\x2C\n      parentURL\x2C\n    );\n\n    const conditions = DEFAULT_CONDITIONS;\n\n    const defaultResolver = this.#resolvers[0];\n\n    const resolver = this.#resolvers.length === 1 ?\n      defaultResolver :\n      this.#resolvers[1];\n    const resolution = await resolver(\n      originalSpecifier\x2C\n      {\n        conditions\x2C\n        importAssertions\x2C\n        parentURL\x2C\n      }\x2C\n      defaultResolver\x2C\n    );\n\n    if (typeof resolution !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object'\x2C\n        'loader resolve'\x2C\n        resolution\x2C\n      );\n    }\n\n    const { format\x2C url } = resolution;\n\n    if (\n      format != null &&\n      typeof format !== 'string'\n    ) {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n\n    if (typeof url !== 'string') { // non-strings can be coerced to a url string\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'url'\x2C\n        url\x2C\n      );\n    }\n\n    new URL(url); // Intentionally trigger error if `url` is invalid\n\n    return {\n      format\x2C\n      url\x2C\n    };\n  }\n}\n\nObjectSetPrototypeOf(ESMLoader.prototype\x2C null);\n\nexports.ESMLoader = ESMLoader;\n
code-source-info,0x3172a1b3222e,106,0,18003,C0O0C4O18003,,
code-creation,Function,10,27375,0x3172a1b32afe,659, node:internal/modules/esm/loader:1:1,0x3172a1b321a8,~
code-source-info,0x3172a1b32afe,106,0,18003,C0O0C122O79C128O79C132O130C138O139C144O155C150O177C156O199C162O224C168O249C174O265C180O281C185O305C191O319C197O342C203O363C209O378C215O407C221O463C227O463C232O444C238O675C244O675C249O701C254O505C260O531C266O555C272O580C278O617C284O645C290O755C296O755C301O717C307O732C313O747C319O833C325O833C330O790C336O810C342O883C348O883C352O883C354O945C360O945C364O945C366O1042C372O1042C377O1000C383O1018C389O1118C395O1118C400O1093C406O1198C412O1198C417O1182C423O1260C429O1260C434O1244C440O1335C446O1335C451O1316C457O1391C463O1391C468O1374C639O17953C646O17922C651O17972C653O17990C658O18002,,
code-creation,Function,10,27417,0x3172a1b32fa6,154,<instance_members_initializer> node:internal/modules/esm/loader:68:3,0x3172a1b32620,~
code-source-info,0x3172a1b32fa6,106,1877,2720,C3O1897C17O2052C28O2058C45O2232C56O2238C73O2287C88O2381C95O2381C109O2499C119O2586C126O2586C140O2709C153O2720,,
tick,0x1bfd39474,27459,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,Eval,10,27500,0x3172a1b3497e,5, node:internal/modules/esm/module_map:1:1,0x3172a1b34790,~
script-source,107,node:internal/modules/esm/module_map,'use strict';\n\nconst ModuleJob = require('internal/modules/esm/module_job');\nconst { kImplicitAssertType } = require('internal/modules/esm/assert');\nconst {\n  ObjectCreate\x2C\n  SafeMap\x2C\n} = primordials;\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n// Tracks the state of the loader-level module cache\nclass ModuleMap extends SafeMap {\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  get(url\x2C type = kImplicitAssertType) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    return super.get(url)?.[type];\n  }\n  set(url\x2C type = kImplicitAssertType\x2C job) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    if (job instanceof ModuleJob !== true &&\n        typeof job !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('job'\x2C 'ModuleJob'\x2C job);\n    }\n    debug(`Storing ${url} (${\n      type === kImplicitAssertType ? 'implicit type' : type\n    }) in ModuleMap`);\n    const cachedJobsForUrl = super.get(url) ?? ObjectCreate(null);\n    cachedJobsForUrl[type] = job;\n    return super.set(url\x2C cachedJobsForUrl);\n  }\n  has(url\x2C type = kImplicitAssertType) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    return super.get(url)?.[type] !== undefined;\n  }\n}\nmodule.exports = ModuleMap;\n
code-source-info,0x3172a1b3497e,107,0,1444,C0O0C4O1444,,
code-creation,Function,10,27542,0x3172a1b34db6,175, node:internal/modules/esm/module_map:1:1,0x3172a1b348f8,~
code-source-info,0x3172a1b34db6,107,0,1444,C0O0C23O33C26O33C30O33C32O109C35O109C40O85C46O159C52O175C57O213C60O213C65O246C78O247C84O213C86O324C89O324C94O350C99O299C105O385C108O385C113O366C123O495C167O1416C169O1431C174O1443,,
code-creation,Eval,10,27667,0x3172a1b35916,5, node:internal/modules/esm/module_job:1:1,0x3172a1b35620,~
script-source,108,node:internal/modules/esm/module_job,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSome\x2C\n  FunctionPrototype\x2C\n  ObjectCreate\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  PromiseResolve\x2C\n  PromisePrototypeCatch\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst { ModuleWrap } = internalBinding('module_wrap');\n\nconst { decorateErrorStack } = require('internal/util');\nconst {\n  getSourceMapsEnabled\x2C\n} = require('internal/source_map/source_map_cache');\nconst assert = require('internal/assert');\nconst resolvedPromise = PromiseResolve();\n\nconst noop = FunctionPrototype;\n\nlet hasPausedEntry = false;\n\nconst CJSGlobalLike = [\n  'require'\x2C\n  'module'\x2C\n  'exports'\x2C\n  '__filename'\x2C\n  '__dirname'\x2C\n];\nconst isCommonJSGlobalLikeNotDefinedError = (errorMessage) =>\n  ArrayPrototypeSome(\n    CJSGlobalLike\x2C\n    (globalLike) => errorMessage === `${globalLike} is not defined`\n  );\n\n/* A ModuleJob tracks the loading of a single Module\x2C and the ModuleJobs of\n * its dependencies\x2C over time. */\nclass ModuleJob {\n  // `loader` is the Loader instance used for loading dependencies.\n  // `moduleProvider` is a function\n  constructor(loader\x2C url\x2C importAssertions = ObjectCreate(null)\x2C\n              moduleProvider\x2C isMain\x2C inspectBrk) {\n    this.loader = loader;\n    this.importAssertions = importAssertions;\n    this.isMain = isMain;\n    this.inspectBrk = inspectBrk;\n\n    this.module = undefined;\n    // Expose the promise to the ModuleWrap directly for linking below.\n    // `this.module` is also filled in below.\n    this.modulePromise = ReflectApply(moduleProvider\x2C loader\x2C [url\x2C isMain]);\n\n    // Wait for the ModuleWrap instance being linked with all dependencies.\n    const link = async () => {\n      this.module = await this.modulePromise;\n      assert(this.module instanceof ModuleWrap);\n\n      // Explicitly keeping track of dependency jobs is needed in order\n      // to flatten out the dependency graph below in `_instantiate()`\x2C\n      // so that circular dependencies can't cause a deadlock by two of\n      // these `link` callbacks depending on each other.\n      const dependencyJobs = [];\n      const promises = this.module.link(async (specifier\x2C assertions) => {\n        const baseURL = this.loader.getBaseURL(url);\n        const jobPromise = this.loader.getModuleJob(specifier\x2C baseURL\x2C assertions);\n        ArrayPrototypePush(dependencyJobs\x2C jobPromise);\n        const job = await jobPromise;\n        return job.modulePromise;\n      });\n\n      if (promises !== undefined)\n        await PromiseAll(new SafeArrayIterator(promises));\n\n      return PromiseAll(new SafeArrayIterator(dependencyJobs));\n    };\n    // Promise for the list of all dependencyJobs.\n    this.linked = link();\n    // This promise is awaited later anyway\x2C so silence\n    // 'unhandled rejection' warnings.\n    PromisePrototypeCatch(this.linked\x2C noop);\n\n    // instantiated == deep dependency jobs wrappers are instantiated\x2C\n    // and module wrapper is instantiated.\n    this.instantiated = undefined;\n  }\n\n  instantiate() {\n    if (this.instantiated === undefined) {\n      this.instantiated = this._instantiate();\n    }\n    return this.instantiated;\n  }\n\n  async _instantiate() {\n    const jobsInGraph = new SafeSet();\n    const addJobsToDependencyGraph = async (moduleJob) => {\n      if (jobsInGraph.has(moduleJob)) {\n        return;\n      }\n      jobsInGraph.add(moduleJob);\n      const dependencyJobs = await moduleJob.linked;\n      return PromiseAll(new SafeArrayIterator(\n        ArrayPrototypeMap(dependencyJobs\x2C addJobsToDependencyGraph)));\n    };\n    await addJobsToDependencyGraph(this);\n\n    try {\n      if (!hasPausedEntry && this.inspectBrk) {\n        hasPausedEntry = true;\n        const initWrapper = internalBinding('inspector').callAndPauseOnStart;\n        initWrapper(this.module.instantiate\x2C this.module);\n      } else {\n        this.module.instantiate();\n      }\n    } catch (e) {\n      decorateErrorStack(e);\n      // TODO(@bcoe): Add source map support to exception that occurs as result\n      // of missing named export. This is currently not possible because\n      // stack trace originates in module_job\x2C not the file itself. A hidden\n      // symbol with filename could be set in node_errors.cc to facilitate this.\n      if (!getSourceMapsEnabled() &&\n          StringPrototypeIncludes(e.message\x2C\n                                  ' does not provide an export named')) {\n        const splitStack = StringPrototypeSplit(e.stack\x2C '\\n');\n        const parentFileUrl = StringPrototypeReplace(\n          splitStack[0]\x2C\n          /:\\d+$/\x2C\n          ''\n        );\n        const { 1: childSpecifier\x2C 2: name } = StringPrototypeMatch(\n          e.message\x2C\n          /module '(.*)' does not provide an export named '(.+)'/);\n        const { url: childFileURL } = await this.loader.resolve(\n          childSpecifier\x2C parentFileUrl\x2C\n        );\n        let format;\n        try {\n          // This might throw for non-CommonJS modules because we aren't passing\n          // in the import assertions and some formats require them; but we only\n          // care about CommonJS for the purposes of this error message.\n          ({ format } =\n            await this.loader.load(childFileURL));\n        } catch {\n          // Continue regardless of error.\n        }\n\n        if (format === 'commonjs') {\n          const importStatement = splitStack[1];\n          // TODO(@ctavan): The original error stack only provides the single\n          // line which causes the error. For multi-line import statements we\n          // cannot generate an equivalent object destructuring assignment by\n          // just parsing the error stack.\n          const oneLineNamedImports = StringPrototypeMatch(importStatement\x2C /{.*}/);\n          const destructuringAssignment = oneLineNamedImports &&\n            StringPrototypeReplace(oneLineNamedImports\x2C /\\s+as\\s+/g\x2C ': ');\n          e.message = `Named export '${name}' not found. The requested module` +\n            ` '${childSpecifier}' is a CommonJS module\x2C which may not support` +\n            ' all module.exports as named exports.\\nCommonJS modules can ' +\n            'always be imported via the default export\x2C for example using:' +\n            `\\n\\nimport pkg from '${childSpecifier}';\\n${\n              destructuringAssignment ?\n                `const ${destructuringAssignment} = pkg;\\n` : ''}`;\n          const newStack = StringPrototypeSplit(e.stack\x2C '\\n');\n          newStack[3] = `SyntaxError: ${e.message}`;\n          e.stack = ArrayPrototypeJoin(newStack\x2C '\\n');\n        }\n      }\n      throw e;\n    }\n\n    for (const dependencyJob of jobsInGraph) {\n      // Calling `this.module.instantiate()` instantiates not only the\n      // ModuleWrap in this module\x2C but all modules in the graph.\n      dependencyJob.instantiated = resolvedPromise;\n    }\n  }\n\n  async run() {\n    await this.instantiate();\n    const timeout = -1;\n    const breakOnSigint = false;\n    try {\n      await this.module.evaluate(timeout\x2C breakOnSigint);\n    } catch (e) {\n      if (e?.name === 'ReferenceError' &&\n          isCommonJSGlobalLikeNotDefinedError(e.message)) {\n        e.message += ' in ES module scope';\n\n        if (StringPrototypeStartsWith(e.message\x2C 'require ')) {\n          e.message += '\x2C you can use import instead';\n        }\n\n        const packageConfig =\n          StringPrototypeStartsWith(this.module.url\x2C 'file://') &&\n            RegExpPrototypeTest(/\\.js(\\?[^#]*)?(#.*)?$/\x2C this.module.url) &&\n            require('internal/modules/esm/resolve')\n              .getPackageScopeConfig(this.module.url);\n        if (packageConfig.type === 'module') {\n          e.message +=\n            '\\nThis file is being treated as an ES module because it has a ' +\n            `'.js' file extension and '${packageConfig.pjsonPath}' contains ` +\n            '"type": "module". To treat it as a CommonJS script\x2C rename it ' +\n            'to use the \\'.cjs\\' file extension.';\n        }\n      }\n      throw e;\n    }\n    return { module: this.module };\n  }\n}\nObjectSetPrototypeOf(ModuleJob.prototype\x2C null);\nmodule.exports = ModuleJob;\n
code-source-info,0x3172a1b35916,108,0,8238,C0O0C4O8238,,
code-creation,Function,10,28000,0x3172a1b35e0e,343, node:internal/modules/esm/module_job:1:1,0x3172a1b35890,~
code-source-info,0x3172a1b35e0e,108,0,8238,C0O0C88O25C94O47C100O68C106O90C112O112C117O133C123O149C128O173C134O187C139O205C145O230C151O246C157O269C163O290C169O301C175O328C181O352C187O378C193O402C199O470C205O470C210O455C216O534C222O534C227O511C233O596C239O596C244O570C250O660C256O660C260O660C262O712C265O712C267O744C269O744C271O785C272O785C274O815C278O815C280O933C284O933C323O8192C330O8161C335O8210C337O8225C342O8237,,
tick,0x1003b1270,28084,1,0x1003b104c,6,0x0,0x3172a1b0abef,0x3172a1b35edb,0x105108d28,0x10510894c,0x3172a1b34dd0,0x105108d28,0x10510894c,0x3172a1b32c5a,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,Eval,10,28125,0x3172a1b37a66,5, node:internal/modules/esm/assert:1:1,0x3172a1b37870,~
script-source,109,node:internal/modules/esm/assert,'use strict';\n\nconst {\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ObjectCreate\x2C\n  ObjectValues\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n} = primordials;\nconst { validateString } = require('internal/validators');\n\nconst {\n  ERR_IMPORT_ASSERTION_TYPE_FAILED\x2C\n  ERR_IMPORT_ASSERTION_TYPE_MISSING\x2C\n  ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED\x2C\n} = require('internal/errors').codes;\n\n// The HTML spec has an implied default type of `'javascript'`.\nconst kImplicitAssertType = 'javascript';\n\n/**\n * Define a map of module formats to import assertion types (the value of\n * `type` in `assert { type: 'json' }`).\n * @type {Map<string\x2C string>}\n */\nconst formatTypeMap = {\n  '__proto__': null\x2C\n  'builtin': kImplicitAssertType\x2C\n  'commonjs': kImplicitAssertType\x2C\n  'json': 'json'\x2C\n  'module': kImplicitAssertType\x2C\n  'wasm': kImplicitAssertType\x2C // It's unclear whether the HTML spec will require an assertion type or not for Wasm; see https://github.com/WebAssembly/esm-integration/issues/42\n};\n\n/**\n * The HTML spec disallows the default type to be explicitly specified\n * (for now); so `import './file.js'` is okay but\n * `import './file.js' assert { type: 'javascript' }` throws.\n * @type {Array<string\x2C string>}\n */\nconst supportedAssertionTypes = ArrayPrototypeFilter(\n  ObjectValues(formatTypeMap)\x2C\n  (type) => type !== kImplicitAssertType);\n\n\n/**\n * Test a module's import assertions.\n * @param {string} url The URL of the imported module\x2C for error reporting.\n * @param {string} format One of Node's supported translators\n * @param {Record<string\x2C string>} importAssertions Validations for the\n *                                                  module import.\n * @returns {true}\n * @throws {TypeError} If the format and assertion type are incompatible.\n */\nfunction validateAssertions(url\x2C format\x2C\n                            importAssertions = ObjectCreate(null)) {\n  const validType = formatTypeMap[format];\n\n  switch (validType) {\n    case undefined:\n      // Ignore assertions for module formats we don't recognize\x2C to allow new\n      // formats in the future.\n      return true;\n\n    case kImplicitAssertType:\n      // This format doesn't allow an import assertion type\x2C so the property\n      // must not be set on the import assertions object.\n      if (!ObjectPrototypeHasOwnProperty(importAssertions\x2C 'type')) {\n        return true;\n      }\n      return handleInvalidType(url\x2C importAssertions.type);\n\n    case importAssertions.type:\n      // The asserted type is the valid type for this format.\n      return true;\n\n    default:\n      // There is an expected type for this format\x2C but the value of\n      // `importAssertions.type` might not have been it.\n      if (!ObjectPrototypeHasOwnProperty(importAssertions\x2C 'type')) {\n        // `type` wasn't specified at all.\n        throw new ERR_IMPORT_ASSERTION_TYPE_MISSING(url\x2C validType);\n      }\n      handleInvalidType(url\x2C importAssertions.type);\n  }\n}\n\n/**\n * Throw the correct error depending on what's wrong with the type assertion.\n * @param {string} url The resolved URL for the module to be imported\n * @param {string} type The value of the import assertion `type` property\n */\nfunction handleInvalidType(url\x2C type) {\n  // `type` might have not been a string.\n  validateString(type\x2C 'type');\n\n  // `type` might not have been one of the types we understand.\n  if (!ArrayPrototypeIncludes(supportedAssertionTypes\x2C type)) {\n    throw new ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED(type);\n  }\n\n  // `type` was the wrong value for this format.\n  throw new ERR_IMPORT_ASSERTION_TYPE_FAILED(url\x2C type);\n}\n\n\nmodule.exports = {\n  kImplicitAssertType\x2C\n  validateAssertions\x2C\n};\n
code-source-info,0x3172a1b37a66,109,0,3624,C0O0C4O3624,,
code-creation,Function,10,28250,0x3172a1b37d3e,201, node:internal/modules/esm/assert:1:1,0x3172a1b379e0,~
code-source-info,0x3172a1b37d3e,109,0,3624,C0O0C46O25C51O49C57O75C63O91C68O107C74O182C77O182C82O163C88O341C91O341C96O367C101O225C107O261C113O298C119O468C121O468C123O659C130O695C136O730C142O781C148O812C154O659C156O1240C159O1264C169O1240C174O1240C176O3557C183O3578C189O3601C195O3572C200O3623,,
code-creation,LazyCompile,10,28292,0x3172a1b38346,9, node:internal/modules/esm/assert:43:3,0x3172a1b37b38,~
code-source-info,0x3172a1b38346,109,1295,1333,C0O1310C2O1314C4O1310C8O1333,,
code-creation,Eval,10,28709,0x3172a1b39ede,5, node:internal/modules/esm/resolve:1:1,0x3172a1b39740,~
script-source,110,node:internal/modules/esm/resolve,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  JSONParse\x2C\n  JSONStringify\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst internalFS = require('internal/fs/utils');\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  realpathSync\x2C\n  statSync\x2C\n  Stats\x2C\n} = require('fs');\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst { sep\x2C relative\x2C resolve } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\nconst typeFlag = getOptionValue('--input-type');\nconst { URL\x2C pathToFileURL\x2C fileURLToPath } = require('internal/url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_PACKAGE_CONFIG\x2C\n  ERR_INVALID_PACKAGE_TARGET\x2C\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n  ERR_PACKAGE_IMPORT_NOT_DEFINED\x2C\n  ERR_PACKAGE_PATH_NOT_EXPORTED\x2C\n  ERR_UNSUPPORTED_DIR_IMPORT\x2C\n  ERR_NETWORK_IMPORT_DISALLOWED\x2C\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst { Module: CJSModule } = require('internal/modules/cjs/loader');\n\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst userConditions = getOptionValue('--conditions');\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\nconst DEFAULT_CONDITIONS = ObjectFreeze([\n  'node'\x2C\n  'import'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\n\n/**\n * @typedef {string | string[] | Record<string\x2C unknown>} Exports\n * @typedef {'module' | 'commonjs'} PackageType\n * @typedef {{\n *   exports?: ExportConfig;\n *   name?: string;\n *   main?: string;\n *   type?: PackageType;\n * }} PackageConfig\n */\n\nconst emittedPackageWarnings = new SafeSet();\n\nfunction emitTrailingSlashPatternDeprecation(match\x2C pjsonUrl\x2C base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated trailing slash pattern mapping "${match}" in the ` +\n    `"exports" field module resolution of the package at ${pjsonPath}${\n      base ? ` imported from ${fileURLToPath(base)}` :\n        ''}. Mapping specifiers ending in "/" is no longer supported.`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0155'\n  );\n}\n\n/**\n * @param {URL} url\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @param {string} main\n * @returns {void}\n */\nfunction emitLegacyIndexDeprecation(url\x2C packageJSONUrl\x2C base\x2C main) {\n  const format = defaultGetFormatWithoutErrors(url);\n  if (format !== 'module')\n    return;\n  const path = fileURLToPath(url);\n  const pkgPath = fileURLToPath(new URL('.'\x2C packageJSONUrl));\n  const basePath = fileURLToPath(base);\n  if (main)\n    process.emitWarning(\n      `Package ${pkgPath} has a "main" field set to ${JSONStringify(main)}\x2C ` +\n      `excluding the full filename and extension to the resolved file at "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${\n        basePath}.\\n Automatic extension resolution of the "main" field is ` +\n      'deprecated for ES modules.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n  else\n    process.emitWarning(\n      `No "main" or "exports" field defined in the package.json for ${pkgPath\n      } resolving the main entry point "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${basePath\n      }.\\nDefault "index" lookups for the main are deprecated for ES modules.`\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n}\n\n/**\n * @param {string[]} [conditions]\n * @returns {Set<string>}\n */\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions'\x2C conditions\x2C\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\n\nconst realpathCache = new SafeMap();\nconst packageJSONCache = new SafeMap(); /* string -> PackageConfig */\n\n/**\n * @param {string | URL} path\n * @returns {import('fs').Stats}\n */\nconst tryStatSync =\n  (path) => statSync(path\x2C { throwIfNoEntry: false }) ?? new Stats();\n\n/**\n * @param {string} path\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {PackageConfig}\n */\nfunction getPackageConfig(path\x2C specifier\x2C base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path\x2C\n      exists: false\x2C\n      main: undefined\x2C\n      name: undefined\x2C\n      type: 'none'\x2C\n      exports: undefined\x2C\n      imports: undefined\x2C\n    };\n    packageJSONCache.set(path\x2C packageConfig);\n    return packageConfig;\n  }\n\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path\x2C\n      (base ? `"${specifier}" from ` : '') + fileURLToPath(base || specifier)\x2C\n      error.message\n    );\n  }\n\n  let { imports\x2C main\x2C name\x2C type } = packageJSON;\n  const { exports } = packageJSON;\n  if (typeof imports !== 'object' || imports === null) imports = undefined;\n  if (typeof main !== 'string') main = undefined;\n  if (typeof name !== 'string') name = undefined;\n  // Ignore unknown types for forwards compatibility\n  if (type !== 'module' && type !== 'commonjs') type = 'none';\n\n  const packageConfig = {\n    pjsonPath: path\x2C\n    exists: true\x2C\n    main\x2C\n    name\x2C\n    type\x2C\n    exports\x2C\n    imports\x2C\n  };\n  packageJSONCache.set(path\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * @param {URL | string} resolved\n * @returns {PackageConfig}\n */\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json'\x2C resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath\x2C 'node_modules/package.json'))\n      break;\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl)\x2C\n                                           resolved);\n    if (packageConfig.exists) return packageConfig;\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json'\x2C packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check "/package.json" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath\x2C\n    exists: false\x2C\n    main: undefined\x2C\n    name: undefined\x2C\n    type: 'none'\x2C\n    exports: undefined\x2C\n    imports: undefined\x2C\n  };\n  packageJSONCache.set(packageJSONPath\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * @param {string | URL} url\n * @returns {boolean}\n */\nfunction fileExists(url) {\n  return statSync(url\x2C { throwIfNoEntry: false })?.isFile() ?? false;\n}\n\n/**\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M\x2C M.js\x2C M.json\x2C M.node)\n * 3. TRY(M/index.js\x2C M/index.json\x2C M/index.node)\n * 4. TRY(pkg_url/index.js\x2C pkg_url/index.json\x2C pkg_url/index.node)\n * 5. NOT_FOUND\n * @param {URL} packageJSONUrl\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @returns {URL}\n */\nfunction legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if (fileExists(guess = new URL(`./${packageConfig.main}`\x2C\n                                   packageJSONUrl))) {\n      return guess;\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`\x2C\n                                          packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.node`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`\x2C\n                                        packageJSONUrl)));\n    else guess = undefined;\n    if (guess) {\n      emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C\n                                 packageConfig.main);\n      return guess;\n    }\n    // Fallthrough.\n  }\n  if (fileExists(guess = new URL('./index.js'\x2C packageJSONUrl)));\n  // So fs.\n  else if (fileExists(guess = new URL('./index.json'\x2C packageJSONUrl)));\n  else if (fileExists(guess = new URL('./index.node'\x2C packageJSONUrl)));\n  else guess = undefined;\n  if (guess) {\n    emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C packageConfig.main);\n    return guess;\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C fileURLToPath(base));\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensionsWithTryExactName(search) {\n  if (fileExists(search)) return search;\n  return resolveExtensions(search);\n}\n\nconst extensions = ['.js'\x2C '.json'\x2C '.node'\x2C '.mjs'];\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensions(search) {\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const guess = new URL(`${search.pathname}${extension}`\x2C search);\n    if (fileExists(guess)) return guess;\n  }\n  return undefined;\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveDirectoryEntry(search) {\n  const dirPath = fileURLToPath(search);\n  const pkgJsonPath = resolve(dirPath\x2C 'package.json');\n  if (fileExists(pkgJsonPath)) {\n    const pkgJson = packageJsonReader.read(pkgJsonPath);\n    if (pkgJson.containsKeys) {\n      const { main } = JSONParse(pkgJson.string);\n      if (main != null) {\n        const mainUrl = pathToFileURL(resolve(dirPath\x2C main));\n        return resolveExtensionsWithTryExactName(mainUrl);\n      }\n    }\n  }\n  return resolveExtensions(new URL('index'\x2C search));\n}\n\nconst encodedSepRegEx = /%2F|%5C/i;\n/**\n * @param {URL} resolved\n * @param {string | URL | undefined} base\n * @param {boolean} preserveSymlinks\n * @returns {URL | undefined}\n */\nfunction finalizeResolution(resolved\x2C base\x2C preserveSymlinks) {\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved.pathname))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname\x2C 'must not include encoded "/" or "\\\\" characters'\x2C\n      fileURLToPath(base));\n\n  let path = fileURLToPath(resolved);\n  if (getOptionValue('--experimental-specifier-resolution') === 'node') {\n    let file = resolveExtensionsWithTryExactName(resolved);\n\n    // Directory\n    if (file === undefined) {\n      file = StringPrototypeEndsWith(path\x2C '/') ?\n        (resolveDirectoryEntry(resolved) || resolved) : resolveDirectoryEntry(new URL(`${resolved}/`));\n\n      if (file === resolved) return file;\n\n      if (file === undefined) {\n        throw new ERR_MODULE_NOT_FOUND(\n          resolved.pathname\x2C fileURLToPath(base)\x2C 'module');\n      }\n    }\n\n    path = file;\n  }\n\n  const stats = tryStatSync(StringPrototypeEndsWith(path\x2C '/') ?\n    StringPrototypeSlice(path\x2C -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path\x2C fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname\x2C base && fileURLToPath(base)\x2C 'module');\n  }\n\n  if (!preserveSymlinks) {\n    const real = realpathSync(path\x2C {\n      [internalFS.realpathCacheKey]: realpathCache\n    });\n    const { search\x2C hash } = resolved;\n    resolved =\n        pathToFileURL(real + (StringPrototypeEndsWith(path\x2C sep) ? '/' : ''));\n    resolved.search = search;\n    resolved.hash = hash;\n  }\n\n  return resolved;\n}\n\n/**\n * @param {string} specifier\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction throwImportNotDefined(specifier\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier\x2C packageJSONUrl && fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C\n    fileURLToPath(base));\n}\n\n/**\n * @param {string} subpath\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction throwExportsNotFound(subpath\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C\n    base && fileURLToPath(base));\n}\n\n/**\n *\n * @param {string | URL} subpath\n * @param {URL} packageJSONUrl\n * @param {boolean} internal\n * @param {string | URL | undefined} base\n */\nfunction throwInvalidSubpath(subpath\x2C packageJSONUrl\x2C internal\x2C base) {\n  const reason = `request is not a valid subpath for the "${internal ?\n    'imports' : 'exports'}" resolution of ${fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath\x2C reason\x2C\n                                         base && fileURLToPath(base));\n}\n\nfunction throwInvalidPackageTarget(\n  subpath\x2C target\x2C packageJSONUrl\x2C internal\x2C base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target\x2C null\x2C '');\n  } else {\n    target = `${target}`;\n  }\n  throw new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C target\x2C\n    internal\x2C base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\\\|\\/|$)/i;\nconst invalidPackageNameRegEx = /^\\.|%|\\\\/;\nconst patternRegEx = /\\*/g;\n\nfunction resolvePackageTargetString(\n  target\x2C subpath\x2C match\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C conditions) {\n\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (!StringPrototypeStartsWith(target\x2C './')) {\n    if (internal && !StringPrototypeStartsWith(target\x2C '../') &&\n        !StringPrototypeStartsWith(target\x2C '/')) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {\n        // Continue regardless of error.\n      }\n      if (!isURL) {\n        const exportTarget = pattern ?\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\n          target + subpath;\n        return packageResolve(\n          exportTarget\x2C packageJSONUrl\x2C conditions);\n      }\n    }\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C StringPrototypeSlice(target\x2C 2)))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  const resolved = new URL(target\x2C packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.'\x2C packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath\x2C packagePath))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (subpath === '') return resolved;\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C subpath)) {\n    const request = pattern ?\n      StringPrototypeReplace(match\x2C '*'\x2C () => subpath) : match + subpath;\n    throwInvalidSubpath(request\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (pattern) {\n    return new URL(\n      RegExpPrototypeSymbolReplace(\n        patternRegEx\x2C\n        resolved.href\x2C\n        () => subpath\n      )\n    );\n  }\n\n  return new URL(subpath\x2C resolved);\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\nfunction resolvePackageTarget(packageJSONUrl\x2C target\x2C subpath\x2C packageSubpath\x2C\n                              base\x2C pattern\x2C internal\x2C conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target\x2C subpath\x2C packageSubpath\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C\n      conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0) {\n      return null;\n    }\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolveResult;\n      try {\n        resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C targetItem\x2C subpath\x2C packageSubpath\x2C base\x2C pattern\x2C\n          internal\x2C conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET') {\n          continue;\n        }\n        throw e;\n      }\n      if (resolveResult === undefined) {\n        continue;\n      }\n      if (resolveResult === null) {\n        lastException = null;\n        continue;\n      }\n      return resolveResult;\n    }\n    if (lastException === undefined || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl)\x2C base\x2C\n          '"exports" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C conditionalTarget\x2C subpath\x2C packageSubpath\x2C base\x2C\n          pattern\x2C internal\x2C conditions);\n        if (resolveResult === undefined)\n          continue;\n        return resolveResult;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throwInvalidPackageTarget(packageSubpath\x2C target\x2C packageJSONUrl\x2C internal\x2C\n                            base);\n}\n\n/**\n *\n * @param {Exports} exports\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @returns {boolean}\n */\nfunction isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl)\x2C base\x2C\n        '"exports" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * @param {URL} packageJSONUrl\n * @param {string} packageSubpath\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageExportsResolve(\n  packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base))\n    exports = { '.': exports };\n\n  if (ObjectPrototypeHasOwnProperty(exports\x2C packageSubpath) &&\n      !StringPrototypeIncludes(packageSubpath\x2C '*') &&\n      !StringPrototypeEndsWith(packageSubpath\x2C '/')) {\n    const target = exports[packageSubpath];\n    const resolveResult = resolvePackageTarget(\n      packageJSONUrl\x2C target\x2C ''\x2C packageSubpath\x2C base\x2C false\x2C false\x2C conditions\n    );\n\n    if (resolveResult == null) {\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    }\n\n    return resolveResult;\n  }\n\n  let bestMatch = '';\n  let bestMatchSubpath;\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n    if (patternIndex !== -1 &&\n        StringPrototypeStartsWith(packageSubpath\x2C\n                                  StringPrototypeSlice(key\x2C 0\x2C patternIndex))) {\n      // When this reaches EOL\x2C this can throw at the top of the whole function:\n      //\n      // if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n      //   throwInvalidSubpath(packageSubpath)\n      //\n      // To match "imports" and the spec.\n      if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n        emitTrailingSlashPatternDeprecation(packageSubpath\x2C packageJSONUrl\x2C\n                                            base);\n      const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n      if (packageSubpath.length >= key.length &&\n          StringPrototypeEndsWith(packageSubpath\x2C patternTrailer) &&\n          patternKeyCompare(bestMatch\x2C key) === 1 &&\n          StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n        bestMatch = key;\n        bestMatchSubpath = StringPrototypeSlice(\n          packageSubpath\x2C patternIndex\x2C\n          packageSubpath.length - patternTrailer.length);\n      }\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const resolveResult = resolvePackageTarget(\n      packageJSONUrl\x2C\n      target\x2C\n      bestMatchSubpath\x2C\n      bestMatch\x2C\n      base\x2C\n      true\x2C\n      false\x2C\n      conditions);\n\n    if (resolveResult == null) {\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    }\n    return resolveResult;\n  }\n\n  throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n}\n\nfunction patternKeyCompare(a\x2C b) {\n  const aPatternIndex = StringPrototypeIndexOf(a\x2C '*');\n  const bPatternIndex = StringPrototypeIndexOf(b\x2C '*');\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLenA > baseLenB) return -1;\n  if (baseLenB > baseLenA) return 1;\n  if (aPatternIndex === -1) return 1;\n  if (bPatternIndex === -1) return -1;\n  if (a.length > b.length) return -1;\n  if (b.length > a.length) return 1;\n  return 0;\n}\n\n/**\n * @param {string} name\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageImportsResolve(name\x2C base\x2C conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name\x2C '#/') ||\n      StringPrototypeEndsWith(name\x2C '/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name\x2C reason\x2C fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports\x2C name) &&\n          !StringPrototypeIncludes(name\x2C '*')) {\n        const resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C imports[name]\x2C ''\x2C name\x2C base\x2C false\x2C true\x2C conditions\n        );\n        if (resolveResult != null) {\n          return resolveResult;\n        }\n      } else {\n        let bestMatch = '';\n        let bestMatchSubpath;\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n          if (patternIndex !== -1 &&\n              StringPrototypeStartsWith(name\x2C\n                                        StringPrototypeSlice(key\x2C 0\x2C\n                                                             patternIndex))) {\n            const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n            if (name.length >= key.length &&\n                StringPrototypeEndsWith(name\x2C patternTrailer) &&\n                patternKeyCompare(bestMatch\x2C key) === 1 &&\n                StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n              bestMatch = key;\n              bestMatchSubpath = StringPrototypeSlice(\n                name\x2C patternIndex\x2C name.length - patternTrailer.length);\n            }\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const resolveResult = resolvePackageTarget(packageJSONUrl\x2C target\x2C\n                                                     bestMatchSubpath\x2C\n                                                     bestMatch\x2C base\x2C true\x2C\n                                                     true\x2C conditions);\n          if (resolveResult != null) {\n            return resolveResult;\n          }\n        }\n      }\n    }\n  }\n  throwImportNotDefined(name\x2C packageJSONUrl\x2C base);\n}\n\n/**\n * @param {URL} url\n * @returns {PackageType}\n */\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {{ packageName: string\x2C packageSubpath: string\x2C isScoped: boolean }}\n */\nfunction parsePackageName(specifier\x2C base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier\x2C '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier\x2C '/'\x2C separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier\x2C 0\x2C separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // \\\\ separators.\n  if (RegExpPrototypeExec(invalidPackageNameRegEx\x2C packageName) !== null)\n    validPackageName = false;\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier\x2C 'is not a valid package name'\x2C fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier\x2C separatorIndex));\n\n  return { packageName\x2C packageSubpath\x2C isScoped };\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {resolved: URL\x2C format? : string}\n */\nfunction packageResolve(specifier\x2C base\x2C conditions) {\n  if (NativeModule.canBeRequiredByUsers(specifier))\n    return new URL('node:' + specifier);\n\n  const { packageName\x2C packageSubpath\x2C isScoped } =\n    parsePackageName(specifier\x2C base);\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName &&\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions);\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json'\x2C base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath\x2C 0\x2C\n                                                  packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json'\x2C packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJSONPath\x2C specifier\x2C base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions);\n    }\n    if (packageSubpath === '.') {\n      return legacyMainResolve(\n        packageJSONUrl\x2C\n        packageConfig\x2C\n        base\n      );\n    }\n\n    return new URL(packageSubpath\x2C packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName\x2C fileURLToPath(base));\n}\n\n/**\n * @param {string} specifier\n * @returns {boolean}\n */\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @param {boolean} preserveSymlinks\n * @returns {url: URL\x2C format?: string}\n */\nfunction moduleResolve(specifier\x2C base\x2C conditions\x2C preserveSymlinks) {\n  const isRemote = base.protocol === 'http:' ||\n    base.protocol === 'https:';\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier\x2C base);\n  } else if (!isRemote && specifier[0] === '#') {\n    resolved = packageImportsResolve(specifier\x2C base\x2C conditions);\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      if (!isRemote) {\n        resolved = packageResolve(specifier\x2C base\x2C conditions);\n      }\n    }\n  }\n  if (resolved.protocol !== 'file:') {\n    return resolved;\n  }\n  return finalizeResolution(resolved\x2C base\x2C preserveSymlinks);\n}\n\n/**\n * Try to resolve an import as a CommonJS module\n * @param {string} specifier\n * @param {string} parentURL\n * @returns {boolean|string}\n */\nfunction resolveAsCommonJS(specifier\x2C parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent\x2C null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier\x2C tmpModule\x2C false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent\x2C found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found\x2C `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier\x2C '/')[0];\n      const index = StringPrototypeIndexOf(found\x2C pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found\x2C index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = RegExpPrototypeSymbolReplace(new RegExp(`\\\\${sep}`\x2C 'g')\x2C\n                                           found\x2C '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\n// TODO(@JakobJingleheimer): de-dupe `specifier` & `parsed`\nfunction checkIfDisallowedImport(specifier\x2C parsed\x2C parsedParentURL) {\n  if (parsedParentURL) {\n    const parentURL = fileURLToPath(parsedParentURL?.href);\n\n    if (\n      parsedParentURL.protocol === 'http:' ||\n      parsedParentURL.protocol === 'https:'\n    ) {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // data: and blob: disallowed due to allowing file: access via\n        // indirection\n        if (parsed &&\n          parsed.protocol !== 'https:' &&\n          parsed.protocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier\x2C\n            parentURL\x2C\n            'remote imports cannot import from a local location.'\n          );\n        }\n\n        return { url: parsed.href };\n      }\n      if (NativeModule.canBeRequiredByUsers(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier\x2C\n          parentURL\x2C\n          'remote imports cannot import from a local location.'\n        );\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier\x2C\n        parentURL\x2C\n        'only relative and absolute specifiers are supported.'\n      );\n    }\n  }\n}\n\nfunction throwIfUnsupportedURLProtocol(url) {\n  if (url.protocol !== 'file:' && url.protocol !== 'data:' &&\n      url.protocol !== 'node:') {\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(url);\n  }\n}\n\nfunction throwIfUnsupportedURLScheme(parsed\x2C experimentalNetworkImports) {\n  if (\n    parsed &&\n    parsed.protocol !== 'file:' &&\n    parsed.protocol !== 'data:' &&\n    (\n      !experimentalNetworkImports ||\n      (\n        parsed.protocol !== 'https:' &&\n        parsed.protocol !== 'http:'\n      )\n    )\n  ) {\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed\x2C ArrayPrototypeConcat(\n      'file'\x2C\n      'data'\x2C\n      experimentalNetworkImports ? ['https'\x2C 'http'] : []\x2C\n    ));\n  }\n}\n\nasync function defaultResolve(specifier\x2C context = {}\x2C defaultResolveUnused) {\n  let { parentURL\x2C conditions } = context;\n  if (parentURL && policy?.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve\x2C reaction } = redirects;\n      const destination = resolve(specifier\x2C new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        // Prevent network requests from firing if resolution would be banned.\n        // Network requests can extract data by doing things like putting\n        // secrets in query params\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C '))\n        );\n      }\n    }\n  }\n\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  let parsed;\n  try {\n    if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n      parsed = new URL(specifier\x2C parsedParentURL);\n    } else {\n      parsed = new URL(specifier);\n    }\n\n    if (parsed.protocol === 'data:' ||\n      (experimentalNetworkImports &&\n        (\n          parsed.protocol === 'https:' ||\n          parsed.protocol === 'http:'\n        )\n      )\n    ) {\n      return { url: parsed.href };\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns\x2C DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier\x2C\n    parsed\x2C\n    parsedParentURL\x2C\n  );\n\n  if (maybeReturn) return maybeReturn;\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return { url: specifier };\n\n  throwIfUnsupportedURLScheme(parsed\x2C experimentalNetworkImports);\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n    // This is the initial entry point to the program\x2C and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval\x2C --print or STDIN string input. It is not allowed with file\n    // input\x2C to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only\x2C package scope surrounding the\n    // entry point\x2C etc.).\n    if (typeFlag) throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(\n      specifier\x2C\n      parentURL\x2C\n      conditions\x2C\n      isMain ? preserveSymlinksMain : preserveSymlinks\n    );\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier\x2C 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier\x2C parentURL);\n      if (found) {\n        // Modify the stack and message string to include the hint\n        const lines = StringPrototypeSplit(error.stack\x2C '\\n');\n        const hint = `Did you mean to import ${found}?`;\n        error.stack =\n          ArrayPrototypeShift(lines) + '\\n' +\n          hint + '\\n' +\n          ArrayPrototypeJoin(lines\x2C '\\n');\n        error.message += `\\n${hint}`;\n      }\n    }\n    throw error;\n  }\n\n  throwIfUnsupportedURLProtocol(url);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems\x2C silencing them\n    url: url.href\x2C\n    format: defaultGetFormatWithoutErrors(url\x2C context)\x2C\n  };\n}\n\nmodule.exports = {\n  DEFAULT_CONDITIONS\x2C\n  defaultResolve\x2C\n  encodedSepRegEx\x2C\n  getPackageScopeConfig\x2C\n  getPackageType\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\x2C\n};\n\n// cycle\nconst {\n  defaultGetFormatWithoutErrors\x2C\n} = require('internal/modules/esm/get_format');\n\nif (policy) {\n  const $defaultResolve = defaultResolve;\n  module.exports.defaultResolve = async function defaultResolve(\n    specifier\x2C\n    context\n  ) {\n    const ret = await $defaultResolve(specifier\x2C context\x2C $defaultResolve);\n    // This is a preflight check to avoid data exfiltration by query params etc.\n    policy.manifest.mightAllow(ret.url\x2C () =>\n      new ERR_MANIFEST_DEPENDENCY_MISSING(\n        context.parentURL\x2C\n        specifier\x2C\n        context.conditions\n      )\n    );\n    return ret;\n  };\n}\n
code-source-info,0x3172a1b39ede,110,0,39398,C0O0C4O39398,,
code-creation,Function,10,30167,0x3172a1b3afb6,1173, node:internal/modules/esm/resolve:1:1,0x3172a1b39e58,~
code-source-info,0x3172a1b3afb6,110,0,39398,C0O0C406O25C412O41C418O65C424O87C430O110C436O123C442O140C447O156C453O185C459O218C465O228C471O251C477O283C483O306C488O317C494O328C500O338C506O365C512O392C518O418C524O448C530O474C536O498C542O522C548O585C551O585C555O585C557O640C560O640C565O623C571O728C574O728C579O689C585O705C591O717C597O770C600O770C605O751C611O865C617O865C626O909C633O865C635O989C638O989C643O962C649O967C655O977C661O1031C667O1031C671O1031C673O1099C679O1099C683O1099C685O1180C691O1180C695O1180C697O1247C703O1247C707O1247C709O1325C712O1325C717O1287C723O1292C729O1307C735O1732C738O1732C743O1758C748O1360C754O1390C760O1415C766O1447C772O1477C778O1507C784O1542C790O1566C796O1600C802O1633C808O1663C814O1696C820O1796C823O1796C828O1782C834O1863C837O1863C841O1863C843O1935C849O1935C854O1984C860O1984C865O2039C876O2100C883O2142C884O2142C938O2164C989O2100C993O2100C995O2216C1003O2216C1008O2216C1010O2533C1013O2533C1018O2533C1020O4822C1022O4822C1027O4822C1029O4862C1031O4862C1036O4862C1038O5001C1042O5001C1044O10312C1048O10312C1050O11286C1054O11286C1056O14596C1060O14596C1062O14799C1066O14799C1068O14832C1072O14832C1074O38613C1081O38634C1087O38656C1093O38674C1099O38693C1105O38718C1111O38736C1117O38761C1123O38628C1127O38842C1130O38842C1135O38807C1141O38887C1152O38927C1154O38927C1156O38952C1165O38975C1172O39397,,
tick,0x1bfc5a984,30250,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x3172a1b32c72,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,Eval,10,30334,0x3172a1b3e886,5, node:internal/modules/esm/get_format:1:1,0x3172a1b3e640,~
script-source,111,node:internal/modules/esm/get_format,'use strict';\nconst {\n  RegExpPrototypeExec\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n} = primordials;\nconst { extname } = require('path');\nconst { getOptionValue } = require('internal/options');\nconst { fetchModule } = require('internal/modules/esm/fetch_module');\nconst {\n  extensionFormatMap\x2C\n  getLegacyExtensionFormat\x2C\n  mimeToFormat\x2C\n} = require('internal/modules/esm/formats');\n\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\nconst experimentalSpecifierResolution =\n  getOptionValue('--experimental-specifier-resolution');\nconst { getPackageType } = require('internal/modules/esm/resolve');\nconst { URL\x2C fileURLToPath } = require('internal/url');\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require('internal/errors').codes;\n\nconst protocolHandlers = ObjectAssign(ObjectCreate(null)\x2C {\n  'data:': getDataProtocolModuleFormat\x2C\n  'file:': getFileProtocolModuleFormat\x2C\n  'http:': getHttpProtocolModuleFormat\x2C\n  'https:': getHttpProtocolModuleFormat\x2C\n  'node:'() { return 'builtin'; }\x2C\n});\n\nfunction getDataProtocolModuleFormat(parsed) {\n  const { 1: mime } = RegExpPrototypeExec(\n    /^([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n    parsed.pathname\x2C\n  ) || [ null\x2C null\x2C null ];\n\n  return mimeToFormat(mime);\n}\n\nfunction getFileProtocolModuleFormat(url\x2C context\x2C ignoreErrors) {\n  const ext = extname(url.pathname);\n  if (ext === '.js') {\n    return getPackageType(url) === 'module' ? 'module' : 'commonjs';\n  }\n\n  const format = extensionFormatMap[ext];\n  if (format) return format;\n\n  if (experimentalSpecifierResolution !== 'node') {\n    // Explicit undefined return indicates load hook should rerun format check\n    if (ignoreErrors) return undefined;\n    throw new ERR_UNKNOWN_FILE_EXTENSION(ext\x2C fileURLToPath(url));\n  }\n\n  return getLegacyExtensionFormat(ext) ?? null;\n}\n\nfunction getHttpProtocolModuleFormat(url\x2C context) {\n  if (experimentalNetworkImports) {\n    return PromisePrototypeThen(\n      PromiseResolve(fetchModule(url\x2C context))\x2C\n      (entry) => {\n        return mimeToFormat(entry.headers['content-type']);\n      }\n    );\n  }\n}\n\nfunction defaultGetFormatWithoutErrors(url\x2C context) {\n  const parsed = new URL(url);\n  if (!ObjectPrototypeHasOwnProperty(protocolHandlers\x2C parsed.protocol))\n    return null;\n  return protocolHandlers[parsed.protocol](parsed\x2C context\x2C true);\n}\n\nfunction defaultGetFormat(url\x2C context) {\n  const parsed = new URL(url);\n  return ObjectPrototypeHasOwnProperty(protocolHandlers\x2C parsed.protocol) ?\n    protocolHandlers[parsed.protocol](parsed\x2C context\x2C false) :\n    null;\n}\n\nmodule.exports = {\n  defaultGetFormat\x2C\n  defaultGetFormatWithoutErrors\x2C\n  extensionFormatMap\x2C\n};\n
code-source-info,0x3172a1b3e886,111,0,2721,C0O0C4O2721,,
code-creation,Function,10,30459,0x3172a1b3ece6,332, node:internal/modules/esm/get_format:1:1,0x3172a1b3e800,~
code-source-info,0x3172a1b3ece6,111,0,2721,C0O0C78O24C84O47C89O63C94O79C100O112C106O136C112O189C115O189C120O177C126O233C129O233C134O214C139O286C142O286C147O270C153O410C156O410C161O342C167O364C173O392C179O489C182O489C186O489C188O581C191O581C195O581C197O663C200O663C205O644C211O735C214O735C219O712C225O717C231O799C234O799C239O825C244O768C250O859C252O872C264O905C270O945C276O985C282O1026C286O1057C294O859C299O859C301O2624C308O2645C314O2665C320O2698C326O2639C331O2720,,
code-creation,Eval,10,30584,0x3172a1b3fa2e,5, node:internal/modules/esm/fetch_module:1:1,0x3172a1b3f758,~
script-source,112,node:internal/modules/esm/fetch_module,'use strict';\nconst {\n  ObjectPrototypeHasOwnProperty\x2C\n  PromisePrototypeThen\x2C\n  SafeMap\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  Buffer: { concat: BufferConcat }\x2C\n} = require('buffer');\nconst {\n  ERR_NETWORK_IMPORT_DISALLOWED\x2C\n  ERR_NETWORK_IMPORT_BAD_RESPONSE\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n} = require('internal/errors').codes;\nconst { URL } = require('internal/url');\nconst net = require('net');\nconst { once } = require('events');\nconst { compose } = require('stream');\n/**\n * @typedef CacheEntry\n * @property {Promise<string> | string} resolvedHREF\n * @property {Record<string\x2C string>} headers\n * @property {Promise<Buffer> | Buffer} body\n */\n\n/**\n * Only for GET requests\x2C other requests would need new Map\n * HTTP cache semantics keep diff caches\n *\n * It caches either the promise or the cache entry since import.meta.url needs\n * the value synchronously for the response location after all redirects.\n *\n * Maps HREF to pending cache entry\n * @type {Map<string\x2C Promise<CacheEntry> | CacheEntry>}\n */\nconst cacheForGET = new SafeMap();\n\n// [1] The V8 snapshot doesn't like some C++ APIs to be loaded eagerly. Do it\n// lazily/at runtime and not top level of an internal module.\n\n// [2] Creating a new agent instead of using the gloabl agent improves\n// performance and precludes the agent becoming tainted.\n\nlet HTTPSAgent;\nfunction HTTPSGet(url\x2C opts) {\n  const https = require('https'); // [1]\n  HTTPSAgent ??= new https.Agent({ // [2]\n    keepAlive: true\x2C\n  });\n  return https.get(url\x2C {\n    agent: HTTPSAgent\x2C\n    ...opts\x2C\n  });\n}\n\nlet HTTPAgent;\nfunction HTTPGet(url\x2C opts) {\n  const http = require('http'); // [1]\n  HTTPAgent ??= new http.Agent({ // [2]\n    keepAlive: true\x2C\n  });\n  return http.get(url\x2C {\n    agent: HTTPAgent\x2C\n    ...opts\x2C\n  });\n}\n\nfunction dnsLookup(name\x2C opts) {\n  // eslint-disable-next-line no-func-assign\n  dnsLookup = require('dns/promises').lookup;\n  return dnsLookup(name\x2C opts);\n}\n\nlet zlib;\nfunction createBrotliDecompress() {\n  zlib ??= require('zlib'); // [1]\n  // eslint-disable-next-line no-func-assign\n  createBrotliDecompress = zlib.createBrotliDecompress;\n  return createBrotliDecompress();\n}\n\nfunction createUnzip() {\n  zlib ??= require('zlib'); // [1]\n  // eslint-disable-next-line no-func-assign\n  createUnzip = zlib.createUnzip;\n  return createUnzip();\n}\n\n/**\n * @param {URL} parsed\n * @returns {Promise<CacheEntry> | CacheEntry}\n */\nfunction fetchWithRedirects(parsed) {\n  const existing = cacheForGET.get(parsed.href);\n  if (existing) {\n    return existing;\n  }\n  const handler = parsed.protocol === 'http:' ? HTTPGet : HTTPSGet;\n  const result = (async () => {\n    const req = handler(parsed\x2C {\n      headers: { Accept: '*/*' }\x2C\n    });\n    // Note that `once` is used here to handle `error` and that it hits the\n    // `finally` on network error/timeout.\n    const { 0: res } = await once(req\x2C 'response');\n    try {\n      const isRedirect = res.statusCode >= 300 && res.statusCode <= 303;\n      const hasLocation = ObjectPrototypeHasOwnProperty(res.headers\x2C 'location');\n      if (isRedirect && hasLocation) {\n        const location = new URL(res.headers.location\x2C parsed);\n        if (location.protocol !== 'http:' && location.protocol !== 'https:') {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            res.headers.location\x2C\n            parsed.href\x2C\n            'cannot redirect to non-network location'\n          );\n        }\n        const entry = await fetchWithRedirects(location);\n        cacheForGET.set(parsed.href\x2C entry);\n        return entry;\n      }\n      if (res.statusCode === 404) {\n        const err = new ERR_MODULE_NOT_FOUND(parsed.href\x2C null);\n        err.message = `Cannot find module '${parsed.href}'\x2C HTTP 404`;\n        throw err;\n      }\n      if (res.statusCode > 303 || res.statusCode < 200) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          res.headers.location\x2C\n          parsed.href\x2C\n          'cannot redirect to non-network location');\n      }\n      const { headers } = res;\n      const contentType = headers['content-type'];\n      if (!contentType) {\n        throw new ERR_NETWORK_IMPORT_BAD_RESPONSE(\n          parsed.href\x2C\n          "the 'Content-Type' header is required"\n        );\n      }\n      /**\n       * @type {CacheEntry}\n       */\n      const entry = {\n        resolvedHREF: parsed.href\x2C\n        headers: {\n          'content-type': res.headers['content-type']\x2C\n        }\x2C\n        body: (async () => {\n          let bodyStream = res;\n          if (res.headers['content-encoding'] === 'br') {\n            bodyStream = compose(res\x2C createBrotliDecompress());\n          } else if (\n            res.headers['content-encoding'] === 'gzip' ||\n            res.headers['content-encoding'] === 'deflate'\n          ) {\n            bodyStream = compose(res\x2C createUnzip());\n          }\n          const buffers = await bodyStream.toArray();\n          const body = BufferConcat(buffers);\n          entry.body = body;\n          return body;\n        })()\x2C\n      };\n      cacheForGET.set(parsed.href\x2C entry);\n      await entry.body;\n      return entry;\n    } finally {\n      req.destroy();\n    }\n  })();\n  cacheForGET.set(parsed.href\x2C result);\n  return result;\n}\n\nconst allowList = new net.BlockList();\nallowList.addAddress('::1'\x2C 'ipv6');\nallowList.addRange('127.0.0.1'\x2C '127.255.255.255');\n\n/**\n * Returns if an address has local status by if it is going to a local\n * interface or is an address resolved by DNS to be a local interface\n * @param {string} hostname url.hostname to test\n * @returns {Promise<boolean>}\n */\nasync function isLocalAddress(hostname) {\n  try {\n    if (\n      StringPrototypeStartsWith(hostname\x2C '[') &&\n      StringPrototypeEndsWith(hostname\x2C ']')\n    ) {\n      hostname = StringPrototypeSlice(hostname\x2C 1\x2C -1);\n    }\n    const addr = await dnsLookup(hostname\x2C { verbatim: true });\n    const ipv = addr.family === 4 ? 'ipv4' : 'ipv6';\n    return allowList.check(addr.address\x2C ipv);\n  } catch {\n    // If it errored\x2C the answer is no.\n  }\n  return false;\n}\n\n/**\n * Fetches a location with a shared cache following redirects.\n * Does not respect HTTP cache headers.\n *\n * This splits the header and body Promises so that things only needing\n * headers don't need to wait on the body.\n *\n * In cases where the request & response have already settled\x2C this returns the\n * cache value synchronously.\n *\n * @param {URL} parsed\n * @param {ESModuleContext} context\n * @returns {ReturnType<typeof fetchWithRedirects>}\n */\nfunction fetchModule(parsed\x2C { parentURL }) {\n  const { href } = parsed;\n  const existing = cacheForGET.get(href);\n  if (existing) {\n    return existing;\n  }\n  if (parsed.protocol === 'http:') {\n    return PromisePrototypeThen(isLocalAddress(parsed.hostname)\x2C (is) => {\n      if (is !== true) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          href\x2C\n          parentURL\x2C\n          'http can only be used to load local resources (use https instead).'\n        );\n      }\n      return fetchWithRedirects(parsed);\n    });\n  }\n  return fetchWithRedirects(parsed);\n}\n\nmodule.exports = {\n  fetchModule: fetchModule\x2C\n};\n
code-source-info,0x3172a1b3fa2e,112,0,7132,C0O0C4O7132,,
code-creation,Function,10,30834,0x3172a1b3fe8e,349, node:internal/modules/esm/fetch_module:1:1,0x3172a1b3f9a8,~
code-source-info,0x3172a1b3fe8e,112,0,7132,C0O0C107O24C113O57C119O81C124O92C130O119C136O143C142O235C148O235C153O235C158O215C164O358C170O358C175O384C180O264C186O297C192O332C198O408C204O408C209O400C215O445C221O445C226O478C232O478C237O469C243O517C249O517C254O505C260O1093C262O1093C267O1093C269O1383C270O1383C272O1611C273O1611C275O1990C276O1990C278O5259C283O5251C288O5251C290O5272C293O5282C304O5282C310O5309C313O5319C324O5319C330O7082C337O7116C343O7097C348O7131,,
tick,0x10090e028,30875,1,0x10041f4d8,2,0x0,0x105108c5c,0x10510894c,0x3172a1b3ed74,0x105108d28,0x10510894c,0x3172a1b3b420,0x105108d28,0x10510894c,0x3172a1b32c72,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
new,MemoryChunk,0x120d44380000,262144
code-creation,Eval,10,31417,0x120d44381d3e,5, node:net:1:1,0x120d44381540,~
script-source,113,node:net,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIndexOf\x2C\n  Boolean\x2C\n  Number\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\nconst stream = require('stream');\nlet debug = require('internal/util/debuglog').debuglog('net'\x2C (fn) => {\n  debug = fn;\n});\nconst {\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  normalizedArgsSymbol\x2C\n  makeSyncWrite\n} = require('internal/net');\nconst assert = require('internal/assert');\nconst {\n  UV_EADDRINUSE\x2C\n  UV_EINVAL\x2C\n  UV_ENOTCONN\n} = internalBinding('uv');\n\nconst { Buffer } = require('buffer');\nconst { guessHandleType } = internalBinding('util');\nconst { ShutdownWrap } = internalBinding('stream_wrap');\nconst {\n  TCP\x2C\n  TCPConnectWrap\x2C\n  constants: TCPConstants\n} = internalBinding('tcp_wrap');\nconst {\n  Pipe\x2C\n  PipeConnectWrap\x2C\n  constants: PipeConstants\n} = internalBinding('pipe_wrap');\nconst {\n  newAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol\x2C owner_symbol }\n} = require('internal/async_hooks');\nconst {\n  writevGeneric\x2C\n  writeGeneric\x2C\n  onStreamRead\x2C\n  kAfterAsyncWrite\x2C\n  kHandle\x2C\n  kUpdateTimer\x2C\n  setStreamTimeout\x2C\n  kBuffer\x2C\n  kBufferCb\x2C\n  kBufferGen\n} = require('internal/stream_base_commons');\nconst {\n  codes: {\n    ERR_INVALID_ADDRESS_FAMILY\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FD_TYPE\x2C\n    ERR_INVALID_IP_ADDRESS\x2C\n    ERR_SERVER_ALREADY_LISTEN\x2C\n    ERR_SERVER_NOT_RUNNING\x2C\n    ERR_SOCKET_CLOSED\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n  errnoException\x2C\n  exceptionWithHostPort\x2C\n  genericNodeError\x2C\n  uvExceptionWithHostPort\x2C\n} = require('internal/errors');\nconst { isUint8Array } = require('internal/util/types');\nconst {\n  validateAbortSignal\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateNumber\x2C\n  validatePort\x2C\n  validateString\n} = require('internal/validators');\nconst kLastWriteQueueSize = Symbol('lastWriteQueueSize');\nconst {\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\n} = require('internal/dtrace');\n\n// Lazy loaded to improve startup performance.\nlet cluster;\nlet dns;\nlet BlockList;\nlet SocketAddress;\n\nconst { clearTimeout } = require('timers');\nconst { kTimeout } = require('internal/timers');\n\nconst DEFAULT_IPV4_ADDR = '0.0.0.0';\nconst DEFAULT_IPV6_ADDR = '::';\n\nconst isWindows = process.platform === 'win32';\n\nconst noop = () => {};\n\nfunction getFlags(ipv6Only) {\n  return ipv6Only === true ? TCPConstants.UV_TCP_IPV6ONLY : 0;\n}\n\nfunction createHandle(fd\x2C is_server) {\n  validateInt32(fd\x2C 'fd'\x2C 0);\n  const type = guessHandleType(fd);\n  if (type === 'PIPE') {\n    return new Pipe(\n      is_server ? PipeConstants.SERVER : PipeConstants.SOCKET\n    );\n  }\n\n  if (type === 'TCP') {\n    return new TCP(\n      is_server ? TCPConstants.SERVER : TCPConstants.SOCKET\n    );\n  }\n\n  throw new ERR_INVALID_FD_TYPE(type);\n}\n\n\nfunction getNewAsyncId(handle) {\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\n    newAsyncId() : handle.getAsyncId();\n}\n\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n\n/**\n * Creates a new TCP or IPC server\n * @param {{\n *   allowHalfOpen?: boolean;\n *   pauseOnConnect?: boolean;\n *   }} [options]\n * @param {Function} [connectionListener]\n * @returns {Server}\n */\n\nfunction createServer(options\x2C connectionListener) {\n  return new Server(options\x2C connectionListener);\n}\n\n\n// Target API:\n//\n// let s = net.connect({port: 80\x2C host: 'google.com'}\x2C function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options\x2C [cb])\n// connect(port\x2C [host]\x2C [cb])\n// connect(path\x2C [cb]);\n//\nfunction connect(...args) {\n  const normalized = normalizeArgs(args);\n  const options = normalized[0];\n  debug('createConnection'\x2C normalized);\n  const socket = new Socket(options);\n\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n\n  return socket.connect(normalized);\n}\n\n\n// Returns an array [options\x2C cb]\x2C where options is an object\x2C\n// cb is either a function or null.\n// Used to normalize arguments of Socket.prototype.connect() and\n// Server.prototype.listen(). Possible combinations of parameters:\n//   (options[...][\x2C cb])\n//   (path[...][\x2C cb])\n//   ([port][\x2C host][...][\x2C cb])\n// For Socket.prototype.connect()\x2C the [...] part is ignored\n// For Server.prototype.listen()\x2C the [...] part is [\x2C backlog]\n// but will not be handled here (handled in listen())\nfunction normalizeArgs(args) {\n  let arr;\n\n  if (args.length === 0) {\n    arr = [{}\x2C null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n\n  const arg0 = args[0];\n  let options = {};\n  if (typeof arg0 === 'object' && arg0 !== null) {\n    // (options[...][\x2C cb])\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    // (path[...][\x2C cb])\n    options.path = arg0;\n  } else {\n    // ([port][\x2C host][...][\x2C cb])\n    options.port = arg0;\n    if (args.length > 1 && typeof args[1] === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  const cb = args[args.length - 1];\n  if (typeof cb !== 'function')\n    arr = [options\x2C null];\n  else\n    arr = [options\x2C cb];\n\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\n\n\n// Called when creating new Socket\x2C or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._sockname = null;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle[owner_symbol] = self;\n    self._handle.onread = onStreamRead;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n\n    let userBuf = self[kBuffer];\n    if (userBuf) {\n      const bufGen = self[kBufferGen];\n      if (bufGen !== null) {\n        userBuf = bufGen();\n        if (!isUint8Array(userBuf))\n          return;\n        self[kBuffer] = userBuf;\n      }\n      self._handle.useUserBuffer(userBuf);\n    }\n  }\n}\n\n\nconst kBytesRead = Symbol('kBytesRead');\nconst kBytesWritten = Symbol('kBytesWritten');\nconst kSetNoDelay = Symbol('kSetNoDelay');\nconst kSetKeepAlive = Symbol('kSetKeepAlive');\nconst kSetKeepAliveInitialDelay = Symbol('kSetKeepAliveInitialDelay');\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n  if (options?.objectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'options.objectMode'\x2C\n      options.objectMode\x2C\n      'is not supported'\n    );\n  } else if (options?.readableObjectMode || options?.writableObjectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      `options.${\n        options.readableObjectMode ? 'readableObjectMode' : 'writableObjectMode'\n      }`\x2C\n      options.readableObjectMode || options.writableObjectMode\x2C\n      'is not supported'\n    );\n  }\n  if (typeof options?.keepAliveInitialDelay !== 'undefined') {\n    validateNumber(\n      options?.keepAliveInitialDelay\x2C 'options.keepAliveInitialDelay'\n    );\n\n    if (options.keepAliveInitialDelay < 0) {\n      options.keepAliveInitialDelay = 0;\n    }\n  }\n\n  this.connecting = false;\n  // Problem with this is that users can supply their own handle\x2C that may not\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\n  // probably be supplied by async_hooks.\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this[kHandle] = null;\n  this._parent = null;\n  this._host = null;\n  this[kLastWriteQueueSize] = 0;\n  this[kTimeout] = null;\n  this[kBuffer] = null;\n  this[kBufferCb] = null;\n  this[kBufferGen] = null;\n\n  if (typeof options === 'number')\n    options = { fd: options }; // Legacy interface.\n  else\n    options = { ...options };\n\n  // Default to *not* allowing half open sockets.\n  options.allowHalfOpen = Boolean(options.allowHalfOpen);\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = true;\n  // Handle strings directly.\n  options.decodeStrings = false;\n  stream.Duplex.call(this\x2C options);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== undefined) {\n    const { fd } = options;\n    let err;\n\n    // createHandle will throw ERR_INVALID_FD_TYPE if `fd` is not\n    // a valid `PIPE` or `TCP` descriptor\n    this._handle = createHandle(fd\x2C false);\n\n    err = this._handle.open(fd);\n\n    // While difficult to fabricate\x2C in some architectures\n    // `open` may return an error code for valid file descriptors\n    // which cannot be opened. This is difficult to test as most\n    // un-openable fds will throw on `createHandle`\n    if (err)\n      throw errnoException(err\x2C 'open');\n\n    this[async_id_symbol] = this._handle.getAsyncId();\n\n    if ((fd === 1 || fd === 2) &&\n        (this._handle instanceof Pipe) && isWindows) {\n      // Make stdout and stderr blocking on Windows\n      err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err\x2C 'setBlocking');\n\n      this._writev = null;\n      this._write = makeSyncWrite(fd);\n      // makeSyncWrite adjusts this value like the original handle would\x2C so\n      // we need to let it do that by turning it into a writable\x2C own\n      // property.\n      ObjectDefineProperty(this._handle\x2C 'bytesWritten'\x2C {\n        value: 0\x2C writable: true\n      });\n    }\n  }\n\n  const onread = options.onread;\n  if (onread !== null && typeof onread === 'object' &&\n      (isUint8Array(onread.buffer) || typeof onread.buffer === 'function') &&\n      typeof onread.callback === 'function') {\n    if (typeof onread.buffer === 'function') {\n      this[kBuffer] = true;\n      this[kBufferGen] = onread.buffer;\n    } else {\n      this[kBuffer] = onread.buffer;\n    }\n    this[kBufferCb] = onread.callback;\n  }\n\n  this[kSetNoDelay] = Boolean(options.noDelay);\n  this[kSetKeepAlive] = Boolean(options.keepAlive);\n  this[kSetKeepAliveInitialDelay] = ~~(options.keepAliveInitialDelay / 1000);\n\n  // Shut down the socket when we're finished with it.\n  this.on('end'\x2C onReadableStreamEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // If we have a handle\x2C then start the flow of data into the\n  // buffer.  if not\x2C then this will happen when we connect\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      // Stop the handle from reading and pause the stream\n      this._handle.reading = false;\n      this._handle.readStop();\n      this.readableFlowing = false;\n    } else if (!options.manualStart) {\n      this.read(0);\n    }\n  }\n\n  // Reserve properties\n  this.server = null;\n  this._server = null;\n\n  // Used after `.destroy()`\n  this[kBytesRead] = 0;\n  this[kBytesWritten] = 0;\n}\nObjectSetPrototypeOf(Socket.prototype\x2C stream.Duplex.prototype);\nObjectSetPrototypeOf(Socket\x2C stream.Duplex);\n\n// Refresh existing timeouts.\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (let s = this; s !== null; s = s._parent) {\n    if (s[kTimeout])\n      s[kTimeout].refresh();\n  }\n};\n\n\n// The user has called .end()\x2C and all the bytes have been\n// sent out to the other side.\nSocket.prototype._final = function(cb) {\n  // If still connecting - defer handling `_final` until 'connect' will happen\n  if (this.pending) {\n    debug('_final: not yet connected');\n    return this.once('connect'\x2C () => this._final(cb));\n  }\n\n  if (!this._handle)\n    return cb();\n\n  debug('_final: not ended\x2C call shutdown()');\n\n  const req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = this._handle;\n  req.callback = cb;\n  const err = this._handle.shutdown(req);\n\n  if (err === 1 || err === UV_ENOTCONN)  // synchronous finish\n    return cb();\n  else if (err !== 0)\n    return cb(errnoException(err\x2C 'shutdown'));\n};\n\nfunction afterShutdown() {\n  const self = this.handle[owner_symbol];\n\n  debug('afterShutdown destroyed=%j'\x2C self.destroyed\x2C\n        self._readableState);\n\n  this.callback();\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague\x2C and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk\x2C encoding\x2C cb) {\n  if (!this.writableEnded) {\n    return stream.Duplex.prototype.write.call(this\x2C chunk\x2C encoding\x2C cb);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  const er = genericNodeError(\n    'This socket has been ended by the other party'\x2C\n    { code: 'EPIPE' }\n  );\n  if (typeof cb === 'function') {\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C process.nextTick\x2C cb\x2C er);\n  }\n  this.destroy(er);\n\n  return false;\n}\n\nSocket.prototype.setTimeout = setStreamTimeout;\n\n\nSocket.prototype._onTimeout = function() {\n  const handle = this._handle;\n  const lastWriteQueueSize = this[kLastWriteQueueSize];\n  if (lastWriteQueueSize > 0 && handle) {\n    // `lastWriteQueueSize !== writeQueueSize` means there is\n    // an active write in progress\x2C so we suppress the timeout.\n    const { writeQueueSize } = handle;\n    if (lastWriteQueueSize !== writeQueueSize) {\n      this[kLastWriteQueueSize] = writeQueueSize;\n      this._unrefTimer();\n      return;\n    }\n  }\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  // Backwards compatibility: assume true when `enable` is omitted\n  enable = Boolean(enable === undefined ? true : enable);\n\n  if (!this._handle) {\n    this[kSetNoDelay] = enable;\n    return this;\n  }\n\n  if (this._handle.setNoDelay && enable !== this[kSetNoDelay]) {\n    this[kSetNoDelay] = enable;\n    this._handle.setNoDelay(enable);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.setKeepAlive = function(enable\x2C initialDelayMsecs) {\n  enable = Boolean(enable);\n  const initialDelay = ~~(initialDelayMsecs / 1000);\n\n  if (!this._handle) {\n    this[kSetKeepAlive] = enable;\n    this[kSetKeepAliveInitialDelay] = initialDelay;\n    return this;\n  }\n\n  if (this._handle.setKeepAlive && enable !== this[kSetKeepAlive]) {\n    this[kSetKeepAlive] = enable;\n    this[kSetKeepAliveInitialDelay] = initialDelay;\n    this._handle.setKeepAlive(enable\x2C initialDelay);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObjectDefineProperty(Socket.prototype\x2C '_connecting'\x2C {\n  get: function() {\n    return this.connecting;\n  }\n});\n\nObjectDefineProperty(Socket.prototype\x2C 'pending'\x2C {\n  get() {\n    return !this._handle || this.connecting;\n  }\x2C\n  configurable: true\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'readyState'\x2C {\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    }\n    return 'closed';\n  }\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'bufferSize'\x2C {\n  get: function() {\n    if (this._handle) {\n      return this.writableLength;\n    }\n  }\n});\n\nObjectDefineProperty(Socket.prototype\x2C kUpdateTimer\x2C {\n  get: function() {\n    return this._unrefTimer;\n  }\n});\n\n\nfunction tryReadStart(socket) {\n  // Not already reading\x2C start the flow\n  debug('Socket._handle.readStart');\n  socket._handle.reading = true;\n  const err = socket._handle.readStart();\n  if (err)\n    socket.destroy(errnoException(err\x2C 'read'));\n}\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug('_read');\n\n  if (this.connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect'\x2C () => this._read(n));\n  } else if (!this._handle.reading) {\n    tryReadStart(this);\n  }\n};\n\n\nSocket.prototype.end = function(data\x2C encoding\x2C callback) {\n  stream.Duplex.prototype.end.call(this\x2C\n                                   data\x2C encoding\x2C callback);\n  DTRACE_NET_STREAM_END(this);\n  return this;\n};\n\n\nSocket.prototype.pause = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      this._handle.reading) {\n    this._handle.reading = false;\n    if (!this.destroyed) {\n      const err = this._handle.readStop();\n      if (err)\n        this.destroy(errnoException(err\x2C 'read'));\n    }\n  }\n  return stream.Duplex.prototype.pause.call(this);\n};\n\n\nSocket.prototype.resume = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.resume.call(this);\n};\n\n\nSocket.prototype.read = function(n) {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.read.call(this\x2C n);\n};\n\n\n// Called when the 'end' event is emitted.\nfunction onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this.writableFinished)\n    this.destroy();\n  else\n    this.once('finish'\x2C this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception\x2C cb) {\n  debug('destroy');\n\n  this.connecting = false;\n\n  for (let s = this; s !== null; s = s._parent) {\n    clearTimeout(s[kTimeout]);\n  }\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    const isException = exception ? true : false;\n    // `bytesRead` and `kBytesWritten` should be accessible after `.destroy()`\n    this[kBytesRead] = this._handle.bytesRead;\n    this[kBytesWritten] = this._handle.bytesWritten;\n\n    this._handle.close(() => {\n      debug('emit close');\n      this.emit('close'\x2C isException);\n    });\n    this._handle.onread = noop;\n    this._handle = null;\n    this._sockname = null;\n    cb(exception);\n  } else {\n    cb(exception);\n    process.nextTick(emitCloseNT\x2C this);\n  }\n\n  if (this._server) {\n    debug('has server');\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n\nSocket.prototype._getpeername = function() {\n  if (!this._handle || !this._handle.getpeername) {\n    return this._peername || {};\n  } else if (!this._peername) {\n    this._peername = {};\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\n    this._handle.getpeername(this._peername);\n  }\n  return this._peername;\n};\n\nfunction protoGetter(name\x2C callback) {\n  ObjectDefineProperty(Socket.prototype\x2C name\x2C {\n    configurable: false\x2C\n    enumerable: true\x2C\n    get: callback\n  });\n}\n\nprotoGetter('bytesRead'\x2C function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[kBytesRead];\n});\n\nprotoGetter('remoteAddress'\x2C function remoteAddress() {\n  return this._getpeername().address;\n});\n\nprotoGetter('remoteFamily'\x2C function remoteFamily() {\n  return this._getpeername().family;\n});\n\nprotoGetter('remotePort'\x2C function remotePort() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  } else if (!this._sockname) {\n    this._sockname = {};\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\n    this._handle.getsockname(this._sockname);\n  }\n  return this._sockname;\n};\n\n\nprotoGetter('localAddress'\x2C function localAddress() {\n  return this._getsockname().address;\n});\n\n\nprotoGetter('localPort'\x2C function localPort() {\n  return this._getsockname().port;\n});\n\n\nSocket.prototype[kAfterAsyncWrite] = function() {\n  this[kLastWriteQueueSize] = 0;\n};\n\nSocket.prototype._writeGeneric = function(writev\x2C data\x2C encoding\x2C cb) {\n  // If we are still connecting\x2C then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect'\x2C function connect() {\n      this._writeGeneric(writev\x2C data\x2C encoding\x2C cb);\n    });\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  if (!this._handle) {\n    cb(new ERR_SOCKET_CLOSED());\n    return false;\n  }\n\n  this._unrefTimer();\n\n  let req;\n  if (writev)\n    req = writevGeneric(this\x2C data\x2C cb);\n  else\n    req = writeGeneric(this\x2C data\x2C encoding\x2C cb);\n  if (req.async)\n    this[kLastWriteQueueSize] = req.bytes;\n};\n\n\nSocket.prototype._writev = function(chunks\x2C cb) {\n  this._writeGeneric(true\x2C chunks\x2C ''\x2C cb);\n};\n\n\nSocket.prototype._write = function(data\x2C encoding\x2C cb) {\n  this._writeGeneric(false\x2C data\x2C encoding\x2C cb);\n};\n\n\n// Legacy alias. Having this is probably being overly cautious\x2C but it doesn't\n// really hurt anyone either. This can probably be removed safely if desired.\nprotoGetter('_bytesDispatched'\x2C function _bytesDispatched() {\n  return this._handle ? this._handle.bytesWritten : this[kBytesWritten];\n});\n\nprotoGetter('bytesWritten'\x2C function bytesWritten() {\n  let bytes = this._bytesDispatched;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n  const writableBuffer = this.writableBuffer;\n\n  if (!writableBuffer)\n    return undefined;\n\n  for (const el of writableBuffer) {\n    bytes += el.chunk instanceof Buffer ?\n      el.chunk.length :\n      Buffer.byteLength(el.chunk\x2C el.encoding);\n  }\n\n  if (ArrayIsArray(data)) {\n    // Was a writev\x2C iterate over chunks to get total length\n    for (let i = 0; i < data.length; i++) {\n      const chunk = data[i];\n\n      if (data.allBuffers || chunk instanceof Buffer)\n        bytes += chunk.length;\n      else\n        bytes += Buffer.byteLength(chunk.chunk\x2C chunk.encoding);\n    }\n  } else if (data) {\n    // Writes are either a string or a Buffer.\n    if (typeof data !== 'string')\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data\x2C encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction checkBindError(err\x2C port\x2C handle) {\n  // EADDRINUSE may not be reported until we call listen() or connect().\n  // To complicate matters\x2C a failed bind() followed by listen() or connect()\n  // will implicitly bind to a random port. Ergo\x2C check that the socket is\n  // bound to the expected port before calling listen() or connect().\n  //\n  // FIXME(bnoordhuis) Doesn't work for pipe handles\x2C they don't have a\n  // getsockname() method. Non-issue for now\x2C the cluster module doesn't\n  // really support pipes anyway.\n  if (err === 0 && port > 0 && handle.getsockname) {\n    const out = {};\n    err = handle.getsockname(out);\n    if (err === 0 && port !== out.port) {\n      debug(`checkBindError\x2C bound to ${out.port} instead of ${port}`);\n      err = UV_EADDRINUSE;\n    }\n  }\n  return err;\n}\n\n\nfunction internalConnect(\n  self\x2C address\x2C port\x2C addressType\x2C localAddress\x2C localPort\x2C flags) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert(self.connecting);\n\n  let err;\n\n  if (localAddress || localPort) {\n    if (addressType === 4) {\n      localAddress = localAddress || DEFAULT_IPV4_ADDR;\n      err = self._handle.bind(localAddress\x2C localPort);\n    } else { // addressType === 6\n      localAddress = localAddress || DEFAULT_IPV6_ADDR;\n      err = self._handle.bind6(localAddress\x2C localPort\x2C flags);\n    }\n    debug('binding to localAddress: %s and localPort: %d (addressType: %d)'\x2C\n          localAddress\x2C localPort\x2C addressType);\n\n    err = checkBindError(err\x2C localPort\x2C self._handle);\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C localAddress\x2C localPort);\n      self.destroy(ex);\n      return;\n    }\n  }\n\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress;\n    req.localPort = localPort;\n\n    if (addressType === 4)\n      err = self._handle.connect(req\x2C address\x2C port);\n    else\n      err = self._handle.connect6(req\x2C address\x2C port);\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n\n    err = self._handle.connect(req\x2C address\x2C afterConnect);\n  }\n\n  if (err) {\n    const sockname = self._getsockname();\n    let details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    const ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port\x2C details);\n    self.destroy(ex);\n  }\n}\n\n\nSocket.prototype.connect = function(...args) {\n  let normalized;\n  // If passed an array\x2C it's treated as an array of arguments that have\n  // already been normalized (so we don't normalize more than once). This has\n  // been solved before in https://github.com/nodejs/node/pull/12342\x2C but was\n  // reverted as it had unintended side effects.\n  if (ArrayIsArray(args[0]) && args[0][normalizedArgsSymbol]) {\n    normalized = args[0];\n  } else {\n    normalized = normalizeArgs(args);\n  }\n  const options = normalized[0];\n  const cb = normalized[1];\n\n  // options.port === null will be checked later.\n  if (options.port === undefined && options.path == null)\n    throw new ERR_MISSING_ARGS(['options'\x2C 'port'\x2C 'path']);\n\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (this.destroyed) {\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n\n  const { path } = options;\n  const pipe = !!path;\n  debug('pipe'\x2C pipe\x2C path);\n\n  if (!this._handle) {\n    this._handle = pipe ?\n      new Pipe(PipeConstants.SOCKET) :\n      new TCP(TCPConstants.SOCKET);\n    initSocketHandle(this);\n  }\n\n  if (cb !== null) {\n    this.once('connect'\x2C cb);\n  }\n\n  this._unrefTimer();\n\n  this.connecting = true;\n\n  if (pipe) {\n    validateString(path\x2C 'options.path');\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C internalConnect\x2C this\x2C path\n    );\n  } else {\n    lookupAndConnect(this\x2C options);\n  }\n  return this;\n};\n\n\nfunction lookupAndConnect(self\x2C options) {\n  const { localAddress\x2C localPort } = options;\n  const host = options.host || 'localhost';\n  let { port } = options;\n\n  if (localAddress && !isIP(localAddress)) {\n    throw new ERR_INVALID_IP_ADDRESS(localAddress);\n  }\n\n  if (localPort) {\n    validateNumber(localPort\x2C 'options.localPort');\n  }\n\n  if (typeof port !== 'undefined') {\n    if (typeof port !== 'number' && typeof port !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('options.port'\x2C\n                                     ['number'\x2C 'string']\x2C port);\n    }\n    validatePort(port);\n  }\n  port |= 0;\n\n  // If host is an IP\x2C skip performing a lookup\n  const addressType = isIP(host);\n  if (addressType) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C process.nextTick\x2C () => {\n      if (self.connecting)\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C host\x2C port\x2C addressType\x2C localAddress\x2C localPort\n        );\n    });\n    return;\n  }\n\n  if (options.lookup !== undefined)\n    validateFunction(options.lookup\x2C 'options.lookup');\n\n  if (dns === undefined) dns = require('dns');\n  const dnsopts = {\n    family: options.family\x2C\n    hints: options.hints || 0\n  };\n\n  if (!isWindows &&\n      dnsopts.family !== 4 &&\n      dnsopts.family !== 6 &&\n      dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n\n  debug('connect: find host'\x2C host);\n  debug('connect: dns options'\x2C dnsopts);\n  self._host = host;\n  const lookup = options.lookup || dns.lookup;\n  defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C function() {\n    lookup(host\x2C dnsopts\x2C function emitLookup(err\x2C ip\x2C addressType) {\n      self.emit('lookup'\x2C err\x2C ip\x2C addressType\x2C host);\n\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self.connecting) return;\n\n      if (err) {\n        // net.createConnection() creates a net.Socket object and immediately\n        // calls net.Socket.connect() on it (that's us). There are no event\n        // listeners registered yet so defer the error event to the next tick.\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (!isIP(ip)) {\n        err = new ERR_INVALID_IP_ADDRESS(ip);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (addressType !== 4 && addressType !== 6) {\n        err = new ERR_INVALID_ADDRESS_FAMILY(addressType\x2C\n                                             options.host\x2C\n                                             options.port);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else {\n        self._unrefTimer();\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C ip\x2C port\x2C addressType\x2C localAddress\x2C localPort\n        );\n      }\n    });\n  });\n}\n\n\nfunction connectErrorNT(self\x2C err) {\n  self.destroy(err);\n}\n\n\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.ref);\n    return this;\n  }\n\n  if (typeof this._handle.ref === 'function') {\n    this._handle.ref();\n  }\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.unref);\n    return this;\n  }\n\n  if (typeof this._handle.unref === 'function') {\n    this._handle.unref();\n  }\n\n  return this;\n};\n\n\nfunction afterConnect(status\x2C handle\x2C req\x2C readable\x2C writable) {\n  const self = handle[owner_symbol];\n\n  // Callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  debug('afterConnect');\n\n  assert(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n\n  if (status === 0) {\n    if (self.readable && !readable) {\n      self.push(null);\n      self.read();\n    }\n    if (self.writable && !writable) {\n      self.end();\n    }\n    self._unrefTimer();\n\n    if (self[kSetNoDelay] && self._handle.setNoDelay) {\n      self._handle.setNoDelay(true);\n    }\n\n    if (self[kSetKeepAlive] && self._handle.setKeepAlive) {\n      self._handle.setKeepAlive(true\x2C self[kSetKeepAliveInitialDelay]);\n    }\n\n    self.emit('connect');\n    self.emit('ready');\n\n    // Start the first read\x2C or get an immediate EOF.\n    // this doesn't actually consume any bytes\x2C because len=0.\n    if (readable && !self.isPaused())\n      self.read(0);\n\n  } else {\n    self.connecting = false;\n    let details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    const ex = exceptionWithHostPort(status\x2C\n                                     'connect'\x2C\n                                     req.address\x2C\n                                     req.port\x2C\n                                     details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\n\nfunction addAbortSignalOption(self\x2C options) {\n  if (options?.signal === undefined) {\n    return;\n  }\n  validateAbortSignal(options.signal\x2C 'options.signal');\n  const { signal } = options;\n  const onAborted = () => {\n    self.close();\n  };\n  if (signal.aborted) {\n    process.nextTick(onAborted);\n  } else {\n    signal.addEventListener('abort'\x2C onAborted);\n    self.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n  }\n}\n\nfunction Server(options\x2C connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options\x2C connectionListener);\n\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    connectionListener = options;\n    options = {};\n    this.on('connection'\x2C connectionListener);\n  } else if (options == null || typeof options === 'object') {\n    options = { ...options };\n\n    if (typeof connectionListener === 'function') {\n      this.on('connection'\x2C connectionListener);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C 'Object'\x2C options);\n  }\n  if (typeof options.keepAliveInitialDelay !== 'undefined') {\n    validateNumber(\n      options.keepAliveInitialDelay\x2C 'options.keepAliveInitialDelay'\n    );\n\n    if (options.keepAliveInitialDelay < 0) {\n      options.keepAliveInitialDelay = 0;\n    }\n  }\n\n  this._connections = 0;\n\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingWorkers = false;\n  this._workers = [];\n  this._unref = false;\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n  this.noDelay = Boolean(options.noDelay);\n  this.keepAlive = Boolean(options.keepAlive);\n  this.keepAliveInitialDelay = ~~(options.keepAliveInitialDelay / 1000);\n}\nObjectSetPrototypeOf(Server.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Server\x2C EventEmitter);\n\n\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n// Returns handle if it can be created\x2C or error code if it can't\nfunction createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\n  let err = 0;\n  // Assign handle in listen\x2C and clean up if bind or listen fails\n  let handle;\n\n  let isTCP = false;\n  if (typeof fd === 'number' && fd >= 0) {\n    try {\n      handle = createHandle(fd\x2C true);\n    } catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=%d:'\x2C fd\x2C e.message);\n      return UV_EINVAL;\n    }\n\n    err = handle.open(fd);\n    if (err)\n      return err;\n\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe(PipeConstants.SERVER);\n    if (isWindows) {\n      const instances = NumberParseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!NumberIsNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP(TCPConstants.SERVER);\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to'\x2C address || 'any');\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6(DEFAULT_IPV6_ADDR\x2C port\x2C flags);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle(DEFAULT_IPV4_ADDR\x2C port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address\x2C port\x2C flags);\n    } else {\n      err = handle.bind(address\x2C port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\nfunction setupListenHandle(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags) {\n  debug('setupListenHandle'\x2C address\x2C port\x2C addressType\x2C backlog\x2C fd);\n\n  // If there is not yet a handle\x2C we need to create one and bind.\n  // In the case of a server sent via IPC\x2C we don't need to do this.\n  if (this._handle) {\n    debug('setupListenHandle: have a handle already');\n  } else {\n    debug('setupListenHandle: create a handle');\n\n    let rval = null;\n\n    // Try to bind to the unspecified IPv6 address\x2C see if IPv6 is available\n    if (!address && typeof fd !== 'number') {\n      rval = createServerHandle(DEFAULT_IPV6_ADDR\x2C port\x2C 6\x2C fd\x2C flags);\n\n      if (typeof rval === 'number') {\n        rval = null;\n        address = DEFAULT_IPV4_ADDR;\n        addressType = 4;\n      } else {\n        address = DEFAULT_IPV6_ADDR;\n        addressType = 6;\n      }\n    }\n\n    if (rval === null)\n      rval = createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n\n    if (typeof rval === 'number') {\n      const error = uvExceptionWithHostPort(rval\x2C 'listen'\x2C address\x2C port);\n      process.nextTick(emitErrorNT\x2C this\x2C error);\n      return;\n    }\n    this._handle = rval;\n  }\n\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle[owner_symbol] = this;\n\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  const err = this._handle.listen(backlog || 511);\n\n  if (err) {\n    const ex = uvExceptionWithHostPort(err\x2C 'listen'\x2C address\x2C port);\n    this._handle.close();\n    this._handle = null;\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               emitErrorNT\x2C\n                               this\x2C\n                               ex);\n    return;\n  }\n\n  // Generate connection key\x2C this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  // Unref the handle if the server was unref'ed prior to listening\n  if (this._unref)\n    this.unref();\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitListeningNT\x2C\n                             this);\n}\n\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\n\nfunction emitErrorNT(self\x2C err) {\n  self.emit('error'\x2C err);\n}\n\n\nfunction emitListeningNT(self) {\n  // Ensure handle hasn't closed\n  if (self._handle)\n    self.emit('listening');\n}\n\n\nfunction listenInCluster(server\x2C address\x2C port\x2C addressType\x2C\n                         backlog\x2C fd\x2C exclusive\x2C flags) {\n  exclusive = !!exclusive;\n\n  if (cluster === undefined) cluster = require('cluster');\n\n  if (cluster.isPrimary || exclusive) {\n    // Will create a new handle\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n    return;\n  }\n\n  const serverQuery = {\n    address: address\x2C\n    port: port\x2C\n    addressType: addressType\x2C\n    fd: fd\x2C\n    flags\x2C\n    backlog\x2C\n  };\n\n  // Get the primary's server handle\x2C and listen on it\n  cluster._getServer(server\x2C serverQuery\x2C listenOnPrimaryHandle);\n\n  function listenOnPrimaryHandle(err\x2C handle) {\n    err = checkBindError(err\x2C port\x2C handle);\n\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C address\x2C port);\n      return server.emit('error'\x2C ex);\n    }\n\n    // Reuse primary's server handle\n    server._handle = handle;\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n  }\n}\n\n\nServer.prototype.listen = function(...args) {\n  const normalized = normalizeArgs(args);\n  let options = normalized[0];\n  const cb = normalized[1];\n\n  if (this._handle) {\n    throw new ERR_SERVER_ALREADY_LISTEN();\n  }\n\n  if (cb !== null) {\n    this.once('listening'\x2C cb);\n  }\n  const backlogFromArgs =\n    // (handle\x2C backlog) or (path\x2C backlog) or (port\x2C backlog)\n    toNumber(args.length > 1 && args[1]) ||\n    toNumber(args.length > 2 && args[2]);  // (port\x2C host\x2C backlog)\n\n  options = options._handle || options.handle || options;\n  const flags = getFlags(options.ipv6Only);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a handle\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this\x2C null\x2C -1\x2C -1\x2C backlogFromArgs);\n    return this;\n  }\n  addAbortSignalOption(this\x2C options);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a fd\n  if (typeof options.fd === 'number' && options.fd >= 0) {\n    listenInCluster(this\x2C null\x2C null\x2C null\x2C backlogFromArgs\x2C options.fd);\n    return this;\n  }\n\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is omitted\x2C\n  // that is\x2C listen()\x2C listen(null)\x2C listen(cb)\x2C or listen(null\x2C cb)\n  // or (options[\x2C cb]) where options.port is explicitly set as undefined or\n  // null\x2C bind to an arbitrary unused port\n  if (args.length === 0 || typeof args[0] === 'function' ||\n      (typeof options.port === 'undefined' && 'port' in options) ||\n      options.port === null) {\n    options.port = 0;\n  }\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is specified\n  // or (options[\x2C cb]) where options.port is specified\n  // or if options.port is normalized as 0 before\n  let backlog;\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\n    validatePort(options.port\x2C 'options.port');\n    backlog = options.backlog || backlogFromArgs;\n    // start TCP server listening on host:port\n    if (options.host) {\n      lookupAndListen(this\x2C options.port | 0\x2C options.host\x2C backlog\x2C\n                      options.exclusive\x2C flags);\n    } else { // Undefined host\x2C listens on unspecified address\n      // Default addressType 4 will be used to search for primary server\n      listenInCluster(this\x2C null\x2C options.port | 0\x2C 4\x2C\n                      backlog\x2C undefined\x2C options.exclusive);\n    }\n    return this;\n  }\n\n  // (path[\x2C backlog][\x2C cb]) or (options[\x2C cb])\n  // where path or options.path is a UNIX domain socket or Windows pipe\n  if (options.path && isPipeName(options.path)) {\n    const pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this\x2C pipeName\x2C -1\x2C -1\x2C\n                    backlog\x2C undefined\x2C options.exclusive);\n\n    if (!this._handle) {\n      // Failed and an error shall be emitted in the next tick.\n      // Therefore\x2C we directly return.\n      return this;\n    }\n\n    let mode = 0;\n    if (options.readableAll === true)\n      mode |= PipeConstants.UV_READABLE;\n    if (options.writableAll === true)\n      mode |= PipeConstants.UV_WRITABLE;\n    if (mode !== 0) {\n      const err = this._handle.fchmod(mode);\n      if (err) {\n        this._handle.close();\n        this._handle = null;\n        throw errnoException(err\x2C 'uv_pipe_chmod');\n      }\n    }\n    return this;\n  }\n\n  if (!(('port' in options) || ('path' in options))) {\n    throw new ERR_INVALID_ARG_VALUE('options'\x2C options\x2C\n                                    'must have the property "port" or "path"');\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('options'\x2C options);\n};\n\nfunction lookupAndListen(self\x2C port\x2C address\x2C backlog\x2C exclusive\x2C flags) {\n  if (dns === undefined) dns = require('dns');\n  dns.lookup(address\x2C function doListen(err\x2C ip\x2C addressType) {\n    if (err) {\n      self.emit('error'\x2C err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self\x2C ip\x2C port\x2C addressType\x2C\n                      backlog\x2C undefined\x2C exclusive\x2C flags);\n    }\n  });\n}\n\nObjectDefineProperty(Server.prototype\x2C 'listening'\x2C {\n  get: function() {\n    return !!this._handle;\n  }\x2C\n  configurable: true\x2C\n  enumerable: true\n});\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    const out = {};\n    const err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err\x2C 'address');\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  }\n  return null;\n};\n\nfunction onconnection(err\x2C clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error'\x2C errnoException(err\x2C 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle\x2C\n    allowHalfOpen: self.allowHalfOpen\x2C\n    pauseOnCreate: self.pauseOnConnect\x2C\n    readable: true\x2C\n    writable: true\n  });\n\n  if (self.noDelay && handle.setNoDelay) {\n    handle.setNoDelay(true);\n  }\n\n  if (self.keepAlive && self.setKeepAlive) {\n    handle.setKeepAlive(true\x2C handle.keepAliveInitialDelay);\n  }\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection'\x2C socket);\n}\n\n/**\n * Gets the number of concurrent connections on the server\n * @param {Function} cb\n * @returns {Server}\n */\n\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n\n  function end(err\x2C connections) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               cb\x2C\n                               err\x2C\n                               connections);\n  }\n\n  if (!this._usingWorkers) {\n    end(null\x2C this._connections);\n    return this;\n  }\n\n  // Poll workers\n  let left = this._workers.length;\n  let total = this._connections;\n\n  function oncount(err\x2C count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null\x2C total);\n  }\n\n  for (let n = 0; n < this._workers.length; n++) {\n    this._workers[n].getConnections(oncount);\n  }\n\n  return this;\n};\n\n\nServer.prototype.close = function(cb) {\n  if (typeof cb === 'function') {\n    if (!this._handle) {\n      this.once('close'\x2C function close() {\n        cb(new ERR_SERVER_NOT_RUNNING());\n      });\n    } else {\n      this.once('close'\x2C cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingWorkers) {\n    let left = this._workers.length;\n    const onWorkerClose = () => {\n      if (--left !== 0) return;\n\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n\n    // Increment connections to be sure that\x2C even if all sockets will be closed\n    // during polling of workers\x2C `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll workers\n    for (let n = 0; n < this._workers.length; n++)\n      this._workers[n].close(onWorkerClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n\n  if (this._handle || this._connections) {\n    debug('SERVER handle? %j   connections? %d'\x2C\n          !!this._handle\x2C this._connections);\n    return;\n  }\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitCloseNT\x2C\n                             this);\n};\n\n\nfunction emitCloseNT(self) {\n  debug('SERVER: emit close');\n  self.emit('close');\n}\n\n\nServer.prototype[EventEmitter.captureRejectionSymbol] = function(\n  err\x2C event\x2C sock) {\n\n  switch (event) {\n    case 'connection':\n      sock.destroy(err);\n      break;\n    default:\n      this.emit('error'\x2C err);\n  }\n};\n\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(TCP.prototype\x2C 'owner'\x2C {\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\n});\n\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\n  get() { return this[kHandle]; }\x2C\n  set(v) { return this[kHandle] = v; }\n});\n\nServer.prototype._setupWorker = function(socketList) {\n  this._usingWorkers = true;\n  this._workers.push(socketList);\n  socketList.once('exit'\x2C (socketList) => {\n    const index = ArrayPrototypeIndexOf(this._workers\x2C socketList);\n    this._workers.splice(index\x2C 1);\n  });\n};\n\nServer.prototype.ref = function() {\n  this._unref = false;\n\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\nServer.prototype.unref = function() {\n  this._unref = true;\n\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nlet _setSimultaneousAccepts;\nlet warnSimultaneousAccepts = true;\n\nif (isWindows) {\n  let simultaneousAccepts;\n\n  _setSimultaneousAccepts = function(handle) {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n    if (handle === undefined) {\n      return;\n    }\n\n    if (simultaneousAccepts === undefined) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(!!simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function() {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n  };\n}\n\nmodule.exports = {\n  _createServerHandle: createServerHandle\x2C\n  _normalizeArgs: normalizeArgs\x2C\n  _setSimultaneousAccepts\x2C\n  get BlockList() {\n    BlockList ??= require('internal/blocklist').BlockList;\n    return BlockList;\n  }\x2C\n  get SocketAddress() {\n    SocketAddress ??= require('internal/socketaddress').SocketAddress;\n    return SocketAddress;\n  }\x2C\n  connect\x2C\n  createConnection: connect\x2C\n  createServer\x2C\n  isIP: isIP\x2C\n  isIPv4: isIPv4\x2C\n  isIPv6: isIPv6\x2C\n  Server\x2C\n  Socket\x2C\n  Stream: Socket\x2C // Legacy naming\n};\n
code-source-info,0x120d44381d3e,113,0,49192,C0O0C4O49192,,
code-creation,Function,10,33250,0x120d44384c1e,2547, node:net:1:1,0x120d44381cb8,~
code-source-info,0x120d44384c1e,113,0,49192,C0O0C417O1159C423O1175C429O1200C435O1211C441O1221C447O1236C453O1254C459O1278C464O1302C469O1349C475O1349C479O1349C481O1383C487O1383C491O1383C493O1414C499O1414C504O1447C518O1448C524O1414C526O1572C532O1572C537O1502C543O1510C548O1520C553O1530C559O1554C565O1612C571O1612C575O1612C577O1696C580O1696C585O1650C591O1667C597O1680C603O1739C609O1739C614O1728C620O1786C623O1786C628O1766C634O1836C637O1836C642O1819C648O1931C651O1931C656O1878C662O1885C668O1914C674O2026C677O2026C682O1970C688O1978C694O2008C700O2157C706O2157C711O2066C717O2080C728O2121C734O2138C740O2355C746O2355C751O2200C757O2217C763O2233C769O2249C774O2269C780O2280C785O2296C790O2316C796O2327C802O2340C808O2756C814O2756C819O2756C824O2419C830O2451C836O2477C842O2504C848O2529C854O2557C860O2588C866O2616C872O2639C878O2664C884O2682C890O2707C896O2727C902O2809C908O2809C913O2792C919O2964C925O2964C930O2851C936O2874C942O2894C948O2911C954O2929C960O2945C966O3024C969O3024C973O3024C975O3122C981O3122C986O3064C992O3096C998O3202C999O3202C1001O3215C1002O3215C1004O3224C1005O3224C1007O3239C1008O3239C1010O3280C1016O3280C1021O3263C1027O3320C1033O3320C1038O3307C1044O3375C1046O3375C1048O3412C1050O3412C1052O3437C1055O3445C1062O3454C1065O3437C1067O3481C1071O3481C1073O6933C1076O6933C1080O6933C1082O6977C1085O6977C1089O6977C1091O7022C1094O7022C1098O7022C1100O7067C1103O7067C1107O7067C1109O7126C1112O7126C1116O7126C1118O11638C1121O11666C1129O11684C1134O11691C1139O11638C1144O11703C1150O11739C1155O11703C1160O11779C1163O11786C1172O11808C1176O12034C1179O12041C1188O12058C1192O13570C1195O13577C1202O13598C1206O13620C1209O13627C1218O13648C1222O14158C1225O14165C1234O14186C1238O14569C1241O14576C1250O14599C1254O15085C1257O15092C1266O15110C1270O15160C1276O15188C1290O15223C1298O15160C1303O15273C1309O15301C1323O15327C1331O15273C1336O15412C1342O15440C1356O15474C1364O15412C1369O15796C1375O15824C1389O15858C1397O15796C1402O15944C1408O15972C1413O15983C1419O16006C1430O15944C1435O16371C1438O16378C1447O16394C1451O16629C1454O16636C1463O16650C1467O16843C1470O16850C1479O16866C1483O17206C1486O17213C1495O17230C1499O17420C1502O17427C1511O17442C1515O17779C1518O17786C1527O17808C1531O17961C1534O17968C1543O17987C1547O18946C1550O18953C1559O18976C1563O19437C1571O19437C1576O19557C1584O19557C1594O19656C1602O19656C1612O19752C1620O19752C1630O19843C1633O19850C1642O19873C1650O20155C1658O20155C1668O20253C1676O20253C1686O20342C1689O20349C1694O20359C1698O20377C1706O20429C1709O20436C1718O20460C1726O21227C1729O21234C1738O21252C1746O21326C1749O21333C1758O21350C1766O21594C1774O21594C1784O21734C1792O21734C1802O25206C1805O25213C1814O25231C1822O29632C1825O29639C1834O29653C1842O29846C1845O29853C1854O29869C1862O33261C1865O33289C1877O33313C1886O33261C1896O33325C1902O33325C1912O37311C1915O37318C1926O37337C1934O38798C1937O38805C1950O38822C1958O42779C1964O42807C1985O42840C1997O42779C2007O42931C2010O42938C2023O42956C2031O44214C2034O44221C2047O44246C2055O45005C2058O45012C2071O45028C2079O45900C2082O45907C2095O45937C2103O46415C2106O46422C2118O46445C2131O46469C2139O46787C2145O46812C2166O46836C2178O46876C2190O46787C2200O46923C2206O46951C2223O46977C2235O47012C2247O46923C2257O47054C2260O47061C2273O47084C2281O47330C2284O47337C2297O47351C2305O47454C2308O47461C2321O47477C2329O47585C2331O47640C2332O47640C2334O47647C2345O47670C2346O47670C2348O47694C2357O48402C2362O48674C2372O48716C2382O48754C2392O48771C2402O49030C2412O49059C2422O49070C2432O49092C2442O49108C2452O49126C2462O49136C2472O49146C2482O49164C2537O48689C2546O49191,,
tick,0x1bfd70f34,33375,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x3172a1b3ff6b,0x105108d28,0x10510894c,0x3172a1b3ed74,0x105108d28,0x10510894c,0x3172a1b3b420,0x105108d28,0x10510894c,0x3172a1b32c72,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
tick,0x1bfd70f34,33375,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x3172a1b3ff6b,0x105108d28,0x10510894c,0x3172a1b3ed74,0x105108d28,0x10510894c,0x3172a1b3b420,0x105108d28,0x10510894c,0x3172a1b32c72,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,Eval,10,33500,0x120d4438a5be,5, node:internal/net:1:1,0x120d4438a3f8,~
script-source,114,node:internal/net,'use strict';\n\nconst {\n  RegExp\x2C\n  RegExpPrototypeTest\x2C\n  Symbol\x2C\n} = primordials;\n\nconst Buffer = require('buffer').Buffer;\nconst { writeBuffer } = internalBinding('fs');\nconst errors = require('internal/errors');\n\n// IPv4 Segment\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\nconst IPv4Reg = new RegExp(`^${v4Str}$`);\n\n// IPv6 Segment\nconst v6Seg = '(?:[0-9a-fA-F]{1\x2C4})';\nconst IPv6Reg = new RegExp('^(' +\n  `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1\x2C2}|:)|` +\n  `(?:${v6Seg}:){4}(?:(:${v6Seg}){0\x2C1}:${v4Str}|(:${v6Seg}){1\x2C3}|:)|` +\n  `(?:${v6Seg}:){3}(?:(:${v6Seg}){0\x2C2}:${v4Str}|(:${v6Seg}){1\x2C4}|:)|` +\n  `(?:${v6Seg}:){2}(?:(:${v6Seg}){0\x2C3}:${v4Str}|(:${v6Seg}){1\x2C5}|:)|` +\n  `(?:${v6Seg}:){1}(?:(:${v6Seg}){0\x2C4}:${v4Str}|(:${v6Seg}){1\x2C6}|:)|` +\n  `(?::((?::${v6Seg}){0\x2C5}:${v4Str}|(?::${v6Seg}){1\x2C7}|:))` +\n')(%[0-9a-zA-Z-.:]{1\x2C})?$');\n\nfunction isIPv4(s) {\n  return RegExpPrototypeTest(IPv4Reg\x2C s);\n}\n\nfunction isIPv6(s) {\n  return RegExpPrototypeTest(IPv6Reg\x2C s);\n}\n\nfunction isIP(s) {\n  if (isIPv4(s)) return 4;\n  if (isIPv6(s)) return 6;\n  return 0;\n}\n\nfunction makeSyncWrite(fd) {\n  return function(chunk\x2C enc\x2C cb) {\n    if (enc !== 'buffer')\n      chunk = Buffer.from(chunk\x2C enc);\n\n    this._handle.bytesWritten += chunk.length;\n\n    const ctx = {};\n    writeBuffer(fd\x2C chunk\x2C 0\x2C chunk.length\x2C null\x2C undefined\x2C ctx);\n    if (ctx.errno !== undefined) {\n      const ex = errors.uvException(ctx);\n      ex.errno = ctx.errno;\n      return cb(ex);\n    }\n    cb();\n  };\n}\n\nmodule.exports = {\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  makeSyncWrite\x2C\n  normalizedArgsSymbol: Symbol('normalizedArgs')\n};\n
code-source-info,0x120d4438a5be,114,0,1749,C0O0C4O1749,,
code-creation,Function,10,33584,0x120d4438a9ae,617, node:internal/net:1:1,0x120d4438a538,~
code-source-info,0x120d4438a9ae,114,0,1749,C0O0C45O25C50O35C56O58C61O99C64O99C69O116C73O99C75O149C78O149C83O133C89O187C92O187C96O187C98O246C101O316C106O320C119O335C124O360C129O375C142O360C147O360C149O417C152O457C160O483C173O499C183O473C192O521C205O537C218O547C228O511C237O569C250O586C263O597C273O559C282O625C295O643C308O658C321O669C331O615C340O697C353O715C366O730C379O741C389O687C398O769C411O787C424O802C437O813C447O759C456O841C469O859C482O874C495O885C505O831C514O919C527O934C540O947C550O903C556O965C562O457C567O457C569O1633C576O1654C582O1662C588O1672C594O1682C601O1721C611O1648C616O1748,,
code-creation,Eval,10,33709,0x120d4438dfe6,5, node:internal/dtrace:1:1,0x120d4438dea0,~
script-source,115,node:internal/dtrace,'use strict';\n\nconst config = internalBinding('config');\n\nconst {\n  DTRACE_HTTP_CLIENT_REQUEST = () => {}\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE = () => {}\x2C\n  DTRACE_HTTP_SERVER_REQUEST = () => {}\x2C\n  DTRACE_HTTP_SERVER_RESPONSE = () => {}\x2C\n  DTRACE_NET_SERVER_CONNECTION = () => {}\x2C\n  DTRACE_NET_STREAM_END = () => {}\n} = (config.hasDtrace ? internalBinding('dtrace') : {});\n\nmodule.exports = {\n  DTRACE_HTTP_CLIENT_REQUEST\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE\x2C\n  DTRACE_HTTP_SERVER_REQUEST\x2C\n  DTRACE_HTTP_SERVER_RESPONSE\x2C\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\n};\n
code-source-info,0x120d4438dfe6,115,0,568,C0O0C4O568,,
code-creation,Function,10,33750,0x120d4438e4be,140, node:internal/dtrace:1:1,0x120d4438df60,~
code-source-info,0x120d4438e4be,115,0,568,C0O30C3O30C8O322C17O334C25O68C36O109C47O151C58O192C69O234C80O277C91O368C98O389C104O419C110O450C116O480C122O511C128O543C134O383C139O567,,
code-creation,LazyCompile,10,33875,0x120d4438f33e,34,protoGetter node:net:740:21,0x120d44382180,~
code-source-info,0x120d4438f33e,113,19295,19435,C0O19316C8O19344C13O19355C20O19419C27O19316C33O19434,,
code-creation,LazyCompile,10,33917,0x120d44393486,37,get BlockList node:net:1826:16,0x120d443840b0,~
code-source-info,0x120d44393486,113,48811,48900,C0O48820C14O48834C19O48863C26O48830C32O48879C36O48896,,
code-creation,Eval,10,34000,0x120d4439398e,5, node:internal/blocklist:1:1,0x120d443937a8,~
script-source,116,node:internal/blocklist,'use strict';\n\nconst {\n  Boolean\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\n} = primordials;\n\nconst {\n  BlockList: BlockListHandle\x2C\n} = internalBinding('block_list');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst {\n  SocketAddress\x2C\n  kHandle: kSocketAddressHandle\x2C\n} = require('internal/socketaddress');\n\nconst {\n  JSTransferable\x2C\n  kClone\x2C\n  kDeserialize\x2C\n} = require('internal/worker/js_transferable');\n\nconst { inspect } = require('internal/util/inspect');\n\nconst kHandle = Symbol('kHandle');\nconst { owner_symbol } = internalBinding('symbols');\n\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n} = require('internal/errors').codes;\n\nconst { validateInt32\x2C validateString } = require('internal/validators');\n\nclass BlockList extends JSTransferable {\n  constructor() {\n    super();\n    this[kHandle] = new BlockListHandle();\n    this[kHandle][owner_symbol] = this;\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0)\n      return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `BlockList ${inspect({\n      rules: this.rules\n    }\x2C opts)}`;\n  }\n\n  addAddress(address\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(address)) {\n      validateString(address\x2C 'address');\n      validateString(family\x2C 'family');\n      address = new SocketAddress({\n        address\x2C\n        family\x2C\n      });\n    }\n    this[kHandle].addAddress(address[kSocketAddressHandle]);\n  }\n\n  addRange(start\x2C end\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(start)) {\n      validateString(start\x2C 'start');\n      validateString(family\x2C 'family');\n      start = new SocketAddress({\n        address: start\x2C\n        family\x2C\n      });\n    }\n    if (!SocketAddress.isSocketAddress(end)) {\n      validateString(end\x2C 'end');\n      validateString(family\x2C 'family');\n      end = new SocketAddress({\n        address: end\x2C\n        family\x2C\n      });\n    }\n    const ret = this[kHandle].addRange(\n      start[kSocketAddressHandle]\x2C\n      end[kSocketAddressHandle]);\n    if (ret === false)\n      throw new ERR_INVALID_ARG_VALUE('start'\x2C start\x2C 'must come before end');\n  }\n\n  addSubnet(network\x2C prefix\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(network)) {\n      validateString(network\x2C 'network');\n      validateString(family\x2C 'family');\n      network = new SocketAddress({\n        address: network\x2C\n        family\x2C\n      });\n    }\n    switch (network.family) {\n      case 'ipv4':\n        validateInt32(prefix\x2C 'prefix'\x2C 0\x2C 32);\n        break;\n      case 'ipv6':\n        validateInt32(prefix\x2C 'prefix'\x2C 0\x2C 128);\n        break;\n    }\n    this[kHandle].addSubnet(network[kSocketAddressHandle]\x2C prefix);\n  }\n\n  check(address\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(address)) {\n      validateString(address\x2C 'address');\n      validateString(family\x2C 'family');\n      try {\n        address = new SocketAddress({\n          address\x2C\n          family\x2C\n        });\n      } catch {\n        // Ignore the error. If it's not a valid address\x2C return false.\n        return false;\n      }\n    }\n    return Boolean(this[kHandle].check(address[kSocketAddressHandle]));\n  }\n\n  get rules() {\n    return this[kHandle].getRules();\n  }\n\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/blocklist:InternalBlockList'\x2C\n    };\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kHandle][owner_symbol] = this;\n  }\n}\n\nclass InternalBlockList extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n    if (handle !== undefined)\n      handle[owner_symbol] = this;\n  }\n}\n\nInternalBlockList.prototype.constructor = BlockList.prototype.constructor;\nObjectSetPrototypeOf(InternalBlockList.prototype\x2C BlockList.prototype);\n\nmodule.exports = {\n  BlockList\x2C\n  InternalBlockList\x2C\n};\n
code-source-info,0x120d4439398e,116,0,3877,C0O0C4O3877,,
code-creation,Function,10,34125,0x120d44394396,359, node:internal/blocklist:1:1,0x120d44393908,~
code-source-info,0x120d44394396,116,0,3877,C0O0C35O25C41O36C46O60C51O127C54O127C59O106C65O204C68O204C73O190C78O293C81O293C86O241C92O267C98O385C101O385C106O339C111O357C116O367C121O450C124O450C129O438C135O501C138O501C142O501C144O545C147O545C152O528C158O611C161O611C166O637C171O584C177O688C180O688C185O654C191O669C197O745C204O884C241O3223C251O3384C278O3519C301O3691C306O3725C311O3735C315O3713C319O3787C324O3808C329O3748C334O3821C341O3842C347O3855C353O3836C358O3876,,
code-creation,Eval,10,34250,0x120d44395c7e,5, node:internal/socketaddress:1:1,0x120d44395a88,~
script-source,117,node:internal/socketaddress,'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  SocketAddress: _SocketAddress\x2C\n  AF_INET\x2C\n  AF_INET6\x2C\n} = internalBinding('block_list');\n\nconst {\n  validateObject\x2C\n  validateString\x2C\n  validatePort\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst { inspect } = require('internal/util/inspect');\n\nconst {\n  JSTransferable\x2C\n  kClone\x2C\n  kDeserialize\x2C\n} = require('internal/worker/js_transferable');\n\nconst kHandle = Symbol('kHandle');\nconst kDetail = Symbol('kDetail');\n\nclass SocketAddress extends JSTransferable {\n  static isSocketAddress(value) {\n    return value?.[kHandle] !== undefined;\n  }\n\n  constructor(options = {}) {\n    super();\n    validateObject(options\x2C 'options');\n    let { family = 'ipv4' } = options;\n    const {\n      address = (family === 'ipv4' ? '127.0.0.1' : '::')\x2C\n      port = 0\x2C\n      flowlabel = 0\x2C\n    } = options;\n\n    let type;\n    if (typeof family?.toLowerCase === 'function')\n      family = family.toLowerCase();\n    switch (family) {\n      case 'ipv4':\n        type = AF_INET;\n        break;\n      case 'ipv6':\n        type = AF_INET6;\n        break;\n      default:\n        throw new ERR_INVALID_ARG_VALUE('options.family'\x2C options.family);\n    }\n\n    validateString(address\x2C 'options.address');\n    validatePort(port\x2C 'options.port');\n    validateUint32(flowlabel\x2C 'options.flowlabel'\x2C false);\n\n    this[kHandle] = new _SocketAddress(address\x2C port\x2C type\x2C flowlabel);\n    this[kDetail] = this[kHandle].detail({\n      address: undefined\x2C\n      port: undefined\x2C\n      family: undefined\x2C\n      flowlabel: undefined\x2C\n    });\n  }\n\n  get address() {\n    return this[kDetail].address;\n  }\n\n  get port() {\n    return this[kDetail].port;\n  }\n\n  get family() {\n    return this[kDetail].family === AF_INET ? 'ipv4' : 'ipv6';\n  }\n\n  get flowlabel() {\n    // The flow label can be changed internally.\n    return this[kHandle].flowlabel();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0)\n      return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `SocketAddress ${inspect(this.toJSON()\x2C opts)}`;\n  }\n\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/socketaddress:InternalSocketAddress'\x2C\n    };\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kDetail] = handle.detail({\n      address: undefined\x2C\n      port: undefined\x2C\n      family: undefined\x2C\n      flowlabel: undefined\x2C\n    });\n  }\n\n  toJSON() {\n    return {\n      address: this.address\x2C\n      port: this.port\x2C\n      family: this.family\x2C\n      flowlabel: this.flowlabel\x2C\n    };\n  }\n}\n\nclass InternalSocketAddress extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n  }\n}\n\nInternalSocketAddress.prototype.constructor =\n  SocketAddress.prototype.constructor;\nObjectSetPrototypeOf(InternalSocketAddress.prototype\x2C SocketAddress.prototype);\n\nmodule.exports = {\n  SocketAddress\x2C\n  InternalSocketAddress\x2C\n  kHandle\x2C\n};\n
code-source-info,0x120d44395c7e,117,0,3207,C0O0C4O3207,,
code-creation,Function,10,34417,0x120d443967a6,366, node:internal/socketaddress:1:1,0x120d44395bf8,~
code-source-info,0x120d443967a6,117,0,3207,C0O0C38O25C43O49C48O143C51O143C56O100C62O118C68O129C74O257C77O257C82O185C88O203C94O221C100O237C106O345C109O345C114O345C119O313C125O419C128O419C133O405C138O466C141O466C146O454C152O557C155O557C160O511C165O529C170O539C175O618C178O618C182O618C184O653C187O653C191O653C193O701C226O2071C236O2313C246O2482C279O2877C302O2988C307O3028C312O3038C316O3010C320O3094C325O3119C330O3051C335O3132C342O3153C348O3170C354O3195C360O3147C365O3206,,
tick,0x10035a57c,34417,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x120d443943e7,0x105108d28,0x10510894c,0x120d44393494,0x3172a1b3ffa4,0x105108d28,0x10510894c,0x3172a1b3ed74,0x105108d28,0x10510894c,0x3172a1b3b420,0x105108d28,0x10510894c,0x3172a1b32c72,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,LazyCompile,10,34459,0x120d44397386,72,BlockList node:internal/blocklist:40:14,0x120d443939c0,~
code-source-info,0x120d44397386,116,775,879,C3O784C11O784C23O797C28O802C33O817C36O813C41O811C45O840C50O845C52O844C58O854C64O868C71O878,,
code-creation,LazyCompile,10,34500,0x120d44397b2e,115,addAddress node:internal/blocklist:60:13,0x120d44393a60,~
code-source-info,0x120d44397b2e,116,1149,1460,C14O1182C19O1201C24O1201C31O1235C39O1235C44O1277C52O1277C57O1317C69O1355C75O1372C81O1327C87O1400C89O1405C91O1404C95O1414C102O1433C104O1432C108O1414C114O1459,,
code-creation,LazyCompile,10,34542,0x120d44397cae,20,isSocketAddress node:internal/socketaddress:43:25,0x120d44395d00,~
code-source-info,0x120d44397cae,117,742,798,C0O756C9O771C11O770C18O780C19O794,,
code-creation,LazyCompile,10,34584,0x120d44398616,323,SocketAddress node:internal/socketaddress:47:14,0x120d44395cb0,~
code-source-info,0x120d44398616,117,813,1761,C7O813C13O834C21O834C33O847C41O847C46O893C58O940C69O958C81O998C89O1014C97O1055C99O1065C106O1082C117O1134C122O1134C127O1153C146O1198C151O1222C153O1256C158O1281C160O1311C168O1369C175O1317C180O1311C181O1389C189O1389C194O1437C202O1437C207O1477C220O1477C225O1537C230O1542C235O1557C252O1553C257O1551C261O1609C266O1614C274O1630C276O1629C280O1639C291O1663C296O1686C301O1711C306O1739C310O1639C315O1623C322O1760,,
code-creation,LazyCompile,10,34625,0x120d44398966,99, node:internal/validators:154:3,0x2b48e0c7c198,~
code-source-info,0x120d44398966,15,4384,4943,C0O4442C4O4482C9O4518C14O4556C21O4592C26O4628C33O4664C38O4678C46O4725C50O4739C53O4739C67O4814C75O4879C91O4885C96O4879C98O4942,,
code-creation,LazyCompile,10,34667,0x120d44398b16,129,validatePort node:internal/validators:211:22,0x2b48e0c7c370,~
code-source-info,0x120d44398b16,15,6414,6772,C24O6458C44O6555C47O6555C52O6580C58O6588C65O6604C70O6615C72O6621C75O6610C86O6642C92O6666C99O6676C101O6694C117O6700C122O6694C123O6754C125O6766C128O6770,,
code-creation,LazyCompile,10,34667,0x120d44398d66,149, node:internal/validators:101:40,0x2b48e0c7bf98,~
code-source-info,0x120d44398d66,15,2880,3390,C0O2911C3O2916C9O2939C15O2978C31O2984C36O2978C37O3043C42O3048C48O3080C64O3086C69O3080C70O3157C80O3209C90O3248C109O3215C114O3209C115O3285C120O3307C125O3320C141O3326C146O3320C148O3389,,
code-creation,LazyCompile,10,34709,0x120d44398eee,9,isUint32 node:internal/validators:40:18,0x2b48e0c7be38,~
code-source-info,0x120d44398eee,15,796,841,C0O808C2O832C5O821C8O839,,
code-creation,LazyCompile,10,34750,0x120d44399126,229,addRange node:internal/blocklist:72:11,0x120d44393ab0,~
code-source-info,0x120d44399126,116,1472,2142,C17O1508C22O1527C27O1527C34O1559C42O1559C47O1597C55O1597C60O1637C72O1682C78O1697C84O1645C90O1725C95O1744C100O1744C107O1774C115O1774C120O1808C128O1808C133O1848C145O1891C151O1904C157O1854C163O1944C165O1949C167O1948C171O1958C178O1980C180O1979C186O2013C188O2012C192O1958C199O2041C200O2049C205O2066C221O2072C226O2066C228O2141,,
code-creation,Eval,10,34792,0x120d4439975e,5, node:internal/modules/esm/formats:1:1,0x120d443995b8,~
script-source,118,node:internal/modules/esm/formats,'use strict';\n\nconst {\n  RegExpPrototypeTest\x2C\n} = primordials;\nconst { getOptionValue } = require('internal/options');\n\n\nconst experimentalWasmModules = getOptionValue('--experimental-wasm-modules');\nconst experimentalSpecifierResolution =\n  getOptionValue('--experimental-specifier-resolution');\n\nconst extensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'module'\x2C\n  '.json': 'json'\x2C\n  '.mjs': 'module'\x2C\n};\n\nconst legacyExtensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'commonjs'\x2C\n  '.json': 'commonjs'\x2C\n  '.mjs': 'module'\x2C\n  '.node': 'commonjs'\x2C\n};\n\nif (experimentalWasmModules) {\n  extensionFormatMap['.wasm'] = legacyExtensionFormatMap['.wasm'] = 'wasm';\n}\n\nfunction mimeToFormat(mime) {\n  if (\n    RegExpPrototypeTest(\n      /\\s*(text|application)\\/javascript\\s*(;\\s*charset=utf-?8\\s*)?/i\x2C\n      mime\n    )\n  ) return 'module';\n  if (mime === 'application/json') return 'json';\n  if (experimentalWasmModules && mime === 'application/wasm') return 'wasm';\n  return null;\n}\n\nlet experimentalSpecifierResolutionWarned = false;\nfunction getLegacyExtensionFormat(ext) {\n  if (\n    experimentalSpecifierResolution === 'node' &&\n    !experimentalSpecifierResolutionWarned\n  ) {\n    process.emitWarning(\n      'The Node.js specifier resolution in ESM is experimental.'\x2C\n      'ExperimentalWarning');\n    experimentalSpecifierResolutionWarned = true;\n  }\n  return legacyExtensionFormatMap[ext];\n}\n\nmodule.exports = {\n  extensionFormatMap\x2C\n  getLegacyExtensionFormat\x2C\n  legacyExtensionFormatMap\x2C\n  mimeToFormat\x2C\n};\n
code-source-info,0x120d4439975e,118,0,1559,C0O0C4O1559,,
code-creation,Function,10,34875,0x120d44399a1e,142, node:internal/modules/esm/formats:1:1,0x120d443996d8,~
code-source-info,0x120d44399a1e,118,0,1559,C0O0C34O25C40O90C43O90C48O71C53O153C56O153C60O153C62O242C65O242C69O242C71O325C76O465C80O465C82O601C86O634C92O698C98O662C102O1071C103O1071C105O1443C112O1464C118O1486C124O1514C130O1542C136O1458C141O1558,,
code-creation,Eval,10,34917,0x120d4439a106,5, node:internal/modules/esm/initialize_import_meta:1:1,0x120d44399f70,~
script-source,119,node:internal/modules/esm/initialize_import_meta,'use strict';\n\nconst { getOptionValue } = require('internal/options');\nconst experimentalImportMetaResolve =\n  getOptionValue('--experimental-import-meta-resolve');\nconst {\n  PromisePrototypeThen\x2C\n  PromiseReject\x2C\n} = primordials;\nconst asyncESM = require('internal/process/esm_loader');\n\nfunction createImportMetaResolve(defaultParentUrl) {\n  return async function resolve(specifier\x2C parentUrl = defaultParentUrl) {\n    return PromisePrototypeThen(\n      asyncESM.esmLoader.resolve(specifier\x2C parentUrl)\x2C\n      ({ url }) => url\x2C\n      (error) => (\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT' ?\n          error.url : PromiseReject(error))\n    );\n  };\n}\n\n/**\n * @param {object} meta\n * @param {{url: string}} context\n */\nfunction initializeImportMeta(meta\x2C context) {\n  let url = context.url;\n\n  // Alphabetical\n  if (experimentalImportMetaResolve) {\n    meta.resolve = createImportMetaResolve(url);\n  }\n\n  url = asyncESM.esmLoader.getBaseURL(url);\n\n  meta.url = url;\n}\n\nmodule.exports = {\n  initializeImportMeta\n};\n
code-source-info,0x120d4439a106,119,0,1023,C0O0C4O1023,,
code-creation,Function,10,35000,0x120d4439a2ce,90, node:internal/modules/esm/initialize_import_meta:1:1,0x120d4439a080,~
code-source-info,0x120d4439a2ce,119,0,1023,C0O0C28O42C31O42C36O23C41O111C44O111C48O111C50O175C56O199C62O248C65O248C69O248C71O978C78O999C84O993C89O1022,,
code-creation,Eval,10,35042,0x120d4439a7e6,5, node:internal/modules/esm/load:1:1,0x120d4439a670,~
script-source,120,node:internal/modules/esm/load,'use strict';\n\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\nconst { defaultGetSource } = require('internal/modules/esm/get_source');\nconst { validateAssertions } = require('internal/modules/esm/assert');\n\n/**\n * Node.js default load hook.\n * @param {string} url\n * @param {object} context\n * @returns {object}\n */\nasync function defaultLoad(url\x2C context) {\n  const { importAssertions } = context;\n  let {\n    format\x2C\n    source\x2C\n  } = context;\n\n  if (format == null) {\n    format = await defaultGetFormat(url\x2C context);\n  }\n\n  validateAssertions(url\x2C format\x2C importAssertions);\n\n  if (\n    format === 'builtin' ||\n    format === 'commonjs'\n  ) {\n    source = null;\n  } else if (source == null) {\n    source = await defaultGetSource(url\x2C context);\n  }\n\n  return {\n    format\x2C\n    source\x2C\n  };\n}\n\nmodule.exports = {\n  defaultLoad\x2C\n};\n
code-source-info,0x120d4439a7e6,120,0,860,C0O0C4O860,,
code-creation,Function,10,35084,0x120d4439a92e,80, node:internal/modules/esm/load:1:1,0x120d4439a760,~
code-source-info,0x120d4439a92e,120,0,860,C0O0C19O44C22O44C27O23C33O117C36O117C41O96C47O192C50O192C55O169C61O823C68O844C74O838C79O859,,
code-creation,Eval,10,35125,0x120d4439af26,5, node:internal/modules/esm/get_source:1:1,0x120d4439ad20,~
script-source,121,node:internal/modules/esm/get_source,'use strict';\n\nconst {\n  ArrayPrototypeConcat\x2C\n  RegExpPrototypeExec\x2C\n  decodeURIComponent\x2C\n} = primordials;\nconst { getOptionValue } = require('internal/options');\nconst { fetchModule } = require('internal/modules/esm/fetch_module');\n\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\n\nconst { Buffer: { from: BufferFrom } } = require('buffer');\n\nconst fs = require('internal/fs/promises').exports;\nconst { URL } = require('internal/url');\nconst {\n  ERR_INVALID_URL\x2C\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst readFileAsync = fs.readFile;\n\nconst DATA_URL_PATTERN = /^[^/]+\\/[^\x2C;]+(?:[^\x2C]*?)(;base64)?\x2C([\\s\\S]*)$/;\n\nasync function defaultGetSource(url\x2C context\x2C defaultGetSource) {\n  const parsed = new URL(url);\n  let source;\n  if (parsed.protocol === 'file:') {\n    source = await readFileAsync(parsed);\n  } else if (parsed.protocol === 'data:') {\n    const match = RegExpPrototypeExec(DATA_URL_PATTERN\x2C parsed.pathname);\n    if (!match) {\n      throw new ERR_INVALID_URL(url);\n    }\n    const { 1: base64\x2C 2: body } = match;\n    source = BufferFrom(decodeURIComponent(body)\x2C base64 ? 'base64' : 'utf8');\n  } else if (experimentalNetworkImports && (\n    parsed.protocol === 'https:' ||\n    parsed.protocol === 'http:'\n  )) {\n    const res = await fetchModule(parsed\x2C context);\n    source = await res.body;\n  } else {\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed\x2C ArrayPrototypeConcat([\n      'file'\x2C\n      'data'\x2C\n      experimentalNetworkImports ? ['https'\x2C 'http'] : []\x2C\n    ]));\n  }\n  if (policy?.manifest) {\n    policy.manifest.assertIntegrity(parsed\x2C source);\n  }\n  return source;\n}\nexports.defaultGetSource = defaultGetSource;\n
code-source-info,0x120d4439af26,121,0,1869,C0O0C4O1869,,
code-creation,Function,10,35209,0x120d4439b0be,212, node:internal/modules/esm/get_source:1:1,0x120d4439aea0,~
code-source-info,0x120d4439b0be,121,0,1869,C0O0C46O25C52O49C58O72C64O136C67O136C72O117C77O189C80O189C85O173C91O302C94O302C103O346C110O302C112O428C115O428C119O428C121O520C124O520C129O520C134O503C140O551C143O551C148O582C153O608C156O608C161O600C167O698C170O698C175O724C180O643C186O662C192O757C196O754C198O793C202O793C204O1824C206O1849C211O1868,,
code-creation,Eval,10,35584,0x120d4439c706,5, node:internal/fs/promises:1:1,0x120d4439bee8,~
script-source,122,node:internal/fs/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  Error\x2C\n  MathMax\x2C\n  MathMin\x2C\n  ObjectCreate\x2C\n  NumberIsSafeInteger\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  SafeArrayIterator\x2C\n  SafePromisePrototypeFinally\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  F_OK\x2C\n  O_SYMLINK\x2C\n  O_WRONLY\x2C\n  S_IFMT\x2C\n  S_IFREG\n} = internalBinding('constants').fs;\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\n\nconst {\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n  }\x2C\n  AbortError\x2C\n  aggregateTwoErrors\x2C\n} = require('internal/errors');\nconst { isArrayBufferView } = require('internal/util/types');\nconst { rimrafPromises } = require('internal/fs/rimraf');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  copyObject\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getStatsFromBinding\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validateRmOptions\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n} = require('internal/fs/utils');\nconst { opendir } = require('internal/fs/dir');\nconst {\n  parseFileMode\x2C\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst { lazyDOMException\x2C promisify } = require('internal/util');\nconst { EventEmitterMixin } = require('internal/event_target');\nconst { watch } = require('internal/fs/watchers');\nconst { isIterable } = require('internal/streams/utils');\nconst assert = require('internal/assert');\n\nconst kHandle = Symbol('kHandle');\nconst kFd = Symbol('kFd');\nconst kRefs = Symbol('kRefs');\nconst kClosePromise = Symbol('kClosePromise');\nconst kCloseResolve = Symbol('kCloseResolve');\nconst kCloseReject = Symbol('kCloseReject');\nconst kRef = Symbol('kRef');\nconst kUnref = Symbol('kUnref');\nconst kLocked = Symbol('kLocked');\n\nconst { kUsePromises } = binding;\nconst {\n  JSTransferable\x2C kDeserialize\x2C kTransfer\x2C kTransferList\n} = require('internal/worker/js_transferable');\n\nconst {\n  newReadableStreamFromStreamBase\x2C\n} = require('internal/webstreams/adapters');\n\nconst {\n  readableStreamCancel\x2C\n} = require('internal/webstreams/readablestream');\n\nconst getDirectoryEntriesPromise = promisify(getDirents);\nconst validateRmOptionsPromise = promisify(validateRmOptions);\n\nlet cpPromises;\nfunction lazyLoadCpPromises() {\n  return cpPromises ??= require('internal/fs/cp/cp').cpFn;\n}\n\n// Lazy loaded to avoid circular dependency.\nlet fsStreams;\nfunction lazyFsStreams() {\n  return fsStreams ??= require('internal/fs/streams');\n}\n\nclass FileHandle extends EventEmitterMixin(JSTransferable) {\n  /**\n   * @param {InternalFSBinding.FileHandle | undefined} filehandle\n   */\n  constructor(filehandle) {\n    super();\n    this[kHandle] = filehandle;\n    this[kFd] = filehandle ? filehandle.fd : -1;\n\n    this[kRefs] = 1;\n    this[kClosePromise] = null;\n  }\n\n  getAsyncId() {\n    return this[kHandle].getAsyncId();\n  }\n\n  get fd() {\n    return this[kFd];\n  }\n\n  appendFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  chmod(mode) {\n    return fsCall(fchmod\x2C this\x2C mode);\n  }\n\n  chown(uid\x2C gid) {\n    return fsCall(fchown\x2C this\x2C uid\x2C gid);\n  }\n\n  datasync() {\n    return fsCall(fdatasync\x2C this);\n  }\n\n  sync() {\n    return fsCall(fsync\x2C this);\n  }\n\n  read(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(read\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  readv(buffers\x2C position) {\n    return fsCall(readv\x2C this\x2C buffers\x2C position);\n  }\n\n  readFile(options) {\n    return fsCall(readFile\x2C this\x2C options);\n  }\n\n  stat(options) {\n    return fsCall(fstat\x2C this\x2C options);\n  }\n\n  truncate(len = 0) {\n    return fsCall(ftruncate\x2C this\x2C len);\n  }\n\n  utimes(atime\x2C mtime) {\n    return fsCall(futimes\x2C this\x2C atime\x2C mtime);\n  }\n\n  write(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(write\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  writev(buffers\x2C position) {\n    return fsCall(writev\x2C this\x2C buffers\x2C position);\n  }\n\n  writeFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  close = () => {\n    if (this[kFd] === -1) {\n      return PromiseResolve();\n    }\n\n    if (this[kClosePromise]) {\n      return this[kClosePromise];\n    }\n\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        this[kHandle].close()\x2C\n        () => { this[kClosePromise] = undefined; }\n      );\n    } else {\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        new Promise((resolve\x2C reject) => {\n          this[kCloseResolve] = resolve;\n          this[kCloseReject] = reject;\n        })\x2C () => {\n          this[kClosePromise] = undefined;\n          this[kCloseReject] = undefined;\n          this[kCloseResolve] = undefined;\n        }\n      );\n    }\n\n    this.emit('close');\n    return this[kClosePromise];\n  };\n\n  /**\n   * @typedef {import('../webstreams/readablestream').ReadableStream\n   * } ReadableStream\n   * @returns {ReadableStream}\n   */\n  readableWebStream() {\n    if (this[kFd] === -1)\n      throw new ERR_INVALID_STATE('The FileHandle is closed');\n    if (this[kClosePromise])\n      throw new ERR_INVALID_STATE('The FileHandle is closing');\n    if (this[kLocked])\n      throw new ERR_INVALID_STATE('The FileHandle is locked');\n    this[kLocked] = true;\n\n    const readable = newReadableStreamFromStreamBase(\n      this[kHandle]\x2C\n      undefined\x2C\n      { ondone: () => this[kUnref]() });\n\n    this[kRef]();\n    this.once('close'\x2C () => {\n      readableStreamCancel(readable);\n    });\n\n    return readable;\n  }\n\n  /**\n   * @typedef {import('./streams').ReadStream\n   * } ReadStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   end?: number;\n   *   highWaterMark?: number;\n   *   }} [options]\n   * @returns {ReadStream}\n   */\n  createReadStream(options = undefined) {\n    const { ReadStream } = lazyFsStreams();\n    return new ReadStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  /**\n   * @typedef {import('./streams').WriteStream\n   * } WriteStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   }} [options]\n   * @returns {WriteStream}\n   */\n  createWriteStream(options = undefined) {\n    const { WriteStream } = lazyFsStreams();\n    return new WriteStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  [kTransfer]() {\n    if (this[kClosePromise] || this[kRefs] > 1) {\n      throw lazyDOMException('Cannot transfer FileHandle while in use'\x2C\n                             'DataCloneError');\n    }\n\n    const handle = this[kHandle];\n    this[kFd] = -1;\n    this[kHandle] = null;\n    this[kRefs] = 0;\n\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/fs/promises:FileHandle'\n    };\n  }\n\n  [kTransferList]() {\n    return [ this[kHandle] ];\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kFd] = handle.fd;\n  }\n\n  [kRef]() {\n    this[kRefs]++;\n  }\n\n  [kUnref]() {\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      PromisePrototypeThen(\n        this[kHandle].close()\x2C\n        this[kCloseResolve]\x2C\n        this[kCloseReject]\n      );\n    }\n  }\n}\n\nasync function handleFdClose(fileOpPromise\x2C closeFunc) {\n  return PromisePrototypeThen(\n    fileOpPromise\x2C\n    (result) => PromisePrototypeThen(closeFunc()\x2C () => result)\x2C\n    (opError) =>\n      PromisePrototypeThen(\n        closeFunc()\x2C\n        () => PromiseReject(opError)\x2C\n        (closeError) => PromiseReject(aggregateTwoErrors(closeError\x2C opError))\n      )\n  );\n}\n\nasync function fsCall(fn\x2C handle\x2C ...args) {\n  assert(handle[kRefs] !== undefined\x2C\n         'handle must be an instance of FileHandle');\n\n  if (handle.fd === -1) {\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error('file closed');\n    err.code = 'EBADF';\n    err.syscall = fn.name;\n    throw err;\n  }\n\n  try {\n    handle[kRef]();\n    return await fn(handle\x2C ...new SafeArrayIterator(args));\n  } finally {\n    handle[kUnref]();\n  }\n}\n\nfunction checkAborted(signal) {\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n}\n\nasync function writeFileHandle(filehandle\x2C data\x2C signal\x2C encoding) {\n  checkAborted(signal);\n  if (isCustomIterable(data)) {\n    for await (const buf of data) {\n      checkAborted(signal);\n      const toWrite =\n        isArrayBufferView(buf) ? buf : Buffer.from(buf\x2C encoding || 'utf8');\n      let remaining = toWrite.byteLength;\n      while (remaining > 0) {\n        const writeSize = MathMin(kWriteFileMaxChunkSize\x2C remaining);\n        const { bytesWritten } = await write(\n          filehandle\x2C toWrite\x2C toWrite.byteLength - remaining\x2C writeSize);\n        remaining -= bytesWritten;\n        checkAborted(signal);\n      }\n    }\n    return;\n  }\n  data = new Uint8Array(data.buffer\x2C data.byteOffset\x2C data.byteLength);\n  let remaining = data.byteLength;\n  if (remaining === 0) return;\n  do {\n    checkAborted(signal);\n    const { bytesWritten } =\n      await write(filehandle\x2C data\x2C 0\x2C\n                  MathMin(kWriteFileMaxChunkSize\x2C data.byteLength));\n    remaining -= bytesWritten;\n    data = new Uint8Array(\n      data.buffer\x2C\n      data.byteOffset + bytesWritten\x2C\n      data.byteLength - bytesWritten\n    );\n  } while (remaining > 0);\n}\n\nasync function readFileHandle(filehandle\x2C options) {\n  const signal = options?.signal;\n\n  checkAborted(signal);\n\n  const statFields = await binding.fstat(filehandle.fd\x2C false\x2C kUsePromises);\n\n  checkAborted(signal);\n\n  let size;\n  if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) {\n    size = statFields[8/* size */];\n  } else {\n    size = 0;\n  }\n\n  if (size > kIoMaxLength)\n    throw new ERR_FS_FILE_TOO_LARGE(size);\n\n  let endOfFile = false;\n  let totalRead = 0;\n  const noSize = size === 0;\n  const buffers = [];\n  const fullBuffer = noSize ? undefined : Buffer.allocUnsafeSlow(size);\n  do {\n    checkAborted(signal);\n    let buffer;\n    let offset;\n    let length;\n    if (noSize) {\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\n      offset = 0;\n      length = kReadFileUnknownBufferLength;\n    } else {\n      buffer = fullBuffer;\n      offset = totalRead;\n      length = MathMin(size - totalRead\x2C kReadFileBufferLength);\n    }\n\n    const bytesRead = (await binding.read(filehandle.fd\x2C buffer\x2C offset\x2C\n                                          length\x2C -1\x2C kUsePromises)) || 0;\n    totalRead += bytesRead;\n    endOfFile = bytesRead === 0 || totalRead === size;\n    if (noSize && bytesRead > 0) {\n      const isBufferFull = bytesRead === kReadFileUnknownBufferLength;\n      const chunkBuffer = isBufferFull ? buffer : buffer.slice(0\x2C bytesRead);\n      ArrayPrototypePush(buffers\x2C chunkBuffer);\n    }\n  } while (!endOfFile);\n\n  let result;\n  if (size > 0) {\n    result = totalRead === size ? fullBuffer : fullBuffer.slice(0\x2C totalRead);\n  } else {\n    result = buffers.length === 1 ? buffers[0] : Buffer.concat(buffers\x2C\n                                                               totalRead);\n  }\n\n  return options.encoding ? result.toString(options.encoding) : result;\n}\n\n// All of the functions are defined as async in order to ensure that errors\n// thrown cause promise rejections rather than being thrown synchronously.\nasync function access(path\x2C mode = F_OK) {\n  path = getValidatedPath(path);\n\n  mode = getValidMode(mode\x2C 'access');\n  return binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C\n                        kUsePromises);\n}\n\nasync function cp(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  return lazyLoadCpPromises()(src\x2C dest\x2C options);\n}\n\nasync function copyFile(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n  mode = getValidMode(mode\x2C 'copyFile');\n  return binding.copyFile(pathModule.toNamespacedPath(src)\x2C\n                          pathModule.toNamespacedPath(dest)\x2C\n                          mode\x2C\n                          kUsePromises);\n}\n\n// Note that unlike fs.open() which uses numeric file descriptors\x2C\n// fsPromises.open() uses the fs.FileHandle class.\nasync function open(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  return new FileHandle(\n    await binding.openFileHandle(pathModule.toNamespacedPath(path)\x2C\n                                 flagsNumber\x2C mode\x2C kUsePromises));\n}\n\nasync function read(handle\x2C bufferOrOptions\x2C offset\x2C length\x2C position) {\n  let buffer = bufferOrOptions;\n  if (!isArrayBufferView(buffer)) {\n    bufferOrOptions ??= ObjectCreate(null);\n    ({\n      buffer = Buffer.alloc(16384)\x2C\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\n    } = bufferOrOptions);\n\n    validateBuffer(buffer);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0)\n    return { bytesRead: length\x2C buffer };\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n\n  const bytesRead = (await binding.read(handle.fd\x2C buffer\x2C offset\x2C length\x2C\n                                        position\x2C kUsePromises)) || 0;\n\n  return { bytesRead\x2C buffer };\n}\n\nasync function readv(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesRead = (await binding.readBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                               kUsePromises)) || 0;\n  return { bytesRead\x2C buffers };\n}\n\nasync function write(handle\x2C buffer\x2C offset\x2C length\x2C position) {\n  if (buffer?.byteLength === 0)\n    return { bytesWritten: 0\x2C buffer };\n\n  if (isArrayBufferView(buffer)) {\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    const bytesWritten =\n      (await binding.writeBuffer(handle.fd\x2C buffer\x2C offset\x2C\n                                 length\x2C position\x2C kUsePromises)) || 0;\n    return { bytesWritten\x2C buffer };\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n  validateEncoding(buffer\x2C length);\n  const bytesWritten = (await binding.writeString(handle.fd\x2C buffer\x2C offset\x2C\n                                                  length\x2C kUsePromises)) || 0;\n  return { bytesWritten\x2C buffer };\n}\n\nasync function writev(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  if (buffers.length === 0) {\n    return { bytesWritten: 0\x2C buffers };\n  }\n\n  const bytesWritten = (await binding.writeBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                                   kUsePromises)) || 0;\n  return { bytesWritten\x2C buffers };\n}\n\nasync function rename(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                        pathModule.toNamespacedPath(newPath)\x2C\n                        kUsePromises);\n}\n\nasync function truncate(path\x2C len = 0) {\n  const fd = await open(path\x2C 'r+');\n  return handleFdClose(ftruncate(fd\x2C len)\x2C fd.close);\n}\n\nasync function ftruncate(handle\x2C len = 0) {\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  return binding.ftruncate(handle.fd\x2C len\x2C kUsePromises);\n}\n\nasync function rm(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = await validateRmOptionsPromise(path\x2C options\x2C false);\n  return rimrafPromises(path\x2C options);\n}\n\nasync function rmdir(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = validateRmdirOptions(options);\n\n  if (options.recursive) {\n    emitRecursiveRmdirWarning();\n    const stats = await stat(path);\n    if (stats.isDirectory()) {\n      return rimrafPromises(path\x2C options);\n    }\n  }\n\n  return binding.rmdir(path\x2C kUsePromises);\n}\n\nasync function fdatasync(handle) {\n  return binding.fdatasync(handle.fd\x2C kUsePromises);\n}\n\nasync function fsync(handle) {\n  return binding.fsync(handle.fd\x2C kUsePromises);\n}\n\nasync function mkdir(path\x2C options) {\n  if (typeof options === 'number' || typeof options === 'string') {\n    options = { mode: options };\n  }\n  const {\n    recursive = false\x2C\n    mode = 0o777\n  } = options || {};\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  return binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                       parseFileMode(mode\x2C 'mode'\x2C 0o777)\x2C recursive\x2C\n                       kUsePromises);\n}\n\nasync function readdir(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const result = await binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                       options.encoding\x2C\n                                       !!options.withFileTypes\x2C\n                                       kUsePromises);\n  return options.withFileTypes ?\n    getDirectoryEntriesPromise(path\x2C result) :\n    result;\n}\n\nasync function readlink(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  return binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                          options.encoding\x2C kUsePromises);\n}\n\nasync function symlink(target\x2C path\x2C type_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  return binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                         pathModule.toNamespacedPath(path)\x2C\n                         stringToSymlinkType(type)\x2C\n                         kUsePromises);\n}\n\nasync function fstat(handle\x2C options = { bigint: false }) {\n  const result = await binding.fstat(handle.fd\x2C options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function lstat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                                     options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function stat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.stat(pathModule.toNamespacedPath(path)\x2C\n                                    options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function link(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                      pathModule.toNamespacedPath(newPath)\x2C\n                      kUsePromises);\n}\n\nasync function unlink(path) {\n  path = getValidatedPath(path);\n  return binding.unlink(pathModule.toNamespacedPath(path)\x2C kUsePromises);\n}\n\nasync function fchmod(handle\x2C mode) {\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.fchmod(handle.fd\x2C mode\x2C kUsePromises);\n}\n\nasync function chmod(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C kUsePromises);\n}\n\nasync function lchmod(path\x2C mode) {\n  if (O_SYMLINK === undefined)\n    throw new ERR_METHOD_NOT_IMPLEMENTED('lchmod()');\n\n  const fd = await open(path\x2C O_WRONLY | O_SYMLINK);\n  return handleFdClose(fchmod(fd\x2C mode)\x2C fd.close);\n}\n\nasync function lchown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.lchown(pathModule.toNamespacedPath(path)\x2C\n                        uid\x2C gid\x2C kUsePromises);\n}\n\nasync function fchown(handle\x2C uid\x2C gid) {\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.fchown(handle.fd\x2C uid\x2C gid\x2C kUsePromises);\n}\n\nasync function chown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.chown(pathModule.toNamespacedPath(path)\x2C\n                       uid\x2C gid\x2C kUsePromises);\n}\n\nasync function utimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                        toUnixTimestamp(atime)\x2C\n                        toUnixTimestamp(mtime)\x2C\n                        kUsePromises);\n}\n\nasync function futimes(handle\x2C atime\x2C mtime) {\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  return binding.futimes(handle.fd\x2C atime\x2C mtime\x2C kUsePromises);\n}\n\nasync function lutimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                         toUnixTimestamp(atime)\x2C\n                         toUnixTimestamp(mtime)\x2C\n                         kUsePromises);\n}\n\nasync function realpath(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  return binding.realpath(path\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function mkdtemp(prefix\x2C options) {\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix);\n  warnOnNonPortableTemplate(prefix);\n  return binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function writeFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data) && !isCustomIterable(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(data\x2C options.encoding || 'utf8');\n  }\n\n  validateAbortSignal(options.signal);\n  if (path instanceof FileHandle)\n    return writeFileHandle(path\x2C data\x2C options.signal\x2C options.encoding);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C options.mode);\n  return handleFdClose(\n    writeFileHandle(fd\x2C data\x2C options.signal\x2C options.encoding)\x2C fd.close);\n}\n\nfunction isCustomIterable(obj) {\n  return isIterable(obj) && !isArrayBufferView(obj) && typeof obj !== 'string';\n}\n\nasync function appendFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n  options = copyObject(options);\n  options.flag = options.flag || 'a';\n  return writeFile(path\x2C data\x2C options);\n}\n\nasync function readFile(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const flag = options.flag || 'r';\n\n  if (path instanceof FileHandle)\n    return readFileHandle(path\x2C options);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C 0o666);\n  return handleFdClose(readFileHandle(fd\x2C options)\x2C fd.close);\n}\n\nmodule.exports = {\n  exports: {\n    access\x2C\n    copyFile\x2C\n    cp\x2C\n    open\x2C\n    opendir: promisify(opendir)\x2C\n    rename\x2C\n    truncate\x2C\n    rm\x2C\n    rmdir\x2C\n    mkdir\x2C\n    readdir\x2C\n    readlink\x2C\n    symlink\x2C\n    lstat\x2C\n    stat\x2C\n    link\x2C\n    unlink\x2C\n    chmod\x2C\n    lchmod\x2C\n    lchown\x2C\n    chown\x2C\n    utimes\x2C\n    lutimes\x2C\n    realpath\x2C\n    mkdtemp\x2C\n    writeFile\x2C\n    appendFile\x2C\n    readFile\x2C\n    watch\x2C\n  }\x2C\n\n  FileHandle\x2C\n  kRef\x2C\n  kUnref\x2C\n};\n
code-source-info,0x120d4439c706,122,0,24171,C0O0C4O24171,,
code-creation,Function,10,36500,0x120d4439ef36,1802, node:internal/fs/promises:1:1,0x120d4439c680,~
code-source-info,0x120d4439ef36,122,0,24171,C0O0C517O25C523O47C529O56C535O67C541O78C547O94C553O117C559O128C565O152C571O170C577O187C583O208C589O239C594O249C600O344C604O344C610O372C616O289C622O297C628O310C634O322C640O332C646O393C650O393C654O393C656O435C664O435C670O424C676O628C684O628C690O628C696O478C702O505C708O532C714O555C720O590C726O604C732O686C740O686C746O664C752O745C760O745C766O726C772O1378C780O1378C786O1378C792O803C798O821C804O837C810O864C816O898C822O929C828O943C834O972C839O986C845O1000C851O1023C857O1043C863O1059C869O1072C875O1104C881O1121C887O1144C893O1163C899O1186C905O1207C911O1235C917O1264C922O1285C928O1309C934O1347C940O1428C948O1428C954O1416C959O1602C967O1602C973O1466C979O1483C985O1506C991O1525C997O1543C1003O1563C1009O1582C1015O1653C1023O1653C1027O1653C1029O1710C1037O1710C1043O1678C1049O1696C1054O1766C1062O1766C1068O1744C1073O1818C1081O1818C1087O1808C1092O1874C1100O1874C1106O1859C1112O1924C1120O1924C1124O1924C1126O1969C1130O1969C1134O1969C1136O2000C1140O2000C1144O2000C1146O2029C1150O2029C1154O2029C1156O2068C1160O2068C1164O2068C1166O2115C1170O2115C1174O2115C1176O2161C1180O2161C1184O2161C1186O2198C1190O2198C1194O2198C1196O2229C1200O2229C1204O2229C1206O2263C1210O2263C1214O2263C1216O2308C1220O2291C1226O2386C1234O2386C1240O2327C1245O2343C1250O2357C1255O2368C1260O2478C1268O2478C1274O2441C1280O2556C1288O2556C1294O2530C1300O2639C1304O2639C1306O2695C1310O2695C1312O2730C1313O2730C1315O2885C1316O2885C1318O3006C1446O6853C1456O7256C1466O7313C1478O7404C1488O7441C1520O2981C1522O23728C1528O23758C1536O23764C1542O23776C1548O23790C1554O23798C1558O23817C1568O23841C1574O23853C1580O23867C1586O23875C1592O23886C1598O23897C1604O23910C1610O23924C1616O23937C1622O23948C1628O23958C1634O23968C1640O23980C1646O23991C1652O24003C1662O24015C1672O24026C1682O24038C1692O24051C1702O24065C1712O24078C1722O24093C1732O24109C1742O24123C1762O24138C1772O24152C1782O24160C1792O23743C1801O24170,,
code-creation,Function,10,36542,0x120d4439f98e,27,<instance_members_initializer> node:internal/fs/promises:202:3,0x120d4439dd80,~
code-source-info,0x120d4439f98e,122,4488,5286,C0O4488C12O4496C26O5286,,
tick,0x1bfb84b8c,36584,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x120d4439b14d,0x105108d28,0x10510894c,0x120d4439a952,0x105108d28,0x10510894c,0x3172a1b32c9a,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,Eval,10,36750,0x120d443a261e,5, node:internal/fs/rimraf:1:1,0x120d443a22b8,~
script-source,123,node:internal/fs/rimraf,// This file is a modified version of the rimraf module on npm. It has been\n// modified in the following ways:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  Promise\x2C\n  SafeSet\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst fs = require('fs');\nconst {\n  chmod\x2C\n  chmodSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  unlink\x2C\n  unlinkSync\n} = fs;\nconst { sep } = require('path');\nconst { setTimeout } = require('timers');\nconst { sleep } = require('internal/util');\nconst notEmptyErrorCodes = new SafeSet(['ENOTEMPTY'\x2C 'EEXIST'\x2C 'EPERM']);\nconst retryErrorCodes = new SafeSet(\n  ['EBUSY'\x2C 'EMFILE'\x2C 'ENFILE'\x2C 'ENOTEMPTY'\x2C 'EPERM']);\nconst isWindows = process.platform === 'win32';\nconst epermHandler = isWindows ? fixWinEPERM : _rmdir;\nconst epermHandlerSync = isWindows ? fixWinEPERMSync : _rmdirSync;\nconst readdirEncoding = 'buffer';\nconst separator = Buffer.from(sep);\n\n\nfunction rimraf(path\x2C options\x2C callback) {\n  let retries = 0;\n\n  _rimraf(path\x2C options\x2C function CB(err) {\n    if (err) {\n      if (retryErrorCodes.has(err.code) && retries < options.maxRetries) {\n        retries++;\n        const delay = retries * options.retryDelay;\n        return setTimeout(_rimraf\x2C delay\x2C path\x2C options\x2C CB);\n      }\n\n      // The file is already gone.\n      if (err.code === 'ENOENT')\n        err = null;\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rimraf(path\x2C options\x2C callback) {\n  // SunOS lets the root user unlink directories. Use lstat here to make sure\n  // it's not a directory.\n  lstat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (err.code === 'ENOENT')\n        return callback(null);\n\n      // Windows can EPERM on stat.\n      if (isWindows && err.code === 'EPERM')\n        return fixWinEPERM(path\x2C options\x2C err\x2C callback);\n    } else if (stats.isDirectory()) {\n      return _rmdir(path\x2C options\x2C err\x2C callback);\n    }\n\n    unlink(path\x2C (err) => {\n      if (err) {\n        if (err.code === 'ENOENT')\n          return callback(null);\n        if (err.code === 'EISDIR')\n          return _rmdir(path\x2C options\x2C err\x2C callback);\n        if (err.code === 'EPERM') {\n          return epermHandler(path\x2C options\x2C err\x2C callback);\n        }\n      }\n\n      return callback(err);\n    });\n  });\n}\n\n\nfunction fixWinEPERM(path\x2C options\x2C originalErr\x2C callback) {\n  chmod(path\x2C 0o666\x2C (err) => {\n    if (err)\n      return callback(err.code === 'ENOENT' ? null : originalErr);\n\n    stat(path\x2C (err\x2C stats) => {\n      if (err)\n        return callback(err.code === 'ENOENT' ? null : originalErr);\n\n      if (stats.isDirectory())\n        _rmdir(path\x2C options\x2C originalErr\x2C callback);\n      else\n        unlink(path\x2C callback);\n    });\n  });\n}\n\n\nfunction _rmdir(path\x2C options\x2C originalErr\x2C callback) {\n  rmdir(path\x2C (err) => {\n    if (err) {\n      if (notEmptyErrorCodes.has(err.code))\n        return _rmchildren(path\x2C options\x2C callback);\n      if (err.code === 'ENOTDIR')\n        return callback(originalErr);\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rmchildren(path\x2C options\x2C callback) {\n  const pathBuf = Buffer.from(path);\n\n  readdir(pathBuf\x2C readdirEncoding\x2C (err\x2C files) => {\n    if (err)\n      return callback(err);\n\n    let numFiles = files.length;\n\n    if (numFiles === 0)\n      return rmdir(path\x2C callback);\n\n    let done = false;\n\n    ArrayPrototypeForEach(files\x2C (child) => {\n      const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n      rimraf(childPath\x2C options\x2C (err) => {\n        if (done)\n          return;\n\n        if (err) {\n          done = true;\n          return callback(err);\n        }\n\n        numFiles--;\n        if (numFiles === 0)\n          rmdir(path\x2C callback);\n      });\n    });\n  });\n}\n\n\nfunction rimrafPromises(path\x2C options) {\n  return new Promise((resolve\x2C reject) => {\n    rimraf(path\x2C options\x2C (err) => {\n      if (err)\n        return reject(err);\n\n      resolve();\n    });\n  });\n}\n\n\nfunction rimrafSync(path\x2C options) {\n  let stats;\n\n  try {\n    stats = lstatSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    // Windows can EPERM on stat.\n    if (isWindows && err.code === 'EPERM')\n      fixWinEPERMSync(path\x2C options\x2C err);\n  }\n\n  try {\n    // SunOS lets the root user unlink directories.\n    if (stats?.isDirectory())\n      _rmdirSync(path\x2C options\x2C null);\n    else\n      _unlinkSync(path\x2C options);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'EPERM')\n      return epermHandlerSync(path\x2C options\x2C err);\n    if (err.code !== 'EISDIR')\n      throw err;\n\n    _rmdirSync(path\x2C options\x2C err);\n  }\n}\n\n\nfunction _unlinkSync(path\x2C options) {\n  const tries = options.maxRetries + 1;\n\n  for (let i = 1; i <= tries; i++) {\n    try {\n      return unlinkSync(path);\n    } catch (err) {\n      // Only sleep if this is not the last try\x2C and the delay is greater\n      // than zero\x2C and an error was encountered that warrants a retry.\n      if (retryErrorCodes.has(err.code) &&\n          i < tries &&\n          options.retryDelay > 0) {\n        sleep(i * options.retryDelay);\n      } else if (err.code === 'ENOENT') {\n        // The file is already gone.\n        return;\n      } else if (i === tries) {\n        throw err;\n      }\n    }\n  }\n}\n\n\nfunction _rmdirSync(path\x2C options\x2C originalErr) {\n  try {\n    rmdirSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'ENOTDIR') {\n      throw originalErr || err;\n    }\n\n    if (notEmptyErrorCodes.has(err.code)) {\n      // Removing failed. Try removing all children and then retrying the\n      // original removal. Windows has a habit of not closing handles promptly\n      // when files are deleted\x2C resulting in spurious ENOTEMPTY failures. Work\n      // around that issue by retrying on Windows.\n      const pathBuf = Buffer.from(path);\n\n      ArrayPrototypeForEach(readdirSync(pathBuf\x2C readdirEncoding)\x2C (child) => {\n        const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n        rimrafSync(childPath\x2C options);\n      });\n\n      const tries = options.maxRetries + 1;\n\n      for (let i = 1; i <= tries; i++) {\n        try {\n          return fs.rmdirSync(path);\n        } catch (err) {\n          // Only sleep if this is not the last try\x2C and the delay is greater\n          // than zero\x2C and an error was encountered that warrants a retry.\n          if (retryErrorCodes.has(err.code) &&\n              i < tries &&\n              options.retryDelay > 0) {\n            sleep(i * options.retryDelay);\n          } else if (err.code === 'ENOENT') {\n            // The file is already gone.\n            return;\n          } else if (i === tries) {\n            throw err;\n          }\n        }\n      }\n    }\n\n    throw originalErr || err;\n  }\n}\n\n\nfunction fixWinEPERMSync(path\x2C options\x2C originalErr) {\n  try {\n    chmodSync(path\x2C 0o666);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    throw originalErr;\n  }\n\n  let stats;\n\n  try {\n    stats = statSync(path\x2C { throwIfNoEntry: false });\n  } catch {\n    throw originalErr;\n  }\n\n  if (stats === undefined) return;\n\n  if (stats.isDirectory())\n    _rmdirSync(path\x2C options\x2C originalErr);\n  else\n    _unlinkSync(path\x2C options);\n}\n\n\nmodule.exports = { rimraf\x2C rimrafPromises\x2C rimrafSync };\n
code-source-info,0x120d443a261e,123,0,7453,C0O0C4O7453,,
code-creation,Function,10,37042,0x120d443a2c1e,409, node:internal/fs/rimraf:1:1,0x120d443a2598,~
code-source-info,0x120d443a2c1e,123,0,7453,C0O0C139O368C145O393C151O404C156O450C159O450C164O439C170O480C173O480C177O480C179O642C182O505C188O514C194O527C200O536C206O549C212O560C218O575C224O584C230O597C236O605C242O617C248O627C254O662C257O662C262O654C267O702C270O702C275O687C281O739C284O739C289O729C295O792C302O792C307O792C309O863C316O863C321O863C323O958C330O967C333O950C335O1001C345O1001C347O1060C357O1060C359O1126C361O1126C363O1154C366O1161C371O1161C376O1154C378O7396C385O7415C391O7423C397O7439C403O7411C408O7452,,
tick,0x1bfcd797c,37125,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x120d4439f22e,0x105108d28,0x10510894c,0x120d4439b14d,0x105108d28,0x10510894c,0x120d4439a952,0x105108d28,0x10510894c,0x3172a1b32c9a,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,LazyCompile,10,37167,0x120d443a3b1e,188,from node:buffer:296:28,0x232faba31ca0,~
script-source,24,node:buffer,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  MathFloor\x2C\n  MathMin\x2C\n  MathTrunc\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  SymbolSpecies\x2C\n  SymbolToPrimitive\x2C\n  TypedArrayPrototypeGetByteLength\x2C\n  TypedArrayPrototypeFill\x2C\n  TypedArrayPrototypeSet\x2C\n  Uint8Array\x2C\n  Uint8ArrayPrototype\x2C\n} = primordials;\n\nconst {\n  byteLengthUtf8\x2C\n  compare: _compare\x2C\n  compareOffset\x2C\n  createFromString\x2C\n  fill: bindingFill\x2C\n  indexOfBuffer\x2C\n  indexOfNumber\x2C\n  indexOfString\x2C\n  swap16: _swap16\x2C\n  swap32: _swap32\x2C\n  swap64: _swap64\x2C\n  kMaxLength\x2C\n  kStringMaxLength\n} = internalBinding('buffer');\nconst {\n  getOwnNonIndexProperties\x2C\n  propertyFilter: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\n  }\x2C\n} = internalBinding('util');\nconst {\n  customInspectSymbol\x2C\n  isInsideNodeModules\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  kIsEncodingSymbol\n} = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\n} = require('internal/util/types');\nconst {\n  inspect: utilInspect\n} = require('internal/util/inspect');\nconst { encodings } = internalBinding('string_decoder');\n\nconst {\n  codes: {\n    ERR_BUFFER_OUT_OF_BOUNDS\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_BUFFER_SIZE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_UNKNOWN_ENCODING\n  }\x2C\n  genericNodeError\x2C\n  hideStackFrames\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateBuffer\x2C\n  validateNumber\x2C\n  validateInteger\x2C\n  validateString\n} = require('internal/validators');\n// Provide validateInteger() but with kMaxLength as the default maximum value.\nconst validateOffset = (value\x2C name\x2C min = 0\x2C max = kMaxLength) =>\n  validateInteger(value\x2C name\x2C min\x2C max);\n\nconst {\n  FastBuffer\x2C\n  markAsUntransferable\x2C\n  addBufferPrototypeMethods\x2C\n  createUnsafeBuffer\n} = require('internal/buffer');\n\nconst {\n  Blob\x2C\n  resolveObjectURL\x2C\n} = require('internal/blob');\n\nFastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\n\nconst constants = ObjectDefineProperties({}\x2C {\n  MAX_LENGTH: {\n    value: kMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\x2C\n  MAX_STRING_LENGTH: {\n    value: kStringMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\n});\n\nBuffer.poolSize = 8 * 1024;\nlet poolSize\x2C poolOffset\x2C allocPool;\n\nconst encodingsMap = ObjectCreate(null);\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset = 0;\n}\ncreatePool();\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' +\n                      'issues. Please use the Buffer.alloc()\x2C ' +\n                      'Buffer.allocUnsafe()\x2C or Buffer.from() methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted ||\n      ++nodeModulesCheckCounter > 10000 ||\n      (!require('internal/options').getOptionValue('--pending-deprecation') &&\n       isInsideNodeModules())) {\n    // We don't emit a warning\x2C because we either:\n    // - Already did so\x2C or\n    // - Already checked too many times whether a call is coming\n    //   from node_modules and want to stop slowing down things\x2C or\n    // - We aren't running with `--pending-deprecation` enabled\x2C\n    //   and the code is inside `node_modules`.\n    return;\n  }\n\n  process.emitWarning(bufferWarning\x2C 'DeprecationWarning'\x2C 'DEP0005');\n  bufferWarningAlreadyEmitted = true;\n}\n\nfunction toInteger(n\x2C defaultVal) {\n  n = +n;\n  if (!NumberIsNaN(n) &&\n      n >= NumberMIN_SAFE_INTEGER &&\n      n <= NumberMAX_SAFE_INTEGER) {\n    return ((n % 1) === 0 ? n : MathFloor(n));\n  }\n  return defaultVal;\n}\n\nfunction _copy(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (!isUint8Array(source))\n    throw new ERR_INVALID_ARG_TYPE('source'\x2C ['Buffer'\x2C 'Uint8Array']\x2C source);\n  if (!isUint8Array(target))\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n\n  if (targetStart === undefined) {\n    targetStart = 0;\n  } else {\n    targetStart = toInteger(targetStart\x2C 0);\n    if (targetStart < 0)\n      throw new ERR_OUT_OF_RANGE('targetStart'\x2C '>= 0'\x2C targetStart);\n  }\n\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  } else {\n    sourceStart = toInteger(sourceStart\x2C 0);\n    if (sourceStart < 0)\n      throw new ERR_OUT_OF_RANGE('sourceStart'\x2C '>= 0'\x2C sourceStart);\n  }\n\n  if (sourceEnd === undefined) {\n    sourceEnd = source.length;\n  } else {\n    sourceEnd = toInteger(sourceEnd\x2C 0);\n    if (sourceEnd < 0)\n      throw new ERR_OUT_OF_RANGE('sourceEnd'\x2C '>= 0'\x2C sourceEnd);\n  }\n\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\n    return 0;\n\n  if (sourceStart > source.length) {\n    throw new ERR_OUT_OF_RANGE('sourceStart'\x2C\n                               `<= ${source.length}`\x2C\n                               sourceStart);\n  }\n\n  return _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n}\n\nfunction _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (sourceEnd - sourceStart > target.length - targetStart)\n    sourceEnd = sourceStart + target.length - targetStart;\n\n  let nb = sourceEnd - sourceStart;\n  const sourceLen = source.length - sourceStart;\n  if (nb > sourceLen)\n    nb = sourceLen;\n\n  if (sourceStart !== 0 || sourceEnd < source.length)\n    source = new Uint8Array(source.buffer\x2C source.byteOffset + sourceStart\x2C nb);\n\n  TypedArrayPrototypeSet(target\x2C source\x2C targetStart);\n\n  return nb;\n}\n\n/**\n * The Buffer() constructor is deprecated in documentation and should not be\n * used moving forward. Rather\x2C developers should use one of the three new\n * factory APIs: Buffer.from()\x2C Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n */\nfunction Buffer(arg\x2C encodingOrOffset\x2C length) {\n  showFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new ERR_INVALID_ARG_TYPE('string'\x2C 'string'\x2C arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg\x2C encodingOrOffset\x2C length);\n}\n\nObjectDefineProperty(Buffer\x2C SymbolSpecies\x2C {\n  enumerable: false\x2C\n  configurable: true\x2C\n  get() { return FastBuffer; }\n});\n\n/**\n * Functionally equivalent to Buffer(arg\x2C encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[\x2C encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[\x2C byteOffset[\x2C length]])\n */\nBuffer.from = function from(value\x2C encodingOrOffset\x2C length) {\n  if (typeof value === 'string')\n    return fromString(value\x2C encodingOrOffset);\n\n  if (typeof value === 'object' && value !== null) {\n    if (isAnyArrayBuffer(value))\n      return fromArrayBuffer(value\x2C encodingOrOffset\x2C length);\n\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null &&\n        valueOf !== value &&\n        (typeof valueOf === 'string' || typeof valueOf === 'object')) {\n      return from(valueOf\x2C encodingOrOffset\x2C length);\n    }\n\n    const b = fromObject(value);\n    if (b)\n      return b;\n\n    if (typeof value[SymbolToPrimitive] === 'function') {\n      const primitive = value[SymbolToPrimitive]('string');\n      if (typeof primitive === 'string') {\n        return fromString(primitive\x2C encodingOrOffset);\n      }\n    }\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'first argument'\x2C\n    ['string'\x2C 'Buffer'\x2C 'ArrayBuffer'\x2C 'Array'\x2C 'Array-like Object']\x2C\n    value\n  );\n};\n\n// Identical to the built-in %TypedArray%.of()\x2C but avoids using the deprecated\n// Buffer() constructor. Must use arrow function syntax to avoid automatically\n// adding a `prototype` property and making the function a constructor.\n//\n// Refs: https://tc39.github.io/ecma262/#sec-%typedarray%.of\n// Refs: https://esdiscuss.org/topic/isconstructor#content-11\nconst of = (...items) => {\n  const newObj = createUnsafeBuffer(items.length);\n  for (let k = 0; k < items.length; k++)\n    newObj[k] = items[k];\n  return newObj;\n};\nBuffer.of = of;\n\nObjectSetPrototypeOf(Buffer\x2C Uint8Array);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nconst assertSize = hideStackFrames((size) => {\n  validateNumber(size\x2C 'size');\n  if (!(size >= 0 && size <= kMaxLength)) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\n  }\n});\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[\x2C fill[\x2C encoding]])\n */\nBuffer.alloc = function alloc(size\x2C fill\x2C encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf\x2C fill\x2C 0\x2C buf.length\x2C encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num)\x2C by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafe = function allocUnsafe(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num)\x2C by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set\x2C a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  assertSize(length);\n  return createUnsafeBuffer(length);\n}\n\nObjectSetPrototypeOf(SlowBuffer.prototype\x2C Uint8ArrayPrototype);\nObjectSetPrototypeOf(SlowBuffer\x2C Uint8Array);\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  }\n  return createUnsafeBuffer(size);\n}\n\nfunction fromStringFast(string\x2C ops) {\n  const length = ops.byteLength(string);\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return createFromString(string\x2C ops.encodingVal);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  let b = new FastBuffer(allocPool\x2C poolOffset\x2C length);\n  const actual = ops.write(b\x2C string\x2C 0\x2C length);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case\x2C though.\n    b = new FastBuffer(allocPool\x2C poolOffset\x2C actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromString(string\x2C encoding) {\n  let ops;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    if (string.length === 0)\n      return new FastBuffer();\n    ops = encodingOps.utf8;\n    encoding = undefined;\n  } else {\n    ops = getEncodingOps(encoding);\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n  return fromStringFast(string\x2C ops);\n}\n\nfunction fromArrayBuffer(obj\x2C byteOffset\x2C length) {\n  // Convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (NumberIsNaN(byteOffset))\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // Convert length to non-negative integer.\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength)\n        throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj\x2C byteOffset\x2C length);\n}\n\nfunction fromArrayLike(obj) {\n  if (obj.length <= 0)\n    return new FastBuffer();\n  if (obj.length < (Buffer.poolSize >>> 1)) {\n    if (obj.length > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C obj.length);\n    TypedArrayPrototypeSet(b\x2C obj\x2C 0);\n    poolOffset += obj.length;\n    alignPool();\n    return b;\n  }\n  return new FastBuffer(obj);\n}\n\nfunction fromObject(obj) {\n  if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n    if (typeof obj.length !== 'number') {\n      return new FastBuffer();\n    }\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && ArrayIsArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\nBuffer.compare = function compare(buf1\x2C buf2) {\n  if (!isUint8Array(buf1)) {\n    throw new ERR_INVALID_ARG_TYPE('buf1'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf1);\n  }\n\n  if (!isUint8Array(buf2)) {\n    throw new ERR_INVALID_ARG_TYPE('buf2'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf2);\n  }\n\n  if (buf1 === buf2) {\n    return 0;\n  }\n\n  return _compare(buf1\x2C buf2);\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  return typeof encoding === 'string' && encoding.length !== 0 &&\n         normalizeEncoding(encoding) !== undefined;\n};\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\n\nBuffer.concat = function concat(list\x2C length) {\n  validateArray(list\x2C 'list');\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (let i = 0; i < list.length; i++) {\n      if (list[i].length) {\n        length += list[i].length;\n      }\n    }\n  } else {\n    validateOffset(length\x2C 'length');\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    if (!isUint8Array(buf)) {\n      // TODO(BridgeAR): This should not be of type ERR_INVALID_ARG_TYPE.\n      // Instead\x2C find the proper error code for this.\n      throw new ERR_INVALID_ARG_TYPE(\n        `list[${i}]`\x2C ['Buffer'\x2C 'Uint8Array']\x2C list[i]);\n    }\n    pos += _copyActual(buf\x2C buffer\x2C pos\x2C 0\x2C buf.length);\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length\x2C i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    TypedArrayPrototypeFill(buffer\x2C 0\x2C pos\x2C length);\n  }\n\n  return buffer;\n};\n\nfunction base64ByteLength(str\x2C bytes) {\n  // Handle padding\n  if (StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\nconst encodingOps = {\n  utf8: {\n    encoding: 'utf8'\x2C\n    encodingVal: encodingsMap.utf8\x2C\n    byteLength: byteLengthUtf8\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.utf8Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.utf8Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf8\x2C dir)\n  }\x2C\n  ucs2: {\n    encoding: 'ucs2'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  utf16le: {\n    encoding: 'utf16le'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  latin1: {\n    encoding: 'latin1'\x2C\n    encodingVal: encodingsMap.latin1\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.latin1Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.latin1Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.latin1\x2C dir)\n  }\x2C\n  ascii: {\n    encoding: 'ascii'\x2C\n    encodingVal: encodingsMap.ascii\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.asciiWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.asciiSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.ascii)\x2C\n                    byteOffset\x2C\n                    encodingsMap.ascii\x2C\n                    dir)\n  }\x2C\n  base64: {\n    encoding: 'base64'\x2C\n    encodingVal: encodingsMap.base64\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.base64Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64\x2C\n                    dir)\n  }\x2C\n  base64url: {\n    encoding: 'base64url'\x2C\n    encodingVal: encodingsMap.base64url\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) =>\n      buf.base64urlWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64urlSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64url)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64url\x2C\n                    dir)\n  }\x2C\n  hex: {\n    encoding: 'hex'\x2C\n    encodingVal: encodingsMap.hex\x2C\n    byteLength: (string) => string.length >>> 1\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.hexWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.hexSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.hex)\x2C\n                    byteOffset\x2C\n                    encodingsMap.hex\x2C\n                    dir)\n  }\n};\nfunction getEncodingOps(encoding) {\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf16le')\n        return encodingOps.utf16le;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf-16le')\n        return encodingOps.utf16le;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      break;\n    case 3:\n      if (encoding === 'hex' || StringPrototypeToLowerCase(encoding) === 'hex')\n        return encodingOps.hex;\n      break;\n    case 9:\n      if (encoding === 'base64url' ||\n          StringPrototypeToLowerCase(encoding) === 'base64url')\n        return encodingOps.base64url;\n      break;\n  }\n}\n\nfunction byteLength(string\x2C encoding) {\n  if (typeof string !== 'string') {\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new ERR_INVALID_ARG_TYPE(\n      'string'\x2C ['string'\x2C 'Buffer'\x2C 'ArrayBuffer']\x2C string\n    );\n  }\n\n  const len = string.length;\n  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n  if (!mustMatch && len === 0)\n    return 0;\n\n  if (!encoding)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n  return ops.byteLength(string);\n}\n\nBuffer.byteLength = byteLength;\n\n// For backwards compatibility.\nObjectDefineProperty(Buffer.prototype\x2C 'parent'\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\n});\nObjectDefineProperty(Buffer.prototype\x2C 'offset'\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\n});\n\nBuffer.prototype.copy =\n  function copy(target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n    return _copy(this\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n  };\n\n// No need to verify that "buf.length <= MAX_UINT32" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function toString(encoding\x2C start\x2C end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0\x2C this.length);\n  }\n\n  const len = this.length;\n\n  if (start <= 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n  else\n    start |= 0;\n\n  if (end === undefined || end > len)\n    end = len;\n  else\n    end |= 0;\n\n  if (end <= start)\n    return '';\n\n  if (encoding === undefined)\n    return this.utf8Slice(start\x2C end);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n\n  return ops.slice(this\x2C start\x2C end);\n};\n\nBuffer.prototype.equals = function equals(otherBuffer) {\n  if (!isUint8Array(otherBuffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'otherBuffer'\x2C ['Buffer'\x2C 'Uint8Array']\x2C otherBuffer);\n  }\n\n  if (this === otherBuffer)\n    return true;\n\n  if (this.byteLength !== otherBuffer.byteLength)\n    return false;\n\n  return this.byteLength === 0 || _compare(this\x2C otherBuffer) === 0;\n};\n\nlet INSPECT_MAX_BYTES = 50;\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes\x2C ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = MathMin(max\x2C this.length);\n  const remaining = this.length - max;\n  let str = StringPrototypeTrim(StringPrototypeReplace(\n    this.hexSlice(0\x2C actualMax)\x2C /(.{2})/g\x2C '$1 '));\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  // Inspect special properties as well\x2C if possible.\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n    const obj = ObjectCreate(null);\n    ArrayPrototypeForEach(getOwnNonIndexProperties(this\x2C filter)\x2C\n                          (key) => {\n                            extras = true;\n                            obj[key] = this[key];\n                          });\n    if (extras) {\n      if (this.length !== 0)\n        str += '\x2C ';\n      // '[Object: null prototype] {'.length === 26\n      // This is guarded with a test.\n      str += StringPrototypeSlice(utilInspect(obj\x2C {\n        ...ctx\x2C\n        breakLength: Infinity\x2C\n        compact: true\n      })\x2C 27\x2C -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target\x2C\n                                            targetStart\x2C\n                                            targetEnd\x2C\n                                            sourceStart\x2C\n                                            sourceEnd) {\n  if (!isUint8Array(target)) {\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n  }\n  if (arguments.length === 1)\n    return _compare(this\x2C target);\n\n  if (targetStart === undefined)\n    targetStart = 0;\n  else\n    validateOffset(targetStart\x2C 'targetStart');\n\n  if (targetEnd === undefined)\n    targetEnd = target.length;\n  else\n    validateOffset(targetEnd\x2C 'targetEnd'\x2C 0\x2C target.length);\n\n  if (sourceStart === undefined)\n    sourceStart = 0;\n  else\n    validateOffset(sourceStart\x2C 'sourceStart');\n\n  if (sourceEnd === undefined)\n    sourceEnd = this.length;\n  else\n    validateOffset(sourceEnd\x2C 'sourceEnd'\x2C 0\x2C this.length);\n\n  if (sourceStart >= sourceEnd)\n    return (targetStart >= targetEnd ? 0 : -1);\n  if (targetStart >= targetEnd)\n    return 1;\n\n  return compareOffset(this\x2C target\x2C targetStart\x2C sourceStart\x2C targetEnd\x2C\n                       sourceEnd);\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`\x2C\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string\x2C Buffer\x2C or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding\x2C relevant if val is a string\n// - dir - true for indexOf\x2C false for lastIndexOf\nfunction bidirectionalIndexOf(buffer\x2C val\x2C byteOffset\x2C encoding\x2C dir) {\n  validateBuffer(buffer);\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined\x2C "foo"\x2C {}\x2C coerces to NaN\x2C search whole buffer.\n  if (NumberIsNaN(byteOffset)) {\n    byteOffset = dir ? 0 : (buffer.length || buffer.byteLength);\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'number')\n    return indexOfNumber(buffer\x2C val >>> 0\x2C byteOffset\x2C dir);\n\n  let ops;\n  if (encoding === undefined)\n    ops = encodingOps.utf8;\n  else\n    ops = getEncodingOps(encoding);\n\n  if (typeof val === 'string') {\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    return ops.indexOf(buffer\x2C val\x2C byteOffset\x2C dir);\n  }\n\n  if (isUint8Array(val)) {\n    const encodingVal =\n      (ops === undefined ? encodingsMap.utf8 : ops.encodingVal);\n    return indexOfBuffer(buffer\x2C val\x2C byteOffset\x2C encodingVal\x2C dir);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'value'\x2C ['number'\x2C 'string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C val\n  );\n}\n\nBuffer.prototype.indexOf = function indexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C false);\n};\n\nBuffer.prototype.includes = function includes(val\x2C byteOffset\x2C encoding) {\n  return this.indexOf(val\x2C byteOffset\x2C encoding) !== -1;\n};\n\n// Usage:\n//    buffer.fill(number[\x2C offset[\x2C end]])\n//    buffer.fill(buffer[\x2C offset[\x2C end]])\n//    buffer.fill(string[\x2C offset[\x2C end]][\x2C encoding])\nBuffer.prototype.fill = function fill(value\x2C offset\x2C end\x2C encoding) {\n  return _fill(this\x2C value\x2C offset\x2C end\x2C encoding);\n};\n\nfunction _fill(buf\x2C value\x2C offset\x2C end\x2C encoding) {\n  if (typeof value === 'string') {\n    if (offset === undefined || typeof offset === 'string') {\n      encoding = offset;\n      offset = 0;\n      end = buf.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = buf.length;\n    }\n\n    const normalizedEncoding = normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      validateString(encoding\x2C 'encoding');\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (value.length === 0) {\n      // If value === '' default to zero.\n      value = 0;\n    } else if (value.length === 1) {\n      // Fast path: If `value` fits into a single byte\x2C use that numeric value.\n      if (normalizedEncoding === 'utf8') {\n        const code = StringPrototypeCharCodeAt(value\x2C 0);\n        if (code < 128) {\n          value = code;\n        }\n      } else if (normalizedEncoding === 'latin1') {\n        value = StringPrototypeCharCodeAt(value\x2C 0);\n      }\n    }\n  } else {\n    encoding = undefined;\n  }\n\n  if (offset === undefined) {\n    offset = 0;\n    end = buf.length;\n  } else {\n    validateOffset(offset\x2C 'offset');\n    // Invalid ranges are not set to a default\x2C so can range check early.\n    if (end === undefined) {\n      end = buf.length;\n    } else {\n      validateOffset(end\x2C 'end'\x2C 0\x2C buf.length);\n    }\n    if (offset >= end)\n      return buf;\n  }\n\n\n  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArrayPrototypeGetByteLength(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n    TypedArrayPrototypeFill(buf\x2C value\x2C offset\x2C end);\n  } else {\n    const res = bindingFill(buf\x2C value\x2C offset\x2C end\x2C encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE('value'\x2C value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n\n  return buf;\n}\n\nBuffer.prototype.write = function write(string\x2C offset\x2C length\x2C encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string\x2C 0\x2C this.length);\n  }\n  // Buffer#write(string\x2C encoding)\n  if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string\x2C offset[\x2C length][\x2C encoding])\n  } else {\n    validateOffset(offset\x2C 'offset'\x2C 0\x2C this.length);\n\n    const remaining = this.length - offset;\n\n    if (length === undefined) {\n      length = remaining;\n    } else if (typeof length === 'string') {\n      encoding = length;\n      length = remaining;\n    } else {\n      validateOffset(length\x2C 'length'\x2C 0\x2C this.length);\n      if (length > remaining)\n        length = remaining;\n    }\n  }\n\n  if (!encoding)\n    return this.utf8Write(string\x2C offset\x2C length);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.write(this\x2C string\x2C offset\x2C length);\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (let i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer'\x2C data };\n  }\n  return { type: 'Buffer'\x2C data: [] };\n};\n\nfunction adjustOffset(offset\x2C length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence\x2C don't use offset | 0 or similar techniques.\n  offset = MathTrunc(offset);\n  if (offset === 0) {\n    return 0;\n  }\n  if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  }\n  if (offset < length) {\n    return offset;\n  }\n  return NumberIsNaN(offset) ? 0 : length;\n}\n\nBuffer.prototype.subarray = function subarray(start\x2C end) {\n  const srcLength = this.length;\n  start = adjustOffset(start\x2C srcLength);\n  end = end !== undefined ? adjustOffset(end\x2C srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer\x2C this.byteOffset + start\x2C newLength);\n};\n\nBuffer.prototype.slice = function slice(start\x2C end) {\n  return this.subarray(start\x2C end);\n};\n\nfunction swap(b\x2C n\x2C m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('16-bits');\n  if (len < 128) {\n    for (let i = 0; i < len; i += 2)\n      swap(this\x2C i\x2C i + 1);\n    return this;\n  }\n  return _swap16(this);\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('32-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 4) {\n      swap(this\x2C i\x2C i + 3);\n      swap(this\x2C i + 1\x2C i + 2);\n    }\n    return this;\n  }\n  return _swap32(this);\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('64-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 8) {\n      swap(this\x2C i\x2C i + 7);\n      swap(this\x2C i + 1\x2C i + 6);\n      swap(this\x2C i + 2\x2C i + 5);\n      swap(this\x2C i + 3\x2C i + 4);\n    }\n    return this;\n  }\n  return _swap64(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nlet transcode;\nif (internalBinding('config').hasIntl) {\n  const {\n    icuErrName\x2C\n    transcode: _transcode\n  } = internalBinding('icu');\n\n  // Transcodes the Buffer from one encoding to another\x2C returning a new\n  // Buffer instance.\n  transcode = function transcode(source\x2C fromEncoding\x2C toEncoding) {\n    if (!isUint8Array(source)) {\n      throw new ERR_INVALID_ARG_TYPE('source'\x2C\n                                     ['Buffer'\x2C 'Uint8Array']\x2C source);\n    }\n    if (source.length === 0) return Buffer.alloc(0);\n\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n    const result = _transcode(source\x2C fromEncoding\x2C toEncoding);\n    if (typeof result !== 'number')\n      return result;\n\n    const code = icuErrName(result);\n    const err = genericNodeError(\n      `Unable to transcode Buffer [${code}]`\x2C\n      { code: code\x2C errno: result }\n    );\n    throw err;\n  };\n}\n\nfunction btoa(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('input');\n  }\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (input[n].charCodeAt(0) > 0xff)\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  const buf = Buffer.from(input\x2C 'latin1');\n  return buf.toString('base64');\n}\n\nconst kBase64Digits =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction atob(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('input');\n  }\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (!kBase64Digits.includes(input[n]))\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  return Buffer.from(input\x2C 'base64').toString('latin1');\n}\n\nmodule.exports = {\n  Blob\x2C\n  resolveObjectURL\x2C\n  Buffer\x2C\n  SlowBuffer\x2C\n  transcode\x2C\n  // Legacy\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n  btoa\x2C\n  atob\x2C\n};\n\nObjectDefineProperties(module.exports\x2C {\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  INSPECT_MAX_BYTES: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() { return INSPECT_MAX_BYTES; }\x2C\n    set(val) { INSPECT_MAX_BYTES = val; }\n  }\n});\n
code-source-info,0x120d443a3b1e,24,8440,9391,C3O8478C9O8513C12O8520C17O8556C18O8560C28O8615C33O8619C39O8650C51O8657C56O8706C57O8734C63O8751C68O8751C73O8766C78O8805C95O8896C104O8903C109O8943C110O8965C113O8965C118O8988C120O9001C122O9010C123O9016C125O9033C127O9032C134O9094C136O9100C138O9099C145O9118C151O9136C155O9181C158O9188C163O9228C164O9250C182O9256C187O9250,,
tick,0x1bfd39474,38542,0,0x0,3,0x0,0x120d443a2d91,0x105108d28,0x10510894c,0x120d4439f22e,0x105108d28,0x10510894c,0x120d4439b14d,0x105108d28,0x10510894c,0x120d4439a952,0x105108d28,0x10510894c,0x3172a1b32c9a,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,LazyCompile,10,38542,0x120d443a654e,110,fromString node:buffer:432:20,0x232faba32088,~
code-source-info,0x120d443a654e,24,12491,12925,C0O12518C2O12525C8O12570C14O12577C19O12601C25O12608C30O12621C35O12628C40O12645C41O12650C46O12668C51O12678C56O12715C59O12721C64O12751C66O12780C73O12786C78O12780C79O12837C85O12844C90O12857C95O12864C100O12881C101O12888C104O12895C109O12923,,
code-creation,LazyCompile,10,38625,0x120d443a6706,177,fromStringFast node:buffer:413:24,0x232faba31fe8,~
code-source-info,0x120d443a6706,24,11947,12470,C0O11984C5O11984C11O12007C14O12029C18O12038C21O12018C26O12050C31O12086C36O12057C41O12099C42O12103C44O12117C49O12128C51O12126C54O12114C59O12145C62O12145C65O12169C72O12184C77O12195C85O12169C91O12237C110O12237C116O12268C118O12279C123O12363C130O12382C135O12393C143O12367C149O12420C156O12434C162O12431C168O12444C171O12444C174O12459C176O12468,,
code-creation,LazyCompile,10,38667,0x120d443a68f6,36,FastBuffer node:internal/buffer:958:14,0x232faba3ec18,~
code-source-info,0x120d443a68f6,25,26364,26453,C3O26407C7O26441C20O26407C35O26452,,
code-creation,LazyCompile,10,38667,0x120d443a69f6,23,write node:buffer:593:12,0x232faba323f8,~
code-source-info,0x120d443a69f6,24,16559,16623,C0O16593C17O16593C22O16623,,
code-creation,LazyCompile,10,38709,0x120d443a6ae6,42,alignPool node:buffer:159:19,0x232faba31a20,~
code-source-info,0x120d443a6ae6,24,4032,4136,C0O4066C4O4081C9O4094C19O4105C25O4117C34O4127C41O4135,,
code-creation,Eval,10,38959,0x120d443a7906,5, node:internal/webstreams/adapters:1:1,0x120d443a7540,~
script-source,124,node:internal/webstreams/adapters,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  PromiseAll\x2C\n  PromisePrototypeThen\x2C\n  PromisePrototypeFinally\x2C\n  PromiseResolve\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ReadableStream\x2C\n  isReadableStream\x2C\n} = require('internal/webstreams/readablestream');\n\nconst {\n  WritableStream\x2C\n  isWritableStream\x2C\n} = require('internal/webstreams/writablestream');\n\nconst {\n  CountQueuingStrategy\x2C\n} = require('internal/webstreams/queuingstrategies');\n\nconst {\n  Writable\x2C\n  Readable\x2C\n  Duplex\x2C\n  destroy\x2C\n} = require('stream');\n\nconst {\n  isDestroyed\x2C\n  isReadable\x2C\n  isReadableEnded\x2C\n  isWritable\x2C\n  isWritableEnded\x2C\n} = require('internal/streams/utils');\n\nconst {\n  Buffer\x2C\n} = require('buffer');\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_STREAM_PREMATURE_CLOSE\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\n\nconst {\n  createDeferredPromise\x2C\n} = require('internal/util');\n\nconst {\n  validateBoolean\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst {\n  WriteWrap\x2C\n  ShutdownWrap\x2C\n  kReadBytesOrError\x2C\n  kLastWriteWasAsync\x2C\n  streamBaseState\x2C\n} = internalBinding('stream_wrap');\n\nconst finished = require('internal/streams/end-of-stream');\n\nconst { UV_EOF } = internalBinding('uv');\n\n/**\n * @typedef {import('../../stream').Writable} Writable\n * @typedef {import('../../stream').Readable} Readable\n * @typedef {import('./writablestream').WritableStream} WritableStream\n * @typedef {import('./readablestream').ReadableStream} ReadableStream\n */\n\n/**\n * @typedef {import('../abort_controller').AbortSignal} AbortSignal\n */\n\n/**\n * @param {Writable} streamWritable\n * @returns {WritableStream}\n */\nfunction newWritableStreamFromStreamWritable(streamWritable) {\n  // Not using the internal/streams/utils isWritableNodeStream utility\n  // here because it will return false if streamWritable is a Duplex\n  // whose writable option is false. For a Duplex that is not writable\x2C\n  // we want it to pass this check but return a closed WritableStream.\n  if (typeof streamWritable?._writableState !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'streamWritable'\x2C\n      'stream.Writable'\x2C\n      streamWritable);\n  }\n\n  if (isDestroyed(streamWritable) || !isWritable(streamWritable)) {\n    const writable = new WritableStream();\n    writable.close();\n    return writable;\n  }\n\n  const highWaterMark = streamWritable.writableHighWaterMark;\n  const strategy =\n    streamWritable.writableObjectMode ?\n      new CountQueuingStrategy({ highWaterMark }) :\n      { highWaterMark };\n\n  let controller;\n  let backpressurePromise;\n  let closed;\n\n  function onDrain() {\n    if (backpressurePromise !== undefined)\n      backpressurePromise.resolve();\n  }\n\n  const cleanup = finished(streamWritable\x2C (error) => {\n    if (error?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n      const err = new AbortError(undefined\x2C { cause: error });\n      error = err;\n    }\n\n    cleanup();\n    // This is a protection against non-standard\x2C legacy streams\n    // that happen to emit an error event again after finished is called.\n    streamWritable.on('error'\x2C () => {});\n    if (error != null) {\n      if (backpressurePromise !== undefined)\n        backpressurePromise.reject(error);\n      // If closed is not undefined\x2C the error is happening\n      // after the WritableStream close has already started.\n      // We need to reject it here.\n      if (closed !== undefined) {\n        closed.reject(error);\n        closed = undefined;\n      }\n      controller.error(error);\n      controller = undefined;\n      return;\n    }\n\n    if (closed !== undefined) {\n      closed.resolve();\n      closed = undefined;\n      return;\n    }\n    controller.error(new AbortError());\n    controller = undefined;\n  });\n\n  streamWritable.on('drain'\x2C onDrain);\n\n  return new WritableStream({\n    start(c) { controller = c; }\x2C\n\n    async write(chunk) {\n      if (streamWritable.writableNeedDrain || !streamWritable.write(chunk)) {\n        backpressurePromise = createDeferredPromise();\n        return PromisePrototypeFinally(\n          backpressurePromise.promise\x2C () => {\n            backpressurePromise = undefined;\n          });\n      }\n    }\x2C\n\n    abort(reason) {\n      destroy(streamWritable\x2C reason);\n    }\x2C\n\n    close() {\n      if (closed === undefined && !isWritableEnded(streamWritable)) {\n        closed = createDeferredPromise();\n        streamWritable.end();\n        return closed.promise;\n      }\n\n      controller = undefined;\n      return PromiseResolve();\n    }\x2C\n  }\x2C strategy);\n}\n\n/**\n * @param {WritableStream} writableStream\n * @param {{\n *   decodeStrings? : boolean\x2C\n *   highWaterMark? : number\x2C\n *   objectMode? : boolean\x2C\n *   signal? : AbortSignal\x2C\n * }} [options]\n * @returns {Writable}\n */\nfunction newStreamWritableFromWritableStream(writableStream\x2C options = {}) {\n  if (!isWritableStream(writableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'writableStream'\x2C\n      'WritableStream'\x2C\n      writableStream);\n  }\n\n  validateObject(options\x2C 'options');\n  const {\n    highWaterMark\x2C\n    decodeStrings = true\x2C\n    objectMode = false\x2C\n    signal\x2C\n  } = options;\n\n  validateBoolean(objectMode\x2C 'options.objectMode');\n  validateBoolean(decodeStrings\x2C 'options.decodeStrings');\n\n  const writer = writableStream.getWriter();\n  let closed = false;\n\n  const writable = new Writable({\n    highWaterMark\x2C\n    objectMode\x2C\n    decodeStrings\x2C\n    signal\x2C\n\n    writev(chunks\x2C callback) {\n      function done(error) {\n        error = error.filter((e) => e);\n        try {\n          callback(error.length === 0 ? undefined : error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => destroy(writable\x2C error));\n        }\n      }\n\n      PromisePrototypeThen(\n        writer.ready\x2C\n        () => {\n          return PromisePrototypeThen(\n            PromiseAll(\n              ArrayPrototypeMap(\n                chunks\x2C\n                (data) => writer.write(data.chunk)))\x2C\n            done\x2C\n            done);\n        }\x2C\n        done);\n    }\x2C\n\n    write(chunk\x2C encoding\x2C callback) {\n      if (typeof chunk === 'string' && decodeStrings && !objectMode) {\n        chunk = Buffer.from(chunk\x2C encoding);\n        chunk = new Uint8Array(\n          chunk.buffer\x2C\n          chunk.byteOffset\x2C\n          chunk.byteLength);\n      }\n\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          destroy(writable\x2C error);\n        }\n      }\n\n      PromisePrototypeThen(\n        writer.ready\x2C\n        () => {\n          return PromisePrototypeThen(\n            writer.write(chunk)\x2C\n            done\x2C\n            done);\n        }\x2C\n        done);\n    }\x2C\n\n    destroy(error\x2C callback) {\n      function done() {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => { throw error; });\n        }\n      }\n\n      if (!closed) {\n        if (error != null) {\n          PromisePrototypeThen(\n            writer.abort(error)\x2C\n            done\x2C\n            done);\n        } else {\n          PromisePrototypeThen(\n            writer.close()\x2C\n            done\x2C\n            done);\n        }\n        return;\n      }\n\n      done();\n    }\x2C\n\n    final(callback) {\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => destroy(writable\x2C error));\n        }\n      }\n\n      if (!closed) {\n        PromisePrototypeThen(\n          writer.close()\x2C\n          done\x2C\n          done);\n      }\n    }\x2C\n  });\n\n  PromisePrototypeThen(\n    writer.closed\x2C\n    () => {\n      // If the WritableStream closes before the stream.Writable has been\n      // ended\x2C we signal an error on the stream.Writable.\n      closed = true;\n      if (!isWritableEnded(writable))\n        destroy(writable\x2C new ERR_STREAM_PREMATURE_CLOSE());\n    }\x2C\n    (error) => {\n      // If the WritableStream errors before the stream.Writable has been\n      // destroyed\x2C signal an error on the stream.Writable.\n      closed = true;\n      destroy(writable\x2C error);\n    });\n\n  return writable;\n}\n\n/**\n * @param {Readable} streamReadable\n * @returns {ReadableStream}\n */\nfunction newReadableStreamFromStreamReadable(streamReadable) {\n  // Not using the internal/streams/utils isReadableNodeStream utility\n  // here because it will return false if streamReadable is a Duplex\n  // whose readable option is false. For a Duplex that is not readable\x2C\n  // we want it to pass this check but return a closed ReadableStream.\n  if (typeof streamReadable?._readableState !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'streamReadable'\x2C\n      'stream.Readable'\x2C\n      streamReadable);\n  }\n\n  if (isDestroyed(streamReadable) || !isReadable(streamReadable)) {\n    const readable = new ReadableStream();\n    readable.cancel();\n    return readable;\n  }\n\n  const objectMode = streamReadable.readableObjectMode;\n  const highWaterMark = streamReadable.readableHighWaterMark;\n  // When not running in objectMode explicitly\x2C we just fall\n  // back to a minimal strategy that just specifies the highWaterMark\n  // and no size algorithm. Using a ByteLengthQueuingStrategy here\n  // is unnecessary.\n  const strategy =\n    objectMode ?\n      new CountQueuingStrategy({ highWaterMark }) :\n      { highWaterMark };\n\n  let controller;\n\n  function onData(chunk) {\n    // Copy the Buffer to detach it from the pool.\n    if (Buffer.isBuffer(chunk) && !objectMode)\n      chunk = new Uint8Array(chunk);\n    controller.enqueue(chunk);\n    if (controller.desiredSize <= 0)\n      streamReadable.pause();\n  }\n\n  streamReadable.pause();\n\n  const cleanup = finished(streamReadable\x2C (error) => {\n    if (error?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n      const err = new AbortError(undefined\x2C { cause: error });\n      error = err;\n    }\n\n    cleanup();\n    // This is a protection against non-standard\x2C legacy streams\n    // that happen to emit an error event again after finished is called.\n    streamReadable.on('error'\x2C () => {});\n    if (error)\n      return controller.error(error);\n    controller.close();\n  });\n\n  streamReadable.on('data'\x2C onData);\n\n  return new ReadableStream({\n    start(c) { controller = c; }\x2C\n\n    pull() { streamReadable.resume(); }\x2C\n\n    cancel(reason) {\n      destroy(streamReadable\x2C reason);\n    }\x2C\n  }\x2C strategy);\n}\n\n/**\n * @param {ReadableStream} readableStream\n * @param {{\n *   highWaterMark? : number\x2C\n *   encoding? : string\x2C\n *   objectMode? : boolean\x2C\n *   signal? : AbortSignal\x2C\n * }} [options]\n * @returns {Readable}\n */\nfunction newStreamReadableFromReadableStream(readableStream\x2C options = {}) {\n  if (!isReadableStream(readableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'readableStream'\x2C\n      'ReadableStream'\x2C\n      readableStream);\n  }\n\n  validateObject(options\x2C 'options');\n  const {\n    highWaterMark\x2C\n    encoding\x2C\n    objectMode = false\x2C\n    signal\x2C\n  } = options;\n\n  if (encoding !== undefined && !Buffer.isEncoding(encoding))\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'options.encoding');\n  validateBoolean(objectMode\x2C 'options.objectMode');\n\n  const reader = readableStream.getReader();\n  let closed = false;\n\n  const readable = new Readable({\n    objectMode\x2C\n    highWaterMark\x2C\n    encoding\x2C\n    signal\x2C\n\n    read() {\n      PromisePrototypeThen(\n        reader.read()\x2C\n        (chunk) => {\n          if (chunk.done) {\n            // Value should always be undefined here.\n            readable.push(null);\n          } else {\n            readable.push(chunk.value);\n          }\n        }\x2C\n        (error) => destroy(readable\x2C error));\n    }\x2C\n\n    destroy(error\x2C callback) {\n      function done() {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => { throw error; });\n        }\n      }\n\n      if (!closed) {\n        PromisePrototypeThen(\n          reader.cancel(error)\x2C\n          done\x2C\n          done);\n        return;\n      }\n      done();\n    }\x2C\n  });\n\n  PromisePrototypeThen(\n    reader.closed\x2C\n    () => {\n      closed = true;\n      if (!isReadableEnded(readable))\n        readable.push(null);\n    }\x2C\n    (error) => {\n      closed = true;\n      destroy(readable\x2C error);\n    });\n\n  return readable;\n}\n\n/**\n * @typedef {import('./readablestream').ReadableWritablePair\n * } ReadableWritablePair\n * @typedef {import('../../stream').Duplex} Duplex\n */\n\n/**\n * @param {Duplex} duplex\n * @returns {ReadableWritablePair}\n */\nfunction newReadableWritablePairFromDuplex(duplex) {\n  // Not using the internal/streams/utils isWritableNodeStream and\n  // isReadableNodestream utilities here because they will return false\n  // if the duplex was created with writable or readable options set to\n  // false. Instead\x2C we'll check the readable and writable state after\n  // and return closed WritableStream or closed ReadableStream as\n  // necessary.\n  if (typeof duplex?._writableState !== 'object' ||\n      typeof duplex?._readableState !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('duplex'\x2C 'stream.Duplex'\x2C duplex);\n  }\n\n  if (isDestroyed(duplex)) {\n    const writable = new WritableStream();\n    const readable = new ReadableStream();\n    writable.close();\n    readable.cancel();\n    return { readable\x2C writable };\n  }\n\n  const writable =\n    isWritable(duplex) ?\n      newWritableStreamFromStreamWritable(duplex) :\n      new WritableStream();\n\n  if (!isWritable(duplex))\n    writable.close();\n\n  const readable =\n    isReadable(duplex) ?\n      newReadableStreamFromStreamReadable(duplex) :\n      new ReadableStream();\n\n  if (!isReadable(duplex))\n    readable.cancel();\n\n  return { writable\x2C readable };\n}\n\n/**\n * @param {ReadableWritablePair} pair\n * @param {{\n *   allowHalfOpen? : boolean\x2C\n *   decodeStrings? : boolean\x2C\n *   encoding? : string\x2C\n *   highWaterMark? : number\x2C\n *   objectMode? : boolean\x2C\n *   signal? : AbortSignal\x2C\n * }} [options]\n * @returns {Duplex}\n */\nfunction newStreamDuplexFromReadableWritablePair(pair = {}\x2C options = {}) {\n  validateObject(pair\x2C 'pair');\n  const {\n    readable: readableStream\x2C\n    writable: writableStream\x2C\n  } = pair;\n\n  if (!isReadableStream(readableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'pair.readable'\x2C\n      'ReadableStream'\x2C\n      readableStream);\n  }\n  if (!isWritableStream(writableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'pair.writable'\x2C\n      'WritableStream'\x2C\n      writableStream);\n  }\n\n  validateObject(options\x2C 'options');\n  const {\n    allowHalfOpen = false\x2C\n    objectMode = false\x2C\n    encoding\x2C\n    decodeStrings = true\x2C\n    highWaterMark\x2C\n    signal\x2C\n  } = options;\n\n  validateBoolean(objectMode\x2C 'options.objectMode');\n  if (encoding !== undefined && !Buffer.isEncoding(encoding))\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'options.encoding');\n\n  const writer = writableStream.getWriter();\n  const reader = readableStream.getReader();\n  let writableClosed = false;\n  let readableClosed = false;\n\n  const duplex = new Duplex({\n    allowHalfOpen\x2C\n    highWaterMark\x2C\n    objectMode\x2C\n    encoding\x2C\n    decodeStrings\x2C\n    signal\x2C\n\n    writev(chunks\x2C callback) {\n      function done(error) {\n        error = error.filter((e) => e);\n        try {\n          callback(error.length === 0 ? undefined : error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => destroy(duplex\x2C error));\n        }\n      }\n\n      PromisePrototypeThen(\n        writer.ready\x2C\n        () => {\n          return PromisePrototypeThen(\n            PromiseAll(\n              ArrayPrototypeMap(\n                chunks\x2C\n                (data) => writer.write(data.chunk)))\x2C\n            done\x2C\n            done);\n        }\x2C\n        done);\n    }\x2C\n\n    write(chunk\x2C encoding\x2C callback) {\n      if (typeof chunk === 'string' && decodeStrings && !objectMode) {\n        chunk = Buffer.from(chunk\x2C encoding);\n        chunk = new Uint8Array(\n          chunk.buffer\x2C\n          chunk.byteOffset\x2C\n          chunk.byteLength);\n      }\n\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          destroy(duplex\x2C error);\n        }\n      }\n\n      PromisePrototypeThen(\n        writer.ready\x2C\n        () => {\n          return PromisePrototypeThen(\n            writer.write(chunk)\x2C\n            done\x2C\n            done);\n        }\x2C\n        done);\n    }\x2C\n\n    final(callback) {\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => destroy(duplex\x2C error));\n        }\n      }\n\n      if (!writableClosed) {\n        PromisePrototypeThen(\n          writer.close()\x2C\n          done\x2C\n          done);\n      }\n    }\x2C\n\n    read() {\n      PromisePrototypeThen(\n        reader.read()\x2C\n        (chunk) => {\n          if (chunk.done) {\n            duplex.push(null);\n          } else {\n            duplex.push(chunk.value);\n          }\n        }\x2C\n        (error) => destroy(duplex\x2C error));\n    }\x2C\n\n    destroy(error\x2C callback) {\n      function done() {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => { throw error; });\n        }\n      }\n\n      async function closeWriter() {\n        if (!writableClosed)\n          await writer.abort(error);\n      }\n\n      async function closeReader() {\n        if (!readableClosed)\n          await reader.cancel(error);\n      }\n\n      if (!writableClosed || !readableClosed) {\n        PromisePrototypeThen(\n          PromiseAll([\n            closeWriter()\x2C\n            closeReader()\x2C\n          ])\x2C\n          done\x2C\n          done);\n        return;\n      }\n\n      done();\n    }\x2C\n  });\n\n  PromisePrototypeThen(\n    writer.closed\x2C\n    () => {\n      writableClosed = true;\n      if (!isWritableEnded(duplex))\n        destroy(duplex\x2C new ERR_STREAM_PREMATURE_CLOSE());\n    }\x2C\n    (error) => {\n      writableClosed = true;\n      readableClosed = true;\n      destroy(duplex\x2C error);\n    });\n\n  PromisePrototypeThen(\n    reader.closed\x2C\n    () => {\n      readableClosed = true;\n      if (!isReadableEnded(duplex))\n        duplex.push(null);\n    }\x2C\n    (error) => {\n      writableClosed = true;\n      readableClosed = true;\n      destroy(duplex\x2C error);\n    });\n\n  return duplex;\n}\n\n/**\n * @typedef {import('./queuingstrategies').QueuingStrategy} QueuingStrategy\n * @typedef {{}} StreamBase\n * @param {StreamBase} streamBase\n * @param {QueuingStrategy} strategy\n * @returns {WritableStream}\n */\nfunction newWritableStreamFromStreamBase(streamBase\x2C strategy) {\n  validateObject(streamBase\x2C 'streamBase');\n\n  let current;\n\n  function createWriteWrap(controller\x2C promise) {\n    const req = new WriteWrap();\n    req.handle = streamBase;\n    req.oncomplete = onWriteComplete;\n    req.async = false;\n    req.bytes = 0;\n    req.buffer = null;\n    req.controller = controller;\n    req.promise = promise;\n    return req;\n  }\n\n  function onWriteComplete(status) {\n    if (status < 0) {\n      const error = errnoException(status\x2C 'write'\x2C this.error);\n      this.promise.reject(error);\n      this.controller.error(error);\n      return;\n    }\n    this.promise.resolve();\n  }\n\n  function doWrite(chunk\x2C controller) {\n    const promise = createDeferredPromise();\n    let ret;\n    let req;\n    try {\n      req = createWriteWrap(controller\x2C promise);\n      ret = streamBase.writeBuffer(req\x2C chunk);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = chunk;\n      req.async = !!streamBaseState[kLastWriteWasAsync];\n    } catch (error) {\n      promise.reject(error);\n    }\n\n    if (ret !== 0)\n      promise.reject(errnoException(ret\x2C 'write'\x2C req));\n    else if (!req.async)\n      promise.resolve();\n\n    return promise.promise;\n  }\n\n  return new WritableStream({\n    write(chunk\x2C controller) {\n      current = current !== undefined ?\n        PromisePrototypeThen(\n          current\x2C\n          () => doWrite(chunk\x2C controller)\x2C\n          (error) => controller.error(error)) :\n        doWrite(chunk\x2C controller);\n      return current;\n    }\x2C\n\n    close() {\n      const promise = createDeferredPromise();\n      const req = new ShutdownWrap();\n      req.oncomplete = () => promise.resolve();\n      const err = streamBase.shutdown(req);\n      if (err === 1)\n        promise.resolve();\n      return promise.promise;\n    }\x2C\n  }\x2C strategy);\n}\n\n/**\n * @param {StreamBase} streamBase\n * @param {QueuingStrategy} strategy\n * @returns {ReadableStream}\n */\nfunction newReadableStreamFromStreamBase(streamBase\x2C strategy\x2C options = {}) {\n  validateObject(streamBase\x2C 'streamBase');\n  validateObject(options\x2C 'options');\n\n  const {\n    ondone = () => {}\x2C\n  } = options;\n\n  if (typeof streamBase.onread === 'function')\n    throw new ERR_INVALID_STATE('StreamBase already has a consumer');\n\n  if (typeof ondone !== 'function')\n    throw new ERR_INVALID_ARG_TYPE('options.ondone'\x2C 'Function'\x2C ondone);\n\n  let controller;\n\n  streamBase.onread = (arrayBuffer) => {\n    const nread = streamBaseState[kReadBytesOrError];\n\n    if (nread === 0)\n      return;\n\n    try {\n      if (nread === UV_EOF) {\n        controller.close();\n        streamBase.readStop();\n        try {\n          ondone();\n        } catch (error) {\n          controller.error(error);\n        }\n        return;\n      }\n\n      controller.enqueue(arrayBuffer);\n\n      if (controller.desiredSize <= 0)\n        streamBase.readStop();\n    } catch (error) {\n      controller.error(error);\n      streamBase.readStop();\n    }\n  };\n\n  return new ReadableStream({\n    start(c) { controller = c; }\x2C\n\n    pull() {\n      streamBase.readStart();\n    }\x2C\n\n    cancel() {\n      const promise = createDeferredPromise();\n      try {\n        ondone();\n      } catch (error) {\n        promise.reject(error);\n        return promise.promise;\n      }\n      const req = new ShutdownWrap();\n      req.oncomplete = () => promise.resolve();\n      const err = streamBase.shutdown(req);\n      if (err === 1)\n        promise.resolve();\n      return promise.promise;\n    }\x2C\n  }\x2C strategy);\n}\n\nmodule.exports = {\n  newWritableStreamFromStreamWritable\x2C\n  newReadableStreamFromStreamReadable\x2C\n  newStreamWritableFromWritableStream\x2C\n  newStreamReadableFromReadableStream\x2C\n  newReadableWritablePairFromDuplex\x2C\n  newStreamDuplexFromReadableWritablePair\x2C\n  newWritableStreamFromStreamBase\x2C\n  newReadableStreamFromStreamBase\x2C\n};\n
code-source-info,0x120d443a7906,124,0,24019,C0O0C4O24019,,
code-creation,Function,10,39875,0x120d443a8206,541, node:internal/webstreams/adapters:1:1,0x120d443a7880,~
code-source-info,0x120d443a8206,124,0,24019,C0O0C162O25C168O46C174O60C180O84C186O111C192O129C198O209C201O209C206O169C212O187C218O307C221O307C226O267C232O285C238O391C241O391C246O365C252O499C255O499C260O452C266O464C272O476C278O486C284O612C287O612C292O529C298O544C304O558C310O577C316O591C322O670C325O670C330O658C336O858C339O858C344O700C355O731C361O757C367O784C373O807C379O842C385O924C388O924C393O897C399O1000C402O1000C407O961C413O980C419O1136C422O1136C427O1043C433O1056C439O1072C445O1093C451O1115C457O1186C460O1186C464O1186C466O1249C469O1249C474O1238C480O23691C487O23712C493O23751C499O23790C505O23829C511O23868C517O23905C523O23948C529O23983C535O23706C540O24018,,
tick,0x1bfd70f30,39959,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x120d4439f42a,0x105108d28,0x10510894c,0x120d4439b14d,0x105108d28,0x10510894c,0x120d4439a952,0x105108d28,0x10510894c,0x3172a1b32c9a,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
tick,0x10079d058,40667,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x120d443a82cf,0x105108d28,0x10510894c,0x120d4439f42a,0x105108d28,0x10510894c,0x120d4439b14d,0x105108d28,0x10510894c,0x120d4439a952,0x105108d28,0x10510894c,0x3172a1b32c9a,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,Eval,10,40750,0x120d443ad9ae,5, node:internal/webstreams/readablestream:1:1,0x120d443acbe8,~
script-source,125,node:internal/webstreams/readablestream,'use strict';\n\n/* eslint-disable no-use-before-define */\n\nconst {\n  ArrayBuffer\x2C\n  ArrayBufferPrototypeSlice\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  DataView\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  MathMin\x2C\n  NumberIsInteger\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeCatch\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  PromiseAll\x2C\n  ReflectConstruct\x2C\n  Symbol\x2C\n  SymbolAsyncIterator\x2C\n  SymbolToStringTag\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_INVALID_THIS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  DOMException\x2C\n} = internalBinding('messaging');\n\nconst {\n  isArrayBufferView\x2C\n  isDataView\x2C\n} = require('internal/util/types');\n\nconst {\n  createDeferredPromise\x2C\n  customInspectSymbol: kInspect\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\n\nconst {\n  serialize\x2C\n  deserialize\x2C\n} = require('v8');\n\nconst {\n  validateObject\x2C\n} = require('internal/validators');\n\nconst {\n  kAborted\x2C\n} = require('internal/abort_controller');\n\nconst {\n  MessageChannel\x2C\n} = require('internal/worker/io');\n\nconst {\n  kDeserialize\x2C\n  kTransfer\x2C\n  kTransferList\x2C\n  makeTransferable\x2C\n} = require('internal/worker/js_transferable');\n\nconst {\n  queueMicrotask\x2C\n} = require('internal/process/task_queues');\n\nconst {\n  kIsDisturbed\x2C\n  kIsErrored\x2C\n  kIsReadable\x2C\n} = require('internal/streams/utils');\n\nconst {\n  ArrayBufferViewGetBuffer\x2C\n  ArrayBufferViewGetByteLength\x2C\n  ArrayBufferViewGetByteOffset\x2C\n  ArrayBufferGetByteLength\x2C\n  AsyncIterator\x2C\n  copyArrayBuffer\x2C\n  customInspect\x2C\n  dequeueValue\x2C\n  ensureIsPromise\x2C\n  enqueueValueWithSize\x2C\n  extractHighWaterMark\x2C\n  extractSizeAlgorithm\x2C\n  lazyTransfer\x2C\n  isBrandCheck\x2C\n  resetQueue\x2C\n  setPromiseHandled\x2C\n  transferArrayBuffer\x2C\n  nonOpCancel\x2C\n  nonOpPull\x2C\n  nonOpStart\x2C\n  kType\x2C\n  kState\x2C\n} = require('internal/webstreams/util');\n\nconst {\n  WritableStreamDefaultWriter\x2C\n\n  isWritableStream\x2C\n  isWritableStreamLocked\x2C\n  isWritableStreamDefaultController\x2C\n  isWritableStreamDefaultWriter\x2C\n\n  writableStreamAbort\x2C\n  writableStreamCloseQueuedOrInFlight\x2C\n  writableStreamDefaultWriterCloseWithErrorPropagation\x2C\n  writableStreamDefaultWriterRelease\x2C\n  writableStreamDefaultWriterWrite\x2C\n} = require('internal/webstreams/writablestream');\n\nconst assert = require('internal/assert');\n\nconst kCancel = Symbol('kCancel');\nconst kClose = Symbol('kClose');\nconst kChunk = Symbol('kChunk');\nconst kError = Symbol('kError');\nconst kPull = Symbol('kPull');\n\n/**\n * @typedef {import('../abort_controller').AbortSignal} AbortSignal\n * @typedef {import('./queuingstrategies').QueuingStrategy} QueuingStrategy\n * @typedef {import('./queuingstrategies').QueuingStrategySize\n * } QueuingStrategySize\n * @typedef {import('./writablestream').WritableStream} WritableStream\n */\n\n/**\n * @typedef {ReadableStreamDefaultController | ReadableByteStreamController\n * } ReadableStreamController\n */\n\n/**\n * @typedef {ReadableStreamDefaultReader | ReadableStreamBYOBReader\n * } ReadableStreamReader\n */\n\n/**\n * @callback UnderlyingSourceStartCallback\n * @param {ReadableStreamController} controller\n * @returns { any | Promise<void> }\n */\n\n/**\n * @callback UnderlyingSourcePullCallback\n * @param {ReadableStreamController} controller\n * @returns { Promise<void> }\n */\n\n/**\n * @callback UnderlyingSourceCancelCallback\n * @param {any} reason\n * @returns { Promise<void> }\n */\n\n/**\n * @typedef {{\n *   readable: ReadableStream\x2C\n *   writable: WritableStream\x2C\n * }} ReadableWritablePair\n */\n\n/**\n * @typedef {{\n *   preventClose? : boolean\x2C\n *   preventAbort? : boolean\x2C\n *   preventCancel? : boolean\x2C\n *   signal? : AbortSignal\x2C\n * }} StreamPipeOptions\n */\n\n/**\n * @typedef {{\n *   start? : UnderlyingSourceStartCallback\x2C\n *   pull? : UnderlyingSourcePullCallback\x2C\n *   cancel? : UnderlyingSourceCancelCallback\x2C\n *   type? : "bytes"\x2C\n *   autoAllocateChunkSize? : number\n * }} UnderlyingSource\n */\n\nclass ReadableStream {\n  [kType] = 'ReadableStream';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {UnderlyingSource} [source]\n   * @param {QueuingStrategy} [strategy]\n   */\n  constructor(source = {}\x2C strategy = {}) {\n    if (source === null)\n      throw new ERR_INVALID_ARG_VALUE('source'\x2C 'Object'\x2C source);\n    this[kState] = {\n      disturbed: false\x2C\n      state: 'readable'\x2C\n      storedError: undefined\x2C\n      stream: undefined\x2C\n      transfer: {\n        writable: undefined\x2C\n        port1: undefined\x2C\n        port2: undefined\x2C\n        promise: undefined\x2C\n      }\n    };\n\n    // The spec requires handling of the strategy first\n    // here. Specifically\x2C if getting the size and\n    // highWaterMark from the strategy fail\x2C that has\n    // to trigger a throw before getting the details\n    // from the source. So be sure to keep these in\n    // this order.\n    const size = strategy?.size;\n    const highWaterMark = strategy?.highWaterMark;\n    const type = source.type;\n\n    if (`${type}` === 'bytes') {\n      if (size !== undefined)\n        throw new ERR_INVALID_ARG_VALUE.RangeError('strategy.size'\x2C size);\n      setupReadableByteStreamControllerFromSource(\n        this\x2C\n        source\x2C\n        extractHighWaterMark(highWaterMark\x2C 0));\n      return;\n    }\n\n    if (type !== undefined)\n      throw new ERR_INVALID_ARG_VALUE('source.type'\x2C type);\n    setupReadableStreamDefaultControllerFromSource(\n      this\x2C\n      source\x2C\n      extractHighWaterMark(highWaterMark\x2C 1)\x2C\n      extractSizeAlgorithm(size));\n\n    // eslint-disable-next-line no-constructor-return\n    return makeTransferable(this);\n  }\n\n  get [kIsDisturbed]() {\n    return this[kState].disturbed;\n  }\n\n  get [kIsErrored]() {\n    return this[kState].state === 'errored';\n  }\n\n  get [kIsReadable]() {\n    return this[kState].state === 'readable';\n  }\n\n  /**\n   * @readonly\n   * @type {boolean}\n   */\n  get locked() {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    return isReadableStreamLocked(this);\n  }\n\n  /**\n   * @param {any} [reason]\n   * @returns { Promise<void> }\n   */\n  cancel(reason = undefined) {\n    if (!isReadableStream(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStream'));\n    if (isReadableStreamLocked(this)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('ReadableStream is locked'));\n    }\n    return readableStreamCancel(this\x2C reason);\n  }\n\n  /**\n   * @param {{\n   *   mode? : "byob"\n   * }} [options]\n   * @returns {ReadableStreamReader}\n   */\n  getReader(options = {}) {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    validateObject(options\x2C 'options'\x2C { nullable: true\x2C allowFunction: true });\n    const mode = options?.mode;\n\n    if (mode === undefined)\n      return new ReadableStreamDefaultReader(this);\n\n    if (`${mode}` !== 'byob')\n      throw new ERR_INVALID_ARG_VALUE('options.mode'\x2C mode);\n    return new ReadableStreamBYOBReader(this);\n  }\n\n  /**\n   * @param {ReadableWritablePair} transform\n   * @param {StreamPipeOptions} [options]\n   * @returns {ReadableStream}\n   */\n  pipeThrough(transform\x2C options = {}) {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    const readable = transform?.readable;\n    if (!isReadableStream(readable)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'transform.readable'\x2C\n        'ReadableStream'\x2C\n        readable);\n    }\n    const writable = transform?.writable;\n    if (!isWritableStream(writable)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'transform.writable'\x2C\n        'WritableStream'\x2C\n        writable);\n    }\n\n    // The web platform tests require that these be handled one at a\n    // time and in a specific order. options can be null or undefined.\n    const preventAbort = options?.preventAbort;\n    const preventCancel = options?.preventCancel;\n    const preventClose = options?.preventClose;\n    const signal = options?.signal;\n\n    if (signal !== undefined && signal?.[kAborted] === undefined)\n      throw new ERR_INVALID_ARG_TYPE('options.signal'\x2C 'AbortSignal'\x2C signal);\n\n    if (isReadableStreamLocked(this))\n      throw new ERR_INVALID_STATE.TypeError('The ReadableStream is locked');\n    if (isWritableStreamLocked(writable))\n      throw new ERR_INVALID_STATE.TypeError('The WritableStream is locked');\n\n    const promise = readableStreamPipeTo(\n      this\x2C\n      writable\x2C\n      !!preventClose\x2C\n      !!preventAbort\x2C\n      !!preventCancel\x2C\n      signal);\n    setPromiseHandled(promise);\n\n    return readable;\n  }\n\n  /**\n   * @param {WritableStream} destination\n   * @param {StreamPipeOptions} [options]\n   * @returns {Promise<void>}\n   */\n  pipeTo(destination\x2C options = {}) {\n    try {\n      if (!isReadableStream(this))\n        throw new ERR_INVALID_THIS('ReadableStream');\n      if (!isWritableStream(destination)) {\n        throw new ERR_INVALID_ARG_TYPE(\n          'transform.writable'\x2C\n          'WritableStream'\x2C\n          destination);\n      }\n\n      const preventAbort = options?.preventAbort;\n      const preventCancel = options?.preventCancel;\n      const preventClose = options?.preventClose;\n      const signal = options?.signal;\n\n      if (signal !== undefined && signal?.[kAborted] === undefined)\n        throw new ERR_INVALID_ARG_TYPE('options.signal'\x2C 'AbortSignal'\x2C signal);\n\n      if (isReadableStreamLocked(this))\n        throw new ERR_INVALID_STATE.TypeError('The ReadableStream is locked');\n      if (isWritableStreamLocked(destination))\n        throw new ERR_INVALID_STATE.TypeError('The WritableStream is locked');\n\n      return readableStreamPipeTo(\n        this\x2C\n        destination\x2C\n        !!preventClose\x2C\n        !!preventAbort\x2C\n        !!preventCancel\x2C\n        signal);\n    } catch (error) {\n      return PromiseReject(error);\n    }\n  }\n\n  /**\n   * @returns {ReadableStream[]}\n   */\n  tee() {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    return readableStreamTee(this\x2C false);\n  }\n\n  /**\n   * @param {{\n   *   preventCancel? : boolean\x2C\n   * }} [options]\n   * @returns {AsyncIterable}\n   */\n  values(options = {}) {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    validateObject(options\x2C 'options');\n    const {\n      preventCancel = false\x2C\n    } = options;\n\n    const reader = new ReadableStreamDefaultReader(this);\n    let done = false;\n    let started = false;\n    let current;\n\n    // The nextSteps function is not an async function in order\n    // to make it more efficient. Because nextSteps explicitly\n    // creates a Promise and returns it in the common case\x2C\n    // making it an async function just causes two additional\n    // unnecessary Promise allocations to occur\x2C which just add\n    // cost.\n    function nextSteps() {\n      if (done)\n        return PromiseResolve({ done: true\x2C value: undefined });\n\n      if (reader[kState].stream === undefined) {\n        return PromiseReject(\n          new ERR_INVALID_STATE.TypeError(\n            'The reader is not bound to a ReadableStream'));\n      }\n      const promise = createDeferredPromise();\n\n      readableStreamDefaultReaderRead(reader\x2C {\n        [kChunk](chunk) {\n          current = undefined;\n          promise.resolve({ value: chunk\x2C done: false });\n        }\x2C\n        [kClose]() {\n          current = undefined;\n          done = true;\n          readableStreamReaderGenericRelease(reader);\n          promise.resolve({ done: true\x2C value: undefined });\n        }\x2C\n        [kError](error) {\n          current = undefined;\n          done = true;\n          readableStreamReaderGenericRelease(reader);\n          promise.reject(error);\n        }\n      });\n      return promise.promise;\n    }\n\n    async function returnSteps(value) {\n      if (done)\n        return { done: true\x2C value };\n      done = true;\n\n      if (reader[kState].stream === undefined) {\n        throw new ERR_INVALID_STATE.TypeError(\n          'The reader is not bound to a ReadableStream');\n      }\n      assert(!reader[kState].readRequests.length);\n      if (!preventCancel) {\n        const result = readableStreamReaderGenericCancel(reader\x2C value);\n        readableStreamReaderGenericRelease(reader);\n        await result;\n        return { done: true\x2C value };\n      }\n\n      readableStreamReaderGenericRelease(reader);\n      return { done: true\x2C value };\n    }\n\n    // TODO(@jasnell): Explore whether an async generator\n    // can be used here instead of a custom iterator object.\n    return ObjectSetPrototypeOf({\n      // Changing either of these functions (next or return)\n      // to async functions causes a failure in the streams\n      // Web Platform Tests that check for use of a modified\n      // Promise.prototype.then. Since the await keyword\n      // uses Promise.prototype.then\x2C it is open to prototype\n      // pollution\x2C which causes the test to fail. The other\n      // await uses here do not trigger that failure because\n      // the test that fails does not trigger those code paths.\n      next() {\n        // If this is the first read\x2C delay by one microtask\n        // to ensure that the controller has had an opportunity\n        // to properly start and perform the initial pull.\n        // TODO(@jasnell): The spec doesn't call this out so\n        // need to investigate if it's a bug in our impl or\n        // the spec.\n        if (!started) {\n          current = PromiseResolve();\n          started = true;\n        }\n        current = current !== undefined ?\n          PromisePrototypeThen(current\x2C nextSteps\x2C nextSteps) :\n          nextSteps();\n        return current;\n      }\x2C\n\n      return(error) {\n        return current ?\n          PromisePrototypeThen(\n            current\x2C\n            () => returnSteps(error)\x2C\n            () => returnSteps(error)) :\n          returnSteps(error);\n      }\x2C\n\n      [SymbolAsyncIterator]() { return this; }\n    }\x2C AsyncIterator);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      locked: this.locked\x2C\n      state: this[kState].state\x2C\n      supportsBYOB:\n        this[kState].controller instanceof ReadableByteStreamController\x2C\n    });\n  }\n\n  [kTransfer]() {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    if (this.locked) {\n      this[kState].transfer.port1?.close();\n      this[kState].transfer.port1 = undefined;\n      this[kState].transfer.port2 = undefined;\n      throw new DOMException(\n        'Cannot transfer a locked ReadableStream'\x2C\n        'DataCloneError');\n    }\n\n    const {\n      writable\x2C\n      promise\x2C\n    } = lazyTransfer().newCrossRealmWritableSink(\n      this\x2C\n      this[kState].transfer.port1);\n\n    this[kState].transfer.writable = writable;\n    this[kState].transfer.promise = promise;\n\n    return {\n      data: { port: this[kState].transfer.port2 }\x2C\n      deserializeInfo:\n        'internal/webstreams/readablestream:TransferredReadableStream'\n    };\n  }\n\n  [kTransferList]() {\n    const { port1\x2C port2 } = new MessageChannel();\n    this[kState].transfer.port1 = port1;\n    this[kState].transfer.port2 = port2;\n    return [ port2 ];\n  }\n\n  [kDeserialize]({ port }) {\n    const transfer = lazyTransfer();\n    setupReadableStreamDefaultControllerFromSource(\n      this\x2C\n      new transfer.CrossRealmTransformReadableSource(port)\x2C\n      0\x2C () => 1);\n  }\n}\n\nObjectDefineProperties(ReadableStream.prototype\x2C {\n  [SymbolAsyncIterator]: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    value: ReadableStream.prototype.values\x2C\n  }\x2C\n  locked: kEnumerableProperty\x2C\n  cancel: kEnumerableProperty\x2C\n  getReader: kEnumerableProperty\x2C\n  pipeThrough: kEnumerableProperty\x2C\n  pipeTo: kEnumerableProperty\x2C\n  tee: kEnumerableProperty\x2C\n});\n\nfunction TransferredReadableStream() {\n  return makeTransferable(ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableStream';\n      this[kState] = {\n        disturbed: false\x2C\n        state: 'readable'\x2C\n        storedError: undefined\x2C\n        stream: undefined\x2C\n        transfer: {\n          writable: undefined\x2C\n          port: undefined\x2C\n          promise: undefined\x2C\n        }\n      };\n    }\x2C\n    []\x2C ReadableStream));\n}\nTransferredReadableStream.prototype[kDeserialize] = () => {};\n\nclass ReadableStreamBYOBRequest {\n  [kType] = 'ReadableStreamBYOBRequest';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  /**\n   * @readonly\n   * @type {ArrayBufferView}\n   */\n  get view() {\n    if (!isReadableStreamBYOBRequest(this))\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBRequest');\n    return this[kState].view;\n  }\n\n  /**\n   * @param {number} bytesWritten\n   */\n  respond(bytesWritten) {\n    if (!isReadableStreamBYOBRequest(this))\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBRequest');\n    const {\n      view\x2C\n      controller\x2C\n    } = this[kState];\n    if (controller === undefined) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'This BYOB request has been invalidated');\n    }\n\n    const viewByteLength = ArrayBufferViewGetByteLength(view);\n    const viewBuffer = ArrayBufferViewGetBuffer(view);\n    const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\n\n    if (viewByteLength === 0 || viewBufferByteLength === 0) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'View ArrayBuffer is zero-length or detached');\n    }\n\n    readableByteStreamControllerRespond(controller\x2C bytesWritten);\n  }\n\n  /**\n   * @param {ArrayBufferView} view\n   */\n  respondWithNewView(view) {\n    if (!isReadableStreamBYOBRequest(this))\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBRequest');\n    const {\n      controller\x2C\n    } = this[kState];\n\n    if (controller === undefined) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'This BYOB request has been invalidated');\n    }\n\n    readableByteStreamControllerRespondWithNewView(controller\x2C view);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      view: this.view\x2C\n      controller: this[kState].controller\x2C\n    });\n  }\n}\n\nObjectDefineProperties(ReadableStreamBYOBRequest.prototype\x2C {\n  view: kEnumerableProperty\x2C\n  respond: kEnumerableProperty\x2C\n  respondWithNewView: kEnumerableProperty\x2C\n});\n\nfunction createReadableStreamBYOBRequest(controller\x2C view) {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableStreamBYOBRequest';\n      this[kState] = {\n        controller\x2C\n        view\x2C\n      };\n    }\x2C\n    []\x2C\n    ReadableStreamBYOBRequest\n  );\n}\n\nclass DefaultReadRequest {\n  constructor() {\n    this[kState] = createDeferredPromise();\n  }\n\n  [kChunk](value) {\n    this[kState].resolve?.({ value\x2C done: false });\n  }\n\n  [kClose]() {\n    this[kState].resolve?.({ value: undefined\x2C done: true });\n  }\n\n  [kError](error) {\n    this[kState].reject?.(error);\n  }\n\n  get promise() { return this[kState].promise; }\n}\n\nclass ReadIntoRequest {\n  constructor() {\n    this[kState] = createDeferredPromise();\n  }\n\n  [kChunk](value) {\n    this[kState].resolve?.({ value\x2C done: false });\n  }\n\n  [kClose](value) {\n    this[kState].resolve?.({ value\x2C done: true });\n  }\n\n  [kError](error) {\n    this[kState].reject?.(error);\n  }\n\n  get promise() { return this[kState].promise; }\n}\n\nclass ReadableStreamDefaultReader {\n  [kType] = 'ReadableStreamDefaultReader';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {ReadableStream} stream\n   */\n  constructor(stream) {\n    if (!isReadableStream(stream))\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'ReadableStream'\x2C stream);\n    this[kState] = {\n      readRequests: []\x2C\n      stream: undefined\x2C\n      close: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n    };\n    setupReadableStreamDefaultReader(this\x2C stream);\n  }\n\n  /**\n   * @returns {Promise<{\n   *   value : any\x2C\n   *   done : boolean\n   * }>}\n   */\n  read() {\n    if (!isReadableStreamDefaultReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamDefaultReader'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'The reader is not attached to a stream'));\n    }\n    const readRequest = new DefaultReadRequest();\n    readableStreamDefaultReaderRead(this\x2C readRequest);\n    return readRequest.promise;\n  }\n\n  releaseLock() {\n    if (!isReadableStreamDefaultReader(this))\n      throw new ERR_INVALID_THIS('ReadableStreamDefaultReader');\n    if (this[kState].stream === undefined)\n      return;\n    if (this[kState].readRequests.length) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'Cannot release with pending read requests');\n    }\n    readableStreamReaderGenericRelease(this);\n  }\n\n  /**\n   * @readonly\n   * @type {Promise<void>}\n   */\n  get closed() {\n    if (!isReadableStreamDefaultReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamDefaultReader'));\n    return this[kState].close.promise;\n  }\n\n  /**\n   * @param {any} reason\n   * @returns {Promise<void>}\n   */\n  cancel(reason = undefined) {\n    if (!isReadableStreamDefaultReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamDefaultReader'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\n        'The reader is not attached to a stream'));\n    }\n    return readableStreamReaderGenericCancel(this\x2C reason);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      stream: this[kState].stream\x2C\n      readRequests: this[kState].readRequests.length\x2C\n      close: this[kState].close.promise\x2C\n    });\n  }\n}\n\nObjectDefineProperties(ReadableStreamDefaultReader.prototype\x2C {\n  closed: kEnumerableProperty\x2C\n  read: kEnumerableProperty\x2C\n  releaseLock: kEnumerableProperty\x2C\n  cancel: kEnumerableProperty\x2C\n});\n\nclass ReadableStreamBYOBReader {\n  [kType] = 'ReadableStreamBYOBReader';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {ReadableStream} stream\n   */\n  constructor(stream) {\n    if (!isReadableStream(stream))\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'ReadableStream'\x2C stream);\n    this[kState] = {\n      stream: undefined\x2C\n      requestIntoRequests: []\x2C\n      close: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n    };\n    setupReadableStreamBYOBReader(this\x2C stream);\n  }\n\n  /**\n   * @param {ArrayBufferView} view\n   * @returns {Promise<{\n   *   view : ArrayBufferView\x2C\n   *   done : boolean\x2C\n   * }>}\n   */\n  read(view) {\n    if (!isReadableStreamBYOBReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamBYOBReader'));\n    if (!isArrayBufferView(view)) {\n      return PromiseReject(\n        new ERR_INVALID_ARG_TYPE(\n          'view'\x2C\n          [\n            'Buffer'\x2C\n            'TypedArray'\x2C\n            'DataView'\x2C\n          ]\x2C\n          view));\n    }\n    const viewByteLength = ArrayBufferViewGetByteLength(view);\n    const viewBuffer = ArrayBufferViewGetBuffer(view);\n    const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\n\n    if (viewByteLength === 0 || viewBufferByteLength === 0) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'View ArrayBuffer is zero-length or detached'));\n    }\n    // Supposed to assert here that the view's buffer is not\n    // detached\x2C but there's no API available to use to check that.\n    if (this[kState].stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'The reader is not attached to a stream'));\n    }\n    const readIntoRequest = new ReadIntoRequest();\n    readableStreamBYOBReaderRead(this\x2C view\x2C readIntoRequest);\n    return readIntoRequest.promise;\n  }\n\n  releaseLock() {\n    if (!isReadableStreamBYOBReader(this))\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBReader');\n    if (this[kState].stream === undefined)\n      return;\n    if (this[kState].readIntoRequests.length) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'Cannot release with pending read requests');\n    }\n    readableStreamReaderGenericRelease(this);\n  }\n\n  /**\n   * @readonly\n   * @type {Promise<void>}\n   */\n  get closed() {\n    if (!isReadableStreamBYOBReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamBYOBReader'));\n    return this[kState].close.promise;\n  }\n\n  /**\n   * @param {any} reason\n   * @returns {Promise<void>}\n   */\n  cancel(reason = undefined) {\n    if (!isReadableStreamBYOBReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamBYOBReader'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\n        'The reader is not attached to a stream'));\n    }\n    return readableStreamReaderGenericCancel(this\x2C reason);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      stream: this[kState].stream\x2C\n      requestIntoRequests: this[kState].requestIntoRequests.length\x2C\n      close: this[kState].close.promise\x2C\n    });\n  }\n}\n\nObjectDefineProperties(ReadableStreamBYOBReader.prototype\x2C {\n  closed: kEnumerableProperty\x2C\n  read: kEnumerableProperty\x2C\n  releaseLock: kEnumerableProperty\x2C\n  cancel: kEnumerableProperty\x2C\n});\n\nclass ReadableStreamDefaultController {\n  [kType] = 'ReadableStreamDefaultController';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get desiredSize() {\n    return readableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (!readableStreamDefaultControllerCanCloseOrEnqueue(this))\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\n    readableStreamDefaultControllerClose(this);\n  }\n\n  /**\n   * @param {any} chunk\n   */\n  enqueue(chunk = undefined) {\n    if (!readableStreamDefaultControllerCanCloseOrEnqueue(this))\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\n    readableStreamDefaultControllerEnqueue(this\x2C chunk);\n  }\n\n  /**\n   * @param {any} error\n   */\n  error(error = undefined) {\n    readableStreamDefaultControllerError(this\x2C error);\n  }\n\n  [kCancel](reason) {\n    return readableStreamDefaultControllerCancelSteps(this\x2C reason);\n  }\n\n  [kPull](readRequest) {\n    readableStreamDefaultControllerPullSteps(this\x2C readRequest);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C { });\n  }\n}\n\nObjectDefineProperties(ReadableStreamDefaultController.prototype\x2C {\n  desiredSize: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  enqueue: kEnumerableProperty\x2C\n  error: kEnumerableProperty\x2C\n});\n\nfunction createReadableStreamDefaultController() {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableStreamDefaultController';\n      this[kState] = {};\n    }\x2C\n    []\x2C\n    ReadableStreamDefaultController\x2C\n  );\n}\n\nclass ReadableByteStreamController {\n  [kType] = 'ReadableByteStreamController';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  /**\n   * @readonly\n   * @type {ReadableStreamBYOBRequest}\n   */\n  get byobRequest() {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    if (this[kState].byobRequest === null &&\n        this[kState].pendingPullIntos.length) {\n      const {\n        buffer\x2C\n        byteOffset\x2C\n        bytesFilled\x2C\n        byteLength\x2C\n      } = this[kState].pendingPullIntos[0];\n      const view =\n        new Uint8Array(\n          buffer\x2C\n          byteOffset + bytesFilled\x2C\n          byteLength - bytesFilled);\n      this[kState].byobRequest = createReadableStreamBYOBRequest(this\x2C view);\n    }\n    return this[kState].byobRequest;\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get desiredSize() {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    return readableByteStreamControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    if (this[kState].closeRequested)\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\n    if (this[kState].stream[kState].state !== 'readable')\n      throw new ERR_INVALID_STATE.TypeError('ReadableStream is already closed');\n    readableByteStreamControllerClose(this);\n  }\n\n  /**\n   * @param {ArrayBufferView} chunk\n   */\n  enqueue(chunk) {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    if (!isArrayBufferView(chunk)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C\n        [\n          'Buffer'\x2C\n          'TypedArray'\x2C\n          'DataView'\x2C\n        ]\x2C\n        chunk);\n    }\n    const chunkByteLength = ArrayBufferViewGetByteLength(chunk);\n    const chunkByteOffset = ArrayBufferViewGetByteOffset(chunk);\n    const chunkBuffer = ArrayBufferViewGetBuffer(chunk);\n    const chunkBufferByteLength = ArrayBufferGetByteLength(chunkBuffer);\n    if (chunkByteLength === 0 || chunkBufferByteLength === 0) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'chunk ArrayBuffer is zero-length or detached');\n    }\n    if (this[kState].closeRequested)\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\n    if (this[kState].stream[kState].state !== 'readable')\n      throw new ERR_INVALID_STATE.TypeError('ReadableStream is already closed');\n    readableByteStreamControllerEnqueue(\n      this\x2C\n      chunkBuffer\x2C\n      chunkByteLength\x2C\n      chunkByteOffset);\n  }\n\n  /**\n   * @param {any} error\n   */\n  error(error = undefined) {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    readableByteStreamControllerError(this\x2C error);\n  }\n\n  [kCancel](reason) {\n    return readableByteStreamControllerCancelSteps(this\x2C reason);\n  }\n\n  [kPull](readRequest) {\n    readableByteStreamControllerPullSteps(this\x2C readRequest);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C { });\n  }\n}\n\nObjectDefineProperties(ReadableByteStreamController.prototype\x2C {\n  byobRequest: kEnumerableProperty\x2C\n  desiredSize: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  enqueue: kEnumerableProperty\x2C\n  error: kEnumerableProperty\x2C\n});\n\nfunction createReadableByteStreamController() {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableByteStreamController';\n      this[kState] = {};\n    }\x2C\n    []\x2C\n    ReadableByteStreamController\x2C\n  );\n}\n\nfunction createTeeReadableStream(start\x2C pull\x2C cancel) {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableStream';\n      this[kState] = {\n        disturbed: false\x2C\n        state: 'readable'\x2C\n        storedError: undefined\x2C\n        stream: undefined\x2C\n        transfer: {\n          writable: undefined\x2C\n          port: undefined\x2C\n          promise: undefined\x2C\n        }\n      };\n      setupReadableStreamDefaultControllerFromSource(\n        this\x2C\n        ObjectCreate(null\x2C {\n          start: { value: start }\x2C\n          pull: { value: pull }\x2C\n          cancel: { value: cancel }\n        })\x2C\n        1\x2C\n        () => 1);\n      return makeTransferable(this);\n    }\x2C []\x2C ReadableStream\x2C\n  );\n}\n\nconst isReadableStream =\n  isBrandCheck('ReadableStream');\nconst isReadableByteStreamController =\n  isBrandCheck('ReadableByteStreamController');\nconst isReadableStreamBYOBRequest =\n  isBrandCheck('ReadableStreamBYOBRequest');\nconst isReadableStreamDefaultReader =\n  isBrandCheck('ReadableStreamDefaultReader');\nconst isReadableStreamBYOBReader =\n  isBrandCheck('ReadableStreamBYOBReader');\n\n// ---- ReadableStream Implementation\n\nfunction readableStreamPipeTo(\n  source\x2C\n  dest\x2C\n  preventClose\x2C\n  preventAbort\x2C\n  preventCancel\x2C\n  signal) {\n\n  let reader;\n  let writer;\n  // Both of these can throw synchronously. We want to capture\n  // the error and return a rejected promise instead.\n  try {\n    reader = new ReadableStreamDefaultReader(source);\n    writer = new WritableStreamDefaultWriter(dest);\n  } catch (error) {\n    return PromiseReject(error);\n  }\n\n  source[kState].disturbed = true;\n\n  let shuttingDown = false;\n\n  if (signal !== undefined && signal?.[kAborted] === undefined) {\n    return PromiseReject(\n      new ERR_INVALID_ARG_TYPE(\n        'options.signal'\x2C\n        'AbortSignal'\x2C\n        signal));\n  }\n\n  const promise = createDeferredPromise();\n\n  let currentWrite = PromiseResolve();\n\n  // The error here can be undefined. The rejected arg\n  // tells us that the promise must be rejected even\n  // when error is undefine.\n  function finalize(rejected\x2C error) {\n    writableStreamDefaultWriterRelease(writer);\n    readableStreamReaderGenericRelease(reader);\n    if (signal !== undefined)\n      signal.removeEventListener('abort'\x2C abortAlgorithm);\n    if (rejected)\n      promise.reject(error);\n    else\n      promise.resolve();\n  }\n\n  async function waitForCurrentWrite() {\n    const write = currentWrite;\n    await write;\n    if (write !== currentWrite)\n      await waitForCurrentWrite();\n  }\n\n  function shutdownWithAnAction(action\x2C rejected\x2C originalError) {\n    if (shuttingDown) return;\n    shuttingDown = true;\n    if (dest[kState].state === 'writable' &&\n        !writableStreamCloseQueuedOrInFlight(dest)) {\n      PromisePrototypeThen(\n        waitForCurrentWrite()\x2C\n        complete\x2C\n        (error) => finalize(true\x2C error));\n      return;\n    }\n    complete();\n\n    function complete() {\n      PromisePrototypeThen(\n        action()\x2C\n        () => finalize(rejected\x2C originalError)\x2C\n        (error) => finalize(true\x2C error));\n    }\n  }\n\n  function shutdown(rejected\x2C error) {\n    if (shuttingDown) return;\n    shuttingDown = true;\n    if (dest[kState].state === 'writable' &&\n        !writableStreamCloseQueuedOrInFlight(dest)) {\n      PromisePrototypeThen(\n        waitForCurrentWrite()\x2C\n        () => finalize(rejected\x2C error)\x2C\n        (error) => finalize(true\x2C error));\n      return;\n    }\n    finalize(rejected\x2C error);\n  }\n\n  function abortAlgorithm() {\n    // Cannot use the AbortError class here. It must be a DOMException\n    const error = new DOMException('The operation was aborted'\x2C 'AbortError');\n    const actions = [];\n    if (!preventAbort) {\n      ArrayPrototypePush(\n        actions\x2C\n        () => {\n          if (dest[kState].state === 'writable')\n            return writableStreamAbort(dest\x2C error);\n          return PromiseResolve();\n        });\n    }\n    if (!preventCancel) {\n      ArrayPrototypePush(\n        actions\x2C\n        () => {\n          if (source[kState].state === 'readable')\n            return readableStreamCancel(source\x2C error);\n          return PromiseResolve();\n        });\n    }\n\n    shutdownWithAnAction(\n      async () => PromiseAll(actions.map((action) => action()))\x2C\n      true\x2C\n      error);\n  }\n\n  function watchErrored(stream\x2C promise\x2C action) {\n    if (stream[kState].state === 'errored')\n      action(stream[kState].storedError);\n    else\n      PromisePrototypeCatch(promise\x2C action);\n  }\n\n  function watchClosed(stream\x2C promise\x2C action) {\n    if (stream[kState].state === 'closed')\n      action();\n    else\n      PromisePrototypeThen(promise\x2C action\x2C () => {});\n  }\n\n  async function step() {\n    if (shuttingDown)\n      return true;\n    await writer[kState].ready.promise;\n    return new Promise((resolve\x2C reject) => {\n      readableStreamDefaultReaderRead(\n        reader\x2C\n        {\n          [kChunk](chunk) {\n            currentWrite = writableStreamDefaultWriterWrite(writer\x2C chunk);\n            setPromiseHandled(currentWrite);\n            resolve(false);\n          }\x2C\n          [kClose]: () => resolve(true)\x2C\n          [kError]: reject\x2C\n        });\n    });\n  }\n\n  async function run() {\n    // Run until step resolves as true\n    while (!await step());\n  }\n\n  if (signal !== undefined) {\n    if (signal.aborted) {\n      abortAlgorithm();\n      return promise.promise;\n    }\n    signal.addEventListener('abort'\x2C abortAlgorithm\x2C { once: true });\n  }\n\n  setPromiseHandled(run());\n\n  watchErrored(source\x2C reader[kState].close.promise\x2C (error) => {\n    if (!preventAbort) {\n      return shutdownWithAnAction(\n        () => writableStreamAbort(dest\x2C error)\x2C\n        true\x2C\n        error);\n    }\n    shutdown(true\x2C error);\n  });\n\n  watchErrored(dest\x2C writer[kState].close.promise\x2C (error) => {\n    if (!preventCancel) {\n      return shutdownWithAnAction(\n        () => readableStreamCancel(source\x2C error)\x2C\n        true\x2C\n        error);\n    }\n    shutdown(true\x2C error);\n  });\n\n  watchClosed(source\x2C reader[kState].close.promise\x2C () => {\n    if (!preventClose) {\n      return shutdownWithAnAction(\n        () => writableStreamDefaultWriterCloseWithErrorPropagation(writer));\n    }\n    shutdown();\n  });\n\n  if (writableStreamCloseQueuedOrInFlight(dest) ||\n      dest[kState].state === 'closed') {\n    const error = new ERR_INVALID_STATE.TypeError(\n      'Destination WritableStream is closed');\n    if (!preventCancel) {\n      shutdownWithAnAction(\n        () => readableStreamCancel(source\x2C error)\x2C true\x2C error);\n    } else {\n      shutdown(true\x2C error);\n    }\n  }\n\n  return promise.promise;\n}\n\nfunction readableStreamTee(stream\x2C cloneForBranch2) {\n  const reader = new ReadableStreamDefaultReader(stream);\n  let reading = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1;\n  let reason2;\n  let branch1;\n  let branch2;\n  const cancelPromise = createDeferredPromise();\n\n  async function pullAlgorithm() {\n    if (reading) return;\n    reading = true;\n    const readRequest = {\n      [kChunk](value) {\n        queueMicrotask(() => {\n          reading = false;\n          const value1 = value;\n          let value2 = value;\n          if (!canceled2 && cloneForBranch2) {\n            // Structured Clone\n            value2 = deserialize(serialize(value2));\n          }\n          if (!canceled1) {\n            readableStreamDefaultControllerEnqueue(\n              branch1[kState].controller\x2C\n              value1);\n          }\n          if (!canceled2) {\n            readableStreamDefaultControllerEnqueue(\n              branch2[kState].controller\x2C\n              value2);\n          }\n        });\n      }\x2C\n      [kClose]() {\n        // The `process.nextTick()` is not part of the spec.\n        // This approach was needed to avoid a race condition working with esm\n        // Further information\x2C see: https://github.com/nodejs/node/issues/39758\n        process.nextTick(() => {\n          reading = false;\n          if (!canceled1)\n            readableStreamDefaultControllerClose(branch1[kState].controller);\n          if (!canceled2)\n            readableStreamDefaultControllerClose(branch2[kState].controller);\n          if (!canceled1 || !canceled2)\n            cancelPromise.resolve();\n        });\n      }\x2C\n      [kError]() {\n        reading = false;\n      }\x2C\n    };\n    readableStreamDefaultReaderRead(reader\x2C readRequest);\n  }\n\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = [reason1\x2C reason2];\n      cancelPromise.resolve(readableStreamCancel(stream\x2C compositeReason));\n    }\n    return cancelPromise.promise;\n  }\n\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = [reason1\x2C reason2];\n      cancelPromise.resolve(readableStreamCancel(stream\x2C compositeReason));\n    }\n    return cancelPromise.promise;\n  }\n\n  branch1 =\n    createTeeReadableStream(nonOpStart\x2C pullAlgorithm\x2C cancel1Algorithm);\n  branch2 =\n    createTeeReadableStream(nonOpStart\x2C pullAlgorithm\x2C cancel2Algorithm);\n\n  PromisePrototypeCatch(\n    reader[kState].close.promise\x2C\n    (error) => {\n      readableStreamDefaultControllerError(branch1[kState].controller\x2C error);\n      readableStreamDefaultControllerError(branch2[kState].controller\x2C error);\n      if (!canceled1 || !canceled2)\n        cancelPromise.resolve();\n    });\n\n  return [branch1\x2C branch2];\n}\n\nfunction readableByteStreamControllerConvertPullIntoDescriptor(desc) {\n  const {\n    buffer\x2C\n    bytesFilled\x2C\n    byteLength\x2C\n    byteOffset\x2C\n    ctor\x2C\n    elementSize\x2C\n  } = desc;\n  if (bytesFilled > byteLength)\n    throw new ERR_INVALID_STATE.RangeError('The buffer size is invalid');\n  assert(!(bytesFilled % elementSize));\n  const transferredBuffer = transferArrayBuffer(buffer);\n  return new ctor(transferredBuffer\x2C byteOffset\x2C bytesFilled / elementSize);\n}\n\nfunction isReadableStreamLocked(stream) {\n  return stream[kState].reader !== undefined;\n}\n\nfunction readableStreamCancel(stream\x2C reason) {\n  stream[kState].disturbed = true;\n  switch (stream[kState].state) {\n    case 'closed':\n      return PromiseResolve();\n    case 'errored':\n      return PromiseReject(stream[kState].storedError);\n  }\n  readableStreamClose(stream);\n  const {\n    reader\x2C\n  } = stream[kState];\n  if (reader !== undefined && readableStreamHasBYOBReader(stream)) {\n    for (let n = 0; n < reader[kState].readIntoRequests.length; n++)\n      reader[kState].readIntoRequests[n][kClose]();\n    reader[kState].readIntoRequests = [];\n  }\n\n  return PromisePrototypeThen(\n    ensureIsPromise(\n      stream[kState].controller[kCancel]\x2C\n      stream[kState].controller\x2C\n      reason)\x2C\n    () => {});\n}\n\nfunction readableStreamClose(stream) {\n  assert(stream[kState].state === 'readable');\n  stream[kState].state = 'closed';\n\n  const {\n    reader\x2C\n  } = stream[kState];\n\n  if (reader === undefined)\n    return;\n\n  reader[kState].close.resolve();\n\n  if (readableStreamHasDefaultReader(stream)) {\n    for (let n = 0; n < reader[kState].readRequests.length; n++)\n      reader[kState].readRequests[n][kClose]();\n    reader[kState].readRequests = [];\n  }\n}\n\nfunction readableStreamError(stream\x2C error) {\n  assert(stream[kState].state === 'readable');\n  stream[kState].state = 'errored';\n  stream[kState].storedError = error;\n\n  const {\n    reader\n  } = stream[kState];\n\n  if (reader === undefined)\n    return;\n\n  reader[kState].close.reject(error);\n  setPromiseHandled(reader[kState].close.promise);\n\n  if (readableStreamHasDefaultReader(stream)) {\n    for (let n = 0; n < reader[kState].readRequests.length; n++)\n      reader[kState].readRequests[n][kError](error);\n    reader[kState].readRequests = [];\n  } else {\n    assert(readableStreamHasBYOBReader(stream));\n    for (let n = 0; n < reader[kState].readIntoRequests.length; n++)\n      reader[kState].readIntoRequests[n][kError](error);\n    reader[kState].readIntoRequests = [];\n  }\n}\n\nfunction readableStreamHasDefaultReader(stream) {\n  const {\n    reader\x2C\n  } = stream[kState];\n\n  if (reader === undefined)\n    return false;\n\n  return reader[kState] !== undefined &&\n         reader[kType] === 'ReadableStreamDefaultReader';\n}\n\nfunction readableStreamGetNumReadRequests(stream) {\n  assert(readableStreamHasDefaultReader(stream));\n  return stream[kState].reader[kState].readRequests.length;\n}\n\nfunction readableStreamHasBYOBReader(stream) {\n  const {\n    reader\x2C\n  } = stream[kState];\n\n  if (reader === undefined)\n    return false;\n\n  return reader[kState] !== undefined &&\n         reader[kType] === 'ReadableStreamBYOBReader';\n}\n\nfunction readableStreamGetNumReadIntoRequests(stream) {\n  assert(readableStreamHasBYOBReader(stream));\n  return stream[kState].reader[kState].readIntoRequests.length;\n}\n\nfunction readableStreamFulfillReadRequest(stream\x2C chunk\x2C done) {\n  assert(readableStreamHasDefaultReader(stream));\n  const {\n    reader\x2C\n  } = stream[kState];\n  assert(reader[kState].readRequests.length);\n  const readRequest = ArrayPrototypeShift(reader[kState].readRequests);\n\n  // TODO(@jasnell): It's not clear under what exact conditions done\n  // will be true here. The spec requires this check but none of the\n  // WPT's or other tests trigger it. Will need to investigate how to\n  // get coverage for this.\n  if (done)\n    readRequest[kClose]();\n  else\n    readRequest[kChunk](chunk);\n}\n\nfunction readableStreamFulfillReadIntoRequest(stream\x2C chunk\x2C done) {\n  assert(readableStreamHasBYOBReader(stream));\n  const {\n    reader\x2C\n  } = stream[kState];\n  assert(reader[kState].readIntoRequests.length);\n  const readIntoRequest = ArrayPrototypeShift(reader[kState].readIntoRequests);\n  if (done)\n    readIntoRequest[kClose](chunk);\n  else\n    readIntoRequest[kChunk](chunk);\n}\n\nfunction readableStreamAddReadRequest(stream\x2C readRequest) {\n  assert(readableStreamHasDefaultReader(stream));\n  assert(stream[kState].state === 'readable');\n  ArrayPrototypePush(stream[kState].reader[kState].readRequests\x2C readRequest);\n}\n\nfunction readableStreamAddReadIntoRequest(stream\x2C readIntoRequest) {\n  assert(readableStreamHasBYOBReader(stream));\n  assert(stream[kState].state !== 'errored');\n  ArrayPrototypePush(\n    stream[kState].reader[kState].readIntoRequests\x2C\n    readIntoRequest);\n}\n\nfunction readableStreamReaderGenericCancel(reader\x2C reason) {\n  const {\n    stream\x2C\n  } = reader[kState];\n  assert(stream !== undefined);\n  return readableStreamCancel(stream\x2C reason);\n}\n\nfunction readableStreamReaderGenericInitialize(reader\x2C stream) {\n  reader[kState].stream = stream;\n  stream[kState].reader = reader;\n  switch (stream[kState].state) {\n    case 'readable':\n      reader[kState].close = createDeferredPromise();\n      break;\n    case 'closed':\n      reader[kState].close = {\n        promise: PromiseResolve()\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      break;\n    case 'errored':\n      reader[kState].close = {\n        promise: PromiseReject(stream[kState].storedError)\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      setPromiseHandled(reader[kState].close.promise);\n      break;\n  }\n}\n\nfunction readableStreamReaderGenericRelease(reader) {\n  const {\n    stream\x2C\n  } = reader[kState];\n  assert(stream !== undefined);\n  assert(stream[kState].reader === reader);\n\n  if (stream[kState].state === 'readable') {\n    reader[kState].close.reject?.(\n      new ERR_INVALID_STATE.TypeError('Reader released'));\n  } else {\n    reader[kState].close = {\n      promise: PromiseReject(\n        new ERR_INVALID_STATE.TypeError('Reader released'))\x2C\n      resolve: undefined\x2C\n      reject: undefined\x2C\n    };\n  }\n  setPromiseHandled(reader[kState].close.promise);\n  stream[kState].reader = undefined;\n  reader[kState].stream = undefined;\n}\n\nfunction readableStreamBYOBReaderRead(reader\x2C view\x2C readIntoRequest) {\n  const {\n    stream\x2C\n  } = reader[kState];\n  assert(stream !== undefined);\n  stream[kState].disturbed = true;\n  if (stream[kState].state === 'errored') {\n    readIntoRequest[kError](stream[kState].storedError);\n    return;\n  }\n  readableByteStreamControllerPullInto(\n    stream[kState].controller\x2C\n    view\x2C\n    readIntoRequest);\n}\n\nfunction readableStreamDefaultReaderRead(reader\x2C readRequest) {\n  const {\n    stream\x2C\n  } = reader[kState];\n  assert(stream !== undefined);\n  stream[kState].disturbed = true;\n  switch (stream[kState].state) {\n    case 'closed':\n      readRequest[kClose]();\n      break;\n    case 'errored':\n      readRequest[kError](stream[kState].storedError);\n      break;\n    case 'readable':\n      stream[kState].controller[kPull](readRequest);\n  }\n}\n\nfunction setupReadableStreamBYOBReader(reader\x2C stream) {\n  if (isReadableStreamLocked(stream))\n    throw new ERR_INVALID_STATE.TypeError('ReadableStream is locked');\n  const {\n    controller\x2C\n  } = stream[kState];\n  if (!isReadableByteStreamController(controller))\n    throw new ERR_INVALID_ARG_VALUE('stream'\x2C stream\x2C 'must be a byte stream');\n  readableStreamReaderGenericInitialize(reader\x2C stream);\n  reader[kState].readIntoRequests = [];\n}\n\nfunction setupReadableStreamDefaultReader(reader\x2C stream) {\n  if (isReadableStreamLocked(stream))\n    throw new ERR_INVALID_STATE.TypeError('ReadableStream is locked');\n  readableStreamReaderGenericInitialize(reader\x2C stream);\n  reader[kState].readRequests = [];\n}\n\nfunction readableStreamDefaultControllerClose(controller) {\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller))\n    return;\n  controller[kState].closeRequested = true;\n  if (!controller[kState].queue.length) {\n    readableStreamDefaultControllerClearAlgorithms(controller);\n    readableStreamClose(controller[kState].stream);\n  }\n}\n\nfunction readableStreamDefaultControllerEnqueue(controller\x2C chunk) {\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller))\n    return;\n\n  const {\n    stream\x2C\n  } = controller[kState];\n\n  if (isReadableStreamLocked(stream) &&\n      readableStreamGetNumReadRequests(stream)) {\n    readableStreamFulfillReadRequest(stream\x2C chunk\x2C false);\n  } else {\n    try {\n      const chunkSize =\n        FunctionPrototypeCall(\n          controller[kState].sizeAlgorithm\x2C\n          undefined\x2C\n          chunk);\n      enqueueValueWithSize(controller\x2C chunk\x2C chunkSize);\n    } catch (error) {\n      readableStreamDefaultControllerError(controller\x2C error);\n      throw error;\n    }\n  }\n  readableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nfunction readableStreamDefaultControllerHasBackpressure(controller) {\n  return !readableStreamDefaultControllerShouldCallPull(controller);\n}\n\nfunction readableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  return !controller[kState].closeRequested &&\n         stream[kState].state === 'readable';\n}\n\nfunction readableStreamDefaultControllerGetDesiredSize(controller) {\n  const {\n    stream\x2C\n    highWaterMark\x2C\n    queueTotalSize\x2C\n  } = controller[kState];\n  switch (stream[kState].state) {\n    case 'errored': return null;\n    case 'closed': return 0;\n    default:\n      return highWaterMark - queueTotalSize;\n  }\n}\n\nfunction readableStreamDefaultControllerShouldCallPull(controller) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller) ||\n      !controller[kState].started)\n    return false;\n\n  if (isReadableStreamLocked(stream) &&\n      readableStreamGetNumReadRequests(stream)) {\n    return true;\n  }\n\n  const desiredSize = readableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n\n  return desiredSize > 0;\n}\n\nfunction readableStreamDefaultControllerCallPullIfNeeded(controller) {\n  if (!readableStreamDefaultControllerShouldCallPull(controller))\n    return;\n  if (controller[kState].pulling) {\n    controller[kState].pullAgain = true;\n    return;\n  }\n  assert(!controller[kState].pullAgain);\n  controller[kState].pulling = true;\n  PromisePrototypeThen(\n    ensureIsPromise(controller[kState].pullAlgorithm\x2C controller)\x2C\n    () => {\n      controller[kState].pulling = false;\n      if (controller[kState].pullAgain) {\n        controller[kState].pullAgain = false;\n        readableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n    }\x2C\n    (error) => readableStreamDefaultControllerError(controller\x2C error));\n}\n\nfunction readableStreamDefaultControllerClearAlgorithms(controller) {\n  controller[kState].pullAlgorithm = undefined;\n  controller[kState].cancelAlgorithm = undefined;\n  controller[kState].sizeAlgorithm = undefined;\n}\n\nfunction readableStreamDefaultControllerError(controller\x2C error) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (stream[kState].state === 'readable') {\n    resetQueue(controller);\n    readableStreamDefaultControllerClearAlgorithms(controller);\n    readableStreamError(stream\x2C error);\n  }\n}\n\nfunction readableStreamDefaultControllerCancelSteps(controller\x2C reason) {\n  resetQueue(controller);\n  try {\n    const result = controller[kState].cancelAlgorithm(reason);\n    return result;\n  } finally {\n    readableStreamDefaultControllerClearAlgorithms(controller);\n  }\n}\n\nfunction readableStreamDefaultControllerPullSteps(controller\x2C readRequest) {\n  const {\n    stream\x2C\n    queue\x2C\n  } = controller[kState];\n  if (queue.length) {\n    const chunk = dequeueValue(controller);\n    if (controller[kState].closeRequested && !queue.length) {\n      readableStreamDefaultControllerClearAlgorithms(controller);\n      readableStreamClose(stream);\n    } else {\n      readableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n    readRequest[kChunk](chunk);\n    return;\n  }\n  readableStreamAddReadRequest(stream\x2C readRequest);\n  readableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nfunction setupReadableStreamDefaultController(\n  stream\x2C\n  controller\x2C\n  startAlgorithm\x2C\n  pullAlgorithm\x2C\n  cancelAlgorithm\x2C\n  highWaterMark\x2C\n  sizeAlgorithm) {\n  assert(stream[kState].controller === undefined);\n  controller[kState] = {\n    cancelAlgorithm\x2C\n    closeRequested: false\x2C\n    highWaterMark\x2C\n    pullAgain: false\x2C\n    pullAlgorithm\x2C\n    pulling: false\x2C\n    queue: []\x2C\n    queueTotalSize: 0\x2C\n    started: false\x2C\n    sizeAlgorithm\x2C\n    stream\x2C\n  };\n  stream[kState].controller = controller;\n\n  const startResult = startAlgorithm();\n\n  PromisePrototypeThen(\n    PromiseResolve(startResult)\x2C\n    () => {\n      controller[kState].started = true;\n      assert(!controller[kState].pulling);\n      assert(!controller[kState].pullAgain);\n      readableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\x2C\n    (error) => readableStreamDefaultControllerError(controller\x2C error));\n}\n\nfunction setupReadableStreamDefaultControllerFromSource(\n  stream\x2C\n  source\x2C\n  highWaterMark\x2C\n  sizeAlgorithm) {\n  const controller = createReadableStreamDefaultController();\n  const start = source?.start;\n  const pull = source?.pull;\n  const cancel = source?.cancel;\n  const startAlgorithm = start ?\n    FunctionPrototypeBind(start\x2C source\x2C controller) :\n    nonOpStart;\n  const pullAlgorithm = pull ?\n    FunctionPrototypeBind(pull\x2C source\x2C controller) :\n    nonOpPull;\n\n  const cancelAlgorithm = cancel ?\n    FunctionPrototypeBind(cancel\x2C source) :\n    nonOpCancel;\n\n  setupReadableStreamDefaultController(\n    stream\x2C\n    controller\x2C\n    startAlgorithm\x2C\n    pullAlgorithm\x2C\n    cancelAlgorithm\x2C\n    highWaterMark\x2C\n    sizeAlgorithm);\n}\n\nfunction readableByteStreamControllerClose(controller) {\n  const {\n    closeRequested\x2C\n    pendingPullIntos\x2C\n    queueTotalSize\x2C\n    stream\x2C\n  } = controller[kState];\n\n  if (closeRequested || stream[kState].state !== 'readable')\n    return;\n\n  if (queueTotalSize) {\n    controller[kState].closeRequested = true;\n    return;\n  }\n\n  if (pendingPullIntos.length) {\n    const firstPendingPullInto = pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const error = new ERR_INVALID_STATE.TypeError('Partial read');\n      readableByteStreamControllerError(controller\x2C error);\n      throw error;\n    }\n  }\n\n  readableByteStreamControllerClearAlgorithms(controller);\n  readableStreamClose(stream);\n}\n\nfunction readableByteStreamControllerCommitPullIntoDescriptor(stream\x2C desc) {\n  assert(stream[kState].state !== 'errored');\n  let done = false;\n  if (stream[kState].state === 'closed') {\n    desc.bytesFilled = 0;\n    done = true;\n  }\n\n  const filledView =\n    readableByteStreamControllerConvertPullIntoDescriptor(desc);\n\n  if (desc.type === 'default') {\n    readableStreamFulfillReadRequest(stream\x2C filledView\x2C done);\n  } else {\n    assert(desc.type === 'byob');\n    readableStreamFulfillReadIntoRequest(stream\x2C filledView\x2C done);\n  }\n}\n\nfunction readableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller[kState].byobRequest === null)\n    return;\n  controller[kState].byobRequest[kState].controller = undefined;\n  controller[kState].byobRequest[kState].view = null;\n  controller[kState].byobRequest = null;\n}\n\nfunction readableByteStreamControllerClearAlgorithms(controller) {\n  controller[kState].pullAlgorithm = undefined;\n  controller[kState].cancelAlgorithm = undefined;\n}\n\nfunction readableByteStreamControllerClearPendingPullIntos(controller) {\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller[kState].pendingPullIntos = [];\n}\n\nfunction readableByteStreamControllerGetDesiredSize(controller) {\n  const {\n    stream\x2C\n    highWaterMark\x2C\n    queueTotalSize\x2C\n  } = controller[kState];\n  switch (stream[kState].state) {\n    case 'errored': return null;\n    case 'closed': return 0;\n    default: return highWaterMark - queueTotalSize;\n  }\n}\n\nfunction readableByteStreamControllerShouldCallPull(controller) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (stream[kState].state !== 'readable' ||\n      controller[kState].closeRequested ||\n      !controller[kState].started) {\n    return false;\n  }\n  if (readableStreamHasDefaultReader(stream) &&\n      readableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (readableStreamHasBYOBReader(stream) &&\n      readableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = readableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n\n  return desiredSize > 0;\n}\n\nfunction readableByteStreamControllerHandleQueueDrain(controller) {\n  const {\n    closeRequested\x2C\n    queueTotalSize\x2C\n    stream\x2C\n  } = controller[kState];\n  assert(stream[kState].state === 'readable');\n  if (!queueTotalSize && closeRequested) {\n    readableByteStreamControllerClearAlgorithms(controller);\n    readableStreamClose(stream);\n    return;\n  }\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction readableByteStreamControllerPullInto(\n  controller\x2C\n  view\x2C\n  readIntoRequest) {\n  const {\n    closeRequested\x2C\n    stream\x2C\n    pendingPullIntos\x2C\n  } = controller[kState];\n  let elementSize = 1;\n  let ctor = DataView;\n  if (isArrayBufferView(view) && !isDataView(view)) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n    ctor = view.constructor;\n  }\n  const buffer = ArrayBufferViewGetBuffer(view);\n  const byteOffset = ArrayBufferViewGetByteOffset(view);\n  const byteLength = ArrayBufferViewGetByteLength(view);\n  const bufferByteLength = ArrayBufferGetByteLength(buffer);\n\n  let transferredBuffer;\n  try {\n    transferredBuffer = transferArrayBuffer(buffer);\n  } catch (error) {\n    readIntoRequest[kError](error);\n    return;\n  }\n  const desc = {\n    buffer: transferredBuffer\x2C\n    bufferByteLength\x2C\n    byteOffset\x2C\n    byteLength\x2C\n    bytesFilled: 0\x2C\n    elementSize\x2C\n    ctor\x2C\n    type: 'byob'\x2C\n  };\n  if (pendingPullIntos.length) {\n    ArrayPrototypePush(pendingPullIntos\x2C desc);\n    readableStreamAddReadIntoRequest(stream\x2C readIntoRequest);\n    return;\n  }\n  if (stream[kState].state === 'closed') {\n    const emptyView = new ctor(desc.buffer\x2C byteOffset\x2C 0);\n    readIntoRequest[kClose](emptyView);\n    return;\n  }\n  if (controller[kState].queueTotalSize) {\n    if (readableByteStreamControllerFillPullIntoDescriptorFromQueue(\n      controller\x2C\n      desc)) {\n      const filledView =\n        readableByteStreamControllerConvertPullIntoDescriptor(desc);\n      readableByteStreamControllerHandleQueueDrain(controller);\n      readIntoRequest[kChunk](filledView);\n      return;\n    }\n    if (closeRequested) {\n      const error = new ERR_INVALID_STATE.TypeError('ReadableStream closed');\n      readableByteStreamControllerError(controller\x2C error);\n      readIntoRequest[kError](error);\n      return;\n    }\n  }\n  ArrayPrototypePush(pendingPullIntos\x2C desc);\n  readableStreamAddReadIntoRequest(stream\x2C readIntoRequest);\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction readableByteStreamControllerRespondInternal(controller\x2C bytesWritten) {\n  const {\n    stream\x2C\n    pendingPullIntos\x2C\n  } = controller[kState];\n  const desc = pendingPullIntos[0];\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\n  if (stream[kState].state === 'closed') {\n    if (bytesWritten)\n      throw new ERR_INVALID_STATE.TypeError(\n        'Controller is closed but view is not zero-length');\n    readableByteStreamControllerRespondInClosedState(controller\x2C desc);\n  } else {\n    assert(stream[kState].state === 'readable');\n    if (!bytesWritten)\n      throw new ERR_INVALID_STATE.TypeError('View cannot be zero-length');\n    readableByteStreamControllerRespondInReadableState(\n      controller\x2C\n      bytesWritten\x2C\n      desc);\n  }\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction readableByteStreamControllerRespond(controller\x2C bytesWritten) {\n  const {\n    pendingPullIntos\x2C\n    stream\x2C\n  } = controller[kState];\n  assert(pendingPullIntos.length);\n  const desc = pendingPullIntos[0];\n\n  if (stream[kState].state === 'closed') {\n    if (bytesWritten !== 0)\n      throw new ERR_INVALID_ARG_VALUE('bytesWritten'\x2C bytesWritten);\n  } else {\n    assert(stream[kState].state === 'readable');\n\n    if (!bytesWritten)\n      throw new ERR_INVALID_ARG_VALUE('bytesWritten'\x2C bytesWritten);\n\n    if ((desc.bytesFilled + bytesWritten) > desc.byteLength)\n      throw new ERR_INVALID_ARG_VALUE.RangeError('bytesWritten'\x2C bytesWritten);\n  }\n\n  desc.buffer = transferArrayBuffer(desc.buffer);\n\n  readableByteStreamControllerRespondInternal(controller\x2C bytesWritten);\n}\n\nfunction readableByteStreamControllerRespondInClosedState(controller\x2C desc) {\n  assert(!desc.bytesFilled);\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (readableStreamHasBYOBReader(stream)) {\n    while (readableStreamGetNumReadIntoRequests(stream) > 0) {\n      readableByteStreamControllerCommitPullIntoDescriptor(\n        stream\x2C\n        readableByteStreamControllerShiftPendingPullInto(controller));\n    }\n  }\n}\n\nfunction readableByteStreamControllerFillHeadPullIntoDescriptor(\n  controller\x2C\n  size\x2C\n  desc) {\n  const {\n    pendingPullIntos\x2C\n    byobRequest\x2C\n  } = controller[kState];\n  assert(!pendingPullIntos.length || pendingPullIntos[0] === desc);\n  assert(byobRequest === null);\n  desc.bytesFilled += size;\n}\n\nfunction readableByteStreamControllerEnqueue(\n  controller\x2C\n  buffer\x2C\n  byteLength\x2C\n  byteOffset) {\n  const {\n    closeRequested\x2C\n    pendingPullIntos\x2C\n    queue\x2C\n    stream\x2C\n  } = controller[kState];\n\n  if (closeRequested || stream[kState].state !== 'readable')\n    return;\n\n  const transferredBuffer = transferArrayBuffer(buffer);\n\n  if (pendingPullIntos.length) {\n    const firstPendingPullInto = pendingPullIntos[0];\n\n    const pendingBufferByteLength =\n      ArrayBufferGetByteLength(firstPendingPullInto.buffer);\n    if (pendingBufferByteLength === 0) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'Destination ArrayBuffer is zero-length or detached');\n    }\n\n    firstPendingPullInto.buffer =\n      transferArrayBuffer(firstPendingPullInto.buffer);\n  }\n\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  if (readableStreamHasDefaultReader(stream)) {\n    if (!readableStreamGetNumReadRequests(stream)) {\n      readableByteStreamControllerEnqueueChunkToQueue(\n        controller\x2C\n        transferredBuffer\x2C\n        byteOffset\x2C\n        byteLength);\n    } else {\n      assert(!queue.length);\n      const transferredView =\n        new Uint8Array(transferredBuffer\x2C byteOffset\x2C byteLength);\n      readableStreamFulfillReadRequest(stream\x2C transferredView\x2C false);\n    }\n  } else if (readableStreamHasBYOBReader(stream)) {\n    readableByteStreamControllerEnqueueChunkToQueue(\n      controller\x2C\n      transferredBuffer\x2C\n      byteOffset\x2C\n      byteLength);\n    readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(\n      controller);\n  } else {\n    assert(!isReadableStreamLocked(stream));\n    readableByteStreamControllerEnqueueChunkToQueue(\n      controller\x2C\n      transferredBuffer\x2C\n      byteOffset\x2C\n      byteLength);\n  }\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction readableByteStreamControllerEnqueueChunkToQueue(\n  controller\x2C\n  buffer\x2C\n  byteOffset\x2C\n  byteLength) {\n  ArrayPrototypePush(\n    controller[kState].queue\x2C\n    {\n      buffer\x2C\n      byteOffset\x2C\n      byteLength\x2C\n    });\n  controller[kState].queueTotalSize += byteLength;\n}\n\nfunction readableByteStreamControllerFillPullIntoDescriptorFromQueue(\n  controller\x2C\n  desc) {\n  const {\n    buffer\x2C\n    byteLength\x2C\n    byteOffset\x2C\n    bytesFilled\x2C\n    elementSize\x2C\n  } = desc;\n  const currentAlignedBytes = bytesFilled - (bytesFilled % elementSize);\n  const maxBytesToCopy = MathMin(\n    controller[kState].queueTotalSize\x2C\n    byteLength - bytesFilled);\n  const maxBytesFilled = bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - (maxBytesFilled % elementSize);\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - bytesFilled;\n    ready = true;\n  }\n  const {\n    queue\x2C\n  } = controller[kState];\n\n  while (totalBytesToCopyRemaining) {\n    const headOfQueue = queue[0];\n    const bytesToCopy = MathMin(\n      totalBytesToCopyRemaining\x2C\n      headOfQueue.byteLength);\n    const destStart = byteOffset + desc.bytesFilled;\n    const arrayBufferByteLength = ArrayBufferGetByteLength(buffer);\n    if (arrayBufferByteLength - destStart < bytesToCopy) {\n      throw new ERR_INVALID_STATE.RangeError(\n        'view ArrayBuffer size is invalid');\n    }\n    assert(arrayBufferByteLength - destStart >= bytesToCopy);\n    copyArrayBuffer(\n      buffer\x2C\n      destStart\x2C\n      headOfQueue.buffer\x2C\n      headOfQueue.byteOffset\x2C\n      bytesToCopy);\n    if (headOfQueue.byteLength === bytesToCopy) {\n      ArrayPrototypeShift(queue);\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller[kState].queueTotalSize -= bytesToCopy;\n    readableByteStreamControllerFillHeadPullIntoDescriptor(\n      controller\x2C\n      bytesToCopy\x2C\n      desc);\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (!ready) {\n    assert(!controller[kState].queueTotalSize);\n    assert(desc.bytesFilled > 0);\n    assert(desc.bytesFilled < elementSize);\n  }\n  return ready;\n}\n\nfunction readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(\n  controller) {\n  const {\n    closeRequested\x2C\n    pendingPullIntos\x2C\n    stream\x2C\n  } = controller[kState];\n  assert(!closeRequested);\n  while (pendingPullIntos.length) {\n    if (!controller[kState].queueTotalSize)\n      return;\n    const desc = pendingPullIntos[0];\n    if (readableByteStreamControllerFillPullIntoDescriptorFromQueue(\n      controller\x2C\n      desc)) {\n      readableByteStreamControllerShiftPendingPullInto(controller);\n      readableByteStreamControllerCommitPullIntoDescriptor(stream\x2C desc);\n    }\n  }\n}\n\nfunction readableByteStreamControllerRespondInReadableState(\n  controller\x2C\n  bytesWritten\x2C\n  desc) {\n  const {\n    buffer\x2C\n    bytesFilled\x2C\n    byteLength\x2C\n  } = desc;\n\n  if (bytesFilled + bytesWritten > byteLength)\n    throw new ERR_INVALID_STATE.RangeError('The buffer size is invalid');\n\n  readableByteStreamControllerFillHeadPullIntoDescriptor(\n    controller\x2C\n    bytesWritten\x2C\n    desc);\n\n  if (desc.bytesFilled < desc.elementSize)\n    return;\n\n  readableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = desc.bytesFilled % desc.elementSize;\n\n  if (remainderSize) {\n    const end = desc.byteOffset + desc.bytesFilled;\n    const start = end - remainderSize;\n    const remainder =\n      ArrayBufferPrototypeSlice(\n        buffer\x2C\n        start\x2C\n        end);\n    readableByteStreamControllerEnqueueChunkToQueue(\n      controller\x2C\n      remainder\x2C\n      0\x2C\n      ArrayBufferGetByteLength(remainder));\n  }\n  desc.bytesFilled -= remainderSize;\n  readableByteStreamControllerCommitPullIntoDescriptor(\n    controller[kState].stream\x2C\n    desc);\n  readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction readableByteStreamControllerRespondWithNewView(controller\x2C view) {\n  const {\n    stream\x2C\n    pendingPullIntos\x2C\n  } = controller[kState];\n  assert(pendingPullIntos.length);\n\n  const desc = pendingPullIntos[0];\n  assert(stream[kState].state !== 'errored');\n\n  if (!isArrayBufferView(view)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'view'\x2C\n      [\n        'Buffer'\x2C\n        'TypedArray'\x2C\n        'DataView'\x2C\n      ]\x2C\n      view);\n  }\n  const viewByteLength = ArrayBufferViewGetByteLength(view);\n  const viewByteOffset = ArrayBufferViewGetByteOffset(view);\n  const viewBuffer = ArrayBufferViewGetBuffer(view);\n  const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\n\n  const {\n    byteOffset\x2C\n    byteLength\x2C\n    bytesFilled\x2C\n    bufferByteLength\x2C\n  } = desc;\n\n  if (byteOffset + bytesFilled !== viewByteOffset)\n    throw new ERR_INVALID_ARG_VALUE.RangeError('view'\x2C view);\n\n  if (bytesFilled + viewByteOffset > byteLength)\n    throw new ERR_INVALID_ARG_VALUE.RangeError('view'\x2C view);\n\n  if (bufferByteLength !== viewBufferByteLength)\n    throw new ERR_INVALID_ARG_VALUE.RangeError('view'\x2C view);\n\n  desc.buffer = transferArrayBuffer(viewBuffer);\n\n  readableByteStreamControllerRespondInternal(controller\x2C viewByteLength);\n}\n\nfunction readableByteStreamControllerShiftPendingPullInto(controller) {\n  assert(controller[kState].byobRequest === null);\n  return ArrayPrototypeShift(controller[kState].pendingPullIntos);\n}\n\nfunction readableByteStreamControllerCallPullIfNeeded(controller) {\n  if (!readableByteStreamControllerShouldCallPull(controller))\n    return;\n  if (controller[kState].pulling) {\n    controller[kState].pullAgain = true;\n    return;\n  }\n  assert(!controller[kState].pullAgain);\n  controller[kState].pulling = true;\n  PromisePrototypeThen(\n    ensureIsPromise(controller[kState].pullAlgorithm\x2C controller)\x2C\n    () => {\n      controller[kState].pulling = false;\n      if (controller[kState].pullAgain) {\n        controller[kState].pullAgain = false;\n        readableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    }\x2C\n    (error) => readableByteStreamControllerError(controller\x2C error));\n}\n\nfunction readableByteStreamControllerError(controller\x2C error) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (stream[kState].state !== 'readable')\n    return;\n  readableByteStreamControllerClearPendingPullIntos(controller);\n  resetQueue(controller);\n  readableByteStreamControllerClearAlgorithms(controller);\n  readableStreamError(stream\x2C error);\n}\n\nfunction readableByteStreamControllerCancelSteps(controller\x2C reason) {\n  readableByteStreamControllerClearPendingPullIntos(controller);\n  resetQueue(controller);\n  const result = controller[kState].cancelAlgorithm(reason);\n  readableByteStreamControllerClearAlgorithms(controller);\n  return result;\n}\n\nfunction readableByteStreamControllerPullSteps(controller\x2C readRequest) {\n  const {\n    pendingPullIntos\x2C\n    queue\x2C\n    queueTotalSize\x2C\n    stream\x2C\n  } = controller[kState];\n  assert(readableStreamHasDefaultReader(stream));\n  if (queueTotalSize) {\n    assert(!readableStreamGetNumReadRequests(stream));\n    const {\n      buffer\x2C\n      byteOffset\x2C\n      byteLength\x2C\n    } = ArrayPrototypeShift(queue);\n    controller[kState].queueTotalSize -= byteLength;\n    readableByteStreamControllerHandleQueueDrain(controller);\n    const view = new Uint8Array(buffer\x2C byteOffset\x2C byteLength);\n    readRequest[kChunk](view);\n    return;\n  }\n  const {\n    autoAllocateChunkSize\x2C\n  } = controller[kState];\n  if (autoAllocateChunkSize !== undefined) {\n    try {\n      const buffer = new ArrayBuffer(autoAllocateChunkSize);\n      ArrayPrototypePush(\n        pendingPullIntos\x2C\n        {\n          buffer\x2C\n          bufferByteLength: autoAllocateChunkSize\x2C\n          byteOffset: 0\x2C\n          byteLength: autoAllocateChunkSize\x2C\n          bytesFilled: 0\x2C\n          elementSize: 1\x2C\n          ctor: Uint8Array\x2C\n          type: 'default'\x2C\n        });\n    } catch (error) {\n      readRequest[kError](error);\n      return;\n    }\n  }\n\n  readableStreamAddReadRequest(stream\x2C readRequest);\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction setupReadableByteStreamController(\n  stream\x2C\n  controller\x2C\n  startAlgorithm\x2C\n  pullAlgorithm\x2C\n  cancelAlgorithm\x2C\n  highWaterMark\x2C\n  autoAllocateChunkSize) {\n  assert(stream[kState].controller === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(NumberIsInteger(autoAllocateChunkSize));\n    assert(autoAllocateChunkSize > 0);\n  }\n  controller[kState] = {\n    byobRequest: null\x2C\n    closeRequested: false\x2C\n    pullAgain: false\x2C\n    pulling: false\x2C\n    started: false\x2C\n    stream\x2C\n    queue: []\x2C\n    queueTotalSize: 0\x2C\n    highWaterMark\x2C\n    pullAlgorithm\x2C\n    cancelAlgorithm\x2C\n    autoAllocateChunkSize\x2C\n    pendingPullIntos: []\x2C\n  };\n  stream[kState].controller = controller;\n\n  const startResult = startAlgorithm();\n\n  PromisePrototypeThen(\n    PromiseResolve(startResult)\x2C\n    () => {\n      controller[kState].started = true;\n      assert(!controller[kState].pulling);\n      assert(!controller[kState].pullAgain);\n      readableByteStreamControllerCallPullIfNeeded(controller);\n    }\x2C\n    (error) => readableByteStreamControllerError(controller\x2C error));\n}\n\nfunction setupReadableByteStreamControllerFromSource(\n  stream\x2C\n  source\x2C\n  highWaterMark) {\n  const controller = createReadableByteStreamController();\n  const start = source?.start;\n  const pull = source?.pull;\n  const cancel = source?.cancel;\n  const autoAllocateChunkSize = source?.autoAllocateChunkSize;\n  const startAlgorithm = start ?\n    FunctionPrototypeBind(start\x2C source\x2C controller) :\n    nonOpStart;\n  const pullAlgorithm = pull ?\n    FunctionPrototypeBind(pull\x2C source\x2C controller) :\n    nonOpPull;\n  const cancelAlgorithm = cancel ?\n    FunctionPrototypeBind(cancel\x2C source) :\n    nonOpCancel;\n\n  if (autoAllocateChunkSize === 0) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'source.autoAllocateChunkSize'\x2C\n      autoAllocateChunkSize);\n  }\n  setupReadableByteStreamController(\n    stream\x2C\n    controller\x2C\n    startAlgorithm\x2C\n    pullAlgorithm\x2C\n    cancelAlgorithm\x2C\n    highWaterMark\x2C\n    autoAllocateChunkSize);\n}\n\nmodule.exports = {\n  ReadableStream\x2C\n  ReadableStreamDefaultReader\x2C\n  ReadableStreamBYOBReader\x2C\n  ReadableStreamBYOBRequest\x2C\n  ReadableByteStreamController\x2C\n  ReadableStreamDefaultController\x2C\n  TransferredReadableStream\x2C\n\n  // Exported Brand Checks\n  isReadableStream\x2C\n  isReadableByteStreamController\x2C\n  isReadableStreamBYOBRequest\x2C\n  isReadableStreamDefaultReader\x2C\n  isReadableStreamBYOBReader\x2C\n  isWritableStreamDefaultWriter\x2C\n  isWritableStreamDefaultController\x2C\n\n  readableStreamPipeTo\x2C\n  readableStreamTee\x2C\n  readableByteStreamControllerConvertPullIntoDescriptor\x2C\n  isReadableStreamLocked\x2C\n  readableStreamCancel\x2C\n  readableStreamClose\x2C\n  readableStreamError\x2C\n  readableStreamHasDefaultReader\x2C\n  readableStreamGetNumReadRequests\x2C\n  readableStreamHasBYOBReader\x2C\n  readableStreamGetNumReadIntoRequests\x2C\n  readableStreamFulfillReadRequest\x2C\n  readableStreamFulfillReadIntoRequest\x2C\n  readableStreamAddReadRequest\x2C\n  readableStreamAddReadIntoRequest\x2C\n  readableStreamReaderGenericCancel\x2C\n  readableStreamReaderGenericInitialize\x2C\n  readableStreamReaderGenericRelease\x2C\n  readableStreamBYOBReaderRead\x2C\n  readableStreamDefaultReaderRead\x2C\n  setupReadableStreamBYOBReader\x2C\n  setupReadableStreamDefaultReader\x2C\n  readableStreamDefaultControllerClose\x2C\n  readableStreamDefaultControllerEnqueue\x2C\n  readableStreamDefaultControllerHasBackpressure\x2C\n  readableStreamDefaultControllerCanCloseOrEnqueue\x2C\n  readableStreamDefaultControllerGetDesiredSize\x2C\n  readableStreamDefaultControllerShouldCallPull\x2C\n  readableStreamDefaultControllerCallPullIfNeeded\x2C\n  readableStreamDefaultControllerClearAlgorithms\x2C\n  readableStreamDefaultControllerError\x2C\n  readableStreamDefaultControllerCancelSteps\x2C\n  readableStreamDefaultControllerPullSteps\x2C\n  setupReadableStreamDefaultController\x2C\n  setupReadableStreamDefaultControllerFromSource\x2C\n  readableByteStreamControllerClose\x2C\n  readableByteStreamControllerCommitPullIntoDescriptor\x2C\n  readableByteStreamControllerInvalidateBYOBRequest\x2C\n  readableByteStreamControllerClearAlgorithms\x2C\n  readableByteStreamControllerClearPendingPullIntos\x2C\n  readableByteStreamControllerGetDesiredSize\x2C\n  readableByteStreamControllerShouldCallPull\x2C\n  readableByteStreamControllerHandleQueueDrain\x2C\n  readableByteStreamControllerPullInto\x2C\n  readableByteStreamControllerRespondInternal\x2C\n  readableByteStreamControllerRespond\x2C\n  readableByteStreamControllerRespondInClosedState\x2C\n  readableByteStreamControllerFillHeadPullIntoDescriptor\x2C\n  readableByteStreamControllerEnqueue\x2C\n  readableByteStreamControllerEnqueueChunkToQueue\x2C\n  readableByteStreamControllerFillPullIntoDescriptorFromQueue\x2C\n  readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue\x2C\n  readableByteStreamControllerRespondInReadableState\x2C\n  readableByteStreamControllerRespondWithNewView\x2C\n  readableByteStreamControllerShiftPendingPullInto\x2C\n  readableByteStreamControllerCallPullIfNeeded\x2C\n  readableByteStreamControllerError\x2C\n  readableByteStreamControllerCancelSteps\x2C\n  readableByteStreamControllerPullSteps\x2C\n  setupReadableByteStreamController\x2C\n  setupReadableByteStreamControllerFromSource\x2C\n};\n\n/* eslint-enable no-use-before-define */\n
code-source-info,0x120d443ad9ae,125,0,76621,C0O0C4O76621,,
code-creation,Function,10,43542,0x120d443b3916,3524, node:internal/webstreams/readablestream:1:1,0x120d443ad928,~
code-source-info,0x120d443b3916,125,0,76621,C0O0C655O68C661O83C667O112C673O134C679O157C685O169C691O194C697O219C703O230C709O249C715O265C720O291C726O315C732O326C738O351C744O375C750O393C756O410C762O424C768O444C773O454C779O477C784O498C790O683C794O683C800O683C806O551C812O580C818O607C824O633C830O656C836O740C840O740C846O722C852O818C856O818C862O781C868O802C874O944C878O944C884O861C890O907C895O919C900O1011C904O1011C910O981C916O994C922O1057C926O1057C932O1037C938O1114C942O1114C948O1100C954O1183C958O1183C964O1163C970O1293C974O1293C980O1225C985O1241C990O1254C995O1271C1001O1368C1005O1368C1011O1348C1017O1467C1021O1467C1027O1420C1032O1436C1037O1450C1042O1946C1046O1946C1052O1513C1058O1541C1064O1573C1070O1605C1076O1633C1082O1650C1088O1669C1094O1686C1100O1702C1106O1721C1112O1745C1118O1769C1124O1793C1130O1809C1135O1825C1141O1839C1147O1860C1153O1883C1159O1898C1165O1911C1171O1925C1177O1934C1183O2337C1187O2337C1193O1994C1199O2026C1205O2046C1211O2072C1216O2109C1221O2143C1227O2166C1233O2205C1239O2261C1245O2299C1251O2400C1255O2400C1259O2400C1261O2445C1265O2445C1269O2445C1271O2479C1275O2479C1279O2479C1281O2512C1285O2512C1289O2512C1291O2545C1295O2545C1299O2545C1301O2577C1305O2577C1309O2577C1331O4043C1341O4078C1349O5659C1359O5724C1369O5797C1421O13922C1431O14175C1441O14959C1451O15141C1487O4017C1489O15354C1493O15392C1507O15408C1509O15430C1519O15525C1525O15535C1546O15558C1557O15589C1568O15623C1579O15659C1590O15690C1601O15718C1606O15354C1611O16205C1617O16215C1621O16229C1645O16279C1655O16325C1681O17915C1717O16242C1719O18080C1723O18129C1737O18150C1743O18182C1749O18225C1753O18080C1771O18621C1781O18698C1791O18780C1819O18524C1834O18982C1844O19059C1854O19135C1882O18888C1904O19282C1914O19330C1946O21425C1982O19243C1984O21654C1988O21705C2002O21728C2008O21757C2014O21793C2020O21824C2024O21654C2049O21886C2059O21931C2091O24825C2131O21850C2133O25068C2137O25116C2158O25139C2168O25168C2178O25204C2188O25235C2196O25068C2226O25304C2236O25356C2270O26210C2285O26306C2298O26401C2344O25261C2346O26496C2350O26551C2371O26579C2381O26609C2391O26641C2401O26671C2409O26496C2446O26972C2456O27021C2514O29924C2529O30017C2542O30109C2588O26932C2590O30204C2594O30256C2615O30284C2625O30320C2635O30350C2645O30382C2655O30412C2663O30204C2673O31405C2679O31405C2687O31405C2689O31478C2695O31478C2703O31478C2705O31562C2711O31562C2719O31562C2721O31645C2727O31645C2735O31645C2737O31727C2743O31727C2751O31727C2753O73518C2764O73539C2774O73557C2784O73588C2794O73616C2804O73645C2814O73677C2824O73712C2834O73769C2844O73789C2854O73823C2864O73854C2874O73887C2884O73917C2894O73950C2904O73988C2914O74012C2924O74033C2934O74090C2944O74116C2954O74140C2964O74163C2974O74186C2984O74220C2994O74256C3004O74287C3014O74327C3024O74363C3034O74403C3044O74435C3054O74471C3064O74508C3074O74549C3084O74587C3094O74619C3104O74654C3114O74687C3124O74723C3134O74763C3144O74805C3154O74855C3164O74907C3174O74956C3184O75005C3194O75056C3204O75106C3214O75146C3224O75192C3234O75236C3244O75276C3254O75326C3264O75363C3274O75419C3284O75472C3294O75519C3304O75572C3314O75618C3324O75664C3334O75712C3344O75752C3354O75799C3364O75838C3374O75890C3384O75948C3394O75987C3404O76038C3414O76101C3424O76169C3434O76223C3444O76273C3454O76325C3464O76373C3474O76410C3484O76453C3494O76494C3504O76531C3514O73533C3523O76620,,
code-creation,Function,10,43667,0x120d443b4bae,16,<instance_members_initializer> node:internal/webstreams/readablestream:1035:3,0x120d443b0810,~
code-source-info,0x120d443b4bae,125,26971,27011,C3O26981C15O27011,,
code-creation,Function,10,43667,0x120d443b4c26,16,<instance_members_initializer> node:internal/webstreams/readablestream:965:3,0x120d443b0478,~
code-source-info,0x120d443b4c26,125,25303,25346,C3O25313C15O25346,,
code-creation,Function,10,43667,0x120d443b4ca6,16,<instance_members_initializer> node:internal/webstreams/readablestream:848:3,0x120d443b0150,~
code-source-info,0x120d443b4ca6,125,21885,21921,C3O21895C15O21921,,
code-creation,Function,10,43667,0x120d443b4d1e,16,<instance_members_initializer> node:internal/webstreams/readablestream:754:3,0x120d443afec8,~
code-source-info,0x120d443b4d1e,125,19281,19320,C3O19291C15O19320,,
code-creation,Function,10,43667,0x120d443b4d96,16,<instance_members_initializer> node:internal/webstreams/readablestream:622:3,0x120d443af8e0,~
code-source-info,0x120d443b4d96,125,16278,16315,C3O16288C15O16315,,
code-creation,Function,10,43709,0x120d443b4e0e,16,<instance_members_initializer> node:internal/webstreams/readablestream:201:3,0x120d443af620,~
code-source-info,0x120d443b4e0e,125,4042,4068,C3O4052C15O4068,,
tick,0x1bfc3b5fc,43709,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x120d443a82cf,0x105108d28,0x10510894c,0x120d4439f42a,0x105108d28,0x10510894c,0x120d4439b14d,0x105108d28,0x10510894c,0x120d4439a952,0x105108d28,0x10510894c,0x3172a1b32c9a,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
tick,0x10055870c,43750,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x120d443a82cf,0x105108d28,0x10510894c,0x120d4439f42a,0x105108d28,0x10510894c,0x120d4439b14d,0x105108d28,0x10510894c,0x120d4439a952,0x105108d28,0x10510894c,0x3172a1b32c9a,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,Eval,10,43959,0x120d443bbbde,5, node:internal/webstreams/util:1:1,0x120d443bb928,~
script-source,126,node:internal/webstreams/util,'use strict';\n\nconst {\n  ArrayBufferPrototype\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  AsyncIteratorPrototype\x2C\n  FunctionPrototypeCall\x2C\n  MathMax\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  ReflectGet\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OPERATION_FAILED\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  copyArrayBuffer\x2C\n  detachArrayBuffer\n} = internalBinding('buffer');\n\nconst {\n  isPromise\x2C\n} = require('internal/util/types');\n\nconst {\n  inspect\x2C\n} = require('util');\n\nconst {\n  getPromiseDetails\x2C\n  kPending\x2C\n} = internalBinding('util');\n\nconst assert = require('internal/assert');\n\nconst kState = Symbol('kState');\nconst kType = Symbol('kType');\n\nconst AsyncIterator = ObjectCreate(AsyncIteratorPrototype\x2C {\n  next: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    writable: true\x2C\n  }\x2C\n  return: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    writable: true\x2C\n  }\x2C\n});\n\nfunction extractHighWaterMark(value\x2C defaultHWM) {\n  if (value === undefined) return defaultHWM;\n  value = +value;\n  if (typeof value !== 'number' ||\n      NumberIsNaN(value) ||\n      value < 0)\n    throw new ERR_INVALID_ARG_VALUE.RangeError('strategy.highWaterMark'\x2C value);\n  return value;\n}\n\nfunction extractSizeAlgorithm(size) {\n  if (size === undefined) return () => 1;\n  if (typeof size !== 'function')\n    throw new ERR_INVALID_ARG_TYPE('strategy.size'\x2C 'Function'\x2C size);\n  return size;\n}\n\nfunction customInspect(depth\x2C options\x2C name\x2C data) {\n  if (depth < 0)\n    return this;\n\n  const opts = {\n    ...options\x2C\n    depth: options.depth == null ? null : options.depth - 1\n  };\n\n  return `${name} ${inspect(data\x2C opts)}`;\n}\n\n// These are defensive to work around the possibility that\n// the buffer\x2C byteLength\x2C and byteOffset properties on\n// ArrayBuffer and ArrayBufferView's may have been tampered with.\n\nfunction ArrayBufferViewGetBuffer(view) {\n  return ReflectGet(view.constructor.prototype\x2C 'buffer'\x2C view);\n}\n\nfunction ArrayBufferViewGetByteLength(view) {\n  return ReflectGet(view.constructor.prototype\x2C 'byteLength'\x2C view);\n}\n\nfunction ArrayBufferViewGetByteOffset(view) {\n  return ReflectGet(view.constructor.prototype\x2C 'byteOffset'\x2C view);\n}\n\nfunction ArrayBufferGetByteLength(view) {\n  return ReflectGet(ArrayBufferPrototype\x2C 'byteLength'\x2C view);\n}\n\nfunction isBrandCheck(brand) {\n  return (value) => {\n    return value != null &&\n           value[kState] !== undefined &&\n           value[kType] === brand;\n  };\n}\n\nfunction transferArrayBuffer(buffer) {\n  const res = detachArrayBuffer(buffer);\n  if (res === undefined) {\n    throw new ERR_OPERATION_FAILED.TypeError(\n      'The ArrayBuffer could not be transferred');\n  }\n  return res;\n}\n\nfunction dequeueValue(controller) {\n  assert(controller[kState].queue !== undefined);\n  assert(controller[kState].queueTotalSize !== undefined);\n  assert(controller[kState].queue.length);\n  const {\n    value\x2C\n    size\x2C\n  } = ArrayPrototypeShift(controller[kState].queue);\n  controller[kState].queueTotalSize =\n    MathMax(0\x2C controller[kState].queueTotalSize - size);\n  return value;\n}\n\nfunction resetQueue(controller) {\n  assert(controller[kState].queue !== undefined);\n  assert(controller[kState].queueTotalSize !== undefined);\n  controller[kState].queue = [];\n  controller[kState].queueTotalSize = 0;\n}\n\nfunction peekQueueValue(controller) {\n  assert(controller[kState].queue !== undefined);\n  assert(controller[kState].queueTotalSize !== undefined);\n  assert(controller[kState].queue.length);\n  return controller[kState].queue[0].value;\n}\n\nfunction enqueueValueWithSize(controller\x2C value\x2C size) {\n  assert(controller[kState].queue !== undefined);\n  assert(controller[kState].queueTotalSize !== undefined);\n  size = +size;\n  if (typeof size !== 'number' ||\n      size < 0 ||\n      NumberIsNaN(size) ||\n      size === Infinity) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\n  }\n  ArrayPrototypePush(controller[kState].queue\x2C { value\x2C size });\n  controller[kState].queueTotalSize += size;\n}\n\nfunction ensureIsPromise(fn\x2C thisArg\x2C ...args) {\n  try {\n    const value = FunctionPrototypeCall(fn\x2C thisArg\x2C ...args);\n    return isPromise(value) ? value : PromiseResolve(value);\n  } catch (error) {\n    return PromiseReject(error);\n  }\n}\n\nfunction isPromisePending(promise) {\n  if (promise === undefined) return false;\n  const details = getPromiseDetails(promise);\n  return details?.[0] === kPending;\n}\n\nfunction setPromiseHandled(promise) {\n  // Alternatively\x2C we could use the native API\n  // MarkAsHandled\x2C but this avoids the extra boundary cross\n  // and is hopefully faster at the cost of an extra Promise\n  // allocation.\n  PromisePrototypeThen(promise\x2C () => {}\x2C () => {});\n}\n\nasync function nonOpFlush() {}\n\nfunction nonOpStart() {}\n\nasync function nonOpPull() {}\n\nasync function nonOpCancel() {}\n\nasync function nonOpWrite() {}\n\nlet transfer;\nfunction lazyTransfer() {\n  if (transfer === undefined)\n    transfer = require('internal/webstreams/transfer');\n  return transfer;\n}\n\nmodule.exports = {\n  ArrayBufferViewGetBuffer\x2C\n  ArrayBufferViewGetByteLength\x2C\n  ArrayBufferViewGetByteOffset\x2C\n  ArrayBufferGetByteLength\x2C\n  AsyncIterator\x2C\n  copyArrayBuffer\x2C\n  customInspect\x2C\n  dequeueValue\x2C\n  ensureIsPromise\x2C\n  enqueueValueWithSize\x2C\n  extractHighWaterMark\x2C\n  extractSizeAlgorithm\x2C\n  lazyTransfer\x2C\n  isBrandCheck\x2C\n  isPromisePending\x2C\n  peekQueueValue\x2C\n  resetQueue\x2C\n  setPromiseHandled\x2C\n  transferArrayBuffer\x2C\n  nonOpCancel\x2C\n  nonOpFlush\x2C\n  nonOpPull\x2C\n  nonOpStart\x2C\n  nonOpWrite\x2C\n  kType\x2C\n  kState\x2C\n};\n
code-source-info,0x120d443bbbde,126,0,5587,C0O0C4O5587,,
code-creation,Function,10,44209,0x120d443bc82e,611, node:internal/webstreams/util:1:1,0x120d443bbb58,~
code-source-info,0x120d443bc82e,126,0,5587,C0O0C196O25C202O49C208O71C214O94C219O120C225O145C231O156C237O171C242O187C248O211C254O229C260O246C266O260C271O393C279O393C285O393C291O309C297O335C303O362C309O473C313O473C319O432C324O451C330O526C338O526C344O511C350O582C358O582C364O569C370O645C374O645C380O610C386O631C392O686C400O686C404O686C406O730C410O730C414O730C416O762C420O762C424O762C426O815C432O802C438O4924C439O4924C441O5068C449O5089C455O5117C461O5149C467O5181C473O5209C479O5226C485O5245C491O5262C497O5278C503O5297C509O5321C515O5345C521O5369C527O5385C533O5401C539O5421C545O5439C551O5453C557O5474C563O5497C569O5512C575O5526C581O5539C587O5553C593O5567C599O5576C605O5083C610O5586,,
tick,0x10096d870,44417,1,0x10041f4d8,2,0x0,0x105108c5c,0x10510894c,0x120d443b3db9,0x105108d28,0x10510894c,0x120d443a82cf,0x105108d28,0x10510894c,0x120d4439f42a,0x105108d28,0x10510894c,0x120d4439b14d,0x105108d28,0x10510894c,0x120d4439a952,0x105108d28,0x10510894c,0x3172a1b32c9a,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
new,MemoryChunk,0x26b72db00000,262144
code-creation,Eval,10,44667,0x120d443bec9e,5, node:internal/webstreams/writablestream:1:1,0x120d443be490,~
script-source,127,node:internal/webstreams/writablestream,'use strict';\n\n/* eslint-disable no-use-before-define */\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperties\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  ReflectConstruct\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_INVALID_THIS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  DOMException\x2C\n} = internalBinding('messaging');\n\nconst {\n  createDeferredPromise\x2C\n  customInspectSymbol: kInspect\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\n\nconst {\n  MessageChannel\x2C\n} = require('internal/worker/io');\n\nconst {\n  kDeserialize\x2C\n  kTransfer\x2C\n  kTransferList\x2C\n  makeTransferable\x2C\n} = require('internal/worker/js_transferable');\n\nconst {\n  customInspect\x2C\n  dequeueValue\x2C\n  ensureIsPromise\x2C\n  enqueueValueWithSize\x2C\n  extractHighWaterMark\x2C\n  extractSizeAlgorithm\x2C\n  lazyTransfer\x2C\n  isBrandCheck\x2C\n  isPromisePending\x2C\n  peekQueueValue\x2C\n  resetQueue\x2C\n  setPromiseHandled\x2C\n  nonOpCancel\x2C\n  nonOpStart\x2C\n  nonOpWrite\x2C\n  kType\x2C\n  kState\x2C\n} = require('internal/webstreams/util');\n\nconst {\n  AbortController\x2C\n} = require('internal/abort_controller');\n\nconst assert = require('internal/assert');\n\nconst kAbort = Symbol('kAbort');\nconst kCloseSentinel = Symbol('kCloseSentinel');\nconst kError = Symbol('kError');\n\n/**\n * @typedef {import('../abort_controller').AbortSignal} AbortSignal\n * @typedef {import('./queuingstrategies').QueuingStrategy\n * } QueuingStrategy\n * @typedef {import('./queuingstrategies').QueuingStrategySize\n * } QueuingStrategySize\n */\n\n/**\n * @callback UnderlyingSinkStartCallback\n * @param {WritableStreamDefaultController} controller\n */\n\n/**\n * @callback UnderlyingSinkWriteCallback\n * @param {any} chunk\n * @param {WritableStreamDefaultController} controller\n * @returns {Promise<void>}\n */\n\n/**\n * @callback UnderlyingSinkCloseCallback\n * @returns {Promise<void>}\n */\n\n/**\n * @callback UnderlyingSinkAbortCallback\n * @param {any} reason\n * @returns {Promise<void>}\n */\n\n/**\n * @typedef {{\n *   start? : UnderlyingSinkStartCallback\x2C\n *   write? : UnderlyingSinkWriteCallback\x2C\n *   close? : UnderlyingSinkCloseCallback\x2C\n *   abort? : UnderlyingSinkAbortCallback\x2C\n *   type? : any\x2C\n * }} UnderlyingSink\n */\n\nclass WritableStream {\n  [kType] = 'WritableStream';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {UnderlyingSink} [sink]\n   * @param {QueuingStrategy} [strategy]\n   */\n  constructor(sink = null\x2C strategy = {}) {\n    const type = sink?.type;\n    if (type !== undefined)\n      throw new ERR_INVALID_ARG_VALUE.RangeError('type'\x2C type);\n\n    this[kState] = {\n      close: createDeferredPromise()\x2C\n      closeRequest: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      inFlightWriteRequest: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      inFlightCloseRequest: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      pendingAbortRequest: {\n        abort: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        reason: undefined\x2C\n        wasAlreadyErroring: false\x2C\n      }\x2C\n      backpressure: false\x2C\n      controller: undefined\x2C\n      state: 'writable'\x2C\n      storedError: undefined\x2C\n      writeRequests: []\x2C\n      writer: undefined\x2C\n      transfer: {\n        readable: undefined\x2C\n        port1: undefined\x2C\n        port2: undefined\x2C\n        promise: undefined\x2C\n      }\n    };\n\n    const size = extractSizeAlgorithm(strategy?.size);\n    const highWaterMark = extractHighWaterMark(strategy?.highWaterMark\x2C 1);\n\n    setupWritableStreamDefaultControllerFromSink(\n      this\x2C\n      sink\x2C\n      highWaterMark\x2C\n      size);\n\n    // eslint-disable-next-line no-constructor-return\n    return makeTransferable(this);\n  }\n\n  /**\n   * @readonly\n   * @type {boolean}\n   */\n  get locked() {\n    if (!isWritableStream(this))\n      throw new ERR_INVALID_THIS('WritableStream');\n    return isWritableStreamLocked(this);\n  }\n\n  /**\n   * @param {any} reason\n   * @returns {Promise<vois>}\n   */\n  abort(reason = undefined) {\n    if (!isWritableStream(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStream'));\n    if (isWritableStreamLocked(this)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('WritableStream is locked'));\n    }\n    return writableStreamAbort(this\x2C reason);\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  close() {\n    if (!isWritableStream(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStream'));\n    if (isWritableStreamLocked(this)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('WritableStream is locked'));\n    }\n    if (writableStreamCloseQueuedOrInFlight(this)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('Failure closing WritableStream'));\n    }\n    return writableStreamClose(this);\n  }\n\n  /**\n   * @returns {WritableStreamDefaultWriter}\n   */\n  getWriter() {\n    if (!isWritableStream(this))\n      throw new ERR_INVALID_THIS('WritableStream');\n    return new WritableStreamDefaultWriter(this);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      locked: this.locked\x2C\n      state: this[kState].state\x2C\n    });\n  }\n\n  [kTransfer]() {\n    if (!isWritableStream(this))\n      throw new ERR_INVALID_THIS('WritableStream');\n    if (this.locked) {\n      this[kState].transfer.port1?.close();\n      this[kState].transfer.port1 = undefined;\n      this[kState].transfer.port2 = undefined;\n      throw new DOMException(\n        'Cannot transfer a locked WritableStream'\x2C\n        'DataCloneError');\n    }\n\n    const {\n      readable\x2C\n      promise\x2C\n    } = lazyTransfer().newCrossRealmReadableStream(\n      this\x2C\n      this[kState].transfer.port1);\n\n    this[kState].transfer.readable = readable;\n    this[kState].transfer.promise = promise;\n\n    setPromiseHandled(this[kState].transfer.promise);\n\n    return {\n      data: { port: this[kState].transfer.port2 }\x2C\n      deserializeInfo:\n        'internal/webstreams/writablestream:TransferredWritableStream'\n    };\n  }\n\n  [kTransferList]() {\n    const { port1\x2C port2 } = new MessageChannel();\n    this[kState].transfer.port1 = port1;\n    this[kState].transfer.port2 = port2;\n    return [ port2 ];\n  }\n\n  [kDeserialize]({ port }) {\n    const transfer = lazyTransfer();\n    setupWritableStreamDefaultControllerFromSink(\n      this\x2C\n      new transfer.CrossRealmTransformWritableSink(port)\x2C\n      1\x2C\n      () => 1);\n  }\n}\n\nObjectDefineProperties(WritableStream.prototype\x2C {\n  locked: kEnumerableProperty\x2C\n  abort: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  getWriter: kEnumerableProperty\x2C\n});\n\nfunction TransferredWritableStream() {\n  return makeTransferable(ReflectConstruct(\n    function() {\n      this[kType] = 'WritableStream';\n      this[kState] = {\n        close: createDeferredPromise()\x2C\n        closeRequest: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        inFlightWriteRequest: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        inFlightCloseRequest: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        pendingAbortRequest: {\n          abort: {\n            promise: undefined\x2C\n            resolve: undefined\x2C\n            reject: undefined\x2C\n          }\x2C\n          reason: undefined\x2C\n          wasAlreadyErroring: false\x2C\n        }\x2C\n        backpressure: false\x2C\n        controller: undefined\x2C\n        state: 'writable'\x2C\n        storedError: undefined\x2C\n        writeRequests: []\x2C\n        writer: undefined\x2C\n        transfer: {\n          promise: undefined\x2C\n          port1: undefined\x2C\n          port2: undefined\x2C\n          readable: undefined\x2C\n        }\x2C\n      };\n    }\x2C\n    []\x2C WritableStream));\n}\nTransferredWritableStream.prototype[kDeserialize] = () => {};\n\nclass WritableStreamDefaultWriter {\n  [kType] = 'WritableStreamDefaultWriter';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {WritableStream} stream\n   */\n  constructor(stream) {\n    if (!isWritableStream(stream))\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'WritableStream'\x2C stream);\n    this[kState] = {\n      stream: undefined\x2C\n      close: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      ready: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\n    };\n    setupWritableStreamDefaultWriter(this\x2C stream);\n  }\n\n  /**\n   * @readonly\n   * @type {Promise<void>}\n   */\n  get closed() {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    return this[kState].close.promise;\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get desiredSize() {\n    if (!isWritableStreamDefaultWriter(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultWriter');\n    if (this[kState].stream === undefined) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'Writer is not bound to a WritableStream');\n    }\n    return writableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  /**\n   * @readonly\n   * @type {Promise<void>}\n   */\n  get ready() {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    return this[kState].ready.promise;\n  }\n\n  /**\n   * @param {any} reason\n   * @returns {Promise<void>}\n   */\n  abort(reason = undefined) {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'Writer is not bound to a WritableStream'));\n    }\n    return writableStreamDefaultWriterAbort(this\x2C reason);\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  close() {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    const {\n      stream\x2C\n    } = this[kState];\n    if (stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'Writer is not bound to a WritableStream'));\n    }\n    if (writableStreamCloseQueuedOrInFlight(stream)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('Failure to close WritableStream'));\n    }\n    return writableStreamDefaultWriterClose(this);\n  }\n\n  releaseLock() {\n    if (!isWritableStreamDefaultWriter(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultWriter');\n    const {\n      stream\x2C\n    } = this[kState];\n    if (stream === undefined)\n      return;\n    assert(stream[kState].writer !== undefined);\n    writableStreamDefaultWriterRelease(this);\n  }\n\n  /**\n   * @param {any} chunk\n   * @returns {Promise<void>}\n   */\n  write(chunk = undefined) {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'Writer is not bound to a WritableStream'));\n    }\n    return writableStreamDefaultWriterWrite(this\x2C chunk);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      stream: this[kState].stream\x2C\n      close: this[kState].close.promise\x2C\n      ready: this[kState].ready.promise\x2C\n      desiredSize: this.desiredSize\x2C\n    });\n  }\n}\n\nObjectDefineProperties(WritableStreamDefaultWriter.prototype\x2C {\n  closed: kEnumerableProperty\x2C\n  ready: kEnumerableProperty\x2C\n  desiredSize: kEnumerableProperty\x2C\n  abort: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  releaseLock: kEnumerableProperty\x2C\n  write: kEnumerableProperty\x2C\n});\n\nclass WritableStreamDefaultController {\n  [kType] = 'WritableStreamDefaultController';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  [kAbort](reason) {\n    const result = this[kState].abortAlgorithm(reason);\n    writableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [kError]() {\n    resetQueue(this);\n  }\n\n  /**\n   * @type {any}\n   */\n  get abortReason() {\n    if (!isWritableStreamDefaultController(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultController');\n    return this[kState].abortReason;\n  }\n\n  /**\n   * @type {AbortSignal}\n   */\n  get signal() {\n    if (!isWritableStreamDefaultController(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultController');\n    return this[kState].abortController.signal;\n  }\n\n  /**\n   * @param {any} error\n   */\n  error(error = undefined) {\n    if (!isWritableStreamDefaultController(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultController');\n    if (this[kState].stream[kState].state !== 'writable')\n      return;\n    writableStreamDefaultControllerError(this\x2C error);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      stream: this[kState].stream\x2C\n    });\n  }\n}\n\nObjectDefineProperties(WritableStreamDefaultController.prototype\x2C {\n  abortReason: kEnumerableProperty\x2C\n  signal: kEnumerableProperty\x2C\n  error: kEnumerableProperty\x2C\n});\n\nfunction createWritableStreamDefaultController() {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'WritableStreamDefaultController';\n    }\x2C\n    []\x2C WritableStreamDefaultController);\n}\n\nconst isWritableStream =\n  isBrandCheck('WritableStream');\nconst isWritableStreamDefaultWriter =\n  isBrandCheck('WritableStreamDefaultWriter');\nconst isWritableStreamDefaultController =\n  isBrandCheck('WritableStreamDefaultController');\n\nfunction isWritableStreamLocked(stream) {\n  return stream[kState].writer !== undefined;\n}\n\nfunction setupWritableStreamDefaultWriter(writer\x2C stream) {\n  if (isWritableStreamLocked(stream))\n    throw new ERR_INVALID_STATE.TypeError('WritableStream is locked');\n  writer[kState].stream = stream;\n  stream[kState].writer = writer;\n  switch (stream[kState].state) {\n    case 'writable':\n      if (!writableStreamCloseQueuedOrInFlight(stream) &&\n          stream[kState].backpressure) {\n        writer[kState].ready = createDeferredPromise();\n      } else {\n        writer[kState].ready = {\n          promise: PromiseResolve()\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        };\n      }\n      setClosedPromiseToNewPromise();\n      break;\n    case 'erroring':\n      writer[kState].ready = {\n        promise: PromiseReject(stream[kState].storedError)\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      setPromiseHandled(writer[kState].ready.promise);\n      setClosedPromiseToNewPromise();\n      break;\n    case 'closed':\n      writer[kState].ready = {\n        promise: PromiseResolve()\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      writer[kState].close = {\n        promise: PromiseResolve()\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      break;\n    default:\n      writer[kState].ready = {\n        promise: PromiseReject(stream[kState].storedError)\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      writer[kState].close = {\n        promise: PromiseReject(stream[kState].storedError)\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      setPromiseHandled(writer[kState].ready.promise);\n      setPromiseHandled(writer[kState].close.promise);\n  }\n\n  function setClosedPromiseToNewPromise() {\n    writer[kState].close = createDeferredPromise();\n  }\n}\n\nfunction writableStreamAbort(stream\x2C reason) {\n  const {\n    state\x2C\n    controller\x2C\n  } = stream[kState];\n  if (state === 'closed' || state === 'errored')\n    return PromiseResolve();\n\n  controller[kState].abortReason = reason;\n  controller[kState].abortController.abort();\n\n  if (stream[kState].pendingAbortRequest.abort.promise !== undefined)\n    return stream[kState].pendingAbortRequest.abort.promise;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    reason = undefined;\n  }\n\n  const abort = createDeferredPromise();\n\n  stream[kState].pendingAbortRequest = {\n    abort\x2C\n    reason\x2C\n    wasAlreadyErroring\x2C\n  };\n\n  if (!wasAlreadyErroring)\n    writableStreamStartErroring(stream\x2C reason);\n\n  return abort.promise;\n}\n\nfunction writableStreamClose(stream) {\n  const {\n    state\x2C\n    writer\x2C\n    backpressure\x2C\n    controller\x2C\n  } = stream[kState];\n  if (state === 'closed' || state === 'errored') {\n    return PromiseReject(\n      new ERR_INVALID_STATE.TypeError('WritableStream is closed'));\n  }\n  assert(state === 'writable' || state === 'erroring');\n  assert(!writableStreamCloseQueuedOrInFlight(stream));\n  stream[kState].closeRequest = createDeferredPromise();\n  const { promise } = stream[kState].closeRequest;\n  if (writer !== undefined && backpressure && state === 'writable')\n    writer[kState].ready.resolve?.();\n  writableStreamDefaultControllerClose(controller);\n  return promise;\n}\n\nfunction writableStreamUpdateBackpressure(stream\x2C backpressure) {\n  assert(stream[kState].state === 'writable');\n  assert(!writableStreamCloseQueuedOrInFlight(stream));\n  const {\n    writer\x2C\n  } = stream[kState];\n  if (writer !== undefined && stream[kState].backpressure !== backpressure) {\n    if (backpressure) {\n      writer[kState].ready = createDeferredPromise();\n    } else {\n      writer[kState].ready.resolve?.();\n    }\n  }\n  stream[kState].backpressure = backpressure;\n}\n\nfunction writableStreamStartErroring(stream\x2C reason) {\n  assert(stream[kState].storedError === undefined);\n  assert(stream[kState].state === 'writable');\n  const {\n    controller\x2C\n    writer\x2C\n  } = stream[kState];\n  assert(controller !== undefined);\n  stream[kState].state = 'erroring';\n  stream[kState].storedError = reason;\n  if (writer !== undefined) {\n    writableStreamDefaultWriterEnsureReadyPromiseRejected(writer\x2C reason);\n  }\n  if (!writableStreamHasOperationMarkedInFlight(stream) &&\n      controller[kState].started) {\n    writableStreamFinishErroring(stream);\n  }\n}\n\nfunction writableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  assert(stream[kState].state === 'errored');\n  if (stream[kState].closeRequest.promise !== undefined) {\n    assert(stream[kState].inFlightCloseRequest.promise === undefined);\n    stream[kState].closeRequest.reject?.(stream[kState].storedError);\n    stream[kState].closeRequest = {\n      promise: undefined\x2C\n      reject: undefined\x2C\n      resolve: undefined\x2C\n    };\n  }\n  const {\n    writer\x2C\n  } = stream[kState];\n  if (writer !== undefined) {\n    writer[kState].close.reject?.(stream[kState].storedError);\n    setPromiseHandled(writer[kState].close.promise);\n  }\n}\n\nfunction writableStreamMarkFirstWriteRequestInFlight(stream) {\n  assert(stream[kState].inFlightWriteRequest.promise === undefined);\n  assert(stream[kState].writeRequests.length);\n  const writeRequest = ArrayPrototypeShift(stream[kState].writeRequests);\n  stream[kState].inFlightWriteRequest = writeRequest;\n}\n\nfunction writableStreamMarkCloseRequestInFlight(stream) {\n  assert(stream[kState].inFlightWriteRequest.promise === undefined);\n  assert(stream[kState].closeRequest.promise !== undefined);\n  stream[kState].inFlightCloseRequest = stream[kState].closeRequest;\n  stream[kState].closeRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n}\n\nfunction writableStreamHasOperationMarkedInFlight(stream) {\n  const {\n    inFlightWriteRequest\x2C\n    inFlightCloseRequest\x2C\n  } = stream[kState];\n  if (inFlightWriteRequest.promise === undefined &&\n      inFlightCloseRequest.promise === undefined) {\n    return false;\n  }\n  return true;\n}\n\nfunction writableStreamFinishInFlightWriteWithError(stream\x2C error) {\n  assert(stream[kState].inFlightWriteRequest.promise !== undefined);\n  stream[kState].inFlightWriteRequest.reject?.(error);\n  stream[kState].inFlightWriteRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n  assert(stream[kState].state === 'writable' ||\n         stream[kState].state === 'erroring');\n  writableStreamDealWithRejection(stream\x2C error);\n}\n\nfunction writableStreamFinishInFlightWrite(stream) {\n  assert(stream[kState].inFlightWriteRequest.promise !== undefined);\n  stream[kState].inFlightWriteRequest.resolve?.();\n  stream[kState].inFlightWriteRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n}\n\nfunction writableStreamFinishInFlightCloseWithError(stream\x2C error) {\n  assert(stream[kState].inFlightCloseRequest.promise !== undefined);\n  stream[kState].inFlightCloseRequest.reject?.(error);\n  stream[kState].inFlightCloseRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n  assert(stream[kState].state === 'writable' ||\n         stream[kState].state === 'erroring');\n  if (stream[kState].pendingAbortRequest.abort.promise !== undefined) {\n    stream[kState].pendingAbortRequest.abort.reject?.(error);\n    stream[kState].pendingAbortRequest = {\n      abort: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      reason: undefined\x2C\n      wasAlreadyErroring: false\x2C\n    };\n  }\n  writableStreamDealWithRejection(stream\x2C error);\n}\n\nfunction writableStreamFinishInFlightClose(stream) {\n  assert(stream[kState].inFlightCloseRequest.promise !== undefined);\n  stream[kState].inFlightCloseRequest.resolve?.();\n  stream[kState].inFlightCloseRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n  if (stream[kState].state === 'erroring') {\n    stream[kState].storedError = undefined;\n    if (stream[kState].pendingAbortRequest.abort.promise !== undefined) {\n      stream[kState].pendingAbortRequest.abort.resolve?.();\n      stream[kState].pendingAbortRequest = {\n        abort: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        reason: undefined\x2C\n        wasAlreadyErroring: false\x2C\n      };\n    }\n  }\n  stream[kState].state = 'closed';\n  if (stream[kState].writer !== undefined)\n    stream[kState].writer[kState].close.resolve?.();\n  assert(stream[kState].pendingAbortRequest.abort.promise === undefined);\n  assert(stream[kState].storedError === undefined);\n}\n\nfunction writableStreamFinishErroring(stream) {\n  assert(stream[kState].state === 'erroring');\n  assert(!writableStreamHasOperationMarkedInFlight(stream));\n  stream[kState].state = 'errored';\n  stream[kState].controller[kError]();\n  const storedError = stream[kState].storedError;\n  for (let n = 0; n < stream[kState].writeRequests.length; n++)\n    stream[kState].writeRequests[n].reject?.(storedError);\n  stream[kState].writeRequests = [];\n\n  if (stream[kState].pendingAbortRequest.abort.promise === undefined) {\n    writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream[kState].pendingAbortRequest;\n  stream[kState].pendingAbortRequest = {\n    abort: {\n      promise: undefined\x2C\n      resolve: undefined\x2C\n      reject: undefined\x2C\n    }\x2C\n    reason: undefined\x2C\n    wasAlreadyErroring: false\x2C\n  };\n  if (abortRequest.wasAlreadyErroring) {\n    abortRequest.abort.reject?.(storedError);\n    writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n  PromisePrototypeThen(\n    ensureIsPromise(\n      stream[kState].controller[kAbort]\x2C\n      stream[kState].controller\x2C\n      abortRequest.reason)\x2C\n    () => {\n      abortRequest.abort.resolve?.();\n      writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }\x2C\n    (error) => {\n      abortRequest.abort.reject?.(error);\n      writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\n\nfunction writableStreamDealWithRejection(stream\x2C error) {\n  const {\n    state\x2C\n  } = stream[kState];\n  if (state === 'writable') {\n    writableStreamStartErroring(stream\x2C error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  writableStreamFinishErroring(stream);\n}\n\nfunction writableStreamCloseQueuedOrInFlight(stream) {\n  if (stream[kState].closeRequest.promise === undefined &&\n      stream[kState].inFlightCloseRequest.promise === undefined) {\n    return false;\n  }\n  return true;\n}\n\nfunction writableStreamAddWriteRequest(stream) {\n  assert(isWritableStreamLocked(stream));\n  assert(stream[kState].state === 'writable');\n  const {\n    promise\x2C\n    resolve\x2C\n    reject\x2C\n  } = createDeferredPromise();\n  ArrayPrototypePush(\n    stream[kState].writeRequests\x2C\n    {\n      promise\x2C\n      resolve\x2C\n      reject\x2C\n    });\n  return promise;\n}\n\nfunction writableStreamDefaultWriterWrite(writer\x2C chunk) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  const {\n    controller\x2C\n  } = stream[kState];\n  const chunkSize = writableStreamDefaultControllerGetChunkSize(\n    controller\x2C\n    chunk);\n  if (stream !== writer[kState].stream) {\n    return PromiseReject(\n      new ERR_INVALID_STATE.TypeError('Mismatched WritableStreams'));\n  }\n  const {\n    state\x2C\n  } = stream[kState];\n\n  if (state === 'errored')\n    return PromiseReject(stream[kState].storedError);\n\n  if (writableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return PromiseReject(\n      new ERR_INVALID_STATE.TypeError('WritableStream is closed'));\n  }\n\n  if (state === 'erroring')\n    return PromiseReject(stream[kState].storedError);\n\n  assert(state === 'writable');\n\n  const promise = writableStreamAddWriteRequest(stream);\n  writableStreamDefaultControllerWrite(controller\x2C chunk\x2C chunkSize);\n  return promise;\n}\n\nfunction writableStreamDefaultWriterRelease(writer) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  assert(stream[kState].writer === writer);\n  const releasedError =\n    new ERR_INVALID_STATE.TypeError('Writer has been released');\n  writableStreamDefaultWriterEnsureReadyPromiseRejected(writer\x2C releasedError);\n  writableStreamDefaultWriterEnsureClosedPromiseRejected(writer\x2C releasedError);\n  stream[kState].writer = undefined;\n  writer[kState].stream = undefined;\n}\n\nfunction writableStreamDefaultWriterGetDesiredSize(writer) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  switch (stream[kState].state) {\n    case 'errored':\n      // Fall through\n    case 'erroring':\n      return null;\n    case 'closed':\n      return 0;\n  }\n  return writableStreamDefaultControllerGetDesiredSize(\n    stream[kState].controller);\n}\n\nfunction writableStreamDefaultWriterEnsureReadyPromiseRejected(writer\x2C error) {\n  if (isPromisePending(writer[kState].ready.promise)) {\n    writer[kState].ready.reject?.(error);\n  } else {\n    writer[kState].ready = {\n      promise: PromiseReject(error)\x2C\n      resolve: undefined\x2C\n      reject: undefined\x2C\n    };\n  }\n  setPromiseHandled(writer[kState].ready.promise);\n}\n\nfunction writableStreamDefaultWriterEnsureClosedPromiseRejected(writer\x2C error) {\n  if (isPromisePending(writer[kState].close.promise)) {\n    writer[kState].close.reject?.(error);\n  } else {\n    writer[kState].close = {\n      promise: PromiseReject(error)\x2C\n      resolve: undefined\x2C\n      reject: undefined\x2C\n    };\n  }\n  setPromiseHandled(writer[kState].close.promise);\n}\n\nfunction writableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  const {\n    state\x2C\n  } = stream[kState];\n  if (writableStreamCloseQueuedOrInFlight(stream) || state === 'closed')\n    return PromiseResolve();\n\n  if (state === 'errored')\n    return PromiseReject(stream[kState].storedError);\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return writableStreamDefaultWriterClose(writer);\n}\n\nfunction writableStreamDefaultWriterClose(writer) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  return writableStreamClose(stream);\n}\n\nfunction writableStreamDefaultWriterAbort(writer\x2C reason) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  return writableStreamAbort(stream\x2C reason);\n}\n\nfunction writableStreamDefaultControllerWrite(controller\x2C chunk\x2C chunkSize) {\n  try {\n    enqueueValueWithSize(controller\x2C chunk\x2C chunkSize);\n  } catch (error) {\n    writableStreamDefaultControllerErrorIfNeeded(controller\x2C error);\n    return;\n  }\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (!writableStreamCloseQueuedOrInFlight(stream) &&\n      stream[kState].state === 'writable') {\n    writableStreamUpdateBackpressure(\n      stream\x2C\n      writableStreamDefaultControllerGetBackpressure(controller));\n  }\n  writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction writableStreamDefaultControllerProcessWrite(controller\x2C chunk) {\n  const {\n    stream\x2C\n    writeAlgorithm\x2C\n  } = controller[kState];\n  writableStreamMarkFirstWriteRequestInFlight(stream);\n\n  PromisePrototypeThen(\n    ensureIsPromise(writeAlgorithm\x2C controller\x2C chunk\x2C controller)\x2C\n    () => {\n      writableStreamFinishInFlightWrite(stream);\n      const {\n        state\x2C\n      } = stream[kState];\n      assert(state === 'writable' || state === 'erroring');\n      dequeueValue(controller);\n      if (!writableStreamCloseQueuedOrInFlight(stream) &&\n          state === 'writable') {\n        writableStreamUpdateBackpressure(\n          stream\x2C\n          writableStreamDefaultControllerGetBackpressure(controller));\n      }\n      writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\x2C\n    (error) => {\n      if (stream[kState].state === 'writable')\n        writableStreamDefaultControllerClearAlgorithms(controller);\n      writableStreamFinishInFlightWriteWithError(stream\x2C error);\n    });\n\n}\n\nfunction writableStreamDefaultControllerProcessClose(controller) {\n  const {\n    closeAlgorithm\x2C\n    queue\x2C\n    stream\x2C\n  } = controller[kState];\n  writableStreamMarkCloseRequestInFlight(stream);\n  dequeueValue(controller);\n  assert(!queue.length);\n  const sinkClosePromise = ensureIsPromise(closeAlgorithm\x2C controller);\n  writableStreamDefaultControllerClearAlgorithms(controller);\n  PromisePrototypeThen(\n    sinkClosePromise\x2C\n    () => writableStreamFinishInFlightClose(stream)\x2C\n    (error) => writableStreamFinishInFlightCloseWithError(stream\x2C error));\n}\n\nfunction writableStreamDefaultControllerGetDesiredSize(controller) {\n  const {\n    highWaterMark\x2C\n    queueTotalSize\x2C\n  } = controller[kState];\n  return highWaterMark - queueTotalSize;\n}\n\nfunction writableStreamDefaultControllerGetChunkSize(controller\x2C chunk) {\n  try {\n    return FunctionPrototypeCall(\n      controller[kState].sizeAlgorithm\x2C\n      undefined\x2C\n      chunk);\n  } catch (error) {\n    writableStreamDefaultControllerErrorIfNeeded(controller\x2C error);\n    return 1;\n  }\n}\n\nfunction writableStreamDefaultControllerErrorIfNeeded(controller\x2C error) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (stream[kState].state === 'writable')\n    writableStreamDefaultControllerError(controller\x2C error);\n}\n\nfunction writableStreamDefaultControllerError(controller\x2C error) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  assert(stream[kState].state === 'writable');\n  writableStreamDefaultControllerClearAlgorithms(controller);\n  writableStreamStartErroring(stream\x2C error);\n}\n\nfunction writableStreamDefaultControllerClose(controller) {\n  enqueueValueWithSize(controller\x2C kCloseSentinel\x2C 0);\n  writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction writableStreamDefaultControllerClearAlgorithms(controller) {\n  controller[kState].writeAlgorithm = undefined;\n  controller[kState].closeAlgorithm = undefined;\n  controller[kState].abortAlgorithm = undefined;\n  controller[kState].sizeAlgorithm = undefined;\n}\n\nfunction writableStreamDefaultControllerGetBackpressure(controller) {\n  return writableStreamDefaultControllerGetDesiredSize(controller) <= 0;\n}\n\nfunction writableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  const {\n    queue\x2C\n    started\x2C\n    stream\x2C\n  } = controller[kState];\n  if (!started || stream[kState].inFlightWriteRequest.promise !== undefined)\n    return;\n\n  if (stream[kState].state === 'erroring') {\n    writableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (!queue.length)\n    return;\n\n  const value = peekQueueValue(controller);\n  if (value === kCloseSentinel)\n    writableStreamDefaultControllerProcessClose(controller);\n  else\n    writableStreamDefaultControllerProcessWrite(controller\x2C value);\n}\n\nfunction setupWritableStreamDefaultControllerFromSink(\n  stream\x2C\n  sink\x2C\n  highWaterMark\x2C\n  sizeAlgorithm) {\n  const controller = createWritableStreamDefaultController();\n  const start = sink?.start;\n  const write = sink?.write;\n  const close = sink?.close;\n  const abort = sink?.abort;\n  const startAlgorithm = start ?\n    FunctionPrototypeBind(start\x2C sink\x2C controller) :\n    nonOpStart;\n  const writeAlgorithm = write ?\n    FunctionPrototypeBind(write\x2C sink) :\n    nonOpWrite;\n  const closeAlgorithm = close ?\n    FunctionPrototypeBind(close\x2C sink) : nonOpCancel;\n  const abortAlgorithm = abort ?\n    FunctionPrototypeBind(abort\x2C sink) : nonOpCancel;\n  setupWritableStreamDefaultController(\n    stream\x2C\n    controller\x2C\n    startAlgorithm\x2C\n    writeAlgorithm\x2C\n    closeAlgorithm\x2C\n    abortAlgorithm\x2C\n    highWaterMark\x2C\n    sizeAlgorithm);\n}\n\nfunction setupWritableStreamDefaultController(\n  stream\x2C\n  controller\x2C\n  startAlgorithm\x2C\n  writeAlgorithm\x2C\n  closeAlgorithm\x2C\n  abortAlgorithm\x2C\n  highWaterMark\x2C\n  sizeAlgorithm) {\n  assert(isWritableStream(stream));\n  assert(stream[kState].controller === undefined);\n  controller[kState] = {\n    abortAlgorithm\x2C\n    abortReason: undefined\x2C\n    closeAlgorithm\x2C\n    highWaterMark\x2C\n    queue: []\x2C\n    queueTotalSize: 0\x2C\n    abortController: new AbortController()\x2C\n    sizeAlgorithm\x2C\n    started: false\x2C\n    stream\x2C\n    writeAlgorithm\x2C\n  };\n  stream[kState].controller = controller;\n\n  writableStreamUpdateBackpressure(\n    stream\x2C\n    writableStreamDefaultControllerGetBackpressure(controller));\n\n  const startResult = startAlgorithm();\n\n  PromisePrototypeThen(\n    PromiseResolve(startResult)\x2C\n    () => {\n      assert(stream[kState].state === 'writable' ||\n             stream[kState].state === 'erroring');\n      controller[kState].started = true;\n      writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\x2C\n    (error) => {\n      assert(stream[kState].state === 'writable' ||\n             stream[kState].state === 'erroring');\n      controller[kState].started = true;\n      writableStreamDealWithRejection(stream\x2C error);\n    });\n}\n\nmodule.exports = {\n  WritableStream\x2C\n  WritableStreamDefaultWriter\x2C\n  WritableStreamDefaultController\x2C\n  TransferredWritableStream\x2C\n\n  // Exported Brand Checks\n  isWritableStream\x2C\n  isWritableStreamDefaultController\x2C\n  isWritableStreamDefaultWriter\x2C\n\n  isWritableStreamLocked\x2C\n  setupWritableStreamDefaultWriter\x2C\n  writableStreamAbort\x2C\n  writableStreamClose\x2C\n  writableStreamUpdateBackpressure\x2C\n  writableStreamStartErroring\x2C\n  writableStreamRejectCloseAndClosedPromiseIfNeeded\x2C\n  writableStreamMarkFirstWriteRequestInFlight\x2C\n  writableStreamMarkCloseRequestInFlight\x2C\n  writableStreamHasOperationMarkedInFlight\x2C\n  writableStreamFinishInFlightWriteWithError\x2C\n  writableStreamFinishInFlightWrite\x2C\n  writableStreamFinishInFlightCloseWithError\x2C\n  writableStreamFinishInFlightClose\x2C\n  writableStreamFinishErroring\x2C\n  writableStreamDealWithRejection\x2C\n  writableStreamCloseQueuedOrInFlight\x2C\n  writableStreamAddWriteRequest\x2C\n  writableStreamDefaultWriterWrite\x2C\n  writableStreamDefaultWriterRelease\x2C\n  writableStreamDefaultWriterGetDesiredSize\x2C\n  writableStreamDefaultWriterEnsureReadyPromiseRejected\x2C\n  writableStreamDefaultWriterEnsureClosedPromiseRejected\x2C\n  writableStreamDefaultWriterCloseWithErrorPropagation\x2C\n  writableStreamDefaultWriterClose\x2C\n  writableStreamDefaultWriterAbort\x2C\n  writableStreamDefaultControllerWrite\x2C\n  writableStreamDefaultControllerProcessWrite\x2C\n  writableStreamDefaultControllerProcessClose\x2C\n  writableStreamDefaultControllerGetDesiredSize\x2C\n  writableStreamDefaultControllerGetChunkSize\x2C\n  writableStreamDefaultControllerErrorIfNeeded\x2C\n  writableStreamDefaultControllerError\x2C\n  writableStreamDefaultControllerClose\x2C\n  writableStreamDefaultControllerClearAlgorithms\x2C\n  writableStreamDefaultControllerGetBackpressure\x2C\n  writableStreamDefaultControllerAdvanceQueueIfNeeded\x2C\n  setupWritableStreamDefaultControllerFromSink\x2C\n  setupWritableStreamDefaultController\x2C\n};\n\n/* eslint-enable no-use-before-define */\n
code-source-info,0x120d443bec9e,127,0,36611,C0O0C4O36611,,
code-creation,Function,10,46042,0x26b72db02c5e,1564, node:internal/webstreams/writablestream:1:1,0x120d443bec18,~
code-source-info,0x26b72db02c5e,127,0,36611,C0O0C381O68C387O90C393O113C399O138C405O163C410O189C416O213C422O231C428O248C434O268C439O278C444O470C447O470C452O470C457O338C463O367C469O394C475O420C481O443C487O527C490O527C495O509C501O651C504O651C509O568C515O614C520O626C525O708C528O708C533O688C539O818C542O818C547O750C552O766C557O779C562O796C568O1166C571O1166C576O873C582O890C588O906C594O925C600O949C606O973C612O997C618O1013C623O1029C629O1049C635O1067C641O1081C647O1102C653O1117C659O1131C665O1145C671O1154C677O1235C680O1235C685O1214C691O1289C694O1289C698O1289C700O1333C703O1333C707O1333C709O1374C712O1374C716O1374C718O1415C721O1415C725O1415C745O2379C755O2414C787O5297C797O5457C807O6298C817O6480C851O2353C853O6695C856O6733C868O6756C874O6786C880O6816C886O6850C890O6695C895O8091C900O8101C904O8115C926O8167C936O8215C986O11501C1020O8128C1022O11754C1025O11805C1037O11828C1043O11858C1049O11894C1055O11924C1061O11954C1067O11990C1073O12020C1077O11754C1100O12089C1110O12141C1120O12254C1132O12413C1160O13209C1194O12046C1196O13343C1199O13398C1211O13426C1217O13457C1223O13487C1227O13343C1232O13742C1235O13742C1239O13742C1241O13814C1244O13814C1248O13814C1250O13903C1253O13903C1257O13903C1259O34686C1266O34707C1272O34725C1278O34756C1284O34791C1290O34848C1296O34868C1302O34905C1308O34939C1314O34965C1320O35001C1326O35024C1332O35047C1338O35083C1344O35114C1350O35167C1356O35214C1362O35256C1368O35300C1374O35346C1380O35383C1386O35429C1392O35466C1398O35498C1404O35533C1410O35572C1416O35605C1422O35641C1428O35679C1434O35724C1440O35781C1446O35839C1452O35895C1458O35931C1464O35967C1470O36007C1476O36054C1482O36101C1488O36150C1494O36197C1500O36245C1506O36285C1512O36325C1518O36375C1524O36425C1534O36480C1544O36528C1554O34701C1563O36610,,
code-creation,Function,10,46084,0x26b72db0355e,16,<instance_members_initializer> node:internal/webstreams/writablestream:493:3,0x26b72db015b8,~
code-source-info,0x26b72db0355e,127,12088,12131,C3O12098C15O12131,,
code-creation,Function,10,46084,0x26b72db035de,16,<instance_members_initializer> node:internal/webstreams/writablestream:349:3,0x26b72db012c0,~
code-source-info,0x26b72db035de,127,8166,8205,C3O8176C15O8205,,
code-creation,Function,10,46125,0x26b72db03656,16,<instance_members_initializer> node:internal/webstreams/writablestream:122:3,0x120d443bfd58,~
code-source-info,0x26b72db03656,127,2378,2404,C3O2388C15O2404,,
tick,0x1bfd3cab0,46125,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x120d443b3db9,0x105108d28,0x10510894c,0x120d443a82cf,0x105108d28,0x10510894c,0x120d4439f42a,0x105108d28,0x10510894c,0x120d4439b14d,0x105108d28,0x10510894c,0x120d4439a952,0x105108d28,0x10510894c,0x3172a1b32c9a,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,LazyCompile,10,46250,0x26b72db06cae,14,isBrandCheck node:internal/webstreams/util:112:22,0x120d443bbe40,~
code-source-info,0x26b72db06cae,126,2398,2541,C0O2398C9O2410C13O2539,,
code-creation,Eval,10,46459,0x26b72db07e1e,5, node:internal/webstreams/queuingstrategies:1:1,0x26b72db07b28,~
script-source,128,node:internal/webstreams/queuingstrategies,'use strict';\n\nconst {\n  ObjectDefineProperties\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_THIS\x2C\n    ERR_MISSING_OPTION\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\n\nconst {\n  customInspect\x2C\n  isBrandCheck\x2C\n  kType\x2C\n  kState\x2C\n} = require('internal/webstreams/util');\n\nconst {\n  validateObject\x2C\n} = require('internal/validators');\n\nconst isByteLengthQueuingStrategy =\n  isBrandCheck('ByteLengthQueuingStrategy');\n\nconst isCountQueuingStrategy =\n  isBrandCheck('CountQueuingStrategy');\n\n/**\n * @callback QueuingStrategySize\n * @param {any} chunk\n * @returns {number}\n */\n\n/**\n * @typedef {{\n *   highWaterMark : number\x2C\n *   size? : QueuingStrategySize\x2C\n * }} QueuingStrategy\n */\n\n// eslint-disable-next-line func-name-matching\x2Cfunc-style\nconst byteSizeFunction = function size(chunk) { return chunk.byteLength; };\n\n// eslint-disable-next-line func-name-matching\x2Cfunc-style\nconst countSizeFunction = function size() { return 1; };\n\n/**\n * @type {QueuingStrategy}\n */\nclass ByteLengthQueuingStrategy {\n  [kType] = 'ByteLengthQueuingStrategy';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {{\n   *   highWaterMark : number\n   * }} init\n   */\n  constructor(init) {\n    validateObject(init\x2C 'init');\n    if (init.highWaterMark === undefined)\n      throw new ERR_MISSING_OPTION('options.highWaterMark');\n\n    // The highWaterMark value is not checked until the strategy\n    // is actually used\x2C per the spec.\n    this[kState] = {\n      highWaterMark: +init.highWaterMark\x2C\n    };\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get highWaterMark() {\n    if (!isByteLengthQueuingStrategy(this))\n      throw new ERR_INVALID_THIS('ByteLengthQueuingStrategy');\n    return this[kState].highWaterMark;\n  }\n\n  /**\n   * @type {QueuingStrategySize}\n   */\n  get size() {\n    if (!isByteLengthQueuingStrategy(this))\n      throw new ERR_INVALID_THIS('ByteLengthQueuingStrategy');\n    return byteSizeFunction;\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      highWaterMark: this.highWaterMark\x2C\n    });\n  }\n}\n\nObjectDefineProperties(ByteLengthQueuingStrategy.prototype\x2C {\n  highWaterMark: kEnumerableProperty\x2C\n  size: kEnumerableProperty\x2C\n});\n\n/**\n * @type {QueuingStrategy}\n */\nclass CountQueuingStrategy {\n  [kType] = 'CountQueuingStrategy';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {{\n   *   highWaterMark : number\n   * }} init\n   */\n  constructor(init) {\n    validateObject(init\x2C 'init');\n    if (init.highWaterMark === undefined)\n      throw new ERR_MISSING_OPTION('options.highWaterMark');\n\n    // The highWaterMark value is not checked until the strategy\n    // is actually used\x2C per the spec.\n    this[kState] = {\n      highWaterMark: +init.highWaterMark\x2C\n    };\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get highWaterMark() {\n    if (!isCountQueuingStrategy(this))\n      throw new ERR_INVALID_THIS('CountQueuingStrategy');\n    return this[kState].highWaterMark;\n  }\n\n  /**\n   * @type {QueuingStrategySize}\n   */\n  get size() {\n    if (!isCountQueuingStrategy(this))\n      throw new ERR_INVALID_THIS('CountQueuingStrategy');\n    return countSizeFunction;\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      highWaterMark: this.highWaterMark\x2C\n    });\n  }\n}\n\nObjectDefineProperties(CountQueuingStrategy.prototype\x2C {\n  highWaterMark: kEnumerableProperty\x2C\n  size: kEnumerableProperty\x2C\n});\n\nmodule.exports = {\n  ByteLengthQueuingStrategy\x2C\n  CountQueuingStrategy\x2C\n};\n
code-source-info,0x26b72db07e1e,128,0,3637,C0O0C4O3637,,
code-creation,Function,10,46625,0x26b72db08b16,404, node:internal/webstreams/queuingstrategies:1:1,0x26b72db07d98,~
code-source-info,0x26b72db08b16,128,0,3637,C0O0C35O25C40O51C45O162C48O162C53O162C58O111C64O133C70O259C73O259C78O222C83O234C88O350C91O350C96O296C102O313C107O329C113O338C119O418C122O418C127O398C133O489C136O489C140O489C142O566C145O566C149O566C151O882C155O882C157O1018C161O1018C180O1122C190O1168C209O2049C244O2238C256O2268C262O2297C266O2189C288O2390C298O2431C317O3293C352O3477C364O3507C370O3536C374O3433C379O3562C386O3583C392O3612C398O3577C403O3636,,
code-creation,Function,10,46625,0x26b72db08dce,16,<instance_members_initializer> node:internal/webstreams/queuingstrategies:116:3,0x26b72db082c8,~
code-source-info,0x26b72db08dce,128,2389,2421,C3O2399C15O2421,,
code-creation,Function,10,46625,0x26b72db08e46,16,<instance_members_initializer> node:internal/webstreams/queuingstrategies:60:3,0x26b72db080c0,~
code-source-info,0x26b72db08e46,128,1121,1158,C3O1131C15O1158,,
code-creation,LazyCompile,10,46750,0x26b72db0997e,251,promisify node:internal/util:324:19,0x232faba02318,~
script-source,16,node:internal/util,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_NO_CRYPTO\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\x2C\n  uvErrmapGet\x2C\n  overrideStackTrace\x2C\n} = require('internal/errors');\nconst { signals } = internalBinding('constants').os;\nconst {\n  getHiddenValue\x2C\n  setHiddenValue\x2C\n  arrow_message_private_symbol: kArrowMessagePrivateSymbolIndex\x2C\n  decorated_private_symbol: kDecoratedPrivateSymbolIndex\x2C\n  sleep: _sleep\x2C\n  toUSVString: _toUSVString\x2C\n} = internalBinding('util');\nconst { isNativeError } = internalBinding('types');\n\nconst noCrypto = !process.versions.openssl;\n\nconst experimentalWarnings = new SafeSet();\n\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\n\nconst unpairedSurrogateRe =\n  /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5\x2C `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = RegExpPrototypeExec(unpairedSurrogateRe\x2C str);\n  if (!match)\n    return str;\n  return _toUSVString(str\x2C match.index);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  uvBinding ??= internalBinding('uv');\n  return uvBinding;\n}\n\nfunction removeColors(str) {\n  return StringPrototypeReplace(str\x2C colorRegExp\x2C '');\n}\n\nfunction isError(e) {\n  // An error could be an instance of Error while not being a native error\n  // or could be from a different realm and not be instance of Error but still\n  // be a native error.\n  return isNativeError(e) || e instanceof Error;\n}\n\n// Keep a list of deprecation codes that have been warned on so we only warn on\n// each one once.\nconst codesWarned = new SafeSet();\n\nlet validateString;\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set\x2C then it is a no-op.\nfunction deprecate(fn\x2C msg\x2C code) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Lazy-load to avoid a circular dependency.\n  if (validateString === undefined)\n    ({ validateString } = require('internal/validators'));\n\n  if (code !== undefined)\n    validateString(code\x2C 'code');\n\n  let warned = false;\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true;\n      if (code !== undefined) {\n        if (!codesWarned.has(code)) {\n          process.emitWarning(msg\x2C 'DeprecationWarning'\x2C code\x2C deprecated);\n          codesWarned.add(code);\n        }\n      } else {\n        process.emitWarning(msg\x2C 'DeprecationWarning'\x2C deprecated);\n      }\n    }\n    if (new.target) {\n      return ReflectConstruct(fn\x2C args\x2C new.target);\n    }\n    return ReflectApply(fn\x2C this\x2C args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  ObjectSetPrototypeOf(deprecated\x2C fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype\x2C as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) ||\n      getHiddenValue(err\x2C kDecoratedPrivateSymbolIndex) === true)\n    return;\n\n  const arrow = getHiddenValue(err\x2C kArrowMessagePrivateSymbolIndex);\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    setHiddenValue(err\x2C kDecoratedPrivateSymbolIndex\x2C true);\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new ERR_NO_CRYPTO();\n}\n\n// Return undefined if there is no match.\n// Move the "slow cases" to a separate function to make sure this function gets\n// inlined properly. That prioritizes the common case.\nfunction normalizeEncoding(enc) {\n  if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';\n  return slowCases(enc);\n}\n\nfunction slowCases(enc) {\n  switch (enc.length) {\n    case 4:\n      if (enc === 'UTF8') return 'utf8';\n      if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf8') return 'utf8';\n      if (enc === 'ucs2') return 'utf16le';\n      break;\n    case 3:\n      if (enc === 'hex' || enc === 'HEX' ||\n          `${enc}`.toLowerCase() === 'hex')\n        return 'hex';\n      break;\n    case 5:\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      if (enc === 'UTF-8') return 'utf8';\n      if (enc === 'ASCII') return 'ascii';\n      if (enc === 'UCS-2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf-8') return 'utf8';\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      break;\n    case 6:\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      if (enc === 'BASE64') return 'base64';\n      if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      break;\n    case 7:\n      if (enc === 'utf16le' || enc === 'UTF16LE' ||\n          `${enc}`.toLowerCase() === 'utf16le')\n        return 'utf16le';\n      break;\n    case 8:\n      if (enc === 'utf-16le' || enc === 'UTF-16LE' ||\n        `${enc}`.toLowerCase() === 'utf-16le')\n        return 'utf16le';\n      break;\n    case 9:\n      if (enc === 'base64url' || enc === 'BASE64URL' ||\n          `${enc}`.toLowerCase() === 'base64url')\n        return 'base64url';\n      break;\n    default:\n      if (enc === '') return 'utf8';\n  }\n}\n\nfunction emitExperimentalWarning(feature) {\n  if (experimentalWarnings.has(feature)) return;\n  const msg = `${feature} is an experimental feature. This feature could ` +\n       'change at any time';\n  experimentalWarnings.add(feature);\n  process.emitWarning(msg\x2C 'ExperimentalWarning');\n}\n\nfunction filterDuplicateStrings(items\x2C low) {\n  const map = new SafeMap();\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = StringPrototypeToLowerCase(item);\n    if (low) {\n      map.set(key\x2C key);\n    } else {\n      map.set(key\x2C item);\n    }\n  }\n  return ArrayPrototypeSort(ArrayFrom(map.values()));\n}\n\nfunction cachedResult(fn) {\n  let result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return ArrayPrototypeSlice(result);\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return ReflectConstruct(type\x2C args\x2C new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  ObjectDefineProperties(fn\x2C {\n    name: { value: type.name }\x2C\n    length: { value: type.length }\n  });\n  ObjectSetPrototypeOf(fn\x2C type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[StringPrototypeToUpperCase(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nfunction getSystemErrorName(err) {\n  const entry = uvErrmapGet(err);\n  return entry ? entry[0] : `Unknown system error ${err}`;\n}\n\nfunction getSystemErrorMap() {\n  return lazyUv().getErrorMap();\n}\n\nconst kCustomPromisifiedSymbol = SymbolFor('nodejs.util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nlet validateFunction;\n\nfunction promisify(original) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateFunction === undefined)\n    ({ validateFunction } = require('internal/validators'));\n\n  validateFunction(original\x2C 'original');\n\n  if (original[kCustomPromisifiedSymbol]) {\n    const fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn\x2C 'util.promisify.custom');\n\n    return ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n      value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments\x2C e.g. ['bytesRead'\x2C 'buffer'] for fs.read.\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve\x2C reject) => {\n      ArrayPrototypePush(args\x2C (err\x2C ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (let i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original\x2C this\x2C args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn\x2C ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n    value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n  });\n  return ObjectDefineProperties(\n    fn\x2C\n    ObjectGetOwnPropertyDescriptors(original)\n  );\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// The built-in Array#join is slower in v8 6.0\nfunction join(output\x2C separator) {\n  let str = '';\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      // It is faster not to use a template string here\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\n\n// As of V8 6.6\x2C depending on the size of the array\x2C this is anywhere\n// between 1.5-10x faster than the two-arg version of Array#splice()\nfunction spliceOne(list\x2C index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\n\nlet getStructuredStack;\n\nfunction isInsideNodeModules() {\n  if (getStructuredStack === undefined) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    // Use `runInNewContext()` to get something tamper-proof and\n    // side-effect-free. Since this is currently only used for a deprecated API\x2C\n    // the perf implications should be okay.\n    getStructuredStack = runInNewContext(`(function() {\n      try { Error.stackTraceLimit = Infinity; } catch {}\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e\x2C (err\x2C trace) => trace);\n        return e.stack;\n      };\n    })()`\x2C { overrideStackTrace }\x2C { filename: 'structured-stack' });\n  }\n\n  const stack = getStructuredStack();\n\n  // Iterate over all stack frames and look for the first one not coming\n  // from inside Node.js itself:\n  if (ArrayIsArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      // If a filename does not start with / or contain \\\x2C\n      // it's likely from Node.js core.\n      if (!RegExpPrototypeTest(/^\\/|\\\\/\x2C filename))\n        continue;\n      return RegExpPrototypeTest(kNodeModulesRE\x2C filename);\n    }\n  }\n  return false;\n}\n\nfunction once(callback) {\n  let called = false;\n  return function(...args) {\n    if (called) return;\n    called = true;\n    ReflectApply(callback\x2C this\x2C args);\n  };\n}\n\nlet validateUint32;\n\nfunction sleep(msec) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateUint32 === undefined)\n    ({ validateUint32 } = require('internal/validators'));\n\n  validateUint32(msec\x2C 'msec');\n  _sleep(msec);\n}\n\nfunction createDeferredPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res\x2C rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise\x2C resolve\x2C reject };\n}\n\nlet _DOMException;\nconst lazyDOMExceptionClass = () => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return _DOMException;\n};\n\nconst lazyDOMException = hideStackFrames((message\x2C name) => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return new _DOMException(message\x2C name);\n});\n\nconst kEnumerableProperty = ObjectCreate(null);\nkEnumerableProperty.enumerable = true;\n\nmodule.exports = {\n  assertCrypto\x2C\n  cachedResult\x2C\n  convertToValidSignal\x2C\n  createClassWrapper\x2C\n  createDeferredPromise\x2C\n  decorateErrorStack\x2C\n  deprecate\x2C\n  emitExperimentalWarning\x2C\n  filterDuplicateStrings\x2C\n  getConstructorOf\x2C\n  getSystemErrorMap\x2C\n  getSystemErrorName\x2C\n  isError\x2C\n  isInsideNodeModules\x2C\n  join\x2C\n  lazyDOMException\x2C\n  lazyDOMExceptionClass\x2C\n  normalizeEncoding\x2C\n  once\x2C\n  promisify\x2C\n  sleep\x2C\n  spliceOne\x2C\n  toUSVString\x2C\n  removeColors\x2C\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: SymbolFor('nodejs.util.inspect.custom')\x2C\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation\x2C just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('kIsEncodingSymbol')\x2C\n  kVmBreakFirstLineSymbol: Symbol('kVmBreakFirstLineSymbol')\x2C\n\n  kEnumerableProperty\x2C\n};\n
code-source-info,0x26b72db0997e,16,8845,10349,C0O8845C17O8907C25O8947C33O8971C38O8950C55O9007C68O9007C73O9050C80O9063C82O9062C87O9107C94O9116C96O9115C100O9148C110O9148C115O9200C126O9232C136O9273C143O9207C148O9339C149O9502C156O9511C158O9510C161O9502C163O10066C174O10091C180O10091C185O10066C190O10127C201O10152C211O10191C218O10127C223O10258C234O10301C240O10301C245O10265C250O10347,,
tick,0x1bfc3b8b4,47292,0,0x0,3,0x0,0x120d4439f44a,0x105108d28,0x10510894c,0x120d4439b14d,0x105108d28,0x10510894c,0x120d4439a952,0x105108d28,0x10510894c,0x3172a1b32c9a,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,LazyCompile,10,47375,0x26b72db0b2f6,65,EventEmitterMixin node:internal/event_target:962:27,0x174551eccf28,~
script-source,44,node:internal/event_target,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  Boolean\x2C\n  Error\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ReflectApply\x2C\n  SafeArrayIterator\x2C\n  SafeFinalizationRegistry\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SafeWeakSet\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_EVENT_RECURSION\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_INVALID_THIS\x2C\n  }\n} = require('internal/errors');\nconst { validateObject\x2C validateString } = require('internal/validators');\n\nconst { customInspectSymbol\x2C kEnumerableProperty } = require('internal/util');\nconst { inspect } = require('util');\n\nconst kIsEventTarget = SymbolFor('nodejs.event_target');\nconst kIsNodeEventTarget = Symbol('kIsNodeEventTarget');\n\nconst EventEmitter = require('events');\nconst {\n  kMaxEventTargetListeners\x2C\n  kMaxEventTargetListenersWarned\x2C\n} = EventEmitter;\n\nconst kEvents = Symbol('kEvents');\nconst kIsBeingDispatched = Symbol('kIsBeingDispatched');\nconst kStop = Symbol('kStop');\nconst kTarget = Symbol('kTarget');\nconst kHandlers = Symbol('khandlers');\nconst kWeakHandler = Symbol('kWeak');\n\nconst kHybridDispatch = SymbolFor('nodejs.internal.kHybridDispatch');\nconst kCreateEvent = Symbol('kCreateEvent');\nconst kNewListener = Symbol('kNewListener');\nconst kRemoveListener = Symbol('kRemoveListener');\nconst kIsNodeStyleListener = Symbol('kIsNodeStyleListener');\nconst kTrustEvent = Symbol('kTrustEvent');\n\nconst { now } = require('internal/perf/utils');\n\n// TODO(joyeecheung): V8 snapshot does not support instance member\n// initializers for now:\n// https://bugs.chromium.org/p/v8/issues/detail?id=10704\nconst kType = Symbol('type');\nconst kDefaultPrevented = Symbol('defaultPrevented');\nconst kCancelable = Symbol('cancelable');\nconst kTimestamp = Symbol('timestamp');\nconst kBubbles = Symbol('bubbles');\nconst kComposed = Symbol('composed');\nconst kPropagationStopped = Symbol('propagationStopped');\n\nconst isTrustedSet = new SafeWeakSet();\nconst isTrusted = ObjectGetOwnPropertyDescriptor({\n  get isTrusted() {\n    return isTrustedSet.has(this);\n  }\n}\x2C 'isTrusted').get;\n\nfunction isEvent(value) {\n  return typeof value?.[kType] === 'string';\n}\n\nclass Event {\n  /**\n   * @param {string} type\n   * @param {{\n   *   bubbles?: boolean\x2C\n   *   cancelable?: boolean\x2C\n   *   composed?: boolean\x2C\n   * }} [options]\n   */\n  constructor(type\x2C options = null) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    validateObject(options\x2C 'options'\x2C {\n      allowArray: true\x2C allowFunction: true\x2C nullable: true\x2C\n    });\n    const { cancelable\x2C bubbles\x2C composed } = { ...options };\n    this[kCancelable] = !!cancelable;\n    this[kBubbles] = !!bubbles;\n    this[kComposed] = !!composed;\n    this[kType] = `${type}`;\n    this[kDefaultPrevented] = false;\n    this[kTimestamp] = now();\n    this[kPropagationStopped] = false;\n    if (options?.[kTrustEvent]) {\n      isTrustedSet.add(this);\n    }\n\n    // isTrusted is special (LegacyUnforgeable)\n    ObjectDefineProperty(this\x2C 'isTrusted'\x2C {\n      get: isTrusted\x2C\n      enumerable: true\x2C\n      configurable: false\n    });\n    this[kTarget] = null;\n    this[kIsBeingDispatched] = false;\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({\n      type: this[kType]\x2C\n      defaultPrevented: this[kDefaultPrevented]\x2C\n      cancelable: this[kCancelable]\x2C\n      timeStamp: this[kTimestamp]\x2C\n    }\x2C opts)}`;\n  }\n\n  stopImmediatePropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kStop] = true;\n  }\n\n  preventDefault() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kDefaultPrevented] = true;\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get target() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get currentTarget() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get srcElement() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {string}\n   */\n  get type() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kType];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get cancelable() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kCancelable];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get defaultPrevented() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kCancelable] && this[kDefaultPrevented];\n  }\n\n  /**\n   * @type {number}\n   */\n  get timeStamp() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTimestamp];\n  }\n\n\n  // The following are non-op and unused properties/methods from Web API Event.\n  // These are not supported in Node.js and are provided purely for\n  // API completeness.\n  /**\n   * @returns {EventTarget[]}\n   */\n  composedPath() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? [this[kTarget]] : [];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get returnValue() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return !this.defaultPrevented;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get bubbles() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kBubbles];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get composed() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kComposed];\n  }\n\n  /**\n   * @type {number}\n   */\n  get eventPhase() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get cancelBubble() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kPropagationStopped];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  set cancelBubble(value) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    if (value) {\n      this.stopPropagation();\n    }\n  }\n\n  stopPropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kPropagationStopped] = true;\n  }\n\n  static NONE = 0;\n  static CAPTURING_PHASE = 1;\n  static AT_TARGET = 2;\n  static BUBBLING_PHASE = 3;\n}\n\nObjectDefineProperties(\n  Event.prototype\x2C {\n    [SymbolToStringTag]: {\n      writable: false\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: 'Event'\x2C\n    }\x2C\n    stopImmediatePropagation: kEnumerableProperty\x2C\n    preventDefault: kEnumerableProperty\x2C\n    target: kEnumerableProperty\x2C\n    currentTarget: kEnumerableProperty\x2C\n    srcElement: kEnumerableProperty\x2C\n    type: kEnumerableProperty\x2C\n    cancelable: kEnumerableProperty\x2C\n    defaultPrevented: kEnumerableProperty\x2C\n    timeStamp: kEnumerableProperty\x2C\n    composedPath: kEnumerableProperty\x2C\n    returnValue: kEnumerableProperty\x2C\n    bubbles: kEnumerableProperty\x2C\n    composed: kEnumerableProperty\x2C\n    eventPhase: kEnumerableProperty\x2C\n    cancelBubble: kEnumerableProperty\x2C\n    stopPropagation: kEnumerableProperty\x2C\n  });\n\nclass NodeCustomEvent extends Event {\n  constructor(type\x2C options) {\n    super(type\x2C options);\n    if (options?.detail) {\n      this.detail = options.detail;\n    }\n  }\n}\n\n// Weak listener cleanup\n// This has to be lazy for snapshots to work\nlet weakListenersState = null;\n// The resource needs to retain the callback so that it doesn't\n// get garbage collected now that it's weak.\nlet objectToWeakListenerMap = null;\nfunction weakListeners() {\n  weakListenersState ??= new SafeFinalizationRegistry(\n    (listener) => listener.remove()\n  );\n  objectToWeakListenerMap ??= new SafeWeakMap();\n  return { registry: weakListenersState\x2C map: objectToWeakListenerMap };\n}\n\n// The listeners for an EventTarget are maintained as a linked list.\n// Unfortunately\x2C the way EventTarget is defined\x2C listeners are accounted\n// using the tuple [handler\x2Ccapture]\x2C and even if we don't actually make\n// use of capture or bubbling\x2C in order to be spec compliant we have to\n// take on the additional complexity of supporting it. Fortunately\x2C using\n// the linked list makes dispatching faster\x2C even if adding/removing is\n// slower.\nclass Listener {\n  constructor(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n              isNodeStyleListener\x2C weak) {\n    this.next = undefined;\n    if (previous !== undefined)\n      previous.next = this;\n    this.previous = previous;\n    this.listener = listener;\n    // TODO(benjamingr) these 4 can be 'flags' to save 3 slots\n    this.once = once;\n    this.capture = capture;\n    this.passive = passive;\n    this.isNodeStyleListener = isNodeStyleListener;\n    this.removed = false;\n    this.weak = Boolean(weak); // Don't retain the object\n\n    if (this.weak) {\n      this.callback = new SafeWeakRef(listener);\n      weakListeners().registry.register(listener\x2C this\x2C this);\n      // Make the retainer retain the listener in a WeakMap\n      weakListeners().map.set(weak\x2C listener);\n      this.listener = this.callback;\n    } else if (typeof listener === 'function') {\n      this.callback = listener;\n      this.listener = listener;\n    } else {\n      this.callback = FunctionPrototypeBind(listener.handleEvent\x2C listener);\n      this.listener = listener;\n    }\n  }\n\n  same(listener\x2C capture) {\n    const myListener = this.weak ? this.listener.deref() : this.listener;\n    return myListener === listener && this.capture === capture;\n  }\n\n  remove() {\n    if (this.previous !== undefined)\n      this.previous.next = this.next;\n    if (this.next !== undefined)\n      this.next.previous = this.previous;\n    this.removed = true;\n    if (this.weak)\n      weakListeners().registry.unregister(this);\n  }\n}\n\nfunction initEventTarget(self) {\n  self[kEvents] = new SafeMap();\n  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\n  self[kMaxEventTargetListenersWarned] = false;\n}\n\nclass EventTarget {\n  // Used in checking whether an object is an EventTarget. This is a well-known\n  // symbol as EventTarget may be used cross-realm.\n  // Ref: https://github.com/nodejs/node/pull/33661\n  static [kIsEventTarget] = true;\n\n  constructor() {\n    initEventTarget(this);\n  }\n\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak) {\n    if (this[kMaxEventTargetListeners] > 0 &&\n        size > this[kMaxEventTargetListeners] &&\n        !this[kMaxEventTargetListenersWarned]) {\n      this[kMaxEventTargetListenersWarned] = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventTarget memory leak detected. ' +\n                          `${size} ${type} listeners ` +\n                          `added to ${inspect(this\x2C { depth: -1 })}. Use ` +\n                          'events.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.target = this;\n      w.type = type;\n      w.count = size;\n      process.emitWarning(w);\n    }\n  }\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {}\n\n  /**\n   * @callback EventTargetCallback\n   * @param {Event} event\n   */\n\n  /**\n   * @typedef {{ handleEvent: EventTargetCallback }} EventListener\n   */\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   *   once?: boolean\x2C\n   *   passive?: boolean\x2C\n   *   signal?: AbortSignal\n   * }} [options]\n   */\n  addEventListener(type\x2C listener\x2C options = {}) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n\n    // We validateOptions before the shouldAddListeners check because the spec\n    // requires us to hit getters.\n    const {\n      once\x2C\n      capture\x2C\n      passive\x2C\n      signal\x2C\n      isNodeStyleListener\x2C\n      weak\x2C\n    } = validateEventListenerOptions(options);\n\n    if (!shouldAddListener(listener)) {\n      // The DOM silently allows passing undefined as a second argument\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error(`addEventListener called with ${listener}` +\n                          ' which has no effect.');\n      w.name = 'AddEventListenerArgumentTypeWarning';\n      w.target = this;\n      w.type = type;\n      process.emitWarning(w);\n      return;\n    }\n    type = String(type);\n\n    if (signal) {\n      if (signal.aborted) {\n        return;\n      }\n      // TODO(benjamingr) make this weak somehow? ideally the signal would\n      // not prevent the event target from GC.\n      signal.addEventListener('abort'\x2C () => {\n        this.removeEventListener(type\x2C listener\x2C options);\n      }\x2C { once: true\x2C [kWeakHandler]: this });\n    }\n\n    let root = this[kEvents].get(type);\n\n    if (root === undefined) {\n      root = { size: 1\x2C next: undefined };\n      // This is the first handler in our linked list.\n      new Listener(root\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                   isNodeStyleListener\x2C weak);\n      this[kNewListener](\n        root.size\x2C\n        type\x2C\n        listener\x2C\n        once\x2C\n        capture\x2C\n        passive\x2C\n        weak);\n      this[kEvents].set(type\x2C root);\n      return;\n    }\n\n    let handler = root.next;\n    let previous = root;\n\n    // We have to walk the linked list to see if we have a match\n    while (handler !== undefined && !handler.same(listener\x2C capture)) {\n      previous = handler;\n      handler = handler.next;\n    }\n\n    if (handler !== undefined) { // Duplicate! Ignore\n      return;\n    }\n\n    new Listener(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                 isNodeStyleListener\x2C weak);\n    root.size++;\n    this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak);\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   */\n  removeEventListener(type\x2C listener\x2C options = {}) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (!shouldAddListener(listener))\n      return;\n\n    type = String(type);\n    const capture = options?.capture === true;\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return;\n\n    let handler = root.next;\n    while (handler !== undefined) {\n      if (handler.same(listener\x2C capture)) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n\n  /**\n   * @param {Event} event\n   */\n  dispatchEvent(event) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n\n    if (!(event instanceof Event))\n      throw new ERR_INVALID_ARG_TYPE('event'\x2C 'Event'\x2C event);\n\n    if (event[kIsBeingDispatched])\n      throw new ERR_EVENT_RECURSION(event.type);\n\n    this[kHybridDispatch](event\x2C event.type\x2C event);\n\n    return event.defaultPrevented !== true;\n  }\n\n  [kHybridDispatch](nodeValue\x2C type\x2C event) {\n    const createEvent = () => {\n      if (event === undefined) {\n        event = this[kCreateEvent](nodeValue\x2C type);\n        event[kTarget] = this;\n        event[kIsBeingDispatched] = true;\n      }\n      return event;\n    };\n    if (event !== undefined) {\n      event[kTarget] = this;\n      event[kIsBeingDispatched] = true;\n    }\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined) {\n      if (event !== undefined)\n        event[kIsBeingDispatched] = false;\n      return true;\n    }\n\n    let handler = root.next;\n    let next;\n\n    while (handler !== undefined &&\n           (handler.passive || event?.[kStop] !== true)) {\n      // Cache the next item in case this iteration removes the current one\n      next = handler.next;\n\n      if (handler.removed) {\n        // Deal with the case an event is removed while event handlers are\n        // Being processed (removeEventListener called from a listener)\n        handler = next;\n        continue;\n      }\n      if (handler.once) {\n        handler.remove();\n        root.size--;\n        const { listener\x2C capture } = handler;\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n      }\n\n      try {\n        let arg;\n        if (handler.isNodeStyleListener) {\n          arg = nodeValue;\n        } else {\n          arg = createEvent();\n        }\n        const callback = handler.weak ?\n          handler.callback.deref() : handler.callback;\n        let result;\n        if (callback) {\n          result = FunctionPrototypeCall(callback\x2C this\x2C arg);\n          if (!handler.isNodeStyleListener) {\n            arg[kIsBeingDispatched] = false;\n          }\n        }\n        if (result !== undefined && result !== null)\n          addCatch(result);\n      } catch (err) {\n        emitUncaughtException(err);\n      }\n\n      handler = next;\n    }\n\n    if (event !== undefined)\n      event[kIsBeingDispatched] = false;\n  }\n\n  [kCreateEvent](nodeValue\x2C type) {\n    return new NodeCustomEvent(type\x2C { detail: nodeValue });\n  }\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({}\x2C opts)}`;\n  }\n}\n\nObjectDefineProperties(EventTarget.prototype\x2C {\n  addEventListener: kEnumerableProperty\x2C\n  removeEventListener: kEnumerableProperty\x2C\n  dispatchEvent: kEnumerableProperty\x2C\n  [SymbolToStringTag]: {\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'EventTarget'\x2C\n  }\n});\n\nfunction initNodeEventTarget(self) {\n  initEventTarget(self);\n}\n\nclass NodeEventTarget extends EventTarget {\n  static [kIsNodeEventTarget] = true;\n  static defaultMaxListeners = 10;\n\n  constructor() {\n    super();\n    initNodeEventTarget(this);\n  }\n\n  /**\n   * @param {number} n\n   */\n  setMaxListeners(n) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    EventEmitter.setMaxListeners(n\x2C this);\n  }\n\n  /**\n   * @returns {number}\n   */\n  getMaxListeners() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return this[kMaxEventTargetListeners];\n  }\n\n  /**\n   * @returns {string[]}\n   */\n  eventNames() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return ArrayFrom(this[kEvents].keys());\n  }\n\n  /**\n   * @param {string} [type]\n   * @returns {number}\n   */\n  listenerCount(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    const root = this[kEvents].get(String(type));\n    return root !== undefined ? root.size : 0;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   * @returns {NodeEventTarget}\n   */\n  off(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   * @returns {NodeEventTarget}\n   */\n  removeListener(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  on(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  addListener(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {any} arg\n   * @returns {boolean}\n   */\n  emit(type\x2C arg) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    validateString(type\x2C 'type');\n    const hadListeners = this.listenerCount(type) > 0;\n    this[kHybridDispatch](arg\x2C type);\n    return hadListeners;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  once(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C\n                          { once: true\x2C [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @returns {NodeEventTarget}\n   */\n  removeAllListeners(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    if (type !== undefined) {\n      this[kEvents].delete(String(type));\n    } else {\n      this[kEvents].clear();\n    }\n\n    return this;\n  }\n}\n\nObjectDefineProperties(NodeEventTarget.prototype\x2C {\n  setMaxListeners: kEnumerableProperty\x2C\n  getMaxListeners: kEnumerableProperty\x2C\n  eventNames: kEnumerableProperty\x2C\n  listenerCount: kEnumerableProperty\x2C\n  off: kEnumerableProperty\x2C\n  removeListener: kEnumerableProperty\x2C\n  on: kEnumerableProperty\x2C\n  addListener: kEnumerableProperty\x2C\n  once: kEnumerableProperty\x2C\n  emit: kEnumerableProperty\x2C\n  removeAllListeners: kEnumerableProperty\x2C\n});\n\n// EventTarget API\n\nfunction shouldAddListener(listener) {\n  if (typeof listener === 'function' ||\n      typeof listener?.handleEvent === 'function') {\n    return true;\n  }\n\n  if (listener == null)\n    return false;\n\n  throw new ERR_INVALID_ARG_TYPE('listener'\x2C 'EventListener'\x2C listener);\n}\n\nfunction validateEventListenerOptions(options) {\n  if (typeof options === 'boolean')\n    return { capture: options };\n\n  if (options === null)\n    return {};\n  validateObject(options\x2C 'options'\x2C {\n    allowArray: true\x2C allowFunction: true\x2C\n  });\n  return {\n    once: Boolean(options.once)\x2C\n    capture: Boolean(options.capture)\x2C\n    passive: Boolean(options.passive)\x2C\n    signal: options.signal\x2C\n    weak: options[kWeakHandler]\x2C\n    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])\n  };\n}\n\n// Test whether the argument is an event object. This is far from a fool-proof\n// test\x2C for example this input will result in a false positive:\n// > isEventTarget({ constructor: EventTarget })\n// It stands in its current implementation as a compromise.\n// Ref: https://github.com/nodejs/node/pull/33661\nfunction isEventTarget(obj) {\n  return obj?.constructor?.[kIsEventTarget];\n}\n\nfunction isNodeEventTarget(obj) {\n  return obj?.constructor?.[kIsNodeEventTarget];\n}\n\nfunction addCatch(promise) {\n  const then = promise.then;\n  if (typeof then === 'function') {\n    FunctionPrototypeCall(then\x2C promise\x2C undefined\x2C function(err) {\n      // The callback is called with nextTick to avoid a follow-up\n      // rejection from this promise.\n      emitUncaughtException(err);\n    });\n  }\n}\n\nfunction emitUncaughtException(err) {\n  process.nextTick(() => { throw err; });\n}\n\nfunction makeEventHandler(handler) {\n  // Event handlers are dispatched in the order they were first set\n  // See https://github.com/nodejs/node/pull/35949#issuecomment-722496598\n  function eventHandler(...args) {\n    if (typeof eventHandler.handler !== 'function') {\n      return;\n    }\n    return ReflectApply(eventHandler.handler\x2C this\x2C args);\n  }\n  eventHandler.handler = handler;\n  return eventHandler;\n}\n\nfunction defineEventHandler(emitter\x2C name) {\n  // 8.1.5.1 Event handlers - basically `on[eventName]` attributes\n  ObjectDefineProperty(emitter\x2C `on${name}`\x2C {\n    get() {\n      return this[kHandlers]?.get(name)?.handler ?? null;\n    }\x2C\n    set(value) {\n      if (!this[kHandlers]) {\n        this[kHandlers] = new SafeMap();\n      }\n      let wrappedHandler = this[kHandlers]?.get(name);\n      if (wrappedHandler) {\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size--;\n          const size = this[kEvents].get(name).size;\n          this[kRemoveListener](size\x2C name\x2C wrappedHandler.handler\x2C false);\n        }\n        wrappedHandler.handler = value;\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size++;\n          const size = this[kEvents].get(name).size;\n          this[kNewListener](size\x2C name\x2C value\x2C false\x2C false\x2C false\x2C false);\n        }\n      } else {\n        wrappedHandler = makeEventHandler(value);\n        this.addEventListener(name\x2C wrappedHandler);\n      }\n      this[kHandlers].set(name\x2C wrappedHandler);\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n}\n\nconst EventEmitterMixin = (Superclass) => {\n  class MixedEventEmitter extends Superclass {\n    constructor(...args) {\n      args = new SafeArrayIterator(args);\n      super(...args);\n      FunctionPrototypeCall(EventEmitter\x2C this);\n    }\n  }\n  const protoProps = ObjectGetOwnPropertyDescriptors(EventEmitter.prototype);\n  delete protoProps.constructor;\n  ObjectDefineProperties(MixedEventEmitter.prototype\x2C protoProps);\n  return MixedEventEmitter;\n};\n\nmodule.exports = {\n  Event\x2C\n  EventEmitterMixin\x2C\n  EventTarget\x2C\n  NodeEventTarget\x2C\n  defineEventHandler\x2C\n  initEventTarget\x2C\n  initNodeEventTarget\x2C\n  kCreateEvent\x2C\n  kNewListener\x2C\n  kTrustEvent\x2C\n  kRemoveListener\x2C\n  kEvents\x2C\n  kWeakHandler\x2C\n  isEventTarget\x2C\n};\n
code-source-info,0x26b72db0b2f6,44,25717,26139,C0O25769C23O25953C30O25985C33O25998C38O25953C43O26012C47O26045C52O26086C57O26045C62O26112C64O26137,,
tick,0x1bfd70fd8,48334,0,0x0,3,0x0,0x120d4439f45c,0x105108d28,0x10510894c,0x120d4439b14d,0x105108d28,0x10510894c,0x120d4439a952,0x105108d28,0x10510894c,0x3172a1b32c9a,0x105108d28,0x10510894c,0x3172a1b30f2c,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,Eval,10,48542,0x26b72db0dcf6,5, node:internal/modules/esm/translators:1:1,0x26b72db0d890,~
script-source,129,node:internal/modules/esm/translators,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  Boolean\x2C\n  JSONParse\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectKeys\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  SyntaxErrorPrototype\x2C\n  globalThis: { WebAssembly }\x2C\n} = primordials;\n\nlet _TYPES = null;\nfunction lazyTypes() {\n  if (_TYPES !== null) return _TYPES;\n  return _TYPES = require('internal/util/types');\n}\n\nconst { readFileSync } = require('fs');\nconst { extname\x2C isAbsolute } = require('path');\nconst {\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst {\n  Module: CJSModule\x2C\n  cjsParseCache\n} = require('internal/modules/cjs/loader');\nconst internalURLModule = require('internal/url');\nconst createDynamicModule = require(\n  'internal/modules/esm/create_dynamic_module');\nconst { fileURLToPath\x2C URL } = require('url');\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\n} = require('internal/errors').codes;\nconst { maybeCacheSourceMap } = require('internal/source_map/source_map_cache');\nconst moduleWrap = internalBinding('module_wrap');\nconst { ModuleWrap } = moduleWrap;\nconst asyncESM = require('internal/process/esm_loader');\nconst { emitWarningSync } = require('internal/process/warning');\nconst { TextDecoder } = require('internal/encoding');\n\nlet cjsParse;\nasync function initCJSParse() {\n  if (typeof WebAssembly === 'undefined') {\n    cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n  } else {\n    const { parse\x2C init } =\n        require('internal/deps/cjs-module-lexer/dist/lexer');\n    await init();\n    cjsParse = parse;\n  }\n}\n\nconst translators = new SafeMap();\nexports.translators = translators;\nexports.enrichCJSError = enrichCJSError;\n\nlet DECODER = null;\nfunction assertBufferSource(body\x2C allowString\x2C hookName) {\n  if (allowString && typeof body === 'string') {\n    return;\n  }\n  const { isArrayBufferView\x2C isAnyArrayBuffer } = lazyTypes();\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\n    return;\n  }\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n    `${allowString ? 'string\x2C ' : ''}array buffer\x2C or typed array`\x2C\n    hookName\x2C\n    'source'\x2C\n    body\n  );\n}\n\nfunction stringify(body) {\n  if (typeof body === 'string') return body;\n  assertBufferSource(body\x2C false\x2C 'transformSource');\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\n  return DECODER.decode(body);\n}\n\nfunction errPath(url) {\n  const parsed = new URL(url);\n  if (parsed.protocol === 'file:') {\n    return fileURLToPath(parsed);\n  }\n  return url;\n}\n\nasync function importModuleDynamically(specifier\x2C { url }\x2C assertions) {\n  return asyncESM.esmLoader.import(specifier\x2C\n                                   asyncESM.esmLoader.getBaseURL(url)\x2C\n                                   assertions);\n}\n\n// Strategy for loading a standard JavaScript module.\ntranslators.set('module'\x2C async function moduleStrategy(url\x2C source\x2C isMain) {\n  assertBufferSource(source\x2C true\x2C 'load');\n  source = stringify(source);\n  maybeCacheSourceMap(url\x2C source);\n  debug(`Translating StandardModule ${url}`);\n  const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n  moduleWrap.callbackMap.set(module\x2C {\n    initializeImportMeta: (meta\x2C wrap) => this.importMetaInitialize(meta\x2C {\n      url: wrap.url\n    })\x2C\n    importModuleDynamically\x2C\n  });\n  return module;\n});\n\n/**\n * @param {Error | any} err\n * @param {string} [content] Content of the file\x2C if known.\n * @param {string} [filename] Useful only if `content` is unknown.\n */\nfunction enrichCJSError(err\x2C content\x2C filename) {\n  if (err != null && ObjectGetPrototypeOf(err) === SyntaxErrorPrototype &&\n      hasEsmSyntax(content || readFileSync(filename\x2C 'utf-8'))) {\n    // Emit the warning synchronously because we are in the middle of handling\n    // a SyntaxError that will throw and likely terminate the process before an\n    // asynchronous warning would be emitted.\n    emitWarningSync(\n      'To load an ES module\x2C set "type": "module" in the package.json or use ' +\n      'the .mjs extension.'\n    );\n  }\n}\n\n// Strategy for loading a node-style CommonJS module\nconst isWindows = process.platform === 'win32';\nconst winSepRegEx = /\\//g;\ntranslators.set('commonjs'\x2C async function commonjsStrategy(url\x2C source\x2C\n                                                            isMain) {\n  debug(`Translating CJSModule ${url}`);\n\n  let filename = internalURLModule.fileURLToPath(new URL(url));\n  if (isWindows)\n    filename = StringPrototypeReplace(filename\x2C winSepRegEx\x2C '\\\\');\n\n  if (!cjsParse) await initCJSParse();\n  const { module\x2C exportNames } = cjsPreparseModuleExports(filename);\n  const namesWithDefault = exportNames.has('default') ?\n    [...exportNames] : ['default'\x2C ...exportNames];\n\n  return new ModuleWrap(url\x2C undefined\x2C namesWithDefault\x2C function() {\n    debug(`Loading CJSModule ${url}`);\n\n    let exports;\n    if (asyncESM.esmLoader.cjsCache.has(module)) {\n      exports = asyncESM.esmLoader.cjsCache.get(module);\n      asyncESM.esmLoader.cjsCache.delete(module);\n    } else {\n      try {\n        exports = CJSModule._load(filename\x2C undefined\x2C isMain);\n      } catch (err) {\n        enrichCJSError(err\x2C undefined\x2C filename);\n        throw err;\n      }\n    }\n\n    for (const exportName of exportNames) {\n      if (!ObjectPrototypeHasOwnProperty(exports\x2C exportName) ||\n          exportName === 'default')\n        continue;\n      // We might trigger a getter -> dont fail.\n      let value;\n      try {\n        value = exports[exportName];\n      } catch {\n        // Continue regardless of error.\n      }\n      this.setExport(exportName\x2C value);\n    }\n    this.setExport('default'\x2C exports);\n  });\n});\n\nfunction cjsPreparseModuleExports(filename) {\n  let module = CJSModule._cache[filename];\n  if (module) {\n    const cached = cjsParseCache.get(module);\n    if (cached)\n      return { module\x2C exportNames: cached.exportNames };\n  }\n  const loaded = Boolean(module);\n  if (!loaded) {\n    module = new CJSModule(filename);\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    CJSModule._cache[filename] = module;\n  }\n\n  let source;\n  try {\n    source = readFileSync(filename\x2C 'utf8');\n  } catch {\n    // Continue regardless of error.\n  }\n\n  let exports\x2C reexports;\n  try {\n    ({ exports\x2C reexports } = cjsParse(source || ''));\n  } catch {\n    exports = [];\n    reexports = [];\n  }\n\n  const exportNames = new SafeSet(new SafeArrayIterator(exports));\n\n  // Set first for cycles.\n  cjsParseCache.set(module\x2C { source\x2C exportNames\x2C loaded });\n\n  if (reexports.length) {\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n  }\n  ArrayPrototypeForEach(reexports\x2C (reexport) => {\n    let resolved;\n    try {\n      resolved = CJSModule._resolveFilename(reexport\x2C module);\n    } catch {\n      return;\n    }\n    const ext = extname(resolved);\n    if ((ext === '.js' || ext === '.cjs' || !CJSModule._extensions[ext]) &&\n        isAbsolute(resolved)) {\n      const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved);\n      for (const name of reexportNames)\n        exportNames.add(name);\n    }\n  });\n\n  return { module\x2C exportNames };\n}\n\n// Strategy for loading a node builtin CommonJS module that isn't\n// through normal resolution\ntranslators.set('builtin'\x2C async function builtinStrategy(url) {\n  debug(`Translating BuiltinModule ${url}`);\n  // Slice 'node:' scheme\n  const id = StringPrototypeSlice(url\x2C 5);\n  const module = loadNativeModule(id\x2C url);\n  if (!StringPrototypeStartsWith(url\x2C 'node:') || !module) {\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\n  }\n  debug(`Loading BuiltinModule ${url}`);\n  return module.getESMFacade();\n});\n\n// Strategy for loading a JSON file\ntranslators.set('json'\x2C async function jsonStrategy(url\x2C source) {\n  emitExperimentalWarning('Importing JSON modules');\n  assertBufferSource(source\x2C true\x2C 'load');\n  debug(`Loading JSONModule ${url}`);\n  const pathname = StringPrototypeStartsWith(url\x2C 'file:') ?\n    fileURLToPath(url) : null;\n  let modulePath;\n  let module;\n  if (pathname) {\n    modulePath = isWindows ?\n      StringPrototypeReplace(pathname\x2C winSepRegEx\x2C '\\\\') : pathname;\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  source = stringify(source);\n  if (pathname) {\n    // A require call could have been called on the same file during loading and\n    // that resolves synchronously. To make sure we always return the identical\n    // export\x2C we have to check again if the module already exists or not.\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  try {\n    const exports = JSONParse(stripBOM(source));\n    module = {\n      exports\x2C\n      loaded: true\n    };\n  } catch (err) {\n    // TODO (BridgeAR): We could add a NodeCore error that wraps the JSON\n    // parse error instead of just manipulating the original error message.\n    // That would allow to add further properties and maybe additional\n    // debugging information.\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n  if (pathname) {\n    CJSModule._cache[modulePath] = module;\n  }\n  return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n    debug(`Parsing JSONModule ${url}`);\n    this.setExport('default'\x2C module.exports);\n  });\n});\n\n// Strategy for loading a wasm module\ntranslators.set('wasm'\x2C async function(url\x2C source) {\n  emitExperimentalWarning('Importing WebAssembly modules');\n\n  assertBufferSource(source\x2C false\x2C 'load');\n\n  debug(`Translating WASMModule ${url}`);\n\n  let compiled;\n  try {\n    compiled = await WebAssembly.compile(source);\n  } catch (err) {\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n\n  const imports =\n      ArrayPrototypeMap(WebAssembly.Module.imports(compiled)\x2C\n                        ({ module }) => module);\n  const exports =\n    ArrayPrototypeMap(WebAssembly.Module.exports(compiled)\x2C\n                      ({ name }) => name);\n\n  return createDynamicModule(imports\x2C exports\x2C url\x2C (reflect) => {\n    const { exports } = new WebAssembly.Instance(compiled\x2C reflect.imports);\n    for (const expt of ObjectKeys(exports))\n      reflect.exports[expt].set(exports[expt]);\n  }).module;\n});\n
code-source-info,0x26b72db0dcf6,129,0,10778,C0O0C4O10778,,
code-creation,Function,10,48959,0x26b72db0e496,715, node:internal/modules/esm/translators:1:1,0x26b72db0dc70,~
code-source-info,0x26b72db0e496,129,0,10778,C0O0C180O25C186O50C192O71C198O82C204O95C210O119C216O152C222O166C228O187C233O198C239O209C245O235C251O259C257O288C268O326C274O372C275O372C277O517C283O517C288O500C294O564C300O564C305O540C311O549C317O641C323O641C328O591C334O607C340O627C346O731C352O731C357O700C363O713C369O797C375O797C379O797C381O850C387O850C391O850C393O939C399O939C404O916C410O931C416O967C422O967C427O1000C440O1001C446O967C448O1081C454O1081C459O1053C465O1185C471O1185C476O1211C481O1117C487O1147C493O1251C499O1251C504O1227C510O1319C513O1319C517O1319C519O1374C522O1359C528O1403C534O1403C538O1403C540O1471C546O1471C551O1451C557O1532C563O1532C568O1516C574O1567C575O1567C577O1891C579O1891C585O1906C587O1926C591O1941C593O1964C597O1997C598O1997C600O3099C613O3099C619O4367C626O4376C629O4359C631O4409C635O4409C637O4428C650O4428C656O7520C669O7520C675O7969C688O7969C694O9917C707O9917C714O10777,,
code-creation,Eval,10,49042,0x26b72db0f99e,5, node:internal/modules/esm/create_dynamic_module:1:1,0x26b72db0f7c8,~
script-source,130,node:internal/modules/esm/create_dynamic_module,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  JSONStringify\x2C\n  ObjectCreate\x2C\n  SafeSet\x2C\n} = primordials;\n\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\n\nfunction createImport(impt\x2C index) {\n  const imptPath = JSONStringify(impt);\n  return `import * as $import_${index} from ${imptPath};\nimport.meta.imports[${imptPath}] = $import_${index};`;\n}\n\nfunction createExport(expt) {\n  const name = `${expt}`;\n  return `let $${name};\nexport { $${name} as ${name} };\nimport.meta.exports.${name} = {\n  get: () => $${name}\x2C\n  set: (v) => $${name} = v\x2C\n};`;\n}\n\nconst createDynamicModule = (imports\x2C exports\x2C url = ''\x2C evaluate) => {\n  debug('creating ESM facade for %s with exports: %j'\x2C url\x2C exports);\n  const source = `\n${ArrayPrototypeJoin(ArrayPrototypeMap(imports\x2C createImport)\x2C '\\n')}\n${ArrayPrototypeJoin(ArrayPrototypeMap(exports\x2C createExport)\x2C '\\n')}\nimport.meta.done();\n`;\n  const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n  const m = new ModuleWrap(`${url}`\x2C undefined\x2C source\x2C 0\x2C 0);\n\n  const readyfns = new SafeSet();\n  const reflect = {\n    exports: ObjectCreate(null)\x2C\n    onReady: (cb) => { readyfns.add(cb); }\x2C\n  };\n\n  if (imports.length)\n    reflect.imports = ObjectCreate(null);\n\n  callbackMap.set(m\x2C {\n    initializeImportMeta: (meta\x2C wrap) => {\n      meta.exports = reflect.exports;\n      if (reflect.imports)\n        meta.imports = reflect.imports;\n      meta.done = () => {\n        evaluate(reflect);\n        reflect.onReady = (cb) => cb(reflect);\n        for (const fn of readyfns) {\n          readyfns.delete(fn);\n          fn(reflect);\n        }\n      };\n    }\x2C\n  });\n\n  return {\n    module: m\x2C\n    reflect\x2C\n  };\n};\n\nmodule.exports = createDynamicModule;\n
code-source-info,0x26b72db0f99e,130,0,1756,C0O0C4O1756,,
code-creation,Function,10,49125,0x26b72db0fbc6,111, node:internal/modules/esm/create_dynamic_module:1:1,0x26b72db0f918,~
code-source-info,0x26b72db0fbc6,130,0,1756,C0O0C39O25C45O47C51O68C57O85C63O101C69O140C72O140C77O173C90O174C96O140C98O642C103O1718C105O1733C110O1755,,
code-creation,Eval,10,49334,0x26b72db10afe,5, node:internal/vm/module:1:1,0x26b72db105b8,~
script-source,131,node:internal/vm/module,'use strict';\n\nconst assert = require('internal/assert');\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeSome\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  ReflectApply\x2C\n  SafeWeakMap\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  TypeError\x2C\n} = primordials;\n\nconst { isContext } = internalBinding('contextify');\nconst {\n  isModuleNamespaceObject\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  getConstructorOf\x2C\n  customInspectSymbol\x2C\n  emitExperimentalWarning\x2C\n} = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_VM_MODULE_ALREADY_LINKED\x2C\n  ERR_VM_MODULE_DIFFERENT_CONTEXT\x2C\n  ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA\x2C\n  ERR_VM_MODULE_LINKING_ERRORED\x2C\n  ERR_VM_MODULE_NOT_MODULE\x2C\n  ERR_VM_MODULE_STATUS\x2C\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateUint32\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst binding = internalBinding('module_wrap');\nconst {\n  ModuleWrap\x2C\n  kUninstantiated\x2C\n  kInstantiating\x2C\n  kInstantiated\x2C\n  kEvaluating\x2C\n  kEvaluated\x2C\n  kErrored\x2C\n} = binding;\n\nconst STATUS_MAP = {\n  [kUninstantiated]: 'unlinked'\x2C\n  [kInstantiating]: 'linking'\x2C\n  [kInstantiated]: 'linked'\x2C\n  [kEvaluating]: 'evaluating'\x2C\n  [kEvaluated]: 'evaluated'\x2C\n  [kErrored]: 'errored'\x2C\n};\n\nlet globalModuleId = 0;\nconst defaultModuleName = 'vm:module';\nconst wrapToModuleMap = new SafeWeakMap();\n\nconst kWrap = Symbol('kWrap');\nconst kContext = Symbol('kContext');\nconst kPerContextModuleId = Symbol('kPerContextModuleId');\nconst kLink = Symbol('kLink');\n\nclass Module {\n  constructor(options) {\n    emitExperimentalWarning('VM Modules');\n\n    if (new.target === Module) {\n      // eslint-disable-next-line no-restricted-syntax\n      throw new TypeError('Module is not a constructor');\n    }\n\n    const {\n      context\x2C\n      sourceText\x2C\n      syntheticExportNames\x2C\n      syntheticEvaluationSteps\x2C\n    } = options;\n\n    if (context !== undefined) {\n      validateObject(context\x2C 'context');\n      if (!isContext(context)) {\n        throw new ERR_INVALID_ARG_TYPE('options.context'\x2C 'vm.Context'\x2C\n                                       context);\n      }\n    }\n\n    let { identifier } = options;\n    if (identifier !== undefined) {\n      validateString(identifier\x2C 'options.identifier');\n    } else if (context === undefined) {\n      identifier = `${defaultModuleName}(${globalModuleId++})`;\n    } else if (context[kPerContextModuleId] !== undefined) {\n      const curId = context[kPerContextModuleId];\n      identifier = `${defaultModuleName}(${curId})`;\n      context[kPerContextModuleId] += 1;\n    } else {\n      identifier = `${defaultModuleName}(0)`;\n      ObjectDefineProperty(context\x2C kPerContextModuleId\x2C {\n        value: 1\x2C\n        writable: true\x2C\n        enumerable: false\x2C\n        configurable: true\x2C\n      });\n    }\n\n    if (sourceText !== undefined) {\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C sourceText\x2C\n                                   options.lineOffset\x2C options.columnOffset\x2C\n                                   options.cachedData);\n\n      binding.callbackMap.set(this[kWrap]\x2C {\n        initializeImportMeta: options.initializeImportMeta\x2C\n        importModuleDynamically: options.importModuleDynamically ?\n          importModuleDynamicallyWrap(options.importModuleDynamically) :\n          undefined\x2C\n      });\n    } else {\n      assert(syntheticEvaluationSteps);\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C\n                                   syntheticExportNames\x2C\n                                   syntheticEvaluationSteps);\n    }\n\n    wrapToModuleMap.set(this[kWrap]\x2C this);\n\n    this[kContext] = context;\n  }\n\n  get identifier() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kWrap].url;\n  }\n\n  get context() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kContext];\n  }\n\n  get namespace() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must not be unlinked or linking');\n    }\n    return this[kWrap].getNamespace();\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return STATUS_MAP[this[kWrap].getStatus()];\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS('must be errored');\n    }\n    return this[kWrap].getError();\n  }\n\n  async link(linker) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateFunction(linker\x2C 'linker');\n    if (this.status === 'linked') {\n      throw new ERR_VM_MODULE_ALREADY_LINKED();\n    }\n    if (this.status !== 'unlinked') {\n      throw new ERR_VM_MODULE_STATUS('must be unlinked');\n    }\n    await this[kLink](linker);\n    this[kWrap].instantiate();\n  }\n\n  async evaluate(options = {}) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n\n    validateObject(options\x2C 'options');\n\n    let timeout = options.timeout;\n    if (timeout === undefined) {\n      timeout = -1;\n    } else {\n      validateUint32(timeout\x2C 'options.timeout'\x2C true);\n    }\n    const { breakOnSigint = false } = options;\n    validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n    const status = this[kWrap].getStatus();\n    if (status !== kInstantiated &&\n        status !== kEvaluated &&\n        status !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS(\n        'must be one of linked\x2C evaluated\x2C or errored'\n      );\n    }\n    await this[kWrap].evaluate(timeout\x2C breakOnSigint);\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || Module;\n    const o = ObjectCreate({ constructor });\n    o.status = this.status;\n    o.identifier = this.identifier;\n    o.context = this.context;\n\n    ObjectSetPrototypeOf(o\x2C ObjectGetPrototypeOf(this));\n    ObjectDefineProperty(o\x2C SymbolToStringTag\x2C {\n      value: constructor.name\x2C\n      configurable: true\n    });\n\n    // Lazy to avoid circular dependency\n    const { inspect } = require('internal/util/inspect');\n    return inspect(o\x2C { ...options\x2C customInspect: false });\n  }\n}\n\nconst kDependencySpecifiers = Symbol('kDependencySpecifiers');\nconst kNoError = Symbol('kNoError');\n\nclass SourceTextModule extends Module {\n  #error = kNoError;\n  #statusOverride;\n\n  constructor(sourceText\x2C options = {}) {\n    validateString(sourceText\x2C 'sourceText');\n    validateObject(options\x2C 'options');\n\n    const {\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n      context\x2C\n      identifier\x2C\n      cachedData\x2C\n    } = options;\n\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n\n    if (initializeImportMeta !== undefined &&\n        typeof initializeImportMeta !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.initializeImportMeta'\x2C 'function'\x2C initializeImportMeta);\n    }\n\n    if (importModuleDynamically !== undefined &&\n        typeof importModuleDynamically !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.importModuleDynamically'\x2C 'function'\x2C\n        importModuleDynamically);\n    }\n\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData'\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        cachedData\n      );\n    }\n\n    super({\n      sourceText\x2C\n      context\x2C\n      identifier\x2C\n      lineOffset\x2C\n      columnOffset\x2C\n      cachedData\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n    });\n\n    this[kLink] = async (linker) => {\n      this.#statusOverride = 'linking';\n\n      const promises = this[kWrap].link(async (identifier\x2C assert) => {\n        const module = await linker(identifier\x2C this\x2C { assert });\n        if (module[kWrap] === undefined) {\n          throw new ERR_VM_MODULE_NOT_MODULE();\n        }\n        if (module.context !== this.context) {\n          throw new ERR_VM_MODULE_DIFFERENT_CONTEXT();\n        }\n        if (module.status === 'errored') {\n          // TODO(devsnek): replace with ERR_VM_MODULE_LINK_FAILURE\n          // and error cause proposal.\n          throw new ERR_VM_MODULE_LINKING_ERRORED();\n        }\n        if (module.status === 'unlinked') {\n          await module[kLink](linker);\n        }\n        return module[kWrap];\n      });\n\n      try {\n        if (promises !== undefined) {\n          await PromiseAll(promises);\n        }\n      } catch (e) {\n        this.#error = e;\n        throw e;\n      } finally {\n        this.#statusOverride = undefined;\n      }\n    };\n\n    this[kDependencySpecifiers] = undefined;\n  }\n\n  get dependencySpecifiers() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kDependencySpecifiers] === undefined) {\n      this[kDependencySpecifiers] = this[kWrap].getStaticDependencySpecifiers();\n    }\n    return this[kDependencySpecifiers];\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return 'errored';\n    }\n    if (this.#statusOverride) {\n      return this.#statusOverride;\n    }\n    return super.status;\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return this.#error;\n    }\n    return super.error;\n  }\n\n  createCachedData() {\n    const { status } = this;\n    if (status === 'evaluating' ||\n        status === 'evaluated' ||\n        status === 'errored') {\n      throw new ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA();\n    }\n    return this[kWrap].createCachedData();\n  }\n}\n\nclass SyntheticModule extends Module {\n  constructor(exportNames\x2C evaluateCallback\x2C options = {}) {\n    if (!ArrayIsArray(exportNames) ||\n      ArrayPrototypeSome(exportNames\x2C (e) => typeof e !== 'string')) {\n      throw new ERR_INVALID_ARG_TYPE('exportNames'\x2C\n                                     'Array of unique strings'\x2C\n                                     exportNames);\n    } else {\n      ArrayPrototypeForEach(exportNames\x2C (name\x2C i) => {\n        if (ArrayPrototypeIndexOf(exportNames\x2C name\x2C i + 1) !== -1) {\n          throw new ERR_INVALID_ARG_VALUE(`exportNames.${name}`\x2C\n                                          name\x2C\n                                          'is duplicated');\n        }\n      });\n    }\n    validateFunction(evaluateCallback\x2C 'evaluateCallback');\n\n    validateObject(options\x2C 'options');\n\n    const { context\x2C identifier } = options;\n\n    super({\n      syntheticExportNames: exportNames\x2C\n      syntheticEvaluationSteps: evaluateCallback\x2C\n      context\x2C\n      identifier\x2C\n    });\n\n    this[kLink] = () => this[kWrap].link(() => {\n      assert.fail('link callback should not be called');\n    });\n  }\n\n  setExport(name\x2C value) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateString(name\x2C 'name');\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must be linked');\n    }\n    this[kWrap].setExport(name\x2C value);\n  }\n}\n\nfunction importModuleDynamicallyWrap(importModuleDynamically) {\n  const importModuleDynamicallyWrapper = async (...args) => {\n    const m = await ReflectApply(importModuleDynamically\x2C this\x2C args);\n    if (isModuleNamespaceObject(m)) {\n      return m;\n    }\n    if (!m || m[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (m.status === 'errored') {\n      throw m.error;\n    }\n    return m.namespace;\n  };\n  return importModuleDynamicallyWrapper;\n}\n\nmodule.exports = {\n  Module\x2C\n  SourceTextModule\x2C\n  SyntheticModule\x2C\n  importModuleDynamicallyWrap\x2C\n  getModuleFromWrap: (wrap) => wrapToModuleMap.get(wrap)\x2C\n};\n
code-source-info,0x26b72db10afe,131,0,12310,C0O0C4O12310,,
code-creation,Function,10,49792,0x26b72db11d5e,872, node:internal/vm/module:1:1,0x26b72db10a78,~
code-source-info,0x26b72db11d5e,131,0,12310,C0O0C156O30C162O30C166O30C168O68C174O84C180O109C186O134C192O156C198O172C204O196C210O220C216O244C222O258C228O274C233O289C238O299C244O320C250O371C253O371C258O357C264O462C270O462C275O412C281O439C287O576C293O576C298O504C304O524C309O547C315O858C321O858C326O884C331O612C337O636C343O661C349O693C355O728C361O771C367O804C373O832C379O1014C385O1014C390O902C396O921C402O941C408O958C414O976C420O994C426O1063C429O1063C433O1063C435O1216C438O1105C444O1119C449O1138C454O1156C460O1173C465O1188C471O1202C477O1245C484O1250C488O1268C495O1283C499O1300C506O1314C510O1330C517O1343C521O1357C528O1374C532O1387C539O1403C543O1414C550O1245C552O1450C553O1450C555O1479C557O1479C559O1516C561O1516C566O1516C568O1550C571O1550C575O1550C577O1584C580O1584C584O1584C586O1632C589O1632C593O1632C595O1677C598O1677C602O1677C660O5923C688O6683C691O6683C695O6683C697O6733C700O6733C704O6733C736O6785C799O10265C827O12150C834O12171C840O12181C846O12201C852O12220C856O12270C866O12165C871O12309,,
code-creation,Function,10,49834,0x26b72db1229e,30,<instance_members_initializer> node:internal/vm/module:256:3,0x26b72db110e8,~
code-source-info,0x26b72db1229e,131,6796,6832,C3O6805C29O6832,,
tick,0x1bfc3b5e0,49875,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x3172a1b30f5f,0x105108d28,0x10510894c,0x3172a1b2c7a9,0x105108d28,0x10510894c,0x3172a1b2859c,0x3172a1b0b476,0x3172a1b05aed
code-creation,LazyCompile,10,49959,0x26b72db13796,30,ESMLoader node:internal/modules/esm/loader:61:1,0x3172a1b322b0,~
code-source-info,0x26b72db13796,106,1658,1658,C9O1658C29O1658,,
code-creation,LazyCompile,10,49959,0x26b72db14c4e,27,ModuleMap node:internal/modules/esm/module_map:17:14,0x3172a1b34a00,~
code-source-info,0x26b72db14c4e,107,518,535,C3O524C7O530C11O524C26O534,,
code-creation,LazyCompile,10,50000,0x26b72db14ef6,13,desc.value node:internal/per_context/primordials:334:32,0x2b48e0c49e58,~
code-source-info,0x26b72db14ef6,6,9631,9690,C0O9648C7O9655C12O9678,,
code-creation,LazyCompile,10,50000,0x26b72db14ffe,13,SafeIterator node:internal/per_context/primordials:279:16,0x2b48e0c498a8,~
code-source-info,0x26b72db14ffe,6,7920,7980,C0O7939C3O7956C7O7954C12O7979,,
code-creation,LazyCompile,10,50000,0x26b72db15136,13,next node:internal/per_context/primordials:282:9,0x2b48e0c49970,~
code-source-info,0x26b72db15136,6,7989,8034,C0O8000C3O8017C8O8007C12O8028,,
code-creation,LazyCompile,10,50084,0x26b72db153b6,152,deprecate node:internal/util:96:19,0x232faba01bc8,~
code-source-info,0x26b72db153b6,16,2408,3584,C0O2408C26O2428C31O2440C37O2454C42O2470C44O2480C45O2535C53O2573C61O2595C66O2576C83O2631C87O2659C100O2659C105O2705C106O2705C108O3280C121O3280C126O3320C129O3327C135O3520C141O3546C145O3541C149O3564C151O3582,,
code-creation,LazyCompile,10,50125,0x26b72db159b6,28,getEmbedderOptions node:internal/options:32:28,0x3172a1b0a3c8,~
code-source-info,0x26b72db159b6,97,760,877,C0O767C6O795C11O813C17O811C23O852C27O875,,
code-creation,LazyCompile,10,50209,0x26b72db15c5e,315,Module._initPaths node:internal/modules/cjs/loader:1227:29,0x3172a1b2b7e0,~
code-source-info,0x26b72db15c5e,103,38405,39361,C0O38428C9O38448C14O38452C22O38466C28O38466C33O38505C42O38525C47O38529C55O38541C61O38541C66O38736C74O38752C77O38757C85O38773C93O38757C103O38795C106O38800C114O38816C125O38800C131O38856C140O38857C143O38862C157O38862C169O38901C173O38920C180O38949C183O38954C191O38954C198O38920C203O38996C210O39025C213O39030C221O39030C228O38996C233O39073C237O39093C244O39127C249O39155C254O39186C257O39191C262O39155C270O39209C273O39127C279O39093C284O39232C286O39244C292O39305C297O39326C302O39346C305O39326C309O39324C314O39360,,
code-creation,Function,11,50292,0x105109040,3616,normalizeString node:path:66:25,0x815de63a820,^
code-source-info,0x105109040,41,2161,4085,,,
code-creation,Function,11,50292,0x105109ec0,664,internalBinding node:internal/bootstrap/loaders:164:45,0x2b48e0c4f828,^
code-source-info,0x105109ec0,9,5115,5353,,,
code-creation,Function,11,50334,0x10510a1c0,200,isBrandCheck node:internal/webstreams/util:112:22,0x120d443bbe40,^
code-source-info,0x10510a1c0,126,2398,2541,,,
code-creation,Function,11,50334,0x10510a300,136,next node:internal/per_context/primordials:282:9,0x2b48e0c49970,^
code-source-info,0x10510a300,6,7989,8034,,,
code-creation,Function,11,50334,0x10510a400,312,SafeMap node:internal/per_context/primordials:360:16,0x2b48e0c49f00,^
code-source-info,0x10510a400,6,10335,10352,,,
code-creation,Eval,10,50417,0x26b72db190e6,5, node:internal/modules/run_main:1:1,0x26b72db18ec0,~
script-source,132,node:internal/modules/run_main,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  StringPrototypeEndsWith\x2C\n} = primordials;\nconst CJSLoader = require('internal/modules/cjs/loader');\nconst { Module\x2C toRealPath\x2C readPackageScope } = CJSLoader;\nconst { getOptionValue } = require('internal/options');\nconst path = require('path');\nconst {\n  handleProcessExit\x2C\n} = require('internal/modules/esm/handle_process_exit');\n\nfunction resolveMainPath(main) {\n  // Note extension resolution for the main entry point can be deprecated in a\n  // future major.\n  // Module._findPath is monkey-patchable here.\n  let mainPath = Module._findPath(path.resolve(main)\x2C null\x2C true);\n  if (!mainPath)\n    return;\n\n  const preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n  if (!preserveSymlinksMain)\n    mainPath = toRealPath(mainPath);\n\n  return mainPath;\n}\n\nfunction shouldUseESMLoader(mainPath) {\n  const userLoader = getOptionValue('--experimental-loader');\n  if (userLoader)\n    return true;\n  const esModuleSpecifierResolution =\n    getOptionValue('--experimental-specifier-resolution');\n  if (esModuleSpecifierResolution === 'node')\n    return true;\n  // Determine the module format of the main\n  if (mainPath && StringPrototypeEndsWith(mainPath\x2C '.mjs'))\n    return true;\n  if (!mainPath || StringPrototypeEndsWith(mainPath\x2C '.cjs'))\n    return false;\n  const pkg = readPackageScope(mainPath);\n  return pkg && pkg.data.type === 'module';\n}\n\nfunction runMainESM(mainPath) {\n  const { loadESM } = require('internal/process/esm_loader');\n  const { pathToFileURL } = require('internal/url');\n\n  handleMainPromise(loadESM((esmLoader) => {\n    const main = path.isAbsolute(mainPath) ?\n      pathToFileURL(mainPath).href : mainPath;\n    return esmLoader.import(main\x2C undefined\x2C ObjectCreate(null));\n  }));\n}\n\nasync function handleMainPromise(promise) {\n  process.on('exit'\x2C handleProcessExit);\n  try {\n    return await promise;\n  } finally {\n    process.off('exit'\x2C handleProcessExit);\n  }\n}\n\n// For backwards compatibility\x2C we have to run a bunch of\n// monkey-patchable code that belongs to the CJS loader (exposed by\n// `require('module')`) even when the entry point is ESM.\nfunction executeUserEntryPoint(main = process.argv[1]) {\n  const resolvedMain = resolveMainPath(main);\n  const useESMLoader = shouldUseESMLoader(resolvedMain);\n  if (useESMLoader) {\n    runMainESM(resolvedMain || main);\n  } else {\n    // Module._load is the monkey-patchable CJS module loader.\n    Module._load(main\x2C null\x2C true);\n  }\n}\n\nmodule.exports = {\n  executeUserEntryPoint\x2C\n  handleMainPromise\x2C\n};\n
code-source-info,0x26b72db190e6,132,0,2537,C0O0C4O2537,,
code-creation,Function,10,50542,0x26b72db193ce,178, node:internal/modules/run_main:1:1,0x26b72db19060,~
code-source-info,0x26b72db193ce,132,0,2537,C0O0C66O25C72O41C78O101C84O101C89O149C95O157C101O169C107O228C113O228C118O209C124O270C130O270C134O270C136O320C142O320C147O297C153O2469C160O2490C166O2515C172O2484C177O2536,,
code-creation,LazyCompile,10,50584,0x26b72db199be,163,initializeESMLoader node:internal/bootstrap/pre_execution:511:29,0x3172a1b08180,~
code-source-info,0x26b72db199be,96,15849,16937,C0O15931C6O15931C13O15980C16O15976C21O15974C25O15998C30O16002C34O16022C40O16051C41O16058C42O16158C48O16158C53O16074C58O16114C63O16204C69O16204C74O16405C79O16363C83O16475C88O16436C92O16641C100O16645C106O16761C112O16761C117O16710C122O16718C127O16736C132O16807C138O16807C143O16826C145O16836C149O16850C151O16870C155O16894C157O16913C162O16936,,
code-creation,LazyCompile,10,50625,0x26b72db19bd6,5,get hasLoadedAnyUserCJSModule node:internal/modules/cjs/loader:74:32,0x3172a1b2acd0,~
code-source-info,0x26b72db19bd6,103,2306,2346,C0O2311C4O2344,,
code-creation,LazyCompile,10,50625,0x26b72db19c7e,21,assert node:internal/assert:11:16,0x232faba1bfe8,~
script-source,21,node:internal/assert,'use strict';\n\nlet error;\nfunction lazyError() {\n  if (!error) {\n    error = require('internal/errors').codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\n\nfunction assert(value\x2C message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\n\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\n\nassert.fail = fail;\n\nmodule.exports = assert;\n
code-source-info,0x26b72db19c7e,21,172,307,C0O193C4O242C7O242C11O259C13O265C18O259C20O306,,
code-creation,LazyCompile,10,50667,0x26b72db19e7e,53,loadPreloadModules node:internal/bootstrap/pre_execution:554:28,0x3172a1b08270,~
code-source-info,0x26b72db19e7e,96,17413,17733,C0O17500C8O17500C13O17531C15O17568C21O17575C26O17651C32O17651C37O17651C42O17618C47O17695C52O17732,,
code-creation,LazyCompile,10,50709,0x26b72db1a06e,166,Module._preloadModules node:internal/modules/cjs/loader:1257:34,0x3172a1b2b870,~
code-source-info,0x26b72db1a06e,103,39397,39971,C0O39412C5O39417C11O39445C12O39452C13O39456C17O39469C23O39664C33O39664C42O39714C45O39736C53O39761C58O39761C63O39736C68O39727C85O39789C88O39795C95O39800C100O39822C106O39835C114O39850C116O39850C119O39884C121O39900C125O39889C130O39924C137O39940C141O39924C146O39909C151O39871C154O39948C158O39961C165O39970,,
code-creation,LazyCompile,10,50750,0x26b72db1a28e,94,Module node:internal/modules/cjs/loader:172:16,0x3172a1b2a630,~
code-source-info,0x26b72db1a28e,103,5284,5521,C14O5306C16O5314C20O5322C22O5334C25O5339C30O5339C35O5332C39O5354C40O5367C44O5375C49O5393C54O5393C60O5414C71O5414C76O5453C77O5467C81O5477C82O5489C86O5500C88O5514C93O5520,,
tick,0x1bfc3b9c0,50750,0,0x0,3,0x0,0x3172a1b0b49c,0x3172a1b05aed
code-creation,LazyCompile,10,50792,0x26b72db1a4c6,162,dirname node:path:1275:10,0x815de63aee8,~
code-source-info,0x26b72db1a4c6,41,38741,39410,C0O38754C8O38754C13O38797C19O38804C24O38817C26O38828C27O38849C34O38849C42O38888C44O38884C48O38922C51O38949C53O38977C57O38984C61O38991C63O38991C68O39010C73O39014C81O39053C83O39049C88O39083C92O39114C97O39133C101O39220C103O38999C108O38959C111O39261C113O39269C118O39283C128O39310C129O39315C135O39334C140O39347C142O39359C143O39364C156O39371C161O39406,,
code-creation,LazyCompile,10,50792,0x26b72db1a69e,45,updateChildren node:internal/modules/cjs/loader:165:24,0x3172a1b2a5e0,~
code-source-info,0x26b72db1a69e,103,5049,5222,C0O5092C7O5098C15O5112C19O5130C23O5138C26O5138C33O5184C38O5184C44O5221,,
code-creation,LazyCompile,10,50834,0x26b72db1a85e,183,Module._nodeModulePaths node:internal/modules/cjs/loader:629:37,0x3172a1b2b110,~
code-source-info,0x26b72db1a85e,103,18773,19904,C0O18828C5O18840C10O18840C17O19019C19O19028C24O19043C28O19068C29O19283C32O19309C36O19316C40O19325C42O19340C47O19350C48O19350C53O19382C58O19382C64O19424C66O19437C68O19433C73O19467C75O19477C77O19473C82O19494C89O19545C100O19545C108O19581C112O19494C117O19620C120O19638C124O19658C126O19664C131O19682C138O19693C144O19697C149O19719C156O19751C159O19358C164O19291C167O19838C175O19838C180O19887C182O19900,,
code-creation,LazyCompile,10,50875,0x26b72db1abfe,127,Module.require node:internal/modules/cjs/loader:991:36,0x3172a1b2b470,~
code-source-info,0x26b72db1abfe,103,30953,31244,C0O30962C8O30962C13O30990C15O30997C20O31011C36O31017C41O31011C42O31126C51O31138C60O31154C63O31168C76O31168C93O31223C102O31235C126O31243,,
code-creation,LazyCompile,10,50959,0x26b72db1aee6,619,Module._load node:internal/modules/cjs/loader:757:24,0x3172a1b2b2d0,~
code-source-info,0x26b72db1aee6,103,23190,26108,C0O23224C2O23253C6O23271C14O23331C23O23271C28O23561C42O23572C47O23604C54O23624C58O23657C60O23714C63O23721C70O23727C74O23745C76O23787C88O23787C93O23857C99O23875C102O23882C106O23925C107O23954C111O23962C112O23977C119O24005C121O24063C124O24070C138O24070C144O24115C152O24119C159O24210C167O24210C173O24265C178O24265C184O24300C189O24311C198O24343C205O24349C210O24343C211O24416C215O24424C216O24453C219O24460C226O24466C230O24480C232O24518C244O24518C249O24584C255O24626C260O24640C265O24640C271O24665C273O24709C279O24725C282O24732C286O24775C287O24782C288O24807C294O24854C298O24862C299O24888C304O24888C310O24927C315O24934C324O24969C328O24977C329O25063C344O25079C350O25112C354O25130C359O25149C363O25163C365O25173C369O25187C372O25194C379O25211C383O25223C387O25255C394O25303C398O25334C403O25359C409O25359C414O25379C426O25385C427O25412C432O25431C436O25445C444O25452C446O25469C450O25505C458O25533C460O25586C467O25592C475O25612C481O25616C487O25666C493O25666C499O25717C501O25727C506O25749C522O25749C529O25843C537O25870C541O25885C547O25870C555O25912C559O25940C565O25912C573O25970C575O25949C580O26016C586O26044C594O26053C598O26016C614O26098C618O26106,,
code-creation,LazyCompile,10,51000,0x26b72db1b37e,89,logger node:internal/util/debuglog:95:18,0x232faba1d540,~
code-source-info,0x26b72db1b37e,22,2869,3064,C0O2869C3O2901C24O2925C30O2942C34O2932C38O2947C39O2962C45O2979C51O2988C55O2969C60O2993C61O3009C65O3016C72O3029C77O3025C83O3016C88O3054,,
code-creation,LazyCompile,10,51042,0x26b72db1b4be,3, node:internal/per_context/primordials:285:21,0x2b48e0c49a18,~
code-source-info,0x26b72db1b4be,6,8055,8084,C0O8066C2O8078,,
code-creation,LazyCompile,10,51042,0x26b72db1b596,140,debug node:internal/util/debuglog:76:15,0x232faba1d4a0,~
code-source-info,0x26b72db1b596,22,2357,2751,C0O2357C3O2376C6O2376C9O2484C16O2505C22O2492C30O2490C36O2524C42O2560C47O2563C50O2560C54O2588C75O2612C81O2629C85O2619C89O2634C90O2649C96O2666C102O2675C106O2656C111O2680C112O2696C116O2703C123O2716C128O2712C134O2703C139O2741,,
code-creation,LazyCompile,10,51084,0x26b72db1b746,41,init node:internal/util/debuglog:72:16,0x232faba1d450,~
code-source-info,0x26b72db1b746,22,2259,2342,C0O2268C10O2274C14O2272C16O2311C26O2321C33O2319C40O2341,,
code-creation,LazyCompile,10,51084,0x26b72db1b836,2,testEnabled node:internal/util/debuglog:32:19,0x3172a1b1c9f0,~
code-source-info,0x26b72db1b836,22,973,984,C0O979C1O984,,
code-creation,LazyCompile,10,51125,0x26b72db1b9ce,116,debuglogImpl node:internal/util/debuglog:49:22,0x232faba1d2a0,~
code-source-info,0x26b72db1b9ce,22,1451,1995,C0O1451C9O1470C18O1484C23O1511C34O1544C39O1552C43O1544C45O1563C55O1563C59O1595C71O1606C75O1611C83O1934C97O1952C99O1950C103O1970C112O1987C115O1993,,
code-creation,LazyCompile,10,51125,0x26b72db1bb86,10, node:internal/modules/cjs/loader:272:66,0x3172a1b2afa0,~
code-source-info,0x26b72db1bb86,103,7709,7734,C0O7721C2O7727C9O7733,,
code-creation,LazyCompile,10,51125,0x26b72db1bc36,2,noop node:internal/util/debuglog:47:14,0x232faba1d250,~
code-source-info,0x26b72db1bc36,22,1419,1427,C1O1426,,
code-creation,LazyCompile,10,51209,0x26b72db1c03e,809,Module._resolveFilename node:internal/modules/cjs/loader:848:35,0x3172a1b2b358,~
code-source-info,0x26b72db1c03e,103,26145,29133,C0O26184C10O26188C19O26241C23O26254C29O26254C36O26291C38O26306C39O26318C41O26328C51O26387C57O26412C63O26391C69O26447C79O26447C88O26501C96O26501C105O26558C111O26571C119O26571C128O26627C136O26627C142O26679C144O26721C151O26770C164O26770C170O26801C173O26835C175O26850C181O26856C185O26840C190O26902C198O26907C202O26922C206O26948C212O26948C217O26939C221O27002C225O27009C231O27009C238O27075C240O27094C244O27080C249O27121C257O27167C262O27126C269O27187C277O27224C282O27187C287O27103C292O27062C295O26865C300O26822C305O27283C311O27312C315O27327C321O27327C330O27384C340O27441C348O27390C353O27384C356O27470C360O27485C366O27485C373O27530C380O27540C389O27558C390O27569C397O27573C402O27602C406O27626C412O27602C420O27657C428O27661C441O27706C447O27748C453O27779C457O27800C463O27779C471O27845C478O27748C485O27868C491O27894C497O27713C502O27900C516O27933C520O27939C528O27944C533O27984C539O27990C543O27984C544O28031C546O28031C547O28128C551O28128C556O28178C560O28178C566O28210C568O28251C570O28259C575O28286C583O28293C589O28306C596O28312C604O28312C609O28268C613O28352C617O28359C625O28380C629O28400C631O28420C632O28506C636O28513C654O28513C660O28557C662O28571C664O28587C665O28611C668O28635C673O28647C677O28705C683O28745C692O28764C698O28705C703O28666C709O28686C715O28686C721O28617C724O28789C730O28812C742O28843C749O28850C754O28861C756O28879C763O28920C771O28920C776O28904C780O29031C788O29031C794O29053C796O29062C800O29086C802O29103C806O29121C808O29121,,
code-creation,LazyCompile,10,51292,0x26b72db1c5f6,28,canBeRequiredByUsers node:internal/bootstrap/loaders:240:30,0x2b48e0c4fb08,~
code-source-info,0x26b72db1c5f6,9,7354,7450,C0O7377C5O7390C10O7394C15O7394C21O7407C23O7425C27O7446,,
code-creation,LazyCompile,10,51334,0x26b72db1c8ae,327,Module._resolveLookupPaths node:internal/modules/cjs/loader:667:38,0x3172a1b2b1a0,~
code-source-info,0x26b72db1c8ae,103,19946,21123,C0O19968C5O19985C10O19985C17O20022C25O20022C30O20066C31O20078C32O20121C39O20125C47O20159C52O20185C59O20192C66O20205C72O20205C80O20239C87O20256C93O20256C101O20290C108O20309C114O20322C120O20322C128O20356C133O20387C138O20404C145O20414C152O20421C161O20439C166O20475C171O20447C177O20501C191O20501C196O20565C202O20572C212O20591C213O20638C217O20661C223O20675C229O20846C234O20858C248O20858C253O20913C255O20930C256O20938C264O21005C272O20938C277O21031C286O21032C289O21037C294O21052C299O21037C311O21066C319O21066C324O21104C326O21121,,
code-creation,LazyCompile,10,51334,0x26b72db1cbce,76,trySelfParentPath node:internal/modules/cjs/loader:427:27,0x3172a1b2a950,~
code-source-info,0x26b72db1cbce,103,12270,12533,C0O12283C4O12296C5O12309C6O12324C12O12354C16O12363C17O12384C24O12387C29O12410C36O12413C44O12455C47O12470C52O12470C59O12478C62O12483C66O12476C69O12487C72O12508C73O12521C75O12532,,
code-creation,LazyCompile,10,51375,0x26b72db1ce0e,232,trySelf node:internal/modules/cjs/loader:441:17,0x3172a1b2a9a0,~
code-source-info,0x26b72db1ce0e,103,12551,13375,C0O12577C4O12594C5O12607C6O12648C9O12648C17O12625C22O12636C27O12686C31O12702C37O12725C38O12738C39O12756C47O12775C48O12788C49O12796C51O12829C55O12821C60O12841C65O12867C70O12913C82O12871C89O12929C94O12947C97O12981C102O12986C107O12947C112O12945C118O13010C119O13023C123O13041C128O13070C133O13099C138O13121C142O13099C149O13163C152O13163C159O13190C168O13070C180O13048C185O13227C197O13248C200O13254C207O13259C212O13293C219O13337C223O13299C228O13293C229O13361C231O13361,,
code-creation,LazyCompile,10,51417,0x26b72db1d0de,129,readPackageScope node:internal/modules/cjs/loader:321:26,0x3172a1b2a770,~
code-source-info,0x26b72db1d0de,103,8919,9437,C0O8962C7O8996C10O8962C16O9008C18O9035C25O9090C28O9052C34O9100C47O9112C54O9168C61O9207C66O9211C70O9172C77O9236C78O9249C79O9268C84O9292C86O9290C90O9268C95O9302C97O9313C104O9334C110O9353C116O9370C117O9397C119O9397C124O9026C127O9422C128O9435,,
code-creation,LazyCompile,10,51459,0x26b72db1d43e,234,readPackage node:internal/modules/cjs/loader:290:21,0x3172a1b2a720,~
code-source-info,0x26b72db1d43e,103,8102,8892,C0O8137C5O8142C13O8142C20O8200C25O8217C30O8217C36O8234C38O8262C40O8278C41O8297C46O8315C51O8315C57O8353C63O8366C72O8392C77O8402C79O8432C84O8449C91O8449C97O8475C98O8488C102O8521C107O8521C112O8559C117O8580C125O8605C133O8633C141O8664C149O8692C160O8708C165O8725C170O8725C176O8754C178O8770C190O8791C195O8798C199O8814C207O8843C213O8854C220O8865C224O8861C227O8824C231O8878C233O8878,,
code-creation,LazyCompile,10,51500,0x26b72db1d746,199,read node:internal/modules/package_json_reader:16:14,0x3172a1b303a0,~
code-source-info,0x26b72db1d746,104,292,954,C0O307C5O317C10O317C17O338C22O351C27O351C32O365C33O412C40O440C43O440C48O412C53O384C59O395C66O489C73O491C79O499C86O544C92O544C97O525C102O575C106O607C112O643C115O654C127O704C132O738C142O652C148O774C154O821C159O821C164O852C169O861C174O861C180O907C185O913C190O913C196O938C198O952,,
code-creation,LazyCompile,10,51542,0x26b72db1da96,3,toNamespacedPath node:path:1266:19,0x815de63ae98,~
code-source-info,0x26b72db1da96,41,38608,38668,C0O38652C2O38664,,
code-creation,LazyCompile,10,51625,0x26b72db1de4e,436,Module._findPath node:internal/modules/cjs/loader:494:28,0x3172a1b2aff0,~
code-source-info,0x26b72db1de4e,103,14309,16913,C0O14362C5O14367C10O14367C16O14390C18O14417C26O14440C30O14460C36O14467C41O14480C42O14493C43O14518C45O14526C51O14537C57O14537C62O14535C66O14588C69O14595C76O14605C80O14619C82O14634C84O14647C85O14655C87O14691C93O14698C100O14709C103O14752C107O14759C111O14709C119O14772C121O14764C125O14794C127O14820C134O14856C137O14836C143O14925C145O14938C149O14930C154O15023C156O15028C160O15037C165O15052C172O15066C177O15071C179O15086C183O15140C186O15140C192O15180C194O15209C196O15232C197O15261C202O15266C207O15266C214O15301C216O15327C219O15327C224O15347C228O15375C229O15382C234O15409C238O15434C244O15470C249O15486C254O15486C262O15536C265O15547C272O15596C278O16210C283O16226C288O16226C296O16272C299O16283C304O16330C308O16401C312O16435C320O16460C325O16442C330O16482C342O16493C348O16551C354O16571C359O16656C363O16688C371O16713C376O16695C381O16733C396O16744C402O16800C406O16822C409O16829C416O16850C420O16868C422O16884C423O14947C428O14912C434O16898C435O16911,,
code-creation,LazyCompile,10,51667,0x26b72db1e1fe,45,isAbsolute node:path:1156:13,0x815de63ada8,~
code-source-info,0x26b72db1e1fe,41,35447,35593,C0O35460C8O35460C13O35506C19O35513C26O35531C31O35531C39O35570C41O35566C44O35589,,
code-creation,LazyCompile,10,51750,0x26b72db1e42e,85,stat node:internal/modules/cjs/loader:151:14,0x3172a1b2a590,~
code-source-info,0x26b72db1e42e,103,4627,5024,C0O4642C5O4658C10O4658C17O4688C23O4733C28O4743C33O4743C39O4762C41O4788C43O4802C44O4824C49O4824C54O4856C61O4889C66O4969C71O4979C76O4979C82O5008C84O5022,,
code-creation,LazyCompile,10,51792,0x26b72db1e586,44,tryExtensions node:internal/modules/cjs/loader:400:23,0x3172a1b2a8b0,~
code-source-info,0x26b72db1e586,103,11501,11685,C0O11536C2O11548C6O11541C11O11584C16O11600C19O11594C23O11584C29O11619C31O11641C33O11657C34O11557C39O11523C42O11670C43O11683,,
code-creation,LazyCompile,10,51792,0x26b72db1e6b6,50,tryFile node:internal/modules/cjs/loader:384:17,0x3172a1b2a810,~
code-source-info,0x26b72db1e6b6,103,11077,11271,C0O11114C3O11114C8O11135C9O11142C14O11149C15O11156C16O11159C24O11184C26O11198C31O11210C36O11210C41O11231C42O11238C45O11245C49O11269,,
code-creation,LazyCompile,10,51834,0x26b72db1e7fe,42,toRealPath node:internal/modules/cjs/loader:393:20,0x3172a1b2a860,~
code-source-info,0x26b72db1e7fe,103,11292,11404,C0O11310C5O11320C10O11333C17O11353C20O11364C28O11383C35O11320C41O11402,,
tick,0x100911a34,51959,0,0x0,3,0x0,0x26b72db1e821,0x26b72db1e6e3,0x26b72db1e59d,0x26b72db1dfa4,0x26b72db1c2cc,0x26b72db1af70,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,LazyCompile,10,52000,0x26b72db1ec16,1042,realpathSync node:fs:2425:22,0xd2efcc368a0,~
script-source,81,node:fs,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers\x2C keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\n// When using FSReqCallback\x2C make sure to create the object only *after* all\n// parameter validation has happened\x2C so that the objects are not kept in memory\n// in case they are created but never used due to an exception.\n\nconst {\n  ArrayPrototypePush\x2C\n  BigIntPrototypeToString\x2C\n  MathMax\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeMap\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  S_IFIFO\x2C\n  S_IFLNK\x2C\n  S_IFMT\x2C\n  S_IFREG\x2C\n  S_IFSOCK\x2C\n  F_OK\x2C\n  R_OK\x2C\n  W_OK\x2C\n  X_OK\x2C\n  O_WRONLY\x2C\n  O_SYMLINK\n} = constants;\n\nconst pathModule = require('path');\nconst { isArrayBufferView } = require('internal/util/types');\n\n// We need to get the statValues from the binding at the callsite since\n// it's re-initialized after deserialization.\n\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_FEATURE_UNAVAILABLE_ON_PLATFORM\x2C\n  }\x2C\n  AbortError\x2C\n  uvErrmapGet\x2C\n  uvException\n} = require('internal/errors');\n\nconst { FSReqCallback } = binding;\nconst { toPathIfFileURL } = require('internal/url');\nconst internalUtil = require('internal/util');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n  }\x2C\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  Stats\x2C\n  getStatsFromBinding\x2C\n  realpathCacheKey\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n} = require('internal/fs/utils');\nconst {\n  Dir\x2C\n  opendir\x2C\n  opendirSync\n} = require('internal/fs/dir');\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n} = require('internal/constants');\nconst {\n  isUint32\x2C\n  parseFileMode\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateCallback\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst watchers = require('internal/fs/watchers');\nconst ReadFileContext = require('internal/fs/read_file_context');\n\nlet truncateWarn = true;\nlet fs;\n\n// Lazy loaded\nlet cpFn;\nlet cpSyncFn;\nlet promises = null;\nlet ReadStream;\nlet WriteStream;\nlet rimraf;\nlet rimrafSync;\n\n// These have to be separate because of how graceful-fs happens to do it's\n// monkeypatching.\nlet FileReadStream;\nlet FileWriteStream;\n\nconst isWindows = process.platform === 'win32';\nconst isOSX = process.platform === 'darwin';\n\n\nfunction showTruncateDeprecation() {\n  if (truncateWarn) {\n    process.emitWarning(\n      'Using fs.truncate with a file descriptor is deprecated. Please use ' +\n      'fs.ftruncate with a file descriptor instead.'\x2C\n      'DeprecationWarning'\x2C 'DEP0081');\n    truncateWarn = false;\n  }\n}\n\nfunction maybeCallback(cb) {\n  validateCallback(cb);\n\n  return cb;\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer\x2C callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  validateCallback(cb);\n\n  return (...args) => ReflectApply(cb\x2C this\x2C args);\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization\x2C since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  validateCallback(cb);\n\n  return (err\x2C stats) => {\n    if (err) return cb(err);\n    cb(err\x2C getStatsFromBinding(stats));\n  };\n}\n\nconst isFd = isUint32;\n\nfunction isFileType(stats\x2C fileType) {\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  let mode = stats[1];\n  if (typeof mode === 'bigint')\n    mode = Number(mode);\n  return (mode & S_IFMT) === fileType;\n}\n\n/**\n * Tests a user's permissions for the file or directory\n * specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction access(path\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = F_OK;\n  }\n\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously tests a user's permissions for the file or\n * directory specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @returns {void}\n */\nfunction accessSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n\n  const ctx = { path };\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @param {(exists?: boolean) => any} callback\n * @returns {void}\n */\nfunction exists(path\x2C callback) {\n  maybeCallback(callback);\n\n  function suppressedCallback(err) {\n    callback(err ? false : true);\n  }\n\n  try {\n    fs.access(path\x2C F_OK\x2C suppressedCallback);\n  } catch {\n    return callback(false);\n  }\n}\n\nObjectDefineProperty(exists\x2C internalUtil.promisify.custom\x2C {\n  value: (path) => {\n    return new Promise((resolve) => fs.exists(path\x2C resolve));\n  }\n});\n\n// fs.existsSync never throws\x2C it only returns true or false.\n// Since fs.existsSync never throws\x2C users have established\n// the expectation that passing invalid arguments to it\x2C even like\n// fs.existsSync()\x2C would only get a false in return\x2C so we cannot signal\n// validation errors to users properly out of compatibility concerns.\n// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\n/**\n * Synchronously tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @returns {boolean}\n */\nfunction existsSync(path) {\n  try {\n    path = getValidatedPath(path);\n  } catch {\n    return false;\n  }\n  const ctx = { path };\n  const nPath = pathModule.toNamespacedPath(path);\n  binding.access(nPath\x2C F_OK\x2C undefined\x2C ctx);\n\n  // In case of an invalid symlink\x2C `binding.access()` on win32\n  // will **not** return an error and is therefore not enough.\n  // Double check with `binding.stat()`.\n  if (isWindows && ctx.errno === undefined) {\n    binding.stat(nPath\x2C false\x2C undefined\x2C ctx);\n  }\n\n  return ctx.errno === undefined;\n}\n\nfunction readFileAfterOpen(err\x2C fd) {\n  const context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  const req = new FSReqCallback();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd\x2C false\x2C req);\n}\n\nfunction readFileAfterStat(err\x2C stats) {\n  const context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  const size = context.size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n\n  if (size > kIoMaxLength) {\n    err = new ERR_FS_FILE_TOO_LARGE(size);\n    return context.close(err);\n  }\n\n  try {\n    if (size === 0) {\n      context.buffers = [];\n    } else {\n      context.buffer = Buffer.allocUnsafeSlow(size);\n    }\n  } catch (err) {\n    return context.close(err);\n  }\n  context.read();\n}\n\nfunction checkAborted(signal\x2C callback) {\n  if (signal?.aborted) {\n    callback(new AbortError(undefined\x2C { cause: signal?.reason }));\n    return true;\n  }\n  return false;\n}\n\n/**\n * Asynchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   data?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readFile(path\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { flag: 'r' });\n  const context = new ReadFileContext(callback\x2C options.encoding);\n  context.isUserFd = isFd(path); // File descriptor ownership\n\n  if (options.signal) {\n    context.signal = options.signal;\n  }\n  if (context.isUserFd) {\n    process.nextTick(function tick(context) {\n      ReflectApply(readFileAfterOpen\x2C { context }\x2C [null\x2C path]);\n    }\x2C context);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  const flagsNumber = stringToFlags(options.flag\x2C 'options.flag');\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               0o666\x2C\n               req);\n}\n\nfunction tryStatSync(fd\x2C isUserFd) {\n  const ctx = {};\n  const stats = binding.fstat(fd\x2C false\x2C undefined\x2C ctx);\n  if (ctx.errno !== undefined && !isUserFd) {\n    fs.closeSync(fd);\n    throw uvException(ctx);\n  }\n  return stats;\n}\n\nfunction tryCreateBuffer(size\x2C fd\x2C isUserFd) {\n  let threw = true;\n  let buffer;\n  try {\n    if (size > kIoMaxLength) {\n      throw new ERR_FS_FILE_TOO_LARGE(size);\n    }\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C len) {\n  let threw = true;\n  let bytesRead;\n  try {\n    bytesRead = fs.readSync(fd\x2C buffer\x2C pos\x2C len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\n/**\n * Synchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   }} [options]\n * @returns {string | Buffer}\n */\nfunction readFileSync(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C options.flag\x2C 0o666);\n\n  const stats = tryStatSync(fd\x2C isUserFd);\n  const size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n  let pos = 0;\n  let buffer; // Single buffer with file data\n  let buffers; // List for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size\x2C fd\x2C isUserFd);\n  }\n\n  let bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // The kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C 0\x2C 8192);\n      if (bytesRead !== 0) {\n        ArrayPrototypePush(buffers\x2C buffer.slice(0\x2C bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // Data was collected into the buffers list.\n    buffer = Buffer.concat(buffers\x2C pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0\x2C pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n}\n\nfunction defaultCloseCallback(err) {\n  if (err != null) throw err;\n}\n\n/**\n * Closes the file descriptor.\n * @param {number} fd\n * @param {(err?: Error) => any} [callback]\n * @returns {void}\n */\nfunction close(fd\x2C callback = defaultCloseCallback) {\n  fd = getValidatedFd(fd);\n  if (callback !== defaultCloseCallback)\n    callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.close(fd\x2C req);\n}\n\n/**\n * Synchronously closes the file descriptor.\n * @param {number} fd\n * @returns {void}\n */\nfunction closeSync(fd) {\n  fd = getValidatedFd(fd);\n\n  const ctx = {};\n  binding.close(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @param {(\n *   err?: Error\x2C\n *   fd?: number\n *   ) => any} callback\n * @returns {void}\n */\nfunction open(path\x2C flags\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  if (arguments.length < 3) {\n    callback = flags;\n    flags = 'r';\n    mode = 0o666;\n  } else if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0o666;\n  } else {\n    mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  }\n  const flagsNumber = stringToFlags(flags);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               mode\x2C\n               req);\n}\n\n/**\n * Synchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @returns {number}\n */\nfunction openSync(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n\n  const ctx = { path };\n  const result = binding.open(pathModule.toNamespacedPath(path)\x2C\n                              flagsNumber\x2C mode\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {number} offset\n * @param {number} length\n * @param {number | bigint} position\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffer?: Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback) {\n  fd = getValidatedFd(fd);\n\n  if (arguments.length <= 3) {\n    // Assume fs.read(fd\x2C options\x2C callback)\n    let options = ObjectCreate(null);\n    if (arguments.length < 3) {\n      // This is fs.read(fd\x2C callback)\n      // buffer will be the callback\n      callback = buffer;\n    } else {\n      // This is fs.read(fd\x2C {}\x2C callback)\n      // buffer will be the options object\n      // offset is the callback\n      options = buffer;\n      callback = offset;\n    }\n\n    ({\n      buffer = Buffer.alloc(16384)\x2C\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\n    } = options);\n  }\n\n  validateBuffer(buffer);\n  callback = maybeCallback(callback);\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return process.nextTick(function tick() {\n      callback(null\x2C 0\x2C buffer);\n    });\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  function wrapper(err\x2C bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C bytesRead || 0\x2C buffer);\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n}\n\nObjectDefineProperty(read\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesRead'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously reads the file from the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | bigint;\n *   }} [offset]\n * @returns {number}\n */\nfunction readSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n\n  validateBuffer(buffer);\n\n  if (arguments.length <= 3) {\n    // Assume fs.readSync(fd\x2C buffer\x2C options)\n    const options = offset || ObjectCreate(null);\n\n    ({\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\n    } = options);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return 0;\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  const ctx = {};\n  const result = binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor)\n * and writes to an array of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffers?: ArrayBufferView[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readv(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C read) {\n    callback(err\x2C read || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.readBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(readv\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesRead'\x2C 'buffers']\x2C enumerable: false });\n\n/**\n * Synchronously reads file from the\n * specified `fd` (file descriptor) and writes to an array\n * of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @returns {number}\n */\nfunction readvSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.readBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes `buffer` to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string | object} buffer\n * @param {number} [offset]\n * @param {number} [length]\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number;\n *   buffer?: Buffer | TypedArray | DataView\n *   ) => any} callback\n * @returns {void}\n */\nfunction write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C written || 0\x2C buffer);\n  }\n\n  fd = getValidatedFd(fd);\n\n  if (isArrayBufferView(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n    if (offset == null || typeof offset === 'function') {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n\n    const req = new FSReqCallback();\n    req.oncomplete = wrapper;\n    return binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n\n  const str = String(buffer);\n  validateEncoding(str\x2C length);\n  callback = maybeCallback(position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  return binding.writeString(fd\x2C str\x2C offset\x2C length\x2C req);\n}\n\nObjectDefineProperty(write\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesWritten'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously writes `buffer` to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string | object} buffer\n * @param {number} [offset]\n * @param {number} [length]\n * @param {number} [position]\n * @returns {number}\n */\nfunction writeSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  let result;\n  if (isArrayBufferView(buffer)) {\n    if (position === undefined)\n      position = null;\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    result = binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                                 undefined\x2C ctx);\n  } else {\n    validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n    validateEncoding(buffer\x2C length);\n\n    if (offset === undefined)\n      offset = null;\n    result = binding.writeString(fd\x2C buffer\x2C offset\x2C length\x2C\n                                 undefined\x2C ctx);\n  }\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes an array of `ArrayBufferView`s to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number\x2C\n *   buffers?: ArrayBufferView[]\n *   ) => any} callback\n * @returns {void}\n */\nfunction writev(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    callback(err\x2C written || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  if (buffers.length === 0) {\n    process.nextTick(callback\x2C null\x2C 0\x2C buffers);\n    return;\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.writeBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(writev\x2C internalUtil.customPromisifyArgs\x2C {\n  value: ['bytesWritten'\x2C 'buffer']\x2C\n  enumerable: false\n});\n\n/**\n * Synchronously writes an array of `ArrayBufferView`s\n * to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @returns {number}\n */\nfunction writevSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  if (buffers.length === 0) {\n    return 0;\n  }\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.writeBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rename(oldPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C\n                 req);\n}\n\n\n/**\n * Synchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction renameSync(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const ctx = { path: oldPath\x2C dest: newPath };\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction truncate(path\x2C len\x2C callback) {\n  if (typeof path === 'number') {\n    showTruncateDeprecation();\n    return fs.ftruncate(path\x2C len\x2C callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = maybeCallback(callback);\n  fs.open(path\x2C 'r+'\x2C (er\x2C fd) => {\n    if (er) return callback(er);\n    const req = new FSReqCallback();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd\x2C (er2) => {\n        callback(aggregateTwoErrors(er2\x2C er));\n      });\n    };\n    binding.ftruncate(fd\x2C len\x2C req);\n  });\n}\n\n/**\n * Synchronously truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @returns {void}\n */\nfunction truncateSync(path\x2C len) {\n  if (typeof path === 'number') {\n    // legacy\n    showTruncateDeprecation();\n    return fs.ftruncateSync(path\x2C len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // Allow error to be thrown\x2C but still close fd.\n  const fd = fs.openSync(path\x2C 'r+');\n  let ret;\n\n  try {\n    ret = fs.ftruncateSync(fd\x2C len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction ftruncate(fd\x2C len = 0\x2C callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  }\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.ftruncate(fd\x2C len\x2C req);\n}\n\n/**\n * Synchronously truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @returns {void}\n */\nfunction ftruncateSync(fd\x2C len = 0) {\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  const ctx = {};\n  binding.ftruncate(fd\x2C len\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction lazyLoadCp() {\n  if (cpFn === undefined) {\n    ({ cpFn } = require('internal/fs/cp/cp'));\n    cpFn = require('util').callbackify(cpFn);\n    ({ cpSyncFn } = require('internal/fs/cp/cp-sync'));\n  }\n}\n\nfunction lazyLoadRimraf() {\n  if (rimraf === undefined)\n    ({ rimraf\x2C rimrafSync } = require('internal/fs/rimraf'));\n}\n\n/**\n * Asynchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rmdir(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  callback = makeCallback(callback);\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    validateRmOptions(\n      path\x2C\n      { ...options\x2C force: false }\x2C\n      true\x2C\n      (err\x2C options) => {\n        if (err === false) {\n          const req = new FSReqCallback();\n          req.oncomplete = callback;\n          return binding.rmdir(path\x2C req);\n        }\n        if (err) {\n          return callback(err);\n        }\n\n        lazyLoadRimraf();\n        rimraf(path\x2C options\x2C callback);\n      });\n  } else {\n    validateRmdirOptions(options);\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    return binding.rmdir(path\x2C req);\n  }\n}\n\n/**\n * Synchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmdirSync(path\x2C options) {\n  path = getValidatedPath(path);\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    options = validateRmOptionsSync(path\x2C { ...options\x2C force: false }\x2C true);\n    if (options !== false) {\n      lazyLoadRimraf();\n      return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n    }\n  } else {\n    validateRmdirOptions(options);\n  }\n\n  const ctx = { path };\n  binding.rmdir(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  return handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rm(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  path = getValidatedPath(path);\n\n  validateRmOptions(path\x2C options\x2C false\x2C (err\x2C options) => {\n    if (err) {\n      return callback(err);\n    }\n    lazyLoadRimraf();\n    return rimraf(pathModule.toNamespacedPath(path)\x2C options\x2C callback);\n  });\n}\n\n/**\n * Synchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmSync(path\x2C options) {\n  path = getValidatedPath(path);\n  options = validateRmOptionsSync(path\x2C options\x2C false);\n\n  lazyLoadRimraf();\n  return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n}\n\n/**\n * Forces all currently queued I/O operations associated\n * with the file to the operating system's synchronized\n * I/O completion state.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fdatasync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd\x2C req);\n}\n\n/**\n * Synchronously forces all currently queued I/O operations\n * associated with the file to the operating\n * system's synchronized I/O completion state.\n * @param {number} fd\n * @returns {void}\n */\nfunction fdatasyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fdatasync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Requests for all data for the open file descriptor\n * to be flushed to the storage device.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fsync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd\x2C req);\n}\n\n/**\n * Synchronously requests for all data for the open\n * file descriptor to be flushed to the storage device.\n * @param {number} fd\n * @returns {void}\n */\nfunction fsyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fsync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction mkdir(path\x2C options\x2C callback) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                parseFileMode(mode\x2C 'mode')\x2C recursive\x2C req);\n}\n\n/**\n * Synchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @returns {string | void}\n */\nfunction mkdirSync(path\x2C options) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const ctx = { path };\n  const result = binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                               parseFileMode(mode\x2C 'mode')\x2C recursive\x2C\n                               undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  if (recursive) {\n    return result;\n  }\n}\n\n/**\n * Reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @param {(\n *   err?: Error\x2C\n *   files?: string[] | Buffer[] | Direct[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readdir(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  if (!options.withFileTypes) {\n    req.oncomplete = callback;\n  } else {\n    req.oncomplete = (err\x2C result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      getDirents(path\x2C result\x2C callback);\n    };\n  }\n  binding.readdir(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C\n                  !!options.withFileTypes\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @returns {string | Buffer[] | Dirent[]}\n */\nfunction readdirSync(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                 options.encoding\x2C !!options.withFileTypes\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return options.withFileTypes ? getDirents(path\x2C result) : result;\n}\n\n/**\n * Invokes the callback with the `fs.Stats`\n * for the file descriptor.\n * @param {number} fd\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction fstat(fd\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  fd = getValidatedFd(fd);\n  callback = makeStatsCallback(callback);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.fstat(fd\x2C options.bigint\x2C req);\n}\n\n/**\n * Retrieves the `fs.Stats` for the symbolic link\n * referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction lstat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.lstat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\n/**\n * Asynchronously gets the stats of a file.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction stat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\nfunction hasNoEntryError(ctx) {\n  if (ctx.errno) {\n    const uvErr = uvErrmapGet(ctx.errno);\n    return uvErr?.[0] === 'ENOENT';\n  }\n\n  if (ctx.error) {\n    return ctx.error.code === 'ENOENT';\n  }\n\n  return false;\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the file descriptor.\n * @param {number} fd\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction fstatSync(fd\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  fd = getValidatedFd(fd);\n  const ctx = { fd };\n  const stats = binding.fstat(fd\x2C options.bigint\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the symbolic link referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction lstatSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                              options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats`\n * for the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction statSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.stat(pathModule.toNamespacedPath(path)\x2C\n                             options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   linkString?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readlink(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.readlink(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @returns {string | Buffer}\n */\nfunction readlinkSync(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  const ctx = { path };\n  const result = binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                                  options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Creates the link called `path` pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string} [type_]\n * @param {(err?: Error) => any} callback_\n * @returns {void}\n */\nfunction symlink(target\x2C path\x2C type_\x2C callback_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  const callback = makeCallback(arguments[arguments.length - 1]);\n\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n\n  if (isWindows && type === null) {\n    let absoluteTarget;\n    try {\n      // Symlinks targets can be relative to the newly created path.\n      // Calculate absolute file name of the symlink target\x2C and check\n      // if it is a directory. Ignore resolve error to keep symlink\n      // errors consistent between platforms if invalid path is\n      // provided.\n      absoluteTarget = pathModule.resolve(path\x2C '..'\x2C target);\n    } catch {\n      // Continue regardless of error.\n    }\n    if (absoluteTarget !== undefined) {\n      stat(absoluteTarget\x2C (err\x2C stat) => {\n        const resolvedType = !err && stat.isDirectory() ? 'dir' : 'file';\n        const resolvedFlags = stringToSymlinkType(resolvedType);\n        const destination = preprocessSymlinkDestination(target\x2C\n                                                         resolvedType\x2C\n                                                         path);\n\n        const req = new FSReqCallback();\n        req.oncomplete = callback;\n        binding.symlink(destination\x2C\n                        pathModule.toNamespacedPath(path)\x2C resolvedFlags\x2C req);\n      });\n      return;\n    }\n  }\n\n  const destination = preprocessSymlinkDestination(target\x2C type\x2C path);\n\n  const flags = stringToSymlinkType(type);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.symlink(destination\x2C pathModule.toNamespacedPath(path)\x2C flags\x2C req);\n}\n\n/**\n * Synchronously creates the link called `path`\n * pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string} [type]\n * @returns {void}\n */\nfunction symlinkSync(target\x2C path\x2C type) {\n  type = (typeof type === 'string' ? type : null);\n  if (isWindows && type === null) {\n    const absoluteTarget = pathModule.resolve(`${path}`\x2C '..'\x2C `${target}`);\n    if (statSync(absoluteTarget\x2C { throwIfNoEntry: false })?.isDirectory()) {\n      type = 'dir';\n    }\n  }\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  const flags = stringToSymlinkType(type);\n\n  const ctx = { path: target\x2C dest: path };\n  binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                  pathModule.toNamespacedPath(path)\x2C flags\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction link(existingPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n               pathModule.toNamespacedPath(newPath)\x2C\n               req);\n}\n\n/**\n * Synchronously creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction linkSync(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const ctx = { path: existingPath\x2C dest: newPath };\n  const result = binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                              pathModule.toNamespacedPath(newPath)\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction unlink(path\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C req);\n}\n\n/**\n * Synchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @returns {void}\n */\nfunction unlinkSync(path) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchmod(fd\x2C mode\x2C callback) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchmod(fd\x2C mode\x2C req);\n}\n\n/**\n * Synchronously sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @returns {void}\n */\nfunction fchmodSync(fd\x2C mode) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  const ctx = {};\n  binding.fchmod(fd\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchmod(path\x2C mode\x2C callback) {\n  callback = maybeCallback(callback);\n  mode = parseFileMode(mode\x2C 'mode');\n  fs.open(path\x2C O_WRONLY | O_SYMLINK\x2C (err\x2C fd) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    // Prefer to return the chmod error\x2C if one occurs\x2C\n    // but still try to close\x2C and report closing errors if they occur.\n    fs.fchmod(fd\x2C mode\x2C (err) => {\n      fs.close(fd\x2C (err2) => {\n        callback(aggregateTwoErrors(err2\x2C err));\n      });\n    });\n  });\n}\n\n/**\n * Synchronously changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @returns {void}\n */\nfunction lchmodSync(path\x2C mode) {\n  const fd = fs.openSync(path\x2C O_WRONLY | O_SYMLINK);\n\n  // Prefer to return the chmod error\x2C if one occurs\x2C\n  // but still try to close\x2C and report closing errors if they occur.\n  let ret;\n  try {\n    ret = fs.fchmodSync(fd\x2C mode);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Asynchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chmod(path\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @returns {void}\n */\nfunction chmodSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n\n  const ctx = { path };\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction lchownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchown(fd\x2C uid\x2C gid\x2C callback) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchown(fd\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction fchownSync(fd\x2C uid\x2C gid) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const ctx = {};\n  binding.fchown(fd\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction chownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction utimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C\n                 toUnixTimestamp(mtime)\x2C\n                 req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction utimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C toUnixTimestamp(mtime)\x2C\n                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by the supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction futimes(fd\x2C atime\x2C mtime\x2C callback) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.futimes(fd\x2C atime\x2C mtime\x2C req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by the\n * supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction futimesSync(fd\x2C atime\x2C mtime) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  const ctx = {};\n  binding.futimes(fd\x2C atime\x2C mtime\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the access and modification times of\n * a file in the same way as `fs.utimes()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lutimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  req);\n}\n\n/**\n * Synchronously changes the access and modification\n * times of a file in the same way as `fs.utimesSync()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction lutimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback) {\n  if (signal?.aborted) {\n    const abortError = new AbortError(undefined\x2C { cause: signal?.reason });\n    if (isUserFd) {\n      callback(abortError);\n    } else {\n      fs.close(fd\x2C (err) => {\n        callback(aggregateTwoErrors(err\x2C abortError));\n      });\n    }\n    return;\n  }\n  // write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback)\n  fs.write(fd\x2C buffer\x2C offset\x2C length\x2C null\x2C (writeErr\x2C written) => {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd\x2C (err) => {\n          callback(aggregateTwoErrors(err\x2C writeErr));\n        });\n      }\n    } else if (written === length) {\n      if (isUserFd) {\n        callback(null);\n      } else {\n        fs.close(fd\x2C callback);\n      }\n    } else {\n      offset += written;\n      length -= written;\n      writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Asynchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction writeFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  if (isFd(path)) {\n    const isUserFd = true;\n    const signal = options.signal;\n    writeAll(path\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  fs.open(path\x2C flag\x2C options.mode\x2C (openErr\x2C fd) => {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      const isUserFd = false;\n      const signal = options.signal;\n      writeAll(fd\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Synchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction writeFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  const flag = options.flag || 'w';\n\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C flag\x2C options.mode);\n\n  let offset = 0;\n  let length = data.byteLength;\n  try {\n    while (length > 0) {\n      const written = fs.writeSync(fd\x2C data\x2C offset\x2C length);\n      offset += written;\n      length -= written;\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n}\n\n/**\n * Asynchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction appendFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path\x2C data\x2C options\x2C callback);\n}\n\n/**\n * Synchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction appendFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path\x2C data\x2C options);\n}\n\n/**\n * Watches for the changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {string | {\n *   persistent?: boolean;\n *   recursive?: boolean;\n *   encoding?: string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   eventType?: string\x2C\n *   filename?: string | Buffer\n *   ) => any} [listener]\n * @returns {watchers.FSWatcher}\n */\nfunction watch(filename\x2C options\x2C listener) {\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options\x2C {});\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n  if (options.recursive && !(isOSX || isWindows))\n    throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively');\n  const watcher = new watchers.FSWatcher();\n  watcher[watchers.kFSWatchStart](filename\x2C\n                                  options.persistent\x2C\n                                  options.recursive\x2C\n                                  options.encoding);\n\n  if (listener) {\n    watcher.addListener('change'\x2C listener);\n  }\n  if (options.signal) {\n    if (options.signal.aborted) {\n      process.nextTick(() => watcher.close());\n    } else {\n      const listener = () => watcher.close();\n      options.signal.addEventListener('abort'\x2C listener);\n      watcher.once('close'\x2C () => {\n        options.signal.removeEventListener('abort'\x2C listener);\n      });\n    }\n  }\n\n  return watcher;\n}\n\n\nconst statWatchers = new SafeMap();\n\n/**\n * Watches for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {{\n *   bigint?: boolean;\n *   persistent?: boolean;\n *   interval?: number;\n *   }} [options]\n * @param {(\n *   current?: Stats\x2C\n *   previous?: Stats\n *   ) => any} listener\n * @returns {watchers.StatWatcher}\n */\nfunction watchFile(filename\x2C options\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  let stat;\n\n  if (options === null || typeof options !== 'object') {\n    listener = options;\n    options = null;\n  }\n\n  options = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007\x2C\n    persistent: true\x2C\n    ...options\n  };\n\n  validateFunction(listener\x2C 'listener');\n\n  stat = statWatchers.get(filename);\n\n  if (stat === undefined) {\n    stat = new watchers.StatWatcher(options.bigint);\n    stat[watchers.kFSStatWatcherStart](filename\x2C\n                                       options.persistent\x2C options.interval);\n    statWatchers.set(filename\x2C stat);\n  } else {\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('add');\n  }\n\n  stat.addListener('change'\x2C listener);\n  return stat;\n}\n\n/**\n * Stops watching for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {() => any} [listener]\n * @returns {void}\n */\nfunction unwatchFile(filename\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  const stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n\n  if (typeof listener === 'function') {\n    const beforeListenerCount = stat.listenerCount('change');\n    stat.removeListener('change'\x2C listener);\n    if (stat.listenerCount('change') < beforeListenerCount)\n      stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');\n  } else {\n    stat.removeAllListeners('change');\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n}\n\n\nlet splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\')\x2C including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return RegExpPrototypeExec(splitRootRe\x2C str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (let i = 0; i < str.length; ++i) {\n      if (StringPrototypeCharCodeAt(str\x2C i) !== CHAR_FORWARD_SLASH)\n        return StringPrototypeSlice(str\x2C 0\x2C i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result\x2C options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  }\n  return asBuffer.toString(options.encoding);\n}\n\n// Finds the next portion of a (partial) path\x2C up to the next path delimiter\nlet nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p\x2C i) {\n    for (; i < p.length; ++i) {\n      const ch = StringPrototypeCharCodeAt(p\x2C i);\n\n      // Check for a separator character\n      if (ch === CHAR_BACKWARD_SLASH || ch === CHAR_FORWARD_SLASH)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p\x2C i) {\n    return StringPrototypeIndexOf(p\x2C '/'\x2C i);\n  };\n}\n\nconst emptyObj = ObjectCreate(null);\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string | null; }} [options]\n * @returns {string | Buffer}\n */\nfunction realpathSync(p\x2C options) {\n  options = getOptions(options\x2C emptyObj);\n  p = toPathIfFileURL(p);\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[realpathCacheKey];\n  const maybeCachedResult = cache?.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n  const original = p;\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows) {\n    const ctx = { path: base };\n    binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n    handleErrorFromBinding(ctx);\n    knownHard[base] = true;\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard[base] || cache?.get(base) === base) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        break;\n      }\n      continue;\n    }\n\n    let resolvedLink;\n    const maybeCachedResolved = cache?.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      const baseLong = pathModule.toNamespacedPath(base);\n      const ctx = { path: base };\n      const stats = binding.lstat(baseLong\x2C true\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n\n      if (!isFileType(stats\x2C S_IFLNK)) {\n        knownHard[base] = true;\n        cache?.set(base\x2C base);\n        continue;\n      }\n\n      // Read the link if it wasn't read before\n      // dev/ino always return 0 on windows\x2C so skip the check.\n      let linkTarget = null;\n      let id;\n      if (!isWindows) {\n        const dev = BigIntPrototypeToString(stats[0]\x2C 32);\n        const ino = BigIntPrototypeToString(stats[7]\x2C 32);\n        id = `${dev}:${ino}`;\n        if (seenLinks[id]) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        const ctx = { path: base };\n        binding.stat(baseLong\x2C false\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n        linkTarget = binding.readlink(baseLong\x2C undefined\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n      }\n      resolvedLink = pathModule.resolve(previous\x2C linkTarget);\n\n      cache?.set(base\x2C resolvedLink);\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      const ctx = { path: base };\n      binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n      knownHard[base] = true;\n    }\n  }\n\n  cache?.set(original\x2C p);\n  return encodeRealpathResult(p\x2C options);\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} path\n * @param {string | { encoding?: string; }} [options]\n * @returns {string | Buffer}\n */\nrealpathSync.native = (path\x2C options) => {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.realpath(path\x2C options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n};\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction realpath(p\x2C options\x2C callback) {\n  callback = typeof options === 'function' ? options : maybeCallback(callback);\n  options = getOptions(options\x2C {});\n  p = toPathIfFileURL(p);\n\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard[base]) {\n    fs.lstat(base\x2C (err\x2C stats) => {\n      if (err) return callback(err);\n      knownHard[base] = true;\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  function LOOP() {\n    // Stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null\x2C encodeRealpathResult(p\x2C options));\n    }\n\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard[base]) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        return callback(null\x2C encodeRealpathResult(p\x2C options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base\x2C { bigint: true }\x2C gotStat);\n  }\n\n  function gotStat(err\x2C stats) {\n    if (err) return callback(err);\n\n    // If not a symlink\x2C skip to the next path part\n    if (!stats.isSymbolicLink()) {\n      knownHard[base] = true;\n      return process.nextTick(LOOP);\n    }\n\n    // Stat & read the link if not read before.\n    // Call `gotTarget()` as soon as the link target is known.\n    // `dev`/`ino` always return 0 on windows\x2C so skip the check.\n    let id;\n    if (!isWindows) {\n      const dev = BigIntPrototypeToString(stats.dev\x2C 32);\n      const ino = BigIntPrototypeToString(stats.ino\x2C 32);\n      id = `${dev}:${ino}`;\n      if (seenLinks[id]) {\n        return gotTarget(null\x2C seenLinks[id]);\n      }\n    }\n    fs.stat(base\x2C (err) => {\n      if (err) return callback(err);\n\n      fs.readlink(base\x2C (err\x2C target) => {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err\x2C target);\n      });\n    });\n  }\n\n  function gotTarget(err\x2C target) {\n    if (err) return callback(err);\n\n    gotResolvedLink(pathModule.resolve(previous\x2C target));\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base\x2C (err) => {\n        if (err) return callback(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n}\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} path\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nrealpath.native = (path\x2C options\x2C callback) => {\n  callback = makeCallback(callback || options);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  return binding.realpath(path\x2C options.encoding\x2C req);\n};\n\n/**\n * Creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   directory?: string\n *   ) => any} callback\n * @returns {void}\n */\nfunction mkdtemp(prefix\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @returns {string}\n */\nfunction mkdtempSync(prefix\x2C options) {\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const path = `${prefix}XXXXXX`;\n  const ctx = { path };\n  const result = binding.mkdtemp(path\x2C options.encoding\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction copyFile(src\x2C dest\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0;\n  }\n\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.copyFile(src\x2C dest\x2C mode\x2C req);\n}\n\n/**\n * Synchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @returns {void}\n */\nfunction copyFileSync(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  const ctx = { path: src\x2C dest };  // non-prefixed\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  binding.copyFile(src\x2C dest\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {object} [options]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction cp(src\x2C dest\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  callback = makeCallback(callback);\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpFn(src\x2C dest\x2C options\x2C callback);\n}\n\n/**\n * Synchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {object} [options]\n * @returns {void}\n */\nfunction cpSync(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpSyncFn(src\x2C dest\x2C options);\n}\n\nfunction lazyLoadStreams() {\n  if (!ReadStream) {\n    ({ ReadStream\x2C WriteStream } = require('internal/fs/streams'));\n    FileReadStream = ReadStream;\n    FileWriteStream = WriteStream;\n  }\n}\n\n/**\n * Creates a readable stream with a default `highWaterMark`\n * of 64 kb.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   end?: number;\n *   highWaterMark?: number;\n *   fs?: Object | null;\n *   }} [options]\n * @returns {ReadStream}\n */\nfunction createReadStream(path\x2C options) {\n  lazyLoadStreams();\n  return new ReadStream(path\x2C options);\n}\n\n/**\n * Creates a write stream.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   fs?: Object | null;\n *   }} [options]\n * @returns {WriteStream}\n */\nfunction createWriteStream(path\x2C options) {\n  lazyLoadStreams();\n  return new WriteStream(path\x2C options);\n}\n\nmodule.exports = fs = {\n  appendFile\x2C\n  appendFileSync\x2C\n  access\x2C\n  accessSync\x2C\n  chown\x2C\n  chownSync\x2C\n  chmod\x2C\n  chmodSync\x2C\n  close\x2C\n  closeSync\x2C\n  copyFile\x2C\n  copyFileSync\x2C\n  cp\x2C\n  cpSync\x2C\n  createReadStream\x2C\n  createWriteStream\x2C\n  exists\x2C\n  existsSync\x2C\n  fchown\x2C\n  fchownSync\x2C\n  fchmod\x2C\n  fchmodSync\x2C\n  fdatasync\x2C\n  fdatasyncSync\x2C\n  fstat\x2C\n  fstatSync\x2C\n  fsync\x2C\n  fsyncSync\x2C\n  ftruncate\x2C\n  ftruncateSync\x2C\n  futimes\x2C\n  futimesSync\x2C\n  lchown\x2C\n  lchownSync\x2C\n  lchmod: constants.O_SYMLINK !== undefined ? lchmod : undefined\x2C\n  lchmodSync: constants.O_SYMLINK !== undefined ? lchmodSync : undefined\x2C\n  link\x2C\n  linkSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  lutimes\x2C\n  lutimesSync\x2C\n  mkdir\x2C\n  mkdirSync\x2C\n  mkdtemp\x2C\n  mkdtempSync\x2C\n  open\x2C\n  openSync\x2C\n  opendir\x2C\n  opendirSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  read\x2C\n  readSync\x2C\n  readv\x2C\n  readvSync\x2C\n  readFile\x2C\n  readFileSync\x2C\n  readlink\x2C\n  readlinkSync\x2C\n  realpath\x2C\n  realpathSync\x2C\n  rename\x2C\n  renameSync\x2C\n  rm\x2C\n  rmSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  symlink\x2C\n  symlinkSync\x2C\n  truncate\x2C\n  truncateSync\x2C\n  unwatchFile\x2C\n  unlink\x2C\n  unlinkSync\x2C\n  utimes\x2C\n  utimesSync\x2C\n  watch\x2C\n  watchFile\x2C\n  writeFile\x2C\n  writeFileSync\x2C\n  write\x2C\n  writeSync\x2C\n  writev\x2C\n  writevSync\x2C\n  Dir\x2C\n  Dirent\x2C\n  Stats\x2C\n\n  get ReadStream() {\n    lazyLoadStreams();\n    return ReadStream;\n  }\x2C\n\n  set ReadStream(val) {\n    ReadStream = val;\n  }\x2C\n\n  get WriteStream() {\n    lazyLoadStreams();\n    return WriteStream;\n  }\x2C\n\n  set WriteStream(val) {\n    WriteStream = val;\n  }\x2C\n\n  // Legacy names... these have to be separate because of how graceful-fs\n  // (and possibly other) modules monkey patch the values.\n  get FileReadStream() {\n    lazyLoadStreams();\n    return FileReadStream;\n  }\x2C\n\n  set FileReadStream(val) {\n    FileReadStream = val;\n  }\x2C\n\n  get FileWriteStream() {\n    lazyLoadStreams();\n    return FileWriteStream;\n  }\x2C\n\n  set FileWriteStream(val) {\n    FileWriteStream = val;\n  }\x2C\n\n  // For tests\n  _toUnixTimestamp: toUnixTimestamp\n};\n\nObjectDefineProperties(fs\x2C {\n  F_OK: { enumerable: true\x2C value: F_OK || 0 }\x2C\n  R_OK: { enumerable: true\x2C value: R_OK || 0 }\x2C\n  W_OK: { enumerable: true\x2C value: W_OK || 0 }\x2C\n  X_OK: { enumerable: true\x2C value: X_OK || 0 }\x2C\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  promises: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      promises ??= require('internal/fs/promises').exports;\n      return promises;\n    }\n  }\n});\n
code-source-info,0x26b72db1ec16,81,64403,68304,C0O64420C8O64450C12O64430C19O64463C25O64467C31O64489C35O64522C45O64537C51O64537C55O64556C61O64571C67O64571C74O64600C76O64608C78O64607C82O64655C86O64660C92O64662C101O64672C103O64701C105O64726C106O64752C115O64752C120O64792C129O64792C134O64831C137O64878C139O64953C141O65048C143O65124C145O65158C151O65175C157O65205C162O65287C168O65320C176O65328C183O65340C189O65348C197O65354C201O65365C207O65365C223O65348C228O65417C234O65417C238O65450C239O65466C243O65606C247O65602C252O65661C258O65661C264O65683C267O65707C269O65718C274O65747C280O65747C287O65783C289O65794C296O65806C298O65822C302O65844C309O65871C311O65882C317O65918C328O65882C340O65930C342O65948C355O65948C360O65946C364O65992C366O66005C370O66078C372O66091C384O66106C390O66108C402O66118C407O66136C413O66151C417O66159C425O66171C429O66140C442O66204C446O66212C454O66224C458O66193C465O66245C467O66266C469O66291C471O66337C478O66342C484O66344C493O66359C495O66392C502O66574C508O66585C514O66585C520O66627C528O66635C535O66663C541O66671C559O66671C565O66716C571O66716C575O66752C581O66775C585O66757C592O66795C593O66811C597O66827C604O66832C610O66834C619O66859C621O67013C624O67029C627O67039C633O67077C640O67106C649O67077C656O67136C664O67165C673O67136C680O67183C694O67198C700O67213C702O67226C707O67244C709O67266C714O67296C718O67343C726O67351C733O67367C739O67375C757O67375C762O67422C768O67422C772O67459C778O67480C796O67480C803O67535C809O67535C813O67578C819O67604C825O67604C832O67642C839O67647C845O67649C854O67680C860O67696C862O67710C866O67776C872O67791C880O67813C884O67813C891O67791C899O67872C905O67889C911O67921C916O68007C924O68034C929O68062C937O68070C944O68084C950O68092C958O68098C962O68109C968O68109C984O68092C989O68163C995O68163C999O68198C1000O68214C1004O65591C1010O68235C1017O68240C1023O68242C1032O68262C1036O68269C1041O68302,,
tick,0x1007bc9c4,55000,0,0x0,3,0x0,0x26b72db1e821,0x26b72db1e6e3,0x26b72db1e59d,0x26b72db1dfa4,0x26b72db1c2cc,0x26b72db1af70,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
tick,0x1bfd70f20,55000,0,0x0,3,0x0,0x26b72db1e821,0x26b72db1e6e3,0x26b72db1e59d,0x26b72db1dfa4,0x26b72db1c2cc,0x26b72db1af70,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,LazyCompile,10,55000,0x26b72db25336,123,getOptions node:internal/fs/utils:315:20,0xd2efcc3ed90,~
script-source,82,node:internal/fs/utils,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  BigInt\x2C\n  Date\x2C\n  DateNow\x2C\n  DatePrototypeGetTime\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeCall\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  NumberIsInteger\x2C\n  MathMin\x2C\n  ObjectIs\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplace\x2C\n  Symbol\x2C\n  TypedArrayPrototypeIncludes\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  codes: {\n    ERR_FS_EISDIR\x2C\n    ERR_FS_INVALID_SYMLINK_TYPE\x2C\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\n  }\x2C\n  hideStackFrames\x2C\n  uvException\n} = require('internal/errors');\nconst {\n  isArrayBufferView\x2C\n  isUint8Array\x2C\n  isDate\x2C\n  isBigUint64Array\n} = require('internal/util/types');\nconst { once } = require('internal/util');\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst kType = Symbol('type');\nconst kStats = Symbol('stats');\nconst assert = require('internal/assert');\n\nconst {\n  fs: {\n    F_OK = 0\x2C\n    W_OK = 0\x2C\n    R_OK = 0\x2C\n    X_OK = 0\x2C\n    COPYFILE_EXCL\x2C\n    COPYFILE_FICLONE\x2C\n    COPYFILE_FICLONE_FORCE\x2C\n    O_APPEND\x2C\n    O_CREAT\x2C\n    O_EXCL\x2C\n    O_RDONLY\x2C\n    O_RDWR\x2C\n    O_SYNC\x2C\n    O_TRUNC\x2C\n    O_WRONLY\x2C\n    S_IFBLK\x2C\n    S_IFCHR\x2C\n    S_IFDIR\x2C\n    S_IFIFO\x2C\n    S_IFLNK\x2C\n    S_IFMT\x2C\n    S_IFREG\x2C\n    S_IFSOCK\x2C\n    UV_FS_SYMLINK_DIR\x2C\n    UV_FS_SYMLINK_JUNCTION\x2C\n    UV_DIRENT_UNKNOWN\x2C\n    UV_DIRENT_FILE\x2C\n    UV_DIRENT_DIR\x2C\n    UV_DIRENT_LINK\x2C\n    UV_DIRENT_FIFO\x2C\n    UV_DIRENT_SOCKET\x2C\n    UV_DIRENT_CHAR\x2C\n    UV_DIRENT_BLOCK\n  }\x2C\n  os: {\n    errno: {\n      EISDIR\n    }\n  }\n} = internalBinding('constants');\n\n// The access modes can be any of F_OK\x2C R_OK\x2C W_OK or X_OK. Some might not be\n// available on specific systems. They can be used in combination as well\n// (F_OK | R_OK | W_OK | X_OK).\nconst kMinimumAccessMode = MathMin(F_OK\x2C W_OK\x2C R_OK\x2C X_OK);\nconst kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;\n\nconst kDefaultCopyMode = 0;\n// The copy modes can be any of COPYFILE_EXCL\x2C COPYFILE_FICLONE or\n// COPYFILE_FICLONE_FORCE. They can be used in combination as well\n// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).\nconst kMinimumCopyMode = MathMin(\n  kDefaultCopyMode\x2C\n  COPYFILE_EXCL\x2C\n  COPYFILE_FICLONE\x2C\n  COPYFILE_FICLONE_FORCE\n);\nconst kMaximumCopyMode = COPYFILE_EXCL |\n                         COPYFILE_FICLONE |\n                         COPYFILE_FICLONE_FORCE;\n\n// Most platforms don't allow reads or writes >= 2 GB.\n// See https://github.com/libuv/libuv/pull/1501.\nconst kIoMaxLength = 2 ** 31 - 1;\n\n// Use 64kb in case the file type is not a regular file and thus do not know the\n// actual file size. Increasing the value further results in more frequent over\n// allocation for small files and consumes CPU time and memory that should be\n// used else wise.\n// Use up to 512kb per read otherwise to partition reading big files to prevent\n// blocking other threads in case the available threads are all in use.\nconst kReadFileUnknownBufferLength = 64 * 1024;\nconst kReadFileBufferLength = 512 * 1024;\n\nconst kWriteFileMaxChunkSize = 512 * 1024;\n\nconst kMaxUserId = 2 ** 32 - 1;\n\nconst isWindows = process.platform === 'win32';\n\nlet fs;\nfunction lazyLoadFs() {\n  if (!fs) {\n    fs = require('fs');\n  }\n  return fs;\n}\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    const reason = 'is invalid encoding';\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'encoding'\x2C reason);\n  }\n}\n\nclass Dirent {\n  constructor(name\x2C type) {\n    this.name = name;\n    this[kType] = type;\n  }\n\n  isDirectory() {\n    return this[kType] === UV_DIRENT_DIR;\n  }\n\n  isFile() {\n    return this[kType] === UV_DIRENT_FILE;\n  }\n\n  isBlockDevice() {\n    return this[kType] === UV_DIRENT_BLOCK;\n  }\n\n  isCharacterDevice() {\n    return this[kType] === UV_DIRENT_CHAR;\n  }\n\n  isSymbolicLink() {\n    return this[kType] === UV_DIRENT_LINK;\n  }\n\n  isFIFO() {\n    return this[kType] === UV_DIRENT_FIFO;\n  }\n\n  isSocket() {\n    return this[kType] === UV_DIRENT_SOCKET;\n  }\n}\n\nclass DirentFromStats extends Dirent {\n  constructor(name\x2C stats) {\n    super(name\x2C null);\n    this[kStats] = stats;\n  }\n}\n\nfor (const name of ReflectOwnKeys(Dirent.prototype)) {\n  if (name === 'constructor') {\n    continue;\n  }\n  DirentFromStats.prototype[name] = function() {\n    return this[kStats][name]();\n  };\n}\n\nfunction copyObject(source) {\n  const target = {};\n  for (const key in source)\n    target[key] = source[key];\n  return target;\n}\n\nconst bufferSep = Buffer.from(pathModule.sep);\n\nfunction join(path\x2C name) {\n  if ((typeof path === 'string' || isUint8Array(path)) &&\n      name === undefined) {\n    return path;\n  }\n\n  if (typeof path === 'string' && isUint8Array(name)) {\n    const pathBuffer = Buffer.from(pathModule.join(path\x2C pathModule.sep));\n    return Buffer.concat([pathBuffer\x2C name]);\n  }\n\n  if (typeof path === 'string' && typeof name === 'string') {\n    return pathModule.join(path\x2C name);\n  }\n\n  if (isUint8Array(path) && isUint8Array(name)) {\n    return Buffer.concat([path\x2C bufferSep\x2C name]);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'path'\x2C ['string'\x2C 'Buffer']\x2C path);\n}\n\nfunction getDirents(path\x2C { 0: names\x2C 1: types }\x2C callback) {\n  let i;\n  if (typeof callback === 'function') {\n    const len = names.length;\n    let toFinish = 0;\n    callback = once(callback);\n    for (i = 0; i < len; i++) {\n      const type = types[i];\n      if (type === UV_DIRENT_UNKNOWN) {\n        const name = names[i];\n        const idx = i;\n        toFinish++;\n        let filepath;\n        try {\n          filepath = join(path\x2C name);\n        } catch (err) {\n          callback(err);\n          return;\n        }\n        lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n          if (err) {\n            callback(err);\n            return;\n          }\n          names[idx] = new DirentFromStats(name\x2C stats);\n          if (--toFinish === 0) {\n            callback(null\x2C names);\n          }\n        });\n      } else {\n        names[i] = new Dirent(names[i]\x2C types[i]);\n      }\n    }\n    if (toFinish === 0) {\n      callback(null\x2C names);\n    }\n  } else {\n    const len = names.length;\n    for (i = 0; i < len; i++) {\n      names[i] = getDirent(path\x2C names[i]\x2C types[i]);\n    }\n    return names;\n  }\n}\n\nfunction getDirent(path\x2C name\x2C type\x2C callback) {\n  if (typeof callback === 'function') {\n    if (type === UV_DIRENT_UNKNOWN) {\n      let filepath;\n      try {\n        filepath = join(path\x2C name);\n      } catch (err) {\n        callback(err);\n        return;\n      }\n      lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        callback(null\x2C new DirentFromStats(name\x2C stats));\n      });\n    } else {\n      callback(null\x2C new Dirent(name\x2C type));\n    }\n  } else if (type === UV_DIRENT_UNKNOWN) {\n    const stats = lazyLoadFs().lstatSync(join(path\x2C name));\n    return new DirentFromStats(name\x2C stats);\n  } else {\n    return new Dirent(name\x2C type);\n  }\n}\n\nfunction getOptions(options\x2C defaultOptions) {\n  if (options === null || options === undefined ||\n      typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = { ...defaultOptions };\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C ['string'\x2C 'Object']\x2C options);\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n\n  if (options.signal !== undefined) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n  return options;\n}\n\n/**\n * @param {InternalFSBinding.FSSyncContext} ctx\n */\nfunction handleErrorFromBinding(ctx) {\n  if (ctx.errno !== undefined) {  // libuv error numbers\n    const err = uvException(ctx);\n    ErrorCaptureStackTrace(err\x2C handleErrorFromBinding);\n    throw err;\n  }\n  if (ctx.error !== undefined) {  // Errors created in C++ land.\n    // TODO(joyeecheung): currently\x2C ctx.error are encoding errors\n    // usually caused by memory problems. We need to figure out proper error\n    // code(s) for this.\n    ErrorCaptureStackTrace(ctx.error\x2C handleErrorFromBinding);\n    throw ctx.error;\n  }\n}\n\n// Check if the path contains null types if it is a string nor Uint8Array\x2C\n// otherwise return silently.\nconst nullCheck = hideStackFrames((path\x2C propName\x2C throwError = true) => {\n  const pathIsString = typeof path === 'string';\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if ((!pathIsString && !pathIsUint8Array) ||\n      (pathIsString && !StringPrototypeIncludes(path\x2C '\\u0000')) ||\n      (pathIsUint8Array && !TypedArrayPrototypeIncludes(path\x2C 0))) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(\n    propName\x2C\n    path\x2C\n    'must be a string or Uint8Array without null bytes'\n  );\n  if (throwError) {\n    throw err;\n  }\n  return err;\n});\n\nfunction preprocessSymlinkDestination(path\x2C type\x2C linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  }\n  path = '' + path;\n  if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath\x2C '..'\x2C path);\n    return pathModule.toNamespacedPath(path);\n  }\n  if (pathModule.isAbsolute(path)) {\n    // If the path is absolute\x2C use the \\\\?\\-prefix to enable long filenames\n    return pathModule.toNamespacedPath(path);\n  }\n  // Windows symlinks don't tolerate forward slashes.\n  return StringPrototypeReplace(path\x2C /\\//g\x2C '\\\\');\n}\n\n// Constructor for file stats.\nfunction StatsBase(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                   ino\x2C size\x2C blocks) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n}\n\nStatsBase.prototype.isDirectory = function() {\n  return this._checkModeProperty(S_IFDIR);\n};\n\nStatsBase.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStatsBase.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(S_IFBLK);\n};\n\nStatsBase.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(S_IFCHR);\n};\n\nStatsBase.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStatsBase.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStatsBase.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst kNsPerMsBigInt = 10n ** 6n;\nconst kNsPerSecBigInt = 10n ** 9n;\nconst kMsPerSec = 10 ** 3;\nconst kNsPerMs = 10 ** 6;\nfunction msFromTimeSpec(sec\x2C nsec) {\n  return sec * kMsPerSec + nsec / kNsPerMs;\n}\n\nfunction nsFromTimeSpecBigInt(sec\x2C nsec) {\n  return sec * kNsPerSecBigInt + nsec;\n}\n\n// The Date constructor performs Math.floor() to the timestamp.\n// https://www.ecma-international.org/ecma-262/#sec-timeclip\n// Since there may be a precision loss when the timestamp is\n// converted to a floating point number\x2C we manually round\n// the timestamp here before passing it to Date().\n// Refs: https://github.com/nodejs/node/pull/12607\nfunction dateFromMs(ms) {\n  return new Date(Number(ms) + 0.5);\n}\n\nfunction BigIntStats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                     ino\x2C size\x2C blocks\x2C\n                     atimeNs\x2C mtimeNs\x2C ctimeNs\x2C birthtimeNs) {\n  ReflectApply(StatsBase\x2C this\x2C [dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                                 ino\x2C size\x2C blocks]);\n\n  this.atimeMs = atimeNs / kNsPerMsBigInt;\n  this.mtimeMs = mtimeNs / kNsPerMsBigInt;\n  this.ctimeMs = ctimeNs / kNsPerMsBigInt;\n  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;\n  this.atimeNs = atimeNs;\n  this.mtimeNs = mtimeNs;\n  this.ctimeNs = ctimeNs;\n  this.birthtimeNs = birthtimeNs;\n  this.atime = dateFromMs(this.atimeMs);\n  this.mtime = dateFromMs(this.mtimeMs);\n  this.ctime = dateFromMs(this.ctimeMs);\n  this.birthtime = dateFromMs(this.birthtimeMs);\n}\n\nObjectSetPrototypeOf(BigIntStats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(BigIntStats\x2C StatsBase);\n\nBigIntStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & BigInt(S_IFMT)) === BigInt(property);\n};\n\nfunction Stats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n               ino\x2C size\x2C blocks\x2C\n               atimeMs\x2C mtimeMs\x2C ctimeMs\x2C birthtimeMs) {\n  FunctionPrototypeCall(StatsBase\x2C this\x2C dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C\n                        blksize\x2C ino\x2C size\x2C blocks);\n  this.atimeMs = atimeMs;\n  this.mtimeMs = mtimeMs;\n  this.ctimeMs = ctimeMs;\n  this.birthtimeMs = birthtimeMs;\n  this.atime = dateFromMs(atimeMs);\n  this.mtime = dateFromMs(mtimeMs);\n  this.ctime = dateFromMs(ctimeMs);\n  this.birthtime = dateFromMs(birthtimeMs);\n}\n\nObjectSetPrototypeOf(Stats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(Stats\x2C StatsBase);\n\n// HACK: Workaround for https://github.com/standard-things/esm/issues/821.\n// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.\nStats.prototype.isFile = StatsBase.prototype.isFile;\n\nStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & S_IFMT) === property;\n};\n\n/**\n * @param {Float64Array | BigUint64Array} stats\n * @param {number} offset\n * @returns {BigIntStats | Stats}\n */\nfunction getStatsFromBinding(stats\x2C offset = 0) {\n  if (isBigUint64Array(stats)) {\n    return new BigIntStats(\n      stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n      stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n      stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n      stats[9 + offset]\x2C\n      nsFromTimeSpecBigInt(stats[10 + offset]\x2C stats[11 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[12 + offset]\x2C stats[13 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[14 + offset]\x2C stats[15 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[16 + offset]\x2C stats[17 + offset])\n    );\n  }\n  return new Stats(\n    stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n    stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n    stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n    stats[9 + offset]\x2C\n    msFromTimeSpec(stats[10 + offset]\x2C stats[11 + offset])\x2C\n    msFromTimeSpec(stats[12 + offset]\x2C stats[13 + offset])\x2C\n    msFromTimeSpec(stats[14 + offset]\x2C stats[15 + offset])\x2C\n    msFromTimeSpec(stats[16 + offset]\x2C stats[17 + offset])\n  );\n}\n\nfunction stringToFlags(flags\x2C name = 'flags') {\n  if (typeof flags === 'number') {\n    validateInt32(flags\x2C name);\n    return flags;\n  }\n\n  if (flags == null) {\n    return O_RDONLY;\n  }\n\n  switch (flags) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // Fall through.\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // Fall through.\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // Fall through.\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // Fall through.\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // Fall through.\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n    case 'as' : // Fall through.\n    case 'sa' : return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // Fall through.\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n    case 'as+': // Fall through.\n    case 'sa+': return O_APPEND | O_CREAT | O_RDWR | O_SYNC;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('flags'\x2C flags);\n}\n\nconst stringToSymlinkType = hideStackFrames((type) => {\n  let flags = 0;\n  if (typeof type === 'string') {\n    switch (type) {\n      case 'dir':\n        flags |= UV_FS_SYMLINK_DIR;\n        break;\n      case 'junction':\n        flags |= UV_FS_SYMLINK_JUNCTION;\n        break;\n      case 'file':\n        break;\n      default:\n        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);\n    }\n  }\n  return flags;\n});\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time\x2C name = 'time') {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (NumberIsFinite(time)) {\n    if (time < 0) {\n      return DateNow() / 1000;\n    }\n    return time;\n  }\n  if (isDate(time)) {\n    // Convert to 123.456 UNIX timestamp\n    return DatePrototypeGetTime(time) / 1000;\n  }\n  throw new ERR_INVALID_ARG_TYPE(name\x2C ['Date'\x2C 'Time in seconds']\x2C time);\n}\n\nconst validateOffsetLengthRead = hideStackFrames(\n  (offset\x2C length\x2C bufferLength) => {\n    if (offset < 0) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C '>= 0'\x2C offset);\n    }\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n    if (offset + length > bufferLength) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C\n                                 `<= ${bufferLength - offset}`\x2C length);\n    }\n  }\n);\n\nconst validateOffsetLengthWrite = hideStackFrames(\n  (offset\x2C length\x2C byteLength) => {\n    if (offset > byteLength) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C `<= ${byteLength}`\x2C offset);\n    }\n\n    if (length > byteLength - offset) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C `<= ${byteLength - offset}`\x2C length);\n    }\n\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n\n    validateInt32(length\x2C 'length'\x2C 0);\n  }\n);\n\nconst validatePath = hideStackFrames((path\x2C propName = 'path') => {\n  if (typeof path !== 'string' && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C ['string'\x2C 'Buffer'\x2C 'URL']\x2C path);\n  }\n\n  const err = nullCheck(path\x2C propName\x2C false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n});\n\nconst getValidatedPath = hideStackFrames((fileURLOrPath\x2C propName = 'path') => {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path\x2C propName);\n  return path;\n});\n\nconst getValidatedFd = hideStackFrames((fd\x2C propName = 'fd') => {\n  if (ObjectIs(fd\x2C -0)) {\n    return 0;\n  }\n\n  validateInt32(fd\x2C propName\x2C 0);\n\n  return fd;\n});\n\nconst validateBufferArray = hideStackFrames((buffers\x2C propName = 'buffers') => {\n  if (!ArrayIsArray(buffers))\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n\n  for (let i = 0; i < buffers.length; i++) {\n    if (!isArrayBufferView(buffers[i]))\n      throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n  }\n\n  return buffers;\n});\n\nlet nonPortableTemplateWarn = true;\n\nfunction warnOnNonPortableTemplate(template) {\n  // Template strings passed to the mkdtemp() family of functions should not\n  // end with 'X' because they are handled inconsistently across platforms.\n  if (nonPortableTemplateWarn && StringPrototypeEndsWith(template\x2C 'X')) {\n    process.emitWarning('mkdtemp() templates ending with X are not portable. ' +\n                        'For details see: https://nodejs.org/api/fs.html');\n    nonPortableTemplateWarn = false;\n  }\n}\n\nconst defaultCpOptions = {\n  dereference: false\x2C\n  errorOnExist: false\x2C\n  filter: undefined\x2C\n  force: true\x2C\n  preserveTimestamps: false\x2C\n  recursive: false\x2C\n  verbatimSymlinks: false\x2C\n};\n\nconst defaultRmOptions = {\n  recursive: false\x2C\n  force: false\x2C\n  retryDelay: 100\x2C\n  maxRetries: 0\n};\n\nconst defaultRmdirOptions = {\n  retryDelay: 100\x2C\n  maxRetries: 0\x2C\n  recursive: false\x2C\n};\n\nconst validateCpOptions = hideStackFrames((options) => {\n  if (options === undefined)\n    return { ...defaultCpOptions };\n  validateObject(options\x2C 'options');\n  options = { ...defaultCpOptions\x2C ...options };\n  validateBoolean(options.dereference\x2C 'options.dereference');\n  validateBoolean(options.errorOnExist\x2C 'options.errorOnExist');\n  validateBoolean(options.force\x2C 'options.force');\n  validateBoolean(options.preserveTimestamps\x2C 'options.preserveTimestamps');\n  validateBoolean(options.recursive\x2C 'options.recursive');\n  validateBoolean(options.verbatimSymlinks\x2C 'options.verbatimSymlinks');\n  if (options.dereference === true && options.verbatimSymlinks === true) {\n    throw new ERR_INCOMPATIBLE_OPTION_PAIR('dereference'\x2C 'verbatimSymlinks');\n  }\n  if (options.filter !== undefined) {\n    validateFunction(options.filter\x2C 'options.filter');\n  }\n  return options;\n});\n\nconst validateRmOptions = hideStackFrames((path\x2C options\x2C expectDir\x2C cb) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  lazyLoadFs().stat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (options.force && err.code === 'ENOENT') {\n        return cb(null\x2C options);\n      }\n      return cb(err\x2C options);\n    }\n\n    if (expectDir && !stats.isDirectory()) {\n      return cb(false);\n    }\n\n    if (stats.isDirectory() && !options.recursive) {\n      return cb(new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\n      }));\n    }\n    return cb(null\x2C options);\n  });\n});\n\nconst validateRmOptionsSync = hideStackFrames((path\x2C options\x2C expectDir) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  if (!options.force || expectDir || !options.recursive) {\n    const isDirectory = lazyLoadFs()\n      .statSync(path\x2C { throwIfNoEntry: !options.force })?.isDirectory();\n\n    if (expectDir && !isDirectory) {\n      return false;\n    }\n\n    if (isDirectory && !options.recursive) {\n      throw new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\n      });\n    }\n  }\n\n  return options;\n});\n\nlet recursiveRmdirWarned = process.noDeprecation;\nfunction emitRecursiveRmdirWarning() {\n  if (!recursiveRmdirWarned) {\n    process.emitWarning(\n      'In future versions of Node.js\x2C fs.rmdir(path\x2C { recursive: true }) ' +\n      'will be removed. Use fs.rm(path\x2C { recursive: true }) instead'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0147'\n    );\n    recursiveRmdirWarned = true;\n  }\n}\n\nconst validateRmdirOptions = hideStackFrames(\n  (options\x2C defaults = defaultRmdirOptions) => {\n    if (options === undefined)\n      return defaults;\n    validateObject(options\x2C 'options');\n\n    options = { ...defaults\x2C ...options };\n\n    validateBoolean(options.recursive\x2C 'options.recursive');\n    validateInt32(options.retryDelay\x2C 'options.retryDelay'\x2C 0);\n    validateUint32(options.maxRetries\x2C 'options.maxRetries');\n\n    return options;\n  });\n\nconst getValidMode = hideStackFrames((mode\x2C type) => {\n  let min = kMinimumAccessMode;\n  let max = kMaximumAccessMode;\n  let def = F_OK;\n  if (type === 'copyFile') {\n    min = kMinimumCopyMode;\n    max = kMaximumCopyMode;\n    def = mode || kDefaultCopyMode;\n  } else {\n    assert(type === 'access');\n  }\n  if (mode == null) {\n    return def;\n  }\n  if (NumberIsInteger(mode) && mode >= min && mode <= max) {\n    return mode;\n  }\n  if (typeof mode !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE('mode'\x2C 'integer'\x2C mode);\n  }\n  throw new ERR_OUT_OF_RANGE(\n    'mode'\x2C `an integer >= ${min} && <= ${max}`\x2C mode);\n});\n\nconst validateStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer === 'string') {\n    return;\n  }\n\n  if (\n    typeof buffer === 'object' &&\n    buffer !== null &&\n    typeof buffer.toString === 'function' &&\n    ObjectPrototypeHasOwnProperty(buffer\x2C 'toString')\n  ) {\n    return;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    name\x2C\n    ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n    buffer\n  );\n});\n\nconst validatePosition = hideStackFrames((position\x2C name) => {\n  if (typeof position === 'number') {\n    validateInteger(position\x2C 'position');\n  } else if (typeof position === 'bigint') {\n    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {\n      throw new ERR_OUT_OF_RANGE('position'\x2C\n                                 `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`\x2C\n                                 position);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('position'\x2C\n                                   ['integer'\x2C 'bigint']\x2C\n                                   position);\n  }\n});\n\nmodule.exports = {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  assertEncoding\x2C\n  BigIntStats\x2C  // for testing\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirent\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  realpathCacheKey: Symbol('realpathCacheKey')\x2C\n  getStatsFromBinding\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  Stats\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n};\n
code-source-info,0x26b72db25336,82,7252,7875,C0O7282C14O7374C16O7396C17O7404C23O7443C29O7487C31O7511C35O7526C42O7561C48O7600C66O7606C71O7600C72O7693C79O7702C84O7720C87O7743C92O7720C96O7769C102O7797C107O7825C115O7797C120O7858C122O7873,,
code-creation,LazyCompile,10,55959,0x26b72db272be,48,assertEncoding node:internal/fs/utils:152:24,0xd2efcc3e798,~
code-source-info,0x26b72db272be,82,3561,3738,C0O3576C6O3593C9O3600C14O3600C21O3643C24O3670C40O3676C45O3670C47O3737,,
tick,0x10035a64c,56000,0,0x0,3,0x0,0x26b72db1ec22,0x26b72db1e821,0x26b72db1e6e3,0x26b72db1e59d,0x26b72db1dfa4,0x26b72db1c2cc,0x26b72db1af70,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,LazyCompile,10,56042,0x26b72db273d6,20,toPathIfFileURL node:internal/url:1559:25,0x815de62d9e0,~
script-source,39,node:internal/url,'use strict';\n\nconst {\n  Array\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  FunctionPrototypeBind\x2C\n  Int8Array\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ReflectApply\x2C\n  ReflectGetOwnPropertyDescriptor\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { inspect } = require('internal/util/inspect');\nconst {\n  encodeStr\x2C\n  hexTable\x2C\n  isHexTable\n} = require('internal/querystring');\n\nconst {\n  getConstructorOf\x2C\n  removeColors\x2C\n  toUSVString\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_ARG_NOT_ITERABLE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FILE_URL_HOST\x2C\n    ERR_INVALID_FILE_URL_PATH\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_INVALID_TUPLE\x2C\n    ERR_INVALID_URL\x2C\n    ERR_INVALID_URL_SCHEME\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_NO_CRYPTO\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  CHAR_AMPERSAND\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_EQUAL\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_PERCENT\x2C\n  CHAR_PLUS\n} = require('internal/constants');\nconst path = require('path');\n\nconst {\n  validateCallback\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst querystring = require('querystring');\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst {\n  domainToASCII: _domainToASCII\x2C\n  domainToUnicode: _domainToUnicode\x2C\n  encodeAuth\x2C\n  parse\x2C\n  setURLConstructor\x2C\n  URL_FLAGS_CANNOT_BE_BASE\x2C\n  URL_FLAGS_HAS_FRAGMENT\x2C\n  URL_FLAGS_HAS_HOST\x2C\n  URL_FLAGS_HAS_PASSWORD\x2C\n  URL_FLAGS_HAS_PATH\x2C\n  URL_FLAGS_HAS_QUERY\x2C\n  URL_FLAGS_HAS_USERNAME\x2C\n  URL_FLAGS_IS_DEFAULT_SCHEME_PORT\x2C\n  URL_FLAGS_SPECIAL\x2C\n  kFragment\x2C\n  kHost\x2C\n  kHostname\x2C\n  kPathStart\x2C\n  kPort\x2C\n  kQuery\x2C\n  kSchemeStart\n} = internalBinding('url');\n\nconst {\n  storeDataObject\x2C\n  revokeDataObject\x2C\n} = internalBinding('blob');\n\nconst context = Symbol('context');\nconst cannotBeBase = Symbol('cannot-be-base');\nconst cannotHaveUsernamePasswordPort =\n    Symbol('cannot-have-username-password-port');\nconst special = Symbol('special');\nconst searchParams = Symbol('query');\nconst kFormat = Symbol('format');\n\nlet blob;\nlet cryptoRandom;\n\nfunction lazyBlob() {\n  blob ??= require('internal/blob');\n  return blob;\n}\n\nfunction lazyCryptoRandom() {\n  try {\n    cryptoRandom ??= require('internal/crypto/random');\n  } catch {\n    // If Node.js built without crypto support\x2C we'll fall\n    // through here and handle it later.\n  }\n  return cryptoRandom;\n}\n\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nconst IteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf([][SymbolIterator]())\n);\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-opaque\nconst kOpaqueOrigin = 'null';\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin\nfunction serializeTupleOrigin(scheme\x2C host\x2C port) {\n  return `${scheme}//${host}${port === null ? '' : `:${port}`}`;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard\x2C with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  constructor() {\n    this.flags = 0;\n    this.scheme = ':';\n    this.username = '';\n    this.password = '';\n    this.host = null;\n    this.port = null;\n    this.path = [];\n    this.query = null;\n    this.fragment = null;\n  }\n}\n\nfunction isURLSearchParams(self) {\n  return self && self[searchParams] && !self[searchParams][searchParams];\n}\n\nclass URLSearchParams {\n  // URL Standard says the default value is ''\x2C but as undefined and '' have\n  // the same result\x2C undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init === null || init === undefined) {\n      this[searchParams] = [];\n    } else if (typeof init === 'object' || typeof init === 'function') {\n      const method = init[SymbolIterator];\n      if (method === this[SymbolIterator]) {\n        // While the spec does not have this branch\x2C we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') {\n          throw new ERR_ARG_NOT_ITERABLE('Query pairs');\n        }\n\n        // Sequence<sequence<USVString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if ((typeof pair !== 'object' && typeof pair !== 'function') ||\n              pair === null ||\n              typeof pair[SymbolIterator] !== 'function') {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          }\n          const convertedPair = [];\n          for (const element of pair)\n            ArrayPrototypePush(convertedPair\x2C toUSVString(element));\n          ArrayPrototypePush(pairs\x2C convertedPair);\n        }\n\n        this[searchParams] = [];\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          }\n          ArrayPrototypePush(this[searchParams]\x2C pair[0]\x2C pair[1]);\n        }\n      } else {\n        // Record<USVString\x2C USVString>\n        // Need to use reflection APIs for full spec compliance.\n        const visited = {};\n        this[searchParams] = [];\n        const keys = ReflectOwnKeys(init);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const desc = ReflectGetOwnPropertyDescriptor(init\x2C key);\n          if (desc !== undefined && desc.enumerable) {\n            const typedKey = toUSVString(key);\n            const typedValue = toUSVString(init[key]);\n\n            // Two different key may result same after `toUSVString()`\x2C we only\n            // leave the later one. Refers to WPT.\n            if (visited[typedKey] !== undefined) {\n              this[searchParams][visited[typedKey]] = typedValue;\n            } else {\n              visited[typedKey] = ArrayPrototypePush(this[searchParams]\x2C\n                                                     typedKey\x2C\n                                                     typedValue) - 1;\n            }\n          }\n        }\n      }\n    } else {\n      // USVString\n      init = toUSVString(init);\n      if (init[0] === '?') init = init.slice(1);\n      initSearchParams(this\x2C init);\n    }\n\n    // "associated url object"\n    this[context] = null;\n  }\n\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const separator = '\x2C ';\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const innerInspect = (v) => inspect(v\x2C innerOpts);\n\n    const list = this[searchParams];\n    const output = [];\n    for (let i = 0; i < list.length; i += 2)\n      ArrayPrototypePush(\n        output\x2C\n        `${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    const length = ArrayPrototypeReduce(\n      output\x2C\n      (prev\x2C cur) => prev + removeColors(cur).length + separator.length\x2C\n      -separator.length\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n` +\n      `  ${ArrayPrototypeJoin(output\x2C '\x2C\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ` +\n      `${ArrayPrototypeJoin(output\x2C separator)} }`;\n    }\n    return `${this.constructor.name} {}`;\n  }\n\n  append(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    ArrayPrototypePush(this[searchParams]\x2C name\x2C value);\n    update(this[context]\x2C this);\n  }\n\n  delete(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        list.splice(i\x2C 2);\n      } else {\n        i += 2;\n      }\n    }\n    update(this[context]\x2C this);\n  }\n\n  get(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  }\n\n  getAll(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  }\n\n  has(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  set(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`\x2C in `list`\x2C set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    let found = false;\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i\x2C 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise\x2C append a new name-value pair whose name is `name` and value\n    // is `value`\x2C to `list`.\n    if (!found) {\n      ArrayPrototypePush(list\x2C name\x2C value);\n    }\n\n    update(this[context]\x2C this);\n  }\n\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n\n    if (len <= 2) {\n      // Nothing needs to be done.\n    } else if (len < 100) {\n      // 100 is found through testing.\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (let i = 2; i < len; i += 2) {\n        const curKey = a[i];\n        const curVal = a[i + 1];\n        let j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (let step = 2; step < len; step *= 2) {\n        for (let start = 0; start < len - 2; start += 2 * step) {\n          const mid = start + step;\n          let end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer);\n        }\n      }\n    }\n\n    update(this[context]\x2C this);\n  }\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key+value');\n  }\n\n  forEach(callback\x2C thisArg = undefined) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    validateCallback(callback);\n\n    let list = this[searchParams];\n\n    let i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg\x2C value\x2C key\x2C this);\n      // In case the URL object's `search` is updated\n      list = this[searchParams];\n      i += 2;\n    }\n  }\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key');\n  }\n\n  values() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'value');\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return serializeParams(this[searchParams]);\n  }\n}\n\nObjectDefineProperties(URLSearchParams.prototype\x2C {\n  append: kEnumerableProperty\x2C\n  delete: kEnumerableProperty\x2C\n  get: kEnumerableProperty\x2C\n  getAll: kEnumerableProperty\x2C\n  has: kEnumerableProperty\x2C\n  set: kEnumerableProperty\x2C\n  sort: kEnumerableProperty\x2C\n  entries: kEnumerableProperty\x2C\n  forEach: kEnumerableProperty\x2C\n  keys: kEnumerableProperty\x2C\n  values: kEnumerableProperty\x2C\n  toString: kEnumerableProperty\x2C\n  [SymbolToStringTag]: { configurable: true\x2C value: 'URLSearchParams' }\x2C\n\n  // https://heycam.github.io/webidl/#es-iterable-entries\n  [SymbolIterator]: {\n    configurable: true\x2C\n    writable: true\x2C\n    value: URLSearchParams.prototype.entries\x2C\n  }\x2C\n});\n\nfunction onParseComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                         host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  if (!this[searchParams]) { // Invoked from URL constructor\n    this[searchParams] = new URLSearchParams();\n    this[searchParams][context] = this;\n  }\n  initSearchParams(this[searchParams]\x2C query);\n}\n\nfunction onParseError(flags\x2C input) {\n  throw new ERR_INVALID_URL(input);\n}\n\nfunction onParseProtocolComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_SPECIAL) !== 0) {\n    ctx.flags |= URL_FLAGS_SPECIAL;\n  } else {\n    ctx.flags &= ~URL_FLAGS_SPECIAL;\n  }\n  ctx.scheme = protocol;\n  ctx.port = port;\n}\n\nfunction onParseHostnameComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParsePortComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].port = port;\n}\n\nfunction onParseHostComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  ReflectApply(onParseHostnameComplete\x2C this\x2C arguments);\n  if (port !== null || ((flags & URL_FLAGS_IS_DEFAULT_SCHEME_PORT) !== 0))\n    ReflectApply(onParsePortComplete\x2C this\x2C arguments);\n}\n\nfunction onParsePathComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_PATH) !== 0) {\n    ctx.path = path;\n    ctx.flags |= URL_FLAGS_HAS_PATH;\n  } else {\n    ctx.path = [];\n    ctx.flags &= ~URL_FLAGS_HAS_PATH;\n  }\n\n  // The C++ binding may set host to empty string.\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParseSearchComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                               host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].query = query;\n}\n\nfunction onParseHashComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].fragment = fragment;\n}\n\nfunction isURLThis(self) {\n  return (self !== undefined && self !== null && self[context] !== undefined);\n}\n\nclass URL {\n  constructor(input\x2C base = undefined) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    let base_context;\n    if (base !== undefined) {\n      base_context = new URL(base)[context];\n    }\n    this[context] = new URLContext();\n    parse(input\x2C -1\x2C base_context\x2C undefined\x2C\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C onParseError);\n  }\n\n  get [special]() {\n    return (this[context].flags & URL_FLAGS_SPECIAL) !== 0;\n  }\n\n  get [cannotBeBase]() {\n    return (this[context].flags & URL_FLAGS_CANNOT_BE_BASE) !== 0;\n  }\n\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n  get [cannotHaveUsernamePasswordPort]() {\n    const { host\x2C scheme } = this[context];\n    return ((host == null || host === '') ||\n            this[cannotBeBase] ||\n            scheme === 'file:');\n  }\n\n  [inspect.custom](depth\x2C opts) {\n    if (this == null ||\n        ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new ERR_INVALID_THIS('URL');\n    }\n\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || URL;\n    const obj = ObjectCreate({ constructor });\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj.cannotBeBase = this[cannotBeBase];\n      obj.special = this[special];\n      obj[context] = this[context];\n    }\n\n    return `${constructor.name} ${inspect(obj\x2C opts)}`;\n  }\n\n  [kFormat](options) {\n    if (options)\n      validateObject(options\x2C 'options');\n\n    options = {\n      fragment: true\x2C\n      unicode: false\x2C\n      search: true\x2C\n      auth: true\x2C\n      ...options\n    };\n    const ctx = this[context];\n    // https://url.spec.whatwg.org/#url-serializing\n    let ret = ctx.scheme;\n    if (ctx.host !== null) {\n      ret += '//';\n      const has_username = ctx.username !== '';\n      const has_password = ctx.password !== '';\n      if (options.auth && (has_username || has_password)) {\n        if (has_username)\n          ret += ctx.username;\n        if (has_password)\n          ret += `:${ctx.password}`;\n        ret += '@';\n      }\n      ret += options.unicode ?\n        domainToUnicode(ctx.host) : ctx.host;\n      if (ctx.port !== null)\n        ret += `:${ctx.port}`;\n    }\n    if (this[cannotBeBase]) {\n      ret += ctx.path[0];\n    } else {\n      if (ctx.host === null && ctx.path.length > 1 && ctx.path[0] === '') {\n        ret += '/.';\n      }\n      if (ctx.path.length) {\n        ret += '/' + ArrayPrototypeJoin(ctx.path\x2C '/');\n      }\n    }\n    if (options.search && ctx.query !== null)\n      ret += `?${ctx.query}`;\n    if (options.fragment && ctx.fragment !== null)\n      ret += `#${ctx.fragment}`;\n    return ret;\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  toString() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[kFormat]({});\n  }\n\n  get href() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[kFormat]({});\n  }\n\n  set href(input) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    input = `${input}`;\n    parse(input\x2C -1\x2C undefined\x2C undefined\x2C\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C onParseError);\n  }\n\n  // readonly\n  get origin() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // Refs: https://url.spec.whatwg.org/#concept-url-origin\n    const ctx = this[context];\n    switch (ctx.scheme) {\n      case 'blob:':\n        if (ctx.path.length > 0) {\n          try {\n            return (new URL(ctx.path[0])).origin;\n          } catch {\n            // Fall through... do nothing\n          }\n        }\n        return kOpaqueOrigin;\n      case 'ftp:':\n      case 'http:':\n      case 'https:':\n      case 'ws:':\n      case 'wss:':\n        return serializeTupleOrigin(ctx.scheme\x2C ctx.host\x2C ctx.port);\n    }\n    return kOpaqueOrigin;\n  }\n\n  get protocol() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].scheme;\n  }\n\n  set protocol(scheme) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    scheme = `${scheme}`;\n    if (scheme.length === 0)\n      return;\n    const ctx = this[context];\n    parse(scheme\x2C kSchemeStart\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseProtocolComplete\x2C this));\n  }\n\n  get username() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].username;\n  }\n\n  set username(username) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    username = `${username}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (username === '') {\n      ctx.username = '';\n      ctx.flags &= ~URL_FLAGS_HAS_USERNAME;\n      return;\n    }\n    ctx.username = encodeAuth(username);\n    ctx.flags |= URL_FLAGS_HAS_USERNAME;\n  }\n\n  get password() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].password;\n  }\n\n  set password(password) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    password = `${password}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (password === '') {\n      ctx.password = '';\n      ctx.flags &= ~URL_FLAGS_HAS_PASSWORD;\n      return;\n    }\n    ctx.password = encodeAuth(password);\n    ctx.flags |= URL_FLAGS_HAS_PASSWORD;\n  }\n\n  get host() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    let ret = ctx.host || '';\n    if (ctx.port !== null)\n      ret += `:${ctx.port}`;\n    return ret;\n  }\n\n  set host(host) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    // toUSVString is not needed.\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      // Cannot set the host if cannot-be-base is set\n      return;\n    }\n    parse(host\x2C kHost\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseHostComplete\x2C this));\n  }\n\n  get hostname() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].host || '';\n  }\n\n  set hostname(host) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    // toUSVString is not needed.\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      // Cannot set the host if cannot-be-base is set\n      return;\n    }\n    parse(host\x2C kHostname\x2C null\x2C ctx\x2C onParseHostnameComplete.bind(this));\n  }\n\n  get port() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const port = this[context].port;\n    return port === null ? '' : String(port);\n  }\n\n  set port(port) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    port = `${port}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (port === '') {\n      ctx.port = null;\n      return;\n    }\n    parse(port\x2C kPort\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParsePortComplete\x2C this));\n  }\n\n  get pathname() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    if (this[cannotBeBase])\n      return ctx.path[0];\n    if (ctx.path.length === 0)\n      return '';\n    return `/${ArrayPrototypeJoin(ctx.path\x2C '/')}`;\n  }\n\n  set pathname(path) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    path = `${path}`;\n    if (this[cannotBeBase])\n      return;\n    parse(path\x2C kPathStart\x2C null\x2C this[context]\x2C\n          onParsePathComplete.bind(this));\n  }\n\n  get search() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const { query } = this[context];\n    if (query === null || query === '')\n      return '';\n    return `?${query}`;\n  }\n\n  set search(search) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    search = toUSVString(search);\n    if (search === '') {\n      ctx.query = null;\n      ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n    } else {\n      if (search[0] === '?') search = StringPrototypeSlice(search\x2C 1);\n      ctx.query = '';\n      ctx.flags |= URL_FLAGS_HAS_QUERY;\n      if (search) {\n        parse(search\x2C kQuery\x2C null\x2C ctx\x2C\n              FunctionPrototypeBind(onParseSearchComplete\x2C this));\n      }\n    }\n    initSearchParams(this[searchParams]\x2C search);\n  }\n\n  // readonly\n  get searchParams() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[searchParams];\n  }\n\n  get hash() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const { fragment } = this[context];\n    if (fragment === null || fragment === '')\n      return '';\n    return `#${fragment}`;\n  }\n\n  set hash(hash) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    // toUSVString is not needed.\n    hash = `${hash}`;\n    if (!hash) {\n      ctx.fragment = null;\n      ctx.flags &= ~URL_FLAGS_HAS_FRAGMENT;\n      return;\n    }\n    if (hash[0] === '#') hash = StringPrototypeSlice(hash\x2C 1);\n    ctx.fragment = '';\n    ctx.flags |= URL_FLAGS_HAS_FRAGMENT;\n    parse(hash\x2C kFragment\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseHashComplete\x2C this));\n  }\n\n  toJSON() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[kFormat]({});\n  }\n\n  static createObjectURL(obj) {\n    const cryptoRandom = lazyCryptoRandom();\n    if (cryptoRandom === undefined)\n      throw new ERR_NO_CRYPTO();\n\n    // Yes\x2C lazy loading is annoying but because of circular\n    // references between the url\x2C internal/blob\x2C and buffer\n    // modules\x2C lazy loading here makes sure that things work.\n    const blob = lazyBlob();\n    if (!blob.isBlob(obj))\n      throw new ERR_INVALID_ARG_TYPE('obj'\x2C 'Blob'\x2C obj);\n\n    const id = cryptoRandom.randomUUID();\n\n    storeDataObject(id\x2C obj[blob.kHandle]\x2C obj.size\x2C obj.type);\n\n    return `blob:nodedata:${id}`;\n  }\n\n  static revokeObjectURL(url) {\n    url = `${url}`;\n    try {\n      const parsed = new URL(url);\n      const split = StringPrototypeSplit(parsed.pathname\x2C ':');\n      if (split.length === 2)\n        revokeDataObject(split[1]);\n    } catch {\n      // If there's an error\x2C it's ignored.\n    }\n  }\n}\n\nObjectDefineProperties(URL.prototype\x2C {\n  [kFormat]: { configurable: false\x2C writable: false }\x2C\n  [SymbolToStringTag]: { configurable: true\x2C value: 'URL' }\x2C\n  toString: kEnumerableProperty\x2C\n  href: kEnumerableProperty\x2C\n  origin: kEnumerableProperty\x2C\n  protocol: kEnumerableProperty\x2C\n  username: kEnumerableProperty\x2C\n  password: kEnumerableProperty\x2C\n  host: kEnumerableProperty\x2C\n  hostname: kEnumerableProperty\x2C\n  port: kEnumerableProperty\x2C\n  pathname: kEnumerableProperty\x2C\n  search: kEnumerableProperty\x2C\n  searchParams: kEnumerableProperty\x2C\n  hash: kEnumerableProperty\x2C\n  toJSON: kEnumerableProperty\x2C\n});\n\nfunction update(url\x2C params) {\n  if (!url)\n    return;\n\n  const ctx = url[context];\n  const serializedParams = params.toString();\n  if (serializedParams) {\n    ctx.query = serializedParams;\n    ctx.flags |= URL_FLAGS_HAS_QUERY;\n  } else {\n    ctx.query = null;\n    ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n  }\n}\n\nfunction initSearchParams(url\x2C init) {\n  if (!init) {\n    url[searchParams] = [];\n    return;\n  }\n  url[searchParams] = parseParams(init);\n}\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  let pairStart = 0;\n  let lastPos = 0;\n  let seenSep = false;\n  let buf = '';\n  let encoded = false;\n  let encodeCheck = 0;\n  let i;\n  for (i = 0; i < qs.length; ++i) {\n    const code = StringPrototypeCharCodeAt(qs\x2C i);\n\n    // Try matching key/value pair separator\n    if (code === CHAR_AMPERSAND) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key\x2C add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === CHAR_EQUAL) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === CHAR_PLUS) {\n      if (lastPos < i)\n        buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === CHAR_PERCENT) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        if (isHexTable[code] === 1) {\n          if (++encodeCheck === 3) {\n            encoded = true;\n          }\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  ArrayPrototypePush(out\x2C buf);\n\n  // If `buf` is the key\x2C add an empty value.\n  if (!seenSep)\n    ArrayPrototypePush(out\x2C '');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = new Int8Array([\n/*\n  0\x2C 1\x2C 2\x2C 3\x2C 4\x2C 5\x2C 6\x2C 7\x2C 8\x2C 9\x2C A\x2C B\x2C C\x2C D\x2C E\x2C F\n*/\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x00 - 0x0F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x10 - 0x1F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C 0\x2C 0\x2C 1\x2C 1\x2C 0\x2C // 0x20 - 0x2F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x30 - 0x3F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x40 - 0x4F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C // 0x50 - 0x5F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x60 - 0x6F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C  // 0x70 - 0x7F\n]);\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  const firstEncodedParam = encodeStr(array[0]\x2C noEscape\x2C paramHexTable);\n  const firstEncodedValue = encodeStr(array[1]\x2C noEscape\x2C paramHexTable);\n  let output = `${firstEncodedParam}=${firstEncodedValue}`;\n\n  for (let i = 2; i < len; i += 2) {\n    const encodedParam = encodeStr(array[i]\x2C noEscape\x2C paramHexTable);\n    const encodedValue = encodeStr(array[i + 1]\x2C noEscape\x2C paramHexTable);\n    output += `&${encodedParam}=${encodedValue}`;\n  }\n\n  return output;\n}\n\n// Mainly to mitigate func-name-matching ESLint rule\nfunction defineIDLClass(proto\x2C classStr\x2C obj) {\n  // https://heycam.github.io/webidl/#dfn-class-string\n  ObjectDefineProperty(proto\x2C SymbolToStringTag\x2C {\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: classStr\n  });\n\n  // https://heycam.github.io/webidl/#es-operations\n  for (const key of ObjectKeys(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      writable: true\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: obj[key]\n    });\n  }\n  for (const key of ObjectGetOwnPropertySymbols(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: obj[key]\n    });\n  }\n}\n\n// for merge sort\nfunction merge(out\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  let l\x2C r\x2C o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\nfunction createSearchParamsIterator(target\x2C kind) {\n  const iterator = ObjectCreate(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target\x2C\n    kind\x2C\n    index: 0\n  };\n  return iterator;\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\nconst URLSearchParamsIteratorPrototype = ObjectCreate(IteratorPrototype);\n\ndefineIDLClass(URLSearchParamsIteratorPrototype\x2C 'URLSearchParams Iterator'\x2C {\n  next() {\n    if (!this ||\n        ObjectGetPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n    }\n\n    const {\n      target\x2C\n      kind\x2C\n      index\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined\x2C\n        done: true\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n\n    let result;\n    if (kind === 'key') {\n      result = name;\n    } else if (kind === 'value') {\n      result = value;\n    } else {\n      result = [name\x2C value];\n    }\n\n    return {\n      value: result\x2C\n      done: false\n    };\n  }\x2C\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target\x2C\n      kind\x2C\n      index\n    } = this[context];\n    const output = ArrayPrototypeReduce(\n      ArrayPrototypeSlice(target[searchParams]\x2C index)\x2C\n      (prev\x2C cur\x2C i) => {\n        const key = i % 2 === 0;\n        if (kind === 'key' && key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'value' && !key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'key+value' && !key) {\n          ArrayPrototypePush(prev\x2C [target[searchParams][index + i - 1]\x2C cur]);\n        }\n        return prev;\n      }\x2C\n      []\n    );\n    const breakLn = inspect(output\x2C innerOpts).includes('\\n');\n    const outputStrs = ArrayPrototypeMap(output\x2C (p) => inspect(p\x2C innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${ArrayPrototypeJoin(outputStrs\x2C '\x2C\\n  ')}`;\n    } else {\n      outputStr = ` ${ArrayPrototypeJoin(outputStrs\x2C '\x2C ')}`;\n    }\n    return `${this[SymbolToStringTag]} {${outputStr} }`;\n  }\n});\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToUnicode(`${domain}`);\n}\n\n// Utility function that converts a URL object into an ordinary\n// options object as expected by the http.request and https.request\n// APIs.\nfunction urlToHttpOptions(url) {\n  const options = {\n    protocol: url.protocol\x2C\n    hostname: typeof url.hostname === 'string' &&\n              StringPrototypeStartsWith(url.hostname\x2C '[') ?\n      StringPrototypeSlice(url.hostname\x2C 1\x2C -1) :\n      url.hostname\x2C\n    hash: url.hash\x2C\n    search: url.search\x2C\n    pathname: url.pathname\x2C\n    path: `${url.pathname || ''}${url.search || ''}`\x2C\n    href: url.href\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;\n  }\n  return options;\n}\n\nconst forwardSlashRegEx = /\\//g;\n\nfunction getPathFromURLWin32(url) {\n  const hostname = url.hostname;\n  let pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded \\\\ or / characters'\n        );\n      }\n    }\n  }\n  pathname = pathname.replace(forwardSlashRegEx\x2C '\\\\');\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set\x2C then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\n  }\n  // Otherwise\x2C it's a local path that requires a drive letter\n  const letter = pathname.codePointAt(1) | 0x20;\n  const sep = pathname[2];\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z ||   // a..z A..Z\n      (sep !== ':')) {\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute');\n  }\n  return pathname.slice(1);\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    throw new ERR_INVALID_FILE_URL_HOST(platform);\n  }\n  const pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded / characters'\n        );\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction fileURLToPath(path) {\n  if (typeof path === 'string')\n    path = new URL(path);\n  else if (!isURLInstance(path))\n    throw new ERR_INVALID_ARG_TYPE('path'\x2C ['string'\x2C 'URL']\x2C path);\n  if (path.protocol !== 'file:')\n    throw new ERR_INVALID_URL_SCHEME('file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\n// The following characters are percent-encoded when converting from file path\n// to URL:\n// - %: The percent character is the only character not encoded by the\n//        `pathname` setter.\n// - \\: Backslash is encoded on non-windows platforms since it's a valid\n//      character but the `pathname` setters replaces it by a forward slash.\n// - LF: The newline character is stripped out by the `pathname` setter.\n//       (See whatwg/url#419)\n// - CR: The carriage return character is also stripped out by the `pathname`\n//       setter.\n// - TAB: The tab character is also stripped out by the `pathname` setter.\nconst percentRegEx = /%/g;\nconst backslashRegEx = /\\\\/g;\nconst newlineRegEx = /\\n/g;\nconst carriageReturnRegEx = /\\r/g;\nconst tabRegEx = /\\t/g;\n\nfunction encodePathChars(filepath) {\n  if (StringPrototypeIncludes(filepath\x2C '%'))\n    filepath = StringPrototypeReplace(filepath\x2C percentRegEx\x2C '%25');\n  // In posix\x2C backslash is a valid character in paths:\n  if (!isWindows && StringPrototypeIncludes(filepath\x2C '\\\\'))\n    filepath = StringPrototypeReplace(filepath\x2C backslashRegEx\x2C '%5C');\n  if (StringPrototypeIncludes(filepath\x2C '\\n'))\n    filepath = StringPrototypeReplace(filepath\x2C newlineRegEx\x2C '%0A');\n  if (StringPrototypeIncludes(filepath\x2C '\\r'))\n    filepath = StringPrototypeReplace(filepath\x2C carriageReturnRegEx\x2C '%0D');\n  if (StringPrototypeIncludes(filepath\x2C '\\t'))\n    filepath = StringPrototypeReplace(filepath\x2C tabRegEx\x2C '%09');\n  return filepath;\n}\n\nfunction pathToFileURL(filepath) {\n  const outURL = new URL('file://');\n  if (isWindows && StringPrototypeStartsWith(filepath\x2C '\\\\\\\\')) {\n    // UNC path format: \\\\server\\share\\resource\n    const paths = StringPrototypeSplit(filepath\x2C '\\\\');\n    if (paths.length <= 3) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Missing UNC resource path'\n      );\n    }\n    const hostname = paths[2];\n    if (hostname.length === 0) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Empty UNC servername'\n      );\n    }\n    outURL.hostname = domainToASCII(hostname);\n    outURL.pathname = encodePathChars(\n      ArrayPrototypeJoin(ArrayPrototypeSlice(paths\x2C 3)\x2C '/'));\n  } else {\n    let resolved = path.resolve(filepath);\n    // path.resolve strips trailing slashes so we must add them back\n    const filePathLast = StringPrototypeCharCodeAt(filepath\x2C\n                                                   filepath.length - 1);\n    if ((filePathLast === CHAR_FORWARD_SLASH ||\n         (isWindows && filePathLast === CHAR_BACKWARD_SLASH)) &&\n        resolved[resolved.length - 1] !== path.sep)\n      resolved += '/';\n    outURL.pathname = encodePathChars(resolved);\n  }\n  return outURL;\n}\n\nfunction isURLInstance(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath))\n    return fileURLOrPath;\n  return fileURLToPath(fileURLOrPath);\n}\n\nfunction constructUrl(flags\x2C protocol\x2C username\x2C password\x2C\n                      host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = new URLContext();\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n\n  const url = ObjectCreate(URL.prototype);\n  url[context] = ctx;\n  const params = new URLSearchParams();\n  url[searchParams] = params;\n  params[context] = url;\n  initSearchParams(params\x2C query);\n  return url;\n}\nsetURLConstructor(constructUrl);\n\nmodule.exports = {\n  toUSVString\x2C\n  fileURLToPath\x2C\n  pathToFileURL\x2C\n  toPathIfFileURL\x2C\n  isURLInstance\x2C\n  URL\x2C\n  URLSearchParams\x2C\n  domainToASCII\x2C\n  domainToUnicode\x2C\n  urlToHttpOptions\x2C\n  formatSymbol: kFormat\x2C\n  searchParamsSymbol: searchParams\x2C\n  encodeStr\n};\n
code-source-info,0x26b72db273d6,39,43634,43755,C0O43654C3O43659C9O43693C11O43714C12O43717C15O43724C19O43753,,
code-creation,LazyCompile,10,57625,0x26b72db2a6fe,17,isURLInstance node:internal/url:1555:23,0x815de62d990,~
code-source-info,0x26b72db2a6fe,39,43511,43608,C0O43531C3O43552C6O43577C12O43599C16O43606,,
tick,0x1bfcd7a18,57667,0,0x0,3,0x0,0x26b72db1ec2f,0x26b72db1e821,0x26b72db1e6e3,0x26b72db1e59d,0x26b72db1dfa4,0x26b72db1c2cc,0x26b72db1af70,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,LazyCompile,10,57667,0x26b72db2a85e,81, node:internal/fs/utils:669:38,0xd2efcc3f7b8,~
code-source-info,0x26b72db2a85e,82,18197,18467,C14O18230C22O18263C25O18263C31O18289C36O18320C49O18295C54O18289C55O18385C68O18385C74O18422C76O18451C78O18451C80O18466,,
code-creation,LazyCompile,10,57709,0x26b72db2aa6e,110, node:internal/fs/utils:358:35,0xd2efcc3ee30,~
code-source-info,0x26b72db2aa6e,82,8603,9192,C16O8667C21O8720C26O8720C31O8814C37O8837C41O8865C45O8882C51O8882C60O8933C64O8954C69O8954C76O8999C77O9006C78O9026C94O9026C100O9140C104O9162C106O9162C107O9179C109O9190,,
code-creation,LazyCompile,10,57709,0x26b72db2abe6,16,isUint8Array node:internal/util/types:13:22,0x232faba033f0,~
script-source,17,node:internal/util/types,'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n} = primordials;\n\nfunction isTypedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n}\n\nfunction isUint8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\n}\n\nfunction isUint8ClampedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8ClampedArray';\n}\n\nfunction isUint16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint16Array';\n}\n\nfunction isUint32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint32Array';\n}\n\nfunction isInt8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int8Array';\n}\n\nfunction isInt16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int16Array';\n}\n\nfunction isInt32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int32Array';\n}\n\nfunction isFloat32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float32Array';\n}\n\nfunction isFloat64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float64Array';\n}\n\nfunction isBigInt64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigInt64Array';\n}\n\nfunction isBigUint64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigUint64Array';\n}\n\nmodule.exports = {\n  ...internalBinding('types')\x2C\n  isArrayBufferView: ArrayBufferIsView\x2C\n  isTypedArray\x2C\n  isUint8Array\x2C\n  isUint8ClampedArray\x2C\n  isUint16Array\x2C\n  isUint32Array\x2C\n  isInt8Array\x2C\n  isInt16Array\x2C\n  isInt32Array\x2C\n  isFloat32Array\x2C\n  isFloat64Array\x2C\n  isBigInt64Array\x2C\n  isBigUint64Array\n};\n\nlet isCryptoKey;\nlet isKeyObject;\n\nObjectDefineProperties(module.exports\x2C {\n  isKeyObject: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isKeyObject) {\n        ({ isKeyObject } = require('internal/crypto/keys'));\n      }\n\n      return isKeyObject(obj);\n    }\n  }\x2C\n  isCryptoKey: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isCryptoKey) {\n        ({ isCryptoKey } = require('internal/crypto/keys'));\n      }\n\n      return isCryptoKey(obj);\n    }\n  }\n});\n
code-source-info,0x26b72db2abe6,17,257,342,C0O269C5O276C12O323C15O340,,
code-creation,LazyCompile,10,57834,0x26b72db2b05e,61,splitRoot node:fs:2379:33,0xd2efcc367b0,~
code-source-info,0x26b72db2b05e,81,63205,63397,C0O63230C2O63241C6O63235C11O63262C16O63266C24O63304C26O63300C31O63332C44O63339C49O63371C50O63251C55O63217C58O63382C60O63393,,
code-creation,LazyCompile,10,57834,0x26b72db2b196,20,nextPart node:fs:2412:31,0xd2efcc36850,~
code-source-info,0x26b72db2b196,81,64112,64170,C0O64125C14O64132C19O64166,,
code-creation,LazyCompile,10,57875,0x26b72db2b3f6,63,handleErrorFromBinding node:internal/fs/utils:341:32,0xd2efcc3ede0,~
code-source-info,0x26b72db2b3f6,82,7964,8462,C0O7982C6O8045C11O8045C16O8067C24O8067C29O8124C31O8124C32O8149C38O8377C43O8404C51O8377C56O8450C60O8440C62O8461,,
code-creation,LazyCompile,10,57875,0x26b72db2b546,34,isFileType node:fs:205:20,0xd2efcc34440,~
code-source-info,0x26b72db2b546,81,5285,5526,C0O5419C2O5424C6O5431C10O5465C15O5472C20O5488C22O5503C24O5501C30O5511C33O5524,,
code-creation,Function,11,57959,0x10510a5a0,376,isFileType node:fs:205:20,0xd2efcc34440,^
code-source-info,0x10510a5a0,81,5285,5526,,,
code-creation,Function,11,57959,0x10510a780,1504,resolve node:path:1091:10,0x815de63ad08,^
code-source-info,0x10510a780,41,33781,34691,,,
code-creation,Function,11,58000,0x10510adc0,1720,Module._nodeModulePaths node:internal/modules/cjs/loader:629:37,0x3172a1b2b110,^
code-source-info,0x10510adc0,103,18773,19904,,,
code-creation,Function,11,58000,0x10510b4e0,64,toNamespacedPath node:path:1266:19,0x815de63ae98,^
code-source-info,0x10510b4e0,41,38608,38668,,,
code-creation,Function,11,58000,0x10510b580,216,nextPart node:fs:2412:31,0xd2efcc36850,^
code-source-info,0x10510b580,81,64112,64170,,,
code-creation,LazyCompile,10,58042,0x26b72db2bcce,72,encodeRealpathResult node:fs:2388:30,0xd2efcc36800,~
code-source-info,0x26b72db2bcce,81,63431,63689,C0O63453C4O63478C10O63498C17O63507C22O63523C24O63537C25O63557C30O63564C35O63564C41O63592C48O63601C53O63621C55O63637C56O63660C61O63677C66O63660C71O63687,,
code-creation,LazyCompile,10,58084,0x26b72db2be5e,62,loadNativeModule node:internal/modules/cjs/helpers:44:26,0x3172a1b24d30,~
code-source-info,0x26b72db2be5e,102,1151,1431,C0O1187C5O1200C10O1204C15O1204C21O1221C26O1228C35O1258C43O1258C48O1384C53O1384C57O1414C59O1425C61O1430,,
code-creation,LazyCompile,10,58125,0x26b72db2c816,246,Module.load node:internal/modules/cjs/loader:963:33,0x3172a1b2b3e8,~
code-source-info,0x26b72db2c816,103,30014,30827,C0O30029C8O30075C16O30029C21O30083C26O30096C32O30083C36O30107C38O30121C42O30135C45O30155C52O30172C55O30177C60O30177C66O30155C71O30146C75O30218C78O30218C83O30295C91O30299C101O30352C106O30363C112O30377C124O30383C129O30377C130O30423C133O30430C140O30441C144O30452C150O30472C151O30484C155O30513C160O30522C165O30624C170O30659C175O30670C187O30710C192O30717C197O30717C204O30731C206O30729C211O30763C216O30772C221O30772C228O30797C233O30806C238O30806C245O30826,,
code-creation,LazyCompile,10,58167,0x26b72db2cb86,98,findLongestRegisteredExtension node:internal/modules/cjs/loader:413:40,0x3172a1b2a900,~
code-source-info,0x26b72db2cb86,103,11813,12242,C0O11841C5O11846C10O11846C16O11872C18O11896C20O11922C22O11990C36O11943C44O11990C49O12004C51O12023C55O12032C56O12042C61O12049C63O12096C68O12115C74O12154C77O12165C84O12176C89O12196C91O12220C92O11927C95O12227C97O12240,,
code-creation,LazyCompile,10,58250,0x26b72db2cd66,353,basename node:path:1306:11,0x815de63af38,~
code-source-info,0x26b72db2cd66,41,39511,41903,C0O39529C4O39558C12O39558C17O39590C25O39590C30O39637C32O39654C35O39681C37O39692C41O39721C47O39728C52O39739C57O39754C61O39746C66O39770C68O39778C73O39796C75O39806C76O39830C80O39837C84O39871C87O39899C91O39906C95O39913C96O39913C101O39947C106O39947C112O39991C114O40004C116O40000C121O40174C125O40207C127O40217C131O40234C135O40280C137O40301C142O40467C144O40501C146O40522C150O40549C151O40560C156O40631C158O40644C161O40644C166O40640C171O40700C178O40713C183O40849C190O41012C193O41039C198O39921C203O39881C206O41114C208O41124C213O41141C220O41176C222O41184C227O41211C232O41225C246O41232C251O41271C252O41300C256O41307C260O41314C261O41314C266O41333C271O41337C279O41376C281O41372C286O41540C290O41571C292O41581C296O41596C300O41626C302O41634C307O41754C309O41784C311O41792C315O41322C320O41282C323O41816C325O41824C330O41838C332O41848C333O41853C347O41860C352O41899,,
tick,0x10096deb4,58292,0,0x0,2,0x0,0x26b72db2cb90,0x26b72db2c864,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,LazyCompile,10,58292,0x26b72db2d206,485,Module._extensions..js node:internal/modules/cjs/loader:1108:37,0x3172a1b2b588,~
code-source-info,0x26b72db2d206,103,34649,36401,C0O34748C5O34762C10O34762C16O34781C18O34792C25O34802C34O34835C39O34847C40O34861C46O34889C51O34902C60O34902C67O34940C76O34944C83O35004C86O35004C91O35093C96O35100C103O35106C113O35113C118O35150C123O35168C128O35168C134O35206C139O35212C147O35254C152O35259C157O35271C167O35259C174O35316C179O35316C184O35357C203O35357C209O35528C212O35539C219O35545C224O35573C229O35611C235O35629C244O35629C254O35624C257O35742C261O35788C268O35822C271O35847C279O35854C283O35896C293O35854C300O35822C314O35788C321O35924C325O35981C335O35981C345O35950C352O35959C359O36044C365O36056C367O36091C376O36091C384O36137C387O36131C391O36169C403O36186C416O36195C429O36222C438O36253C443O36222C459O36276C464O36276C469O36341C471O36341C472O36371C477O36371C484O36400,,
code-creation,LazyCompile,10,58375,0x26b72db2d666,376,readFileSync node:fs:450:22,0xd2efcc348f8,~
code-source-info,0x26b72db2d666,81,11383,12760,C0O11403C5O11424C10O11413C17O11468C22O11468C27O11522C35O11540C38O11543C43O11566C56O11543C62O11597C65O11597C71O11639C76O11657C79O11639C88O11673C95O11694C97O11703C99O11749C101O11794C102O11803C107O11816C112O11845C124O11854C130O11902C132O11916C133O11925C138O11949C143O12005C159O11961C165O12019C167O12026C174O12066C175O12060C182O12073C187O11938C192O12197C197O12213C207O12213C213O12238C232O12250C238O12300C239O12314C244O12331C249O12366C256O12366C263O12331C268O12402C270O12409C277O12443C278O12443C283O12097C286O12458C290O12477C295O12480C300O12480C305O12498C306O12507C311O12569C316O12585C321O12585C330O12616C332O12624C337O12654C344O12654C351O12688C357O12714C362O12731C367O12714C373O12744C375O12758,,
code-creation,LazyCompile,10,58417,0x26b72db2d986,30,isEncoding node:buffer:530:40,0x232faba322d0,~
code-source-info,0x26b72db2d986,24,14808,14940,C0O14823C6O14871C12O14878C20O14896C23O14896C28O14924C29O14938,,
code-creation,LazyCompile,10,58417,0x26b72db2da8e,30,normalizeEncoding node:internal/util:160:27,0x232faba01e78,~
code-source-info,0x26b72db2da8e,16,4206,4311,C0O4216C7O4239C14O4257C19O4270C21O4284C22O4287C25O4294C29O4309,,
code-creation,LazyCompile,10,58459,0x26b72db2dc06,113,openSync node:fs:576:18,0xd2efcc34ae0,~
code-source-info,0x26b72db2dc06,81,14454,14833,C0O14478C5O14485C11O14531C16O14531C21O14555C37O14562C44O14613C51O14615C58O14640C63O14648C70O14653C73O14664C78O14664C95O14648C101O14786C106O14786C110O14817C112O14831,,
code-creation,LazyCompile,10,58459,0x26b72db2dd86,37, node:internal/fs/utils:681:42,0xd2efcc3f808,~
code-source-info,0x26b72db2dd86,82,18512,18647,C14O18567C19O18567C24O18601C29O18601C34O18633C36O18645,,
code-creation,LazyCompile,10,58500,0x26b72db2e15e,515,stringToFlags node:internal/fs/utils:556:23,0xd2efcc3f628,~
code-source-info,0x26b72db2e15e,82,15103,16337,C14O15131C20O15168C25O15168C30O15200C32O15213C33O15221C38O15246C42O15262C43O15270C202O15302C206O15318C207O15368C214O15386C216O15384C219O15393C220O15410C224O15424C225O15476C232O15492C234O15490C237O15499C238O15516C245O15533C247O15531C253O15543C255O15541C258O15552C259O15602C266O15619C268O15617C274O15629C276O15627C282O15640C284O15638C287O15647C288O15665C295O15682C297O15680C303O15692C305O15690C308O15699C309O15749C316O15766C318O15764C324O15776C326O15774C332O15785C334O15783C337O15792C338O15809C345O15827C347O15825C353O15837C355O15835C358O15846C359O15896C366O15914C368O15912C374O15924C376O15922C382O15935C384O15933C387O15942C388O15992C395O16010C397O16008C403O16020C405O16018C411O16031C413O16029C416O16038C417O16056C424O16074C426O16072C432O16084C434O16082C437O16091C438O16141C445O16159C447O16157C453O16169C455O16167C461O16178C463O16176C466O16185C467O16235C474O16253C476O16251C482O16263C484O16261C490O16272C492O16270C495O16279C496O16287C509O16293C514O16287,,
code-creation,LazyCompile,10,58542,0x26b72db2e54e,97,parseFileMode node:internal/validators:59:23,0x2b48e0c7be88,~
code-source-info,0x26b72db2e54e,15,1487,1783,C0O1510C11O1527C17O1564C24O1589C27O1569C34O1615C41O1660C52O1621C57O1615C58O1681C66O1689C73O1722C89O1722C94O1768C96O1781,,
code-creation,LazyCompile,10,58584,0x26b72db2e6e6,206, node:internal/validators:84:3,0x2b48e0c7bf48,~
code-source-info,0x26b72db2e6e6,15,2255,2836,C36O2396C39O2401C45O2425C51O2466C67O2472C72O2466C73O2535C78O2540C84O2574C100O2580C105O2574C106O2643C116O2682C129O2695C142O2649C147O2643C148O2720C150O2730C157O2745C162O2760C172O2799C185O2812C198O2766C203O2760C205O2835,,
code-creation,LazyCompile,10,58584,0x26b72db2e8ae,9,isInt32 node:internal/validators:36:17,0x2b48e0c7b928,~
code-source-info,0x26b72db2e8ae,15,734,777,C0O746C2O770C5O759C8O775,,
code-creation,LazyCompile,10,58625,0x26b72db2e9b6,66,tryStatSync node:fs:404:21,0xd2efcc34808,~
code-source-info,0x26b72db2e9b6,81,10358,10568,C0O10389C2O10409C7O10417C22O10417C28O10461C36O10485C38O10501C43O10504C48O10504C53O10523C58O10529C62O10523C63O10553C65O10566,,
code-creation,LazyCompile,10,58667,0x26b72db2eb2e,96,tryCreateBuffer node:fs:414:25,0xd2efcc34858,~
code-source-info,0x26b72db2eb2e,81,10594,10881,C0O10631C2O10643C7O10663C9O10674C11O10672C16O10696C23O10702C28O10696C29O10745C34O10761C39O10761C45O10784C57O10790C58O10817C65O10831C67O10841C72O10844C77O10844C93O10865C95O10879,,
code-creation,LazyCompile,10,58709,0x26b72db2ec86,17,allocUnsafe node:buffer:373:42,0x232faba31e48,~
code-source-info,0x26b72db2ec86,24,10905,10960,C0O10916C5O10916C9O10936C12O10943C16O10958,,
code-creation,LazyCompile,10,58709,0x26b72db2ed8e,54, node:buffer:349:36,0x232faba31d90,~
code-source-info,0x26b72db2ed8e,24,10203,10358,C0O10217C8O10217C13O10249C14O10260C21O10276C23O10273C28O10295C33O10327C46O10301C51O10295C53O10357,,
code-creation,LazyCompile,10,58709,0x26b72db2eeb6,30,validateNumber node:internal/validators:123:24,0x2b48e0c7c088,~
code-source-info,0x26b72db2eeb6,15,3551,3660,C0O3569C6O3604C22O3610C27O3604C29O3659,,
code-creation,LazyCompile,10,58750,0x26b72db2efce,119,allocate node:buffer:398:18,0x232faba31f98,~
code-source-info,0x26b72db2efce,24,11607,11922,C0O11618C1O11627C6O11639C11O11646C16O11663C17O11670C20O11689C24O11698C27O11679C32O11712C34O11724C39O11735C41O11733C44O11721C49O11754C52O11754C55O11782C62O11797C67O11808C75O11782C81O11831C88O11845C94O11842C100O11855C103O11855C106O11872C108O11881C109O11888C114O11895C118O11920,,
code-creation,LazyCompile,10,58750,0x26b72db2f18e,86,tryReadSync node:fs:429:21,0xd2efcc348a8,~
code-source-info,0x26b72db2f18e,81,10903,11138,C0O10952C2O10964C7O10987C12O11002C29O11002C35O11038C47O11044C48O11071C55O11085C57O11095C62O11098C67O11098C83O11119C85O11136,,
code-creation,LazyCompile,10,58792,0x26b72db2f37e,258,readSync node:fs:684:18,0xd2efcc34bb0,~
code-source-info,0x26b72db2f37e,81,17188,18177,C0O17188C2O17231C7O17236C13O17259C18O17259C22O17300C29O17307C34O17382C40O17392C45O17392C50O17426C62O17444C68O17460C75O17471C80O17487C89O17528C94O17554C99O17581C112O17581C117O17626C124O17642C125O17653C130O17666C131O17675C132O17694C138O17705C143O17718C159O17724C164O17718C165O17846C170O17894C181O17846C186O17910C191O17936C195O17954C203O17954C208O18009C210O18030C215O18038C240O18038C246O18130C251O18130C255O18161C257O18175,,
code-creation,LazyCompile,10,58834,0x26b72db2f5e6,52, node:internal/fs/utils:687:40,0xd2efcc3f858,~
code-source-info,0x26b72db2f5e6,82,18690,18811,C14O18719C22O18723C29O18747C30O18756C31O18764C44O18764C49O18799C51O18809,,
code-creation,LazyCompile,10,58834,0x26b72db2f756,51, node:internal/validators:191:40,0x2b48e0c7c2b0,~
code-source-info,0x26b72db2f756,15,5681,5911,C14O5714C19O5719C25O5752C30O5783C43O5758C48O5752C50O5910,,
code-creation,LazyCompile,10,58875,0x26b72db2f8ae,151, node:internal/validators:73:3,0x2b48e0c7bef8,~
code-source-info,0x26b72db2f8ae,15,1828,2209,C12O1848C25O1878C32O1911C38O1948C54O1954C59O1948C60O2007C65O2012C71O2042C87O2048C92O2042C93O2101C95O2111C102O2126C107O2139C117O2178C130O2191C143O2145C148O2139C150O2208,,
code-creation,LazyCompile,10,58875,0x26b72db2fab6,103, node:internal/fs/utils:637:3,0xd2efcc3f718,~
code-source-info,0x26b72db2fab6,82,17314,17693,C0O17354C1O17365C6O17378C22O17384C27O17378C28O17442C29O17453C34O17466C50O17472C55O17466C56O17530C58O17541C64O17550C69O17574C82O17663C95O17580C100O17574C102O17692,,
code-creation,LazyCompile,10,58917,0x26b72db2fdbe,151, node:internal/fs/utils:892:42,0xd2efcc3fb78,~
code-source-info,0x26b72db2fdbe,82,24279,24837,C0O24303C6O24343C14O24343C21O24391C27O24431C32O24454C35O24449C37O24446C47O24480C53O24487C56O24474C61O24502C77O24585C80O24580C98O24605C104O24612C117O24508C122O24502C125O24685C143O24691C148O24685C150O24836,,
code-creation,LazyCompile,10,58959,0x26b72db2ff76,47,closeSync node:fs:526:19,0xd2efcc34a08,~
code-source-info,0x26b72db2ff76,81,13323,13445,C0O13332C5O13337C11O13372C13O13378C18O13386C31O13386C36O13415C41O13415C46O13444,,
code-creation,LazyCompile,10,59000,0x26b72db300ae,162,toString node:buffer:783:46,0x232faba33cd0,~
code-source-info,0x26b72db300ae,24,23298,23860,C0O23298C2O23339C8O23346C13O23371C20O23389C25O23371C31O23397C32O23422C37O23433C38O23443C43O23453C48O23471C50O23481C55O23493C57O23503C58O23515C65O23530C71O23559C76O23570C83O23592C90O23605C92O23613C97O23627C99O23637C100O23641C104O23685C109O23685C115O23707C116O23723C119O23723C124O23751C126O23778C133O23784C138O23778C139O23834C156O23834C161O23858,,
code-creation,LazyCompile,10,59042,0x26b72db3036e,499,getEncodingOps node:buffer:679:24,0x232faba33b28,~
code-source-info,0x26b72db3036e,24,19965,21766,C0O19980C10O20015C62O20043C64O20056C69O20068C74O20087C78O20092C79O20099C81O20112C86O20124C91O20143C95O20148C96O20155C101O20166C107O20210C109O20223C114O20235C119O20254C123O20259C124O20266C126O20279C131O20291C136O20310C140O20315C141O20322C143O20347C145O20360C150O20373C155O20392C159O20397C160O20404C162O20417C167O20430C172O20449C176O20455C177O20462C179O20475C184O20488C189O20507C193O20512C194O20519C199O20530C205O20574C207O20587C212O20600C217O20619C221O20624C222O20631C224O20644C229O20657C234O20676C238O20682C239O20689C241O20702C246O20715C251O20734C255O20739C256O20746C258O20771C260O20784C267O20811C270O20811C277O20848C282O20871C287O20890C291O20898C292O20905C294O20930C296O20943C303O20971C306O20971C313O21008C318O21032C323O21051C327O21059C328O21066C330O21091C332O21104C339O21129C344O21151C349O21170C353O21177C354O21184C356O21197C361O21211C366O21230C370O21237C371O21244C376O21255C382O21299C384O21312C391O21337C396O21359C401O21378C405O21385C406O21392C408O21405C413O21419C418O21438C422O21445C423O21452C425O21477C427O21490C434O21503C437O21503C444O21540C449O21559C454O21578C458O21582C459O21589C461O21614C463O21627C470O21656C473O21656C480O21693C485O21718C490O21737C494O21747C495O21754C498O21765,,
code-creation,LazyCompile,10,59084,0x26b72db30756,12,slice node:buffer:594:12,0x232faba324f0,~
code-source-info,0x26b72db30756,24,16636,16682,C0O16661C5O16661C11O16682,,
code-creation,LazyCompile,10,59209,0x26b72db315be,499,Module._compile node:internal/modules/cjs/loader:1053:37,0x3172a1b2b4f8,~
code-source-info,0x26b72db315be,103,32741,34582,C0O32769C2O32786C4O32799C11O32809C20O32827C25O32839C30O32868C35O32887C40O32896C45O32896C51O32932C56O32939C61O32948C66O32948C72O32992C86O32992C91O33064C103O33064C109O33125C111O33133C119O33137C128O33180C135O33201C141O33295C144O33307C151O33311C159O33342C162O33364C170O33389C177O33393C185O33364C193O33355C203O33586C210O33593C215O33606C221O33606C226O33593C231O33586C237O33670C242O33683C248O33750C256O33771C262O33802C264O33798C269O33824C273O33839C279O33853C285O33872C290O33900C295O33950C300O33955C305O33955C311O33992C316O33992C322O34036C324O34067C329O34096C330O34122C333O34130C339O34147C344O34154C349O34166C357O34164C363O34183C367O34211C388O34220C396O34356C401O34395C410O34433C419O34442C428O34451C437O34459C446O34469C459O34365C465O34486C469O34512C475O34522C481O34539C486O34546C490O34556C496O34566C498O34580,,
code-creation,LazyCompile,10,59250,0x26b72db31ade,224,maybeCacheSourceMap node:internal/source_map/source_map_cache:74:29,0x3172a1b21e58,~
code-source-info,0x26b72db31ade,100,2239,3267,C0O2308C3O2308C7O2334C10O2348C15O2352C23O2372C25O2392C26O2399C30O2412C35O2423C44O2421C54O2564C64O2564C68O2580C69O2587C70O2608C75O2634C80O2608C86O2711C88O2741C91O2769C96O2776C101O2741C107O2811C112O2831C117O2838C122O2860C126O2891C131O2909C136O2913C143O2942C150O2973C160O3003C166O3017C170O2909C178O3143C183O3161C188O3165C196O3198C206O3228C212O3242C216O3161C223O3266,,
code-creation,LazyCompile,10,59292,0x26b72db32536,31,getSourceMapsEnabled node:internal/source_map/source_map_cache:43:30,0x3172a1b21db8,~
code-source-info,0x26b72db32536,100,1418,1563,C0O1425C6O1468C11O1489C17O1489C22O1468C26O1536C30O1561,,
code-creation,LazyCompile,10,59334,0x26b72db326ae,100,setSourceMapsEnabled node:internal/source_map/source_map_cache:50:30,0x3172a1b21e08,~
code-source-info,0x26b72db326ae,100,1594,2209,C0O1604C8O1604C13O1709C19O1709C24O1648C29O1674C34O1738C38O1767C42O1822C48O1822C53O1796C58O1878C64O1936C70O2095C76O2095C81O2068C86O2127C90O2183C92O2201C99O2208,,
code-creation,LazyCompile,10,59334,0x26b72db32826,30,validateBoolean node:internal/validators:139:25,0x2b48e0c7c128,~
code-source-info,0x26b72db32826,15,4061,4172,C0O4079C6O4115C22O4121C27O4115C29O4171,,
code-creation,LazyCompile,10,59375,0x26b72db32c1e,165,wrapSafe node:internal/modules/cjs/loader:1011:18,0x3172a1b2ab80,~
code-source-info,0x26b72db32c1e,103,31441,32533,C0O31441C9O31484C17O31519C22O31526C27O31526C33O31545C40O31555C45O31572C52O31589C56O31678C64O31555C70O31949C74O31966C81O31976C86O31992C98O32107C102O32123C113O31976C118O32408C130O32431C135O32443C142O32454C147O32483C157O32483C162O32517C164O32517,,
code-creation,LazyCompile,10,59459,0x26b72db333f6,472,compileFunction node:vm:308:25,0x3beccad0070,~
script-source,89,node:vm,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeUnshift\x2C\n  Symbol\x2C\n  PromiseReject\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst {\n  ContextifyScript\x2C\n  MicrotaskQueue\x2C\n  makeContext\x2C\n  isContext: _isContext\x2C\n  constants\x2C\n  compileFunction: _compileFunction\x2C\n  measureMemory: _measureMemory\x2C\n} = internalBinding('contextify');\nconst {\n  ERR_CONTEXT_NOT_INITIALIZED\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n} = require('internal/errors').codes;\nconst {\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst {\n  kVmBreakFirstLineSymbol\x2C\n  emitExperimentalWarning\x2C\n} = require('internal/util');\nconst kParsingContext = Symbol('script parsing context');\n\nclass Script extends ContextifyScript {\n  constructor(code\x2C options = {}) {\n    code = `${code}`;\n    if (typeof options === 'string') {\n      options = { filename: options };\n    } else {\n      validateObject(options\x2C 'options');\n    }\n\n    const {\n      filename = 'evalmachine.<anonymous>'\x2C\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      cachedData\x2C\n      produceCachedData = false\x2C\n      importModuleDynamically\x2C\n      [kParsingContext]: parsingContext\x2C\n    } = options;\n\n    validateString(filename\x2C 'options.filename');\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData'\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        cachedData\n      );\n    }\n    validateBoolean(produceCachedData\x2C 'options.produceCachedData');\n\n    // Calling `ReThrow()` on a native TryCatch does not generate a new\n    // abort-on-uncaught-exception check. A dummy try/catch in JS land\n    // protects against that.\n    try { // eslint-disable-line no-useless-catch\n      super(code\x2C\n            filename\x2C\n            lineOffset\x2C\n            columnOffset\x2C\n            cachedData\x2C\n            produceCachedData\x2C\n            parsingContext);\n    } catch (e) {\n      throw e; /* node-do-not-add-exception-line */\n    }\n\n    if (importModuleDynamically !== undefined) {\n      validateFunction(importModuleDynamically\x2C\n                       'options.importModuleDynamically');\n      const { importModuleDynamicallyWrap } =\n        require('internal/vm/module');\n      const { callbackMap } = internalBinding('module_wrap');\n      callbackMap.set(this\x2C {\n        importModuleDynamically:\n          importModuleDynamicallyWrap(importModuleDynamically)\x2C\n      });\n    }\n  }\n\n  runInThisContext(options) {\n    const { breakOnSigint\x2C args } = getRunInContextArgs(options);\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n      return sigintHandlersWrap(super.runInThisContext\x2C this\x2C args);\n    }\n    return ReflectApply(super.runInThisContext\x2C this\x2C args);\n  }\n\n  runInContext(contextifiedObject\x2C options) {\n    validateContext(contextifiedObject);\n    const { breakOnSigint\x2C args } = getRunInContextArgs(options);\n    ArrayPrototypeUnshift(args\x2C contextifiedObject);\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n      return sigintHandlersWrap(super.runInContext\x2C this\x2C args);\n    }\n    return ReflectApply(super.runInContext\x2C this\x2C args);\n  }\n\n  runInNewContext(contextObject\x2C options) {\n    const context = createContext(contextObject\x2C getContextOptions(options));\n    return this.runInContext(context\x2C options);\n  }\n}\n\nfunction validateContext(contextifiedObject) {\n  if (!isContext(contextifiedObject)) {\n    throw new ERR_INVALID_ARG_TYPE('contextifiedObject'\x2C 'vm.Context'\x2C\n                                   contextifiedObject);\n  }\n}\n\nfunction getRunInContextArgs(options = {}) {\n  validateObject(options\x2C 'options');\n\n  let timeout = options.timeout;\n  if (timeout === undefined) {\n    timeout = -1;\n  } else {\n    validateUint32(timeout\x2C 'options.timeout'\x2C true);\n  }\n\n  const {\n    displayErrors = true\x2C\n    breakOnSigint = false\x2C\n    [kVmBreakFirstLineSymbol]: breakFirstLine = false\x2C\n  } = options;\n\n  validateBoolean(displayErrors\x2C 'options.displayErrors');\n  validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n\n  return {\n    breakOnSigint\x2C\n    args: [timeout\x2C displayErrors\x2C breakOnSigint\x2C breakFirstLine]\n  };\n}\n\nfunction getContextOptions(options) {\n  if (!options)\n    return {};\n  const contextOptions = {\n    name: options.contextName\x2C\n    origin: options.contextOrigin\x2C\n    codeGeneration: undefined\x2C\n    microtaskMode: options.microtaskMode\x2C\n  };\n  if (contextOptions.name !== undefined)\n    validateString(contextOptions.name\x2C 'options.contextName');\n  if (contextOptions.origin !== undefined)\n    validateString(contextOptions.origin\x2C 'options.contextOrigin');\n  if (options.contextCodeGeneration !== undefined) {\n    validateObject(options.contextCodeGeneration\x2C\n                   'options.contextCodeGeneration');\n    const { strings\x2C wasm } = options.contextCodeGeneration;\n    if (strings !== undefined)\n      validateBoolean(strings\x2C 'options.contextCodeGeneration.strings');\n    if (wasm !== undefined)\n      validateBoolean(wasm\x2C 'options.contextCodeGeneration.wasm');\n    contextOptions.codeGeneration = { strings\x2C wasm };\n  }\n  if (options.microtaskMode !== undefined)\n    validateString(options.microtaskMode\x2C 'options.microtaskMode');\n  return contextOptions;\n}\n\nfunction isContext(object) {\n  validateObject(object\x2C 'object'\x2C { allowArray: true });\n\n  return _isContext(object);\n}\n\nlet defaultContextNameIndex = 1;\nfunction createContext(contextObject = {}\x2C options = {}) {\n  if (isContext(contextObject)) {\n    return contextObject;\n  }\n\n  validateObject(options\x2C 'options');\n\n  const {\n    name = `VM Context ${defaultContextNameIndex++}`\x2C\n    origin\x2C\n    codeGeneration\x2C\n    microtaskMode\n  } = options;\n\n  validateString(name\x2C 'options.name');\n  if (origin !== undefined)\n    validateString(origin\x2C 'options.origin');\n  if (codeGeneration !== undefined)\n    validateObject(codeGeneration\x2C 'options.codeGeneration');\n\n  let strings = true;\n  let wasm = true;\n  if (codeGeneration !== undefined) {\n    ({ strings = true\x2C wasm = true } = codeGeneration);\n    validateBoolean(strings\x2C 'options.codeGeneration.strings');\n    validateBoolean(wasm\x2C 'options.codeGeneration.wasm');\n  }\n\n  let microtaskQueue = null;\n  if (microtaskMode !== undefined) {\n    validateOneOf(microtaskMode\x2C 'options.microtaskMode'\x2C\n                  ['afterEvaluate'\x2C undefined]);\n\n    if (microtaskMode === 'afterEvaluate')\n      microtaskQueue = new MicrotaskQueue();\n  }\n\n  makeContext(contextObject\x2C name\x2C origin\x2C strings\x2C wasm\x2C microtaskQueue);\n  return contextObject;\n}\n\nfunction createScript(code\x2C options) {\n  return new Script(code\x2C options);\n}\n\n// Remove all SIGINT listeners and re-attach them after the wrapped function\n// has executed\x2C so that caught SIGINT are handled by the listeners again.\nfunction sigintHandlersWrap(fn\x2C thisArg\x2C argsArray) {\n  const sigintListeners = process.rawListeners('SIGINT');\n\n  process.removeAllListeners('SIGINT');\n\n  try {\n    return ReflectApply(fn\x2C thisArg\x2C argsArray);\n  } finally {\n    // Add using the public methods so that the `newListener` handler of\n    // process can re-attach the listeners.\n    ArrayPrototypeForEach(sigintListeners\x2C (listener) => {\n      process.addListener('SIGINT'\x2C listener);\n    });\n  }\n}\n\nfunction runInContext(code\x2C contextifiedObject\x2C options) {\n  validateContext(contextifiedObject);\n  if (typeof options === 'string') {\n    options = {\n      filename: options\x2C\n      [kParsingContext]: contextifiedObject\n    };\n  } else {\n    options = { ...options\x2C [kParsingContext]: contextifiedObject };\n  }\n  return createScript(code\x2C options)\n    .runInContext(contextifiedObject\x2C options);\n}\n\nfunction runInNewContext(code\x2C contextObject\x2C options) {\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n  contextObject = createContext(contextObject\x2C getContextOptions(options));\n  options = { ...options\x2C [kParsingContext]: contextObject };\n  return createScript(code\x2C options).runInNewContext(contextObject\x2C options);\n}\n\nfunction runInThisContext(code\x2C options) {\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n  return createScript(code\x2C options).runInThisContext(options);\n}\n\nfunction compileFunction(code\x2C params\x2C options = {}) {\n  validateString(code\x2C 'code');\n  if (params !== undefined) {\n    validateArray(params\x2C 'params');\n    ArrayPrototypeForEach(params\x2C\n                          (param\x2C i) => validateString(param\x2C `params[${i}]`));\n  }\n\n  const {\n    filename = ''\x2C\n    columnOffset = 0\x2C\n    lineOffset = 0\x2C\n    cachedData = undefined\x2C\n    produceCachedData = false\x2C\n    parsingContext = undefined\x2C\n    contextExtensions = []\x2C\n    importModuleDynamically\x2C\n  } = options;\n\n  validateString(filename\x2C 'options.filename');\n  validateUint32(columnOffset\x2C 'options.columnOffset');\n  validateUint32(lineOffset\x2C 'options.lineOffset');\n  if (cachedData !== undefined)\n    validateBuffer(cachedData\x2C 'options.cachedData');\n  validateBoolean(produceCachedData\x2C 'options.produceCachedData');\n  if (parsingContext !== undefined) {\n    if (\n      typeof parsingContext !== 'object' ||\n      parsingContext === null ||\n      !isContext(parsingContext)\n    ) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.parsingContext'\x2C\n        'Context'\x2C\n        parsingContext\n      );\n    }\n  }\n  validateArray(contextExtensions\x2C 'options.contextExtensions');\n  ArrayPrototypeForEach(contextExtensions\x2C (extension\x2C i) => {\n    const name = `options.contextExtensions[${i}]`;\n    validateObject(extension\x2C name\x2C { nullable: true });\n  });\n\n  const result = _compileFunction(\n    code\x2C\n    filename\x2C\n    lineOffset\x2C\n    columnOffset\x2C\n    cachedData\x2C\n    produceCachedData\x2C\n    parsingContext\x2C\n    contextExtensions\x2C\n    params\n  );\n\n  if (produceCachedData) {\n    result.function.cachedDataProduced = result.cachedDataProduced;\n  }\n\n  if (result.cachedData) {\n    result.function.cachedData = result.cachedData;\n  }\n\n  if (importModuleDynamically !== undefined) {\n    validateFunction(importModuleDynamically\x2C\n                     'options.importModuleDynamically');\n    const { importModuleDynamicallyWrap } =\n      require('internal/vm/module');\n    const { callbackMap } = internalBinding('module_wrap');\n    const wrapped = importModuleDynamicallyWrap(importModuleDynamically);\n    const func = result.function;\n    callbackMap.set(result.cacheKey\x2C {\n      importModuleDynamically: (s\x2C _k\x2C i) => wrapped(s\x2C func\x2C i)\x2C\n    });\n  }\n\n  return result.function;\n}\n\nconst measureMemoryModes = {\n  summary: constants.measureMemory.mode.SUMMARY\x2C\n  detailed: constants.measureMemory.mode.DETAILED\x2C\n};\n\nconst measureMemoryExecutions = {\n  default: constants.measureMemory.execution.DEFAULT\x2C\n  eager: constants.measureMemory.execution.EAGER\x2C\n};\n\nfunction measureMemory(options = {}) {\n  emitExperimentalWarning('vm.measureMemory');\n  validateObject(options\x2C 'options');\n  const { mode = 'summary'\x2C execution = 'default' } = options;\n  validateOneOf(mode\x2C 'options.mode'\x2C ['summary'\x2C 'detailed']);\n  validateOneOf(execution\x2C 'options.execution'\x2C ['default'\x2C 'eager']);\n  const result = _measureMemory(measureMemoryModes[mode]\x2C\n                                measureMemoryExecutions[execution]);\n  if (result === undefined) {\n    return PromiseReject(new ERR_CONTEXT_NOT_INITIALIZED());\n  }\n  return result;\n}\n\nmodule.exports = {\n  Script\x2C\n  createContext\x2C\n  createScript\x2C\n  runInContext\x2C\n  runInNewContext\x2C\n  runInThisContext\x2C\n  isContext\x2C\n  compileFunction\x2C\n  measureMemory\x2C\n};\n\n// The vm module is patched to include vm.Module\x2C vm.SourceTextModule\n// and vm.SyntheticModule in the pre-execution phase when\n// --experimental-vm-modules is on.\n
code-source-info,0x26b72db333f6,89,9562,11817,C10O9562C16O9595C25O9595C30O9627C34O9659C43O9659C48O9696C53O9718C59O9696C64O9825C76O9844C84O9866C92O9886C100O9914C108O9945C116O9977C125O10005C130O10048C139O10048C144O10096C153O10096C158O10152C167O10152C172O10204C176O10238C185O10238C190O10290C199O10290C204O10357C208O10397C221O10486C227O10526C244O10532C249O10526C250O10655C259O10655C264O10720C269O10742C275O10720C280O10914C312O10914C318O11091C322O11127C327O11164C331O11155C335O11202C341O11227C346O11256C350O11247C354O11275C358O11303C368O11324C379O11324C384O11473C393O11473C398O11435C403O11532C412O11532C417O11516C422O11584C426O11584C428O11662C432O11655C434O11688C439O11699C451O11742C459O11688C467O11806C471O11815,,
tick,0x1bfd39474,59959,0,0x0,3,0x0,0x26b72db32c8f,0x26b72db31625,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,LazyCompile,10,59959,0x26b72db345be,95, node:internal/validators:168:39,0x2b48e0c7c1e8,~
code-source-info,0x26b72db345be,15,4985,5263,C16O5021C21O5026C27O5053C43O5059C48O5053C49O5123C56O5130C61O5164C66O5187C71O5204C87O5210C92O5204C94O5262,,
code-creation,LazyCompile,10,60000,0x26b72db3471e,27, node:vm:313:27,0x26b72db330c8,~
code-source-info,0x26b72db3471e,89,9752,9803,C0O9766C10O9798C21O9766C26O9803,,
code-creation,Eval,10,60000,0x26b72db349ae,5, /Users/vignesh/.nvm/versions/node/v17.7.1/lib/node_modules/0x/lib/preload/no-cluster.js:1:1,0x26b72db34868,~
script-source,133,/Users/vignesh/.nvm/versions/node/v17.7.1/lib/node_modules/0x/lib/preload/no-cluster.js,const cluster = require('cluster')\n\ncluster.on('fork'\x2C () => {\n  throw new Error('0x does not support clustering.')\n})\n
code-source-info,0x26b72db349ae,133,0,119,C0O0C4O119,,
code-creation,Function,10,60042,0x26b72db34a96,29, /Users/vignesh/.nvm/versions/node/v17.7.1/lib/node_modules/0x/lib/preload/no-cluster.js:1:1,0x26b72db34928,~
code-source-info,0x26b72db34a96,133,0,119,C0O16C3O16C8O44C21O44C28O118,,
code-creation,LazyCompile,10,60084,0x26b72db34d0e,19,importModuleDynamicallyWrap node:internal/vm/module:435:37,0x26b72db10b30,~
code-source-info,0x26b72db34d0e,131,11705,12148,C0O11705C13O11774C18O12146,,
code-creation,LazyCompile,10,60125,0x26b72db36076,159,makeRequireFunction node:internal/modules/cjs/helpers:58:29,0x3172a1b24d80,~
code-source-info,0x26b72db36076,102,1708,3678,C0O1708C22O1744C25O1748C29O1744C31O1768C33O1779C53O1811C58O1815C69O1831C73O1811C75O1858C81O1858C83O1885C89O1894C95O1922C104O3082C109O3313C111O3329C115O3469C117O3483C121O3495C126O3518C130O3508C134O3583C137O3611C141O3602C145O3627C148O3650C152O3641C156O3661C158O3676,,
code-creation,LazyCompile,10,60125,0x26b72db362c6,14,require node:internal/modules/cjs/helpers:101:31,0x26b72db35f48,~
code-source-info,0x26b72db362c6,102,3108,3154,C0O3123C3O3134C8O3134C13O3148,,
code-creation,LazyCompile,10,60167,0x26b72db36416,10, node:internal/modules/cjs/helpers:29:66,0x3172a1b24f50,~
code-source-info,0x26b72db36416,102,810,835,C0O822C2O828C9O834,,
code-creation,LazyCompile,10,60167,0x26b72db3658e,129,compileForPublicLoader node:internal/bootstrap/loaders:246:25,0x2b48e0c4fb80,~
code-source-info,0x26b72db3658e,9,7544,8216,C0O7563C6O7707C16O7750C33O7713C38O7707C39O7787C44O7787C48O7829C54O8018C61O8049C69O8018C75O8073C80O8091C90O8107C93O8123C98O8107C102O8089C106O8148C111O8148C115O8173C120O8173C124O8204C128O8212,,
code-creation,Eval,10,60209,0x26b72db368ee,5, node:cluster:1:1,0x26b72db367a8,~
script-source,134,node:cluster,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst childOrPrimary = 'NODE_UNIQUE_ID' in process.env ? 'child' : 'primary';\nmodule.exports = require(`internal/cluster/${childOrPrimary}`);\n
code-source-info,0x26b72db368ee,134,0,1291,C0O0C4O1291,,
code-creation,Function,10,60292,0x26b72db36996,39, node:cluster:1:1,0x26b72db36868,~
code-source-info,0x26b72db36996,134,0,1291,C0O1172C3O1200C7O1189C19O1227C24O1272C29O1244C33O1242C38O1290,,
code-creation,Eval,10,60459,0x26b72db375c6,5, node:internal/cluster/primary:1:1,0x26b72db37240,~
script-source,135,node:internal/cluster/primary,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSome\x2C\n  ObjectKeys\x2C\n  ObjectValues\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst assert = require('internal/assert');\nconst { fork } = require('child_process');\nconst path = require('path');\nconst EventEmitter = require('events');\nconst RoundRobinHandle = require('internal/cluster/round_robin_handle');\nconst SharedHandle = require('internal/cluster/shared_handle');\nconst Worker = require('internal/cluster/worker');\nconst { internal\x2C sendHelper } = require('internal/cluster/utils');\nconst cluster = new EventEmitter();\nconst intercom = new EventEmitter();\nconst SCHED_NONE = 1;\nconst SCHED_RR = 2;\nconst minPort = 1024;\nconst maxPort = 65535;\nconst { validatePort } = require('internal/validators');\n\nmodule.exports = cluster;\n\nconst handles = new SafeMap();\ncluster.isWorker = false;\ncluster.isMaster = true; // Deprecated alias. Must be same as isPrimary.\ncluster.isPrimary = true;\ncluster.Worker = Worker;\ncluster.workers = {};\ncluster.settings = {};\ncluster.SCHED_NONE = SCHED_NONE;  // Leave it to the operating system.\ncluster.SCHED_RR = SCHED_RR;      // Primary distributes connections.\n\nlet ids = 0;\nlet debugPortOffset = 1;\nlet initialized = false;\n\n// XXX(bnoordhuis) Fold cluster.schedulingPolicy into cluster.settings?\nlet schedulingPolicy = process.env.NODE_CLUSTER_SCHED_POLICY;\nif (schedulingPolicy === 'rr')\n  schedulingPolicy = SCHED_RR;\nelse if (schedulingPolicy === 'none')\n  schedulingPolicy = SCHED_NONE;\nelse if (process.platform === 'win32') {\n  // Round-robin doesn't perform well on\n  // Windows due to the way IOCP is wired up.\n  schedulingPolicy = SCHED_NONE;\n} else\n  schedulingPolicy = SCHED_RR;\n\ncluster.schedulingPolicy = schedulingPolicy;\n\ncluster.setupPrimary = function(options) {\n  const settings = {\n    args: ArrayPrototypeSlice(process.argv\x2C 2)\x2C\n    exec: process.argv[1]\x2C\n    execArgv: process.execArgv\x2C\n    silent: false\x2C\n    ...cluster.settings\x2C\n    ...options\n  };\n\n  // Tell V8 to write profile data for each process to a separate file.\n  // Without --logfile=v8-%p.log\x2C everything ends up in a single\x2C unusable\n  // file. (Unusable because what V8 logs are memory addresses and each\n  // process has its own memory mappings.)\n  if (ArrayPrototypeSome(settings.execArgv\x2C\n                         (s) => StringPrototypeStartsWith(s\x2C '--prof')) &&\n      !ArrayPrototypeSome(settings.execArgv\x2C\n                          (s) => StringPrototypeStartsWith(s\x2C '--logfile='))) {\n    settings.execArgv = [...settings.execArgv\x2C '--logfile=v8-%p.log'];\n  }\n\n  cluster.settings = settings;\n\n  if (initialized === true)\n    return process.nextTick(setupSettingsNT\x2C settings);\n\n  initialized = true;\n  schedulingPolicy = cluster.schedulingPolicy;  // Freeze policy.\n  assert(schedulingPolicy === SCHED_NONE || schedulingPolicy === SCHED_RR\x2C\n         `Bad cluster.schedulingPolicy: ${schedulingPolicy}`);\n\n  process.nextTick(setupSettingsNT\x2C settings);\n\n  process.on('internalMessage'\x2C (message) => {\n    if (message.cmd !== 'NODE_DEBUG_ENABLED')\n      return;\n\n    for (const worker of ObjectValues(cluster.workers)) {\n      if (worker.state === 'online' || worker.state === 'listening') {\n        process._debugProcess(worker.process.pid);\n      } else {\n        worker.once('online'\x2C function() {\n          process._debugProcess(this.process.pid);\n        });\n      }\n    }\n  });\n};\n\n// Deprecated alias must be same as setupPrimary\ncluster.setupMaster = cluster.setupPrimary;\n\nfunction setupSettingsNT(settings) {\n  cluster.emit('setup'\x2C settings);\n}\n\nfunction createWorkerProcess(id\x2C env) {\n  const workerEnv = { ...process.env\x2C ...env\x2C NODE_UNIQUE_ID: `${id}` };\n  const execArgv = [...cluster.settings.execArgv];\n  const debugArgRegex = /--inspect(?:-brk|-port)?|--debug-port/;\n  const nodeOptions = process.env.NODE_OPTIONS || '';\n\n  if (ArrayPrototypeSome(execArgv\x2C\n                         (arg) => RegExpPrototypeTest(debugArgRegex\x2C arg)) ||\n      RegExpPrototypeTest(debugArgRegex\x2C nodeOptions)) {\n    let inspectPort;\n    if ('inspectPort' in cluster.settings) {\n      if (typeof cluster.settings.inspectPort === 'function')\n        inspectPort = cluster.settings.inspectPort();\n      else\n        inspectPort = cluster.settings.inspectPort;\n\n      validatePort(inspectPort);\n    } else {\n      inspectPort = process.debugPort + debugPortOffset;\n      if (inspectPort > maxPort)\n        inspectPort = inspectPort - maxPort + minPort - 1;\n      debugPortOffset++;\n    }\n\n    ArrayPrototypePush(execArgv\x2C `--inspect-port=${inspectPort}`);\n  }\n\n  return fork(cluster.settings.exec\x2C cluster.settings.args\x2C {\n    cwd: cluster.settings.cwd\x2C\n    env: workerEnv\x2C\n    serialization: cluster.settings.serialization\x2C\n    silent: cluster.settings.silent\x2C\n    windowsHide: cluster.settings.windowsHide\x2C\n    execArgv: execArgv\x2C\n    stdio: cluster.settings.stdio\x2C\n    gid: cluster.settings.gid\x2C\n    uid: cluster.settings.uid\n  });\n}\n\nfunction removeWorker(worker) {\n  assert(worker);\n  delete cluster.workers[worker.id];\n\n  if (ObjectKeys(cluster.workers).length === 0) {\n    assert(handles.size === 0\x2C 'Resource leak detected.');\n    intercom.emit('disconnect');\n  }\n}\n\nfunction removeHandlesForWorker(worker) {\n  assert(worker);\n\n  handles.forEach((handle\x2C key) => {\n    if (handle.remove(worker))\n      handles.delete(key);\n  });\n}\n\ncluster.fork = function(env) {\n  cluster.setupPrimary();\n  const id = ++ids;\n  const workerProcess = createWorkerProcess(id\x2C env);\n  const worker = new Worker({\n    id: id\x2C\n    process: workerProcess\n  });\n\n  worker.on('message'\x2C function(message\x2C handle) {\n    cluster.emit('message'\x2C this\x2C message\x2C handle);\n  });\n\n  worker.process.once('exit'\x2C (exitCode\x2C signalCode) => {\n    /*\n     * Remove the worker from the workers list only\n     * if it has disconnected\x2C otherwise we might\n     * still want to access it.\n     */\n    if (!worker.isConnected()) {\n      removeHandlesForWorker(worker);\n      removeWorker(worker);\n    }\n\n    worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect;\n    worker.state = 'dead';\n    worker.emit('exit'\x2C exitCode\x2C signalCode);\n    cluster.emit('exit'\x2C worker\x2C exitCode\x2C signalCode);\n  });\n\n  worker.process.once('disconnect'\x2C () => {\n    /*\n     * Now is a good time to remove the handles\n     * associated with this worker because it is\n     * not connected to the primary anymore.\n     */\n    removeHandlesForWorker(worker);\n\n    /*\n     * Remove the worker from the workers list only\n     * if its process has exited. Otherwise\x2C we might\n     * still want to access it.\n     */\n    if (worker.isDead())\n      removeWorker(worker);\n\n    worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect;\n    worker.state = 'disconnected';\n    worker.emit('disconnect');\n    cluster.emit('disconnect'\x2C worker);\n  });\n\n  worker.process.on('internalMessage'\x2C internal(worker\x2C onmessage));\n  process.nextTick(emitForkNT\x2C worker);\n  cluster.workers[worker.id] = worker;\n  return worker;\n};\n\nfunction emitForkNT(worker) {\n  cluster.emit('fork'\x2C worker);\n}\n\ncluster.disconnect = function(cb) {\n  const workers = ObjectKeys(cluster.workers);\n\n  if (workers.length === 0) {\n    process.nextTick(() => intercom.emit('disconnect'));\n  } else {\n    for (const worker of ObjectValues(cluster.workers)) {\n      if (worker.isConnected()) {\n        worker.disconnect();\n      }\n    }\n  }\n\n  if (typeof cb === 'function')\n    intercom.once('disconnect'\x2C cb);\n};\n\nconst methodMessageMapping = {\n  close\x2C\n  exitedAfterDisconnect\x2C\n  listening\x2C\n  online\x2C\n  queryServer\x2C\n};\n\nfunction onmessage(message\x2C handle) {\n  const worker = this;\n\n  const fn = methodMessageMapping[message.act];\n\n  if (typeof fn === 'function')\n    fn(worker\x2C message);\n}\n\nfunction online(worker) {\n  worker.state = 'online';\n  worker.emit('online');\n  cluster.emit('online'\x2C worker);\n}\n\nfunction exitedAfterDisconnect(worker\x2C message) {\n  worker.exitedAfterDisconnect = true;\n  send(worker\x2C { ack: message.seq });\n}\n\nfunction queryServer(worker\x2C message) {\n  // Stop processing if worker already disconnecting\n  if (worker.exitedAfterDisconnect)\n    return;\n\n  const key = `${message.address}:${message.port}:${message.addressType}:` +\n              `${message.fd}:${message.index}`;\n  let handle = handles.get(key);\n\n  if (handle === undefined) {\n    let address = message.address;\n\n    // Find shortest path for unix sockets because of the ~100 byte limit\n    if (message.port < 0 && typeof address === 'string' &&\n        process.platform !== 'win32') {\n\n      address = path.relative(process.cwd()\x2C address);\n\n      if (message.address.length < address.length)\n        address = message.address;\n    }\n\n    // UDP is exempt from round-robin connection balancing for what should\n    // be obvious reasons: it's connectionless. There is nothing to send to\n    // the workers except raw datagrams and that's pointless.\n    if (schedulingPolicy !== SCHED_RR ||\n        message.addressType === 'udp4' ||\n        message.addressType === 'udp6') {\n      handle = new SharedHandle(key\x2C address\x2C message);\n    } else {\n      handle = new RoundRobinHandle(key\x2C address\x2C message);\n    }\n\n    handles.set(key\x2C handle);\n  }\n\n  if (!handle.data)\n    handle.data = message.data;\n\n  // Set custom server data\n  handle.add(worker\x2C (errno\x2C reply\x2C handle) => {\n    const { data } = handles.get(key);\n\n    if (errno)\n      handles.delete(key);  // Gives other workers a chance to retry.\n\n    send(worker\x2C {\n      errno\x2C\n      key\x2C\n      ack: message.seq\x2C\n      data\x2C\n      ...reply\n    }\x2C handle);\n  });\n}\n\nfunction listening(worker\x2C message) {\n  const info = {\n    addressType: message.addressType\x2C\n    address: message.address\x2C\n    port: message.port\x2C\n    fd: message.fd\n  };\n\n  worker.state = 'listening';\n  worker.emit('listening'\x2C info);\n  cluster.emit('listening'\x2C worker\x2C info);\n}\n\n// Server in worker is closing\x2C remove from list. The handle may have been\n// removed by a prior call to removeHandlesForWorker() so guard against that.\nfunction close(worker\x2C message) {\n  const key = message.key;\n  const handle = handles.get(key);\n\n  if (handle && handle.remove(worker))\n    handles.delete(key);\n}\n\nfunction send(worker\x2C message\x2C handle\x2C cb) {\n  return sendHelper(worker.process\x2C message\x2C handle\x2C cb);\n}\n\n// Extend generic Worker with methods specific to the primary process.\nWorker.prototype.disconnect = function() {\n  this.exitedAfterDisconnect = true;\n  send(this\x2C { act: 'disconnect' });\n  removeHandlesForWorker(this);\n  removeWorker(this);\n  return this;\n};\n\nWorker.prototype.destroy = function(signo) {\n  const proc = this.process;\n\n  signo = signo || 'SIGTERM';\n\n  if (this.isConnected()) {\n    this.once('disconnect'\x2C () => proc.kill(signo));\n    this.disconnect();\n    return;\n  }\n\n  proc.kill(signo);\n};\n
code-source-info,0x26b72db375c6,135,0,10794,C0O0C4O10794,,
code-creation,Function,10,60875,0x26b72db37f8e,640, node:internal/cluster/primary:1:1,0x26b72db37540,~
code-source-info,0x26b72db37f8e,135,0,10794,C0O0C160O25C166O47C172O70C178O92C184O106C190O122C196O145C201O156C207O216C210O216C214O216C216O261C219O261C224O252C230O300C233O300C237O300C239O338C242O338C247O382C250O382C254O382C256O451C259O451C263O451C265O509C268O509C272O509C274O578C277O578C282O553C288O563C294O629C296O629C301O629C303O666C305O666C310O666C312O705C314O705C316O725C318O725C320O744C324O744C326O766C332O766C334O798C337O798C342O781C348O831C350O846C354O874C356O874C361O874C363O889C367O906C371O915C375O932C379O988C383O1006C387O1014C392O1029C396O1039C400O1055C404O1061C408O1078C412O1084C417O1103C421O1155C426O1172C430O1236C431O1236C433O1261C435O1261C437O1282C438O1282C440O1385C443O1393C448O1397C452O1385C454O1424C459O1445C464O1457C466O1474C470O1491C475O1512C480O1526C482O1543C486O1562C489O1574C496O1583C501O1687C503O1704C507O1727C509O1744C511O1757C516O1782C520O1803C527O1824C531O3495C537O3525C541O3515C545O5393C552O5406C556O7086C563O7105C567O7510C574O7514C580O7523C586O7548C592O7561C598O7571C604O7510C606O10354C609O10361C618O10382C622O10544C625O10551C634O10569C639O10793,,
tick,0x1bfd3cab0,60917,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x26b72db369b3,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x26b72db34a99,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,Eval,10,61167,0x26b72db39dfe,5, node:child_process:1:1,0x26b72db39928,~
script-source,136,node:child_process,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeLastIndexOf\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeTest\x2C\n  SafeSet\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst {\n  promisify\x2C\n  convertToValidSignal\x2C\n  createDeferredPromise\x2C\n  getSystemErrorName\n} = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nlet debug = require('internal/util/debuglog').debuglog(\n  'child_process'\x2C\n  (fn) => {\n    debug = fn;\n  }\n);\nconst { Buffer } = require('buffer');\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\n\nconst {\n  AbortError\x2C\n  codes: errorCodes\x2C\n  genericNodeError\x2C\n} = require('internal/errors');\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_CHILD_PROCESS_IPC_REQUIRED\x2C\n  ERR_CHILD_PROCESS_STDIO_MAXBUFFER\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\x2C\n} = errorCodes;\nconst { clearTimeout\x2C setTimeout } = require('timers');\nconst { getValidatedPath } = require('internal/fs/utils');\nconst {\n  isInt32\x2C\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst child_process = require('internal/child_process');\nconst {\n  getValidStdio\x2C\n  setupChannel\x2C\n  ChildProcess\x2C\n  stdioStringToArray\n} = child_process;\n\nconst MAX_BUFFER = 1024 * 1024;\n\n/**\n * Spawns a new Node.js process + fork.\n * @param {string|URL} modulePath\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   detached?: boolean;\n *   env?: Object;\n *   execPath?: string;\n *   execArgv?: string[];\n *   gid?: number;\n *   serialization?: string;\n *   signal?: AbortSignal;\n *   killSignal?: string | number;\n *   silent?: boolean;\n *   stdio?: Array | string;\n *   uid?: number;\n *   windowsVerbatimArguments?: boolean;\n *   timeout?: number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nfunction fork(modulePath\x2C args = []\x2C options) {\n  modulePath = getValidatedPath(modulePath\x2C 'modulePath');\n\n  // Get options and args arguments.\n  let execArgv;\n\n  if (args == null) {\n    args = [];\n  } else if (typeof args !== 'object') {\n    throw new ERR_INVALID_ARG_VALUE('args'\x2C args);\n  } else if (!ArrayIsArray(args)) {\n    options = args;\n    args = [];\n  }\n\n  if (options == null) {\n    options = {};\n  } else if (typeof options !== 'object') {\n    throw new ERR_INVALID_ARG_VALUE('options'\x2C options);\n  } else {\n    options = { ...options };\n  }\n\n  // Prepare arguments for fork:\n  execArgv = options.execArgv || process.execArgv;\n\n  if (execArgv === process.execArgv && process._eval != null) {\n    const index = ArrayPrototypeLastIndexOf(execArgv\x2C process._eval);\n    if (index > 0) {\n      // Remove the -e switch to avoid fork bombing ourselves.\n      execArgv = ArrayPrototypeSlice(execArgv);\n      ArrayPrototypeSplice(execArgv\x2C index - 1\x2C 2);\n    }\n  }\n\n  args = [...execArgv\x2C modulePath\x2C ...args];\n\n  if (typeof options.stdio === 'string') {\n    options.stdio = stdioStringToArray(options.stdio\x2C 'ipc');\n  } else if (!ArrayIsArray(options.stdio)) {\n    // Use a separate fd=3 for the IPC channel. Inherit stdin\x2C stdout\x2C\n    // and stderr from the parent if silent isn't set.\n    options.stdio = stdioStringToArray(\n      options.silent ? 'pipe' : 'inherit'\x2C\n      'ipc');\n  } else if (!ArrayPrototypeIncludes(options.stdio\x2C 'ipc')) {\n    throw new ERR_CHILD_PROCESS_IPC_REQUIRED('options.stdio');\n  }\n\n  options.execPath = options.execPath || process.execPath;\n  options.shell = false;\n\n  return spawn(options.execPath\x2C args\x2C options);\n}\n\nfunction _forkChild(fd\x2C serializationMode) {\n  // set process.send()\n  const p = new Pipe(PipeConstants.IPC);\n  p.open(fd);\n  p.unref();\n  const control = setupChannel(process\x2C p\x2C serializationMode);\n  process.on('newListener'\x2C function onNewListener(name) {\n    if (name === 'message' || name === 'disconnect') control.refCounted();\n  });\n  process.on('removeListener'\x2C function onRemoveListener(name) {\n    if (name === 'message' || name === 'disconnect') control.unrefCounted();\n  });\n}\n\nfunction normalizeExecArgs(command\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = { ...options };\n  options.shell = typeof options.shell === 'string' ? options.shell : true;\n\n  return {\n    file: command\x2C\n    options: options\x2C\n    callback: callback\n  };\n}\n\n/**\n * Spawns a shell executing the given command.\n * @param {string} command\n * @param {{\n *   cmd?: string;\n *   env?: Object;\n *   encoding?: string;\n *   shell?: string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   }} [options]\n * @param {(\n *   error?: Error\x2C\n *   stdout?: string | Buffer\x2C\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nfunction exec(command\x2C options\x2C callback) {\n  const opts = normalizeExecArgs(command\x2C options\x2C callback);\n  return module.exports.execFile(opts.file\x2C\n                                 opts.options\x2C\n                                 opts.callback);\n}\n\nconst customPromiseExecFunction = (orig) => {\n  return (...args) => {\n    const { promise\x2C resolve\x2C reject } = createDeferredPromise();\n\n    promise.child = orig(...args\x2C (err\x2C stdout\x2C stderr) => {\n      if (err !== null) {\n        err.stdout = stdout;\n        err.stderr = stderr;\n        reject(err);\n      } else {\n        resolve({ stdout\x2C stderr });\n      }\n    });\n\n    return promise;\n  };\n};\n\nObjectDefineProperty(exec\x2C promisify.custom\x2C {\n  enumerable: false\x2C\n  value: customPromiseExecFunction(exec)\n});\n\n/**\n * Spawns the specified file as a shell.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Object;\n *   encoding?: string;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   windowsVerbatimArguments?: boolean;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   error?: Error\x2C\n *   stdout?: string | Buffer\x2C\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nfunction execFile(file\x2C args = []\x2C options\x2C callback) {\n  if (args == null) {\n    args = [];\n  } else if (typeof args === 'object') {\n    if (!ArrayIsArray(args)) {\n      callback = options;\n      options = args;\n      args = [];\n    }\n  } else if (typeof args === 'function') {\n    callback = args;\n    options = {};\n    args = [];\n  } else {\n    throw new ERR_INVALID_ARG_VALUE('args'\x2C args);\n  }\n\n  if (options == null) {\n    options = {};\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } else if (typeof options !== 'object') {\n    throw new ERR_INVALID_ARG_VALUE('options'\x2C options);\n  }\n\n  if (callback && typeof callback !== 'function') {\n    throw new ERR_INVALID_ARG_VALUE('callback'\x2C callback);\n  }\n\n  options = {\n    encoding: 'utf8'\x2C\n    timeout: 0\x2C\n    maxBuffer: MAX_BUFFER\x2C\n    killSignal: 'SIGTERM'\x2C\n    cwd: null\x2C\n    env: null\x2C\n    shell: false\x2C\n    ...options\n  };\n\n  // Validate the timeout\x2C if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer\x2C if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const child = spawn(file\x2C args\x2C {\n    cwd: options.cwd\x2C\n    env: options.env\x2C\n    gid: options.gid\x2C\n    shell: options.shell\x2C\n    signal: options.signal\x2C\n    uid: options.uid\x2C\n    windowsHide: !!options.windowsHide\x2C\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments\n  });\n\n  let encoding;\n  const _stdout = [];\n  const _stderr = [];\n  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {\n    encoding = options.encoding;\n  } else {\n    encoding = null;\n  }\n  let stdoutLen = 0;\n  let stderrLen = 0;\n  let killed = false;\n  let exited = false;\n  let timeoutId;\n\n  let ex = null;\n\n  let cmd = file;\n\n  function exithandler(code\x2C signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    // merge chunks\n    let stdout;\n    let stderr;\n    if (encoding ||\n      (\n        child.stdout &&\n        child.stdout.readableEncoding\n      )) {\n      stdout = ArrayPrototypeJoin(_stdout\x2C '');\n    } else {\n      stdout = Buffer.concat(_stdout);\n    }\n    if (encoding ||\n      (\n        child.stderr &&\n        child.stderr.readableEncoding\n      )) {\n      stderr = ArrayPrototypeJoin(_stderr\x2C '');\n    } else {\n      stderr = Buffer.concat(_stderr);\n    }\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null\x2C stdout\x2C stderr);\n      return;\n    }\n\n    if (args.length !== 0)\n      cmd += ` ${ArrayPrototypeJoin(args\x2C ' ')}`;\n\n    if (!ex) {\n      ex = genericNodeError(`Command failed: ${cmd}\\n${stderr}`\x2C {\n        code: code < 0 ? getSystemErrorName(code) : code\x2C\n        killed: child.killed || killed\x2C\n        signal: signal\n      });\n    }\n\n    ex.cmd = cmd;\n    callback(ex\x2C stdout\x2C stderr);\n  }\n\n  function errorhandler(e) {\n    ex = e;\n\n    if (child.stdout)\n      child.stdout.destroy();\n\n    if (child.stderr)\n      child.stderr.destroy();\n\n    exithandler();\n  }\n\n  function kill() {\n    if (child.stdout)\n      child.stdout.destroy();\n\n    if (child.stderr)\n      child.stderr.destroy();\n\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exithandler();\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }\x2C options.timeout);\n  }\n\n  if (child.stdout) {\n    if (encoding)\n      child.stdout.setEncoding(encoding);\n\n    child.stdout.on('data'\x2C function onChildStdout(chunk) {\n      const encoding = child.stdout.readableEncoding;\n      const length = encoding ?\n        Buffer.byteLength(chunk\x2C encoding) :\n        chunk.length;\n      const slice = encoding ? StringPrototypeSlice :\n        (buf\x2C ...args) => buf.slice(...args);\n      stdoutLen += length;\n\n      if (stdoutLen > options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stdoutLen - length);\n        ArrayPrototypePush(_stdout\x2C slice(chunk\x2C 0\x2C truncatedLen));\n\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stdout');\n        kill();\n      } else {\n        ArrayPrototypePush(_stdout\x2C chunk);\n      }\n    });\n  }\n\n  if (child.stderr) {\n    if (encoding)\n      child.stderr.setEncoding(encoding);\n\n    child.stderr.on('data'\x2C function onChildStderr(chunk) {\n      const encoding = child.stderr.readableEncoding;\n      const length = encoding ?\n        Buffer.byteLength(chunk\x2C encoding) :\n        chunk.length;\n      stderrLen += length;\n\n      if (stderrLen > options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stderrLen - length);\n        ArrayPrototypePush(_stderr\x2C\n                           chunk.slice(0\x2C truncatedLen));\n\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stderr');\n        kill();\n      } else {\n        _stderr.push(chunk);\n      }\n    });\n  }\n\n  child.addListener('close'\x2C exithandler);\n  child.addListener('error'\x2C errorhandler);\n\n  return child;\n}\n\nObjectDefineProperty(execFile\x2C promisify.custom\x2C {\n  enumerable: false\x2C\n  value: customPromiseExecFunction(execFile)\n});\n\nfunction normalizeSpawnArguments(file\x2C args\x2C options) {\n  validateString(file\x2C 'file');\n\n  if (file.length === 0)\n    throw new ERR_INVALID_ARG_VALUE('file'\x2C file\x2C 'cannot be empty');\n\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice(args);\n  } else if (args == null) {\n    args = [];\n  } else if (typeof args !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('args'\x2C 'object'\x2C args);\n  } else {\n    options = args;\n    args = [];\n  }\n\n  if (options === undefined)\n    options = {};\n  else\n    validateObject(options\x2C 'options');\n\n  let cwd = options.cwd;\n\n  // Validate the cwd\x2C if present.\n  if (cwd != null) {\n    cwd = getValidatedPath(cwd\x2C 'options.cwd');\n  }\n\n  // Validate detached\x2C if present.\n  if (options.detached != null) {\n    validateBoolean(options.detached\x2C 'options.detached');\n  }\n\n  // Validate the uid\x2C if present.\n  if (options.uid != null && !isInt32(options.uid)) {\n    throw new ERR_INVALID_ARG_TYPE('options.uid'\x2C 'int32'\x2C options.uid);\n  }\n\n  // Validate the gid\x2C if present.\n  if (options.gid != null && !isInt32(options.gid)) {\n    throw new ERR_INVALID_ARG_TYPE('options.gid'\x2C 'int32'\x2C options.gid);\n  }\n\n  // Validate the shell\x2C if present.\n  if (options.shell != null &&\n      typeof options.shell !== 'boolean' &&\n      typeof options.shell !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE('options.shell'\x2C\n                                   ['boolean'\x2C 'string']\x2C options.shell);\n  }\n\n  // Validate argv0\x2C if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0\x2C 'options.argv0');\n  }\n\n  // Validate windowsHide\x2C if present.\n  if (options.windowsHide != null) {\n    validateBoolean(options.windowsHide\x2C 'options.windowsHide');\n  }\n\n  // Validate windowsVerbatimArguments\x2C if present.\n  let { windowsVerbatimArguments } = options;\n  if (windowsVerbatimArguments != null) {\n    validateBoolean(windowsVerbatimArguments\x2C\n                    'options.windowsVerbatimArguments');\n  }\n\n  if (options.shell) {\n    const command = ArrayPrototypeJoin([file\x2C ...args]\x2C ' ');\n    // Set the shell\x2C switches\x2C and commands.\n    if (process.platform === 'win32') {\n      if (typeof options.shell === 'string')\n        file = options.shell;\n      else\n        file = process.env.comspec || 'cmd.exe';\n      // '/d /s /c' is used only for cmd.exe.\n      if (RegExpPrototypeTest(/^(?:.*\\\\)?cmd(?:\\.exe)?$/i\x2C file)) {\n        args = ['/d'\x2C '/s'\x2C '/c'\x2C `"${command}"`];\n        windowsVerbatimArguments = true;\n      } else {\n        args = ['-c'\x2C command];\n      }\n    } else {\n      if (typeof options.shell === 'string')\n        file = options.shell;\n      else if (process.platform === 'android')\n        file = '/system/bin/sh';\n      else\n        file = '/bin/sh';\n      args = ['-c'\x2C command];\n    }\n  }\n\n  if (typeof options.argv0 === 'string') {\n    ArrayPrototypeUnshift(args\x2C options.argv0);\n  } else {\n    ArrayPrototypeUnshift(args\x2C file);\n  }\n\n  const env = options.env || process.env;\n  const envPairs = [];\n\n  // process.env.NODE_V8_COVERAGE always propagates\x2C making it possible to\n  // collect coverage for programs that spawn with white-listed environment.\n  if (process.env.NODE_V8_COVERAGE &&\n      !ObjectPrototypeHasOwnProperty(options.env || {}\x2C 'NODE_V8_COVERAGE')) {\n    env.NODE_V8_COVERAGE = process.env.NODE_V8_COVERAGE;\n  }\n\n  let envKeys = [];\n  // Prototype values are intentionally included.\n  for (const key in env) {\n    ArrayPrototypePush(envKeys\x2C key);\n  }\n\n  if (process.platform === 'win32') {\n    // On Windows env keys are case insensitive. Filter out duplicates\x2C\n    // keeping only the first one (in lexicographic order)\n    const sawKey = new SafeSet();\n    envKeys = ArrayPrototypeFilter(\n      ArrayPrototypeSort(envKeys)\x2C\n      (key) => {\n        const uppercaseKey = StringPrototypeToUpperCase(key);\n        if (sawKey.has(uppercaseKey)) {\n          return false;\n        }\n        sawKey.add(uppercaseKey);\n        return true;\n      }\n    );\n  }\n\n  for (const key of envKeys) {\n    const value = env[key];\n    if (value !== undefined) {\n      ArrayPrototypePush(envPairs\x2C `${key}=${value}`);\n    }\n  }\n\n  return {\n    // Make a shallow copy so we don't clobber the user's options object.\n    ...options\x2C\n    args\x2C\n    cwd\x2C\n    detached: !!options.detached\x2C\n    envPairs\x2C\n    file\x2C\n    windowsHide: !!options.windowsHide\x2C\n    windowsVerbatimArguments: !!windowsVerbatimArguments\x2C\n  };\n}\n\nfunction abortChildProcess(child\x2C killSignal) {\n  if (!child)\n    return;\n  try {\n    if (child.kill(killSignal)) {\n      child.emit('error'\x2C new AbortError());\n    }\n  } catch (err) {\n    child.emit('error'\x2C err);\n  }\n}\n\n/**\n * Spawns a new process using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Object;\n *   argv0?: string;\n *   stdio?: Array | string;\n *   detached?: boolean;\n *   uid?: number;\n *   gid?: number;\n *   serialization?: string;\n *   shell?: boolean | string;\n *   windowsVerbatimArguments?: boolean;\n *   windowsHide?: boolean;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nfunction spawn(file\x2C args\x2C options) {\n  options = normalizeSpawnArguments(file\x2C args\x2C options);\n  validateTimeout(options.timeout);\n  validateAbortSignal(options.signal\x2C 'options.signal');\n  const killSignal = sanitizeKillSignal(options.killSignal);\n  const child = new ChildProcess();\n\n  debug('spawn'\x2C options);\n  child.spawn(options);\n\n  if (options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal);\n        } catch (err) {\n          child.emit('error'\x2C err);\n        }\n        timeoutId = null;\n      }\n    }\x2C options.timeout);\n\n    child.once('exit'\x2C () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n    });\n  }\n\n  if (options.signal) {\n    const signal = options.signal;\n    if (signal.aborted) {\n      process.nextTick(onAbortListener);\n    } else {\n      signal.addEventListener('abort'\x2C onAbortListener\x2C { once: true });\n      child.once('exit'\x2C\n                 () => signal.removeEventListener('abort'\x2C onAbortListener));\n    }\n\n    function onAbortListener() {\n      abortChildProcess(child\x2C killSignal);\n    }\n  }\n\n  return child;\n}\n\n/**\n * Spawns a new process synchronously using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   argv0?: string;\n *   stdio?: string | Array;\n *   env?: Object;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   shell?: boolean | string;\n *   windowsVerbatimArguments?: boolean;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {{\n *   pid: number;\n *   output: Array;\n *   stdout: Buffer | string;\n *   stderr: Buffer | string;\n *   status: number | null;\n *   signal: string | null;\n *   error: Error;\n *   }}\n */\nfunction spawnSync(file\x2C args\x2C options) {\n  options = {\n    maxBuffer: MAX_BUFFER\x2C\n    ...normalizeSpawnArguments(file\x2C args\x2C options)\n  };\n\n  debug('spawnSync'\x2C options);\n\n  // Validate the timeout\x2C if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer\x2C if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  // Validate and translate the kill signal\x2C if present.\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  options.stdio = getValidStdio(options.stdio || 'pipe'\x2C true).stdio;\n\n  if (options.input) {\n    const stdin = options.stdio[0] = { ...options.stdio[0] };\n    stdin.input = options.input;\n  }\n\n  // We may want to pass data in on any given fd\x2C ensure it is a valid buffer\n  for (let i = 0; i < options.stdio.length; i++) {\n    const input = options.stdio[i] && options.stdio[i].input;\n    if (input != null) {\n      const pipe = options.stdio[i] = { ...options.stdio[i] };\n      if (isArrayBufferView(input)) {\n        pipe.input = input;\n      } else if (typeof input === 'string') {\n        pipe.input = Buffer.from(input\x2C options.encoding);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(`options.stdio[${i}]`\x2C\n                                       ['Buffer'\x2C\n                                        'TypedArray'\x2C\n                                        'DataView'\x2C\n                                        'string']\x2C\n                                       input);\n      }\n    }\n  }\n\n  return child_process.spawnSync(options);\n}\n\n\nfunction checkExecSyncError(ret\x2C args\x2C cmd) {\n  let err;\n  if (ret.error) {\n    err = ret.error;\n    ObjectAssign(err\x2C ret);\n  } else if (ret.status !== 0) {\n    let msg = 'Command failed: ';\n    msg += cmd || ArrayPrototypeJoin(args\x2C ' ');\n    if (ret.stderr && ret.stderr.length > 0)\n      msg += `\\n${ret.stderr.toString()}`;\n    err = genericNodeError(msg\x2C ret);\n  }\n  return err;\n}\n\n/**\n * Spawns a file as a shell synchronously.\n * @param {string} command\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Object;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {Buffer | string}\n */\nfunction execFileSync(command\x2C args\x2C options) {\n  options = normalizeSpawnArguments(command\x2C args\x2C options);\n\n  const inheritStderr = !options.stdio;\n  const ret = spawnSync(options.file\x2C\n                        ArrayPrototypeSlice(options.args\x2C 1)\x2C options);\n\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n\n  const err = checkExecSyncError(ret\x2C options.args\x2C undefined);\n\n  if (err)\n    throw err;\n\n  return ret.stdout;\n}\n\n/**\n * Spawns a shell executing the given `command` synchronously.\n * @param {string} command\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Object;\n *   shell?: string;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {Buffer | string}\n */\nfunction execSync(command\x2C options) {\n  const opts = normalizeExecArgs(command\x2C options\x2C null);\n  const inheritStderr = !opts.options.stdio;\n\n  const ret = spawnSync(opts.file\x2C opts.options);\n\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n\n  const err = checkExecSyncError(ret\x2C opts.args\x2C command);\n\n  if (err)\n    throw err;\n\n  return ret.stdout;\n}\n\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0)) {\n    throw new ERR_OUT_OF_RANGE('timeout'\x2C 'an unsigned integer'\x2C timeout);\n  }\n}\n\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new ERR_OUT_OF_RANGE('options.maxBuffer'\x2C\n                               'a positive number'\x2C\n                               maxBuffer);\n  }\n}\n\n\nfunction sanitizeKillSignal(killSignal) {\n  if (typeof killSignal === 'string' || typeof killSignal === 'number') {\n    return convertToValidSignal(killSignal);\n  } else if (killSignal != null) {\n    throw new ERR_INVALID_ARG_TYPE('options.killSignal'\x2C\n                                   ['string'\x2C 'number']\x2C\n                                   killSignal);\n  }\n}\n\nmodule.exports = {\n  _forkChild\x2C\n  ChildProcess\x2C\n  exec\x2C\n  execFile\x2C\n  execFileSync\x2C\n  execSync\x2C\n  fork\x2C\n  spawn\x2C\n  spawnSync\n};\n
code-source-info,0x26b72db39dfe,136,0,24477,C0O0C4O24477,,
code-creation,Function,10,62084,0x26b72db3a85e,748, node:child_process:1:1,0x26b72db39d78,~
code-source-info,0x26b72db3a85e,136,0,24477,C0O0C235O1159C241O1175C247O1199C253O1225C259O1247C265O1276C271O1298C277O1321C283O1343C289O1367C295O1392C301O1411C307O1427C312O1451C318O1484C324O1507C330O1518C336O1542C342O1683C345O1683C350O1598C355O1611C361O1635C367O1660C373O1739C376O1739C381O1717C387O1783C390O1783C395O1816C408O1817C414O1783C416O1900C419O1900C424O1889C430O1962C433O1962C438O1927C444O1944C450O2060C453O2060C458O2003C464O2024C469O2038C475O2098C481O2123C487O2157C493O2194C499O2218C505O2289C508O2289C513O2260C519O2274C525O2337C528O2337C533O2316C539O2468C542O2468C547O2377C553O2388C559O2411C565O2430C571O2448C577O2522C580O2522C584O2522C586O2639C589O2567C595O2584C601O2600C607O2616C613O2674C619O2674C621O6574C626O6978C636O7018C647O6941C652O12718C662O12758C673O12677C678O24348C688O24369C694O24383C700O24399C706O24407C712O24419C718O24435C724O24447C730O24455C736O24464C742O24363C747O24476,,
tick,0x1bfd39474,62167,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x26b72db38069,0x105108d28,0x10510894c,0x26b72db369b3,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x26b72db34a99,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
new,MemoryChunk,0x2cbd76480000,262144
code-creation,Eval,10,62500,0x26b72db3ddc6,5, node:internal/child_process:1:1,0x26b72db3d6c8,~
script-source,137,node:internal/child_process,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  FunctionPrototype\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  StringPrototypeSlice\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_HANDLE_TYPE\x2C\n    ERR_INVALID_SYNC_FORK_INPUT\x2C\n    ERR_IPC_CHANNEL_CLOSED\x2C\n    ERR_IPC_DISCONNECTED\x2C\n    ERR_IPC_ONE_PIPE\x2C\n    ERR_IPC_SYNC_FORK\x2C\n    ERR_MISSING_ARGS\n  }\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst EventEmitter = require('events');\nconst net = require('net');\nconst dgram = require('dgram');\nconst inspect = require('internal/util/inspect').inspect;\nconst assert = require('internal/assert');\n\nconst { Process } = internalBinding('process_wrap');\nconst {\n  WriteWrap\x2C\n  kReadBytesOrError\x2C\n  kArrayBufferOffset\x2C\n  kLastWriteWasAsync\x2C\n  streamBaseState\n} = internalBinding('stream_wrap');\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\nconst { TCP } = internalBinding('tcp_wrap');\nconst { TTY } = internalBinding('tty_wrap');\nconst { UDP } = internalBinding('udp_wrap');\nconst SocketList = require('internal/socket_list');\nconst { owner_symbol } = require('internal/async_hooks').symbols;\nconst { convertToValidSignal\x2C deprecate } = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nconst spawn_sync = internalBinding('spawn_sync');\nconst { kStateSymbol } = require('internal/dgram');\n\nconst {\n  UV_EACCES\x2C\n  UV_EAGAIN\x2C\n  UV_EINVAL\x2C\n  UV_EMFILE\x2C\n  UV_ENFILE\x2C\n  UV_ENOENT\x2C\n  UV_ENOSYS\x2C\n  UV_ESRCH\n} = internalBinding('uv');\n\nconst { SocketListSend\x2C SocketListReceive } = SocketList;\n\n// Lazy loaded for startup performance and to allow monkey patching of\n// internalBinding('http_parser').HTTPParser.\nlet freeParser;\nlet HTTPParser;\n\nconst MAX_HANDLE_RETRANSMISSIONS = 3;\nconst kChannelHandle = Symbol('kChannelHandle');\nconst kIsUsedAsStdio = Symbol('kIsUsedAsStdio');\nconst kPendingMessages = Symbol('kPendingMessages');\n\n// This object contain function to convert TCP objects to native handle objects\n// and back again.\nconst handleConversion = {\n  'net.Native': {\n    simultaneousAccepts: true\x2C\n\n    send(message\x2C handle\x2C options) {\n      return handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      emit(handle);\n    }\n  }\x2C\n\n  'net.Server': {\n    simultaneousAccepts: true\x2C\n\n    send(message\x2C server\x2C options) {\n      return server._handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const server = new net.Server();\n      server.listen(handle\x2C () => {\n        emit(server);\n      });\n    }\n  }\x2C\n\n  'net.Socket': {\n    send(message\x2C socket\x2C options) {\n      if (!socket._handle)\n        return;\n\n      // If the socket was created by net.Server\n      if (socket.server) {\n        // The worker should keep track of the socket\n        message.key = socket.server._connectionKey;\n\n        const firstTime = !this[kChannelHandle].sockets.send[message.key];\n        const socketList = getSocketList('send'\x2C this\x2C message.key);\n\n        // The server should no longer expose a .connection property\n        // and when asked to close it should query the socket status from\n        // the workers\n        if (firstTime) socket.server._setupWorker(socketList);\n\n        // Act like socket is detached\n        if (!options.keepOpen)\n          socket.server._connections--;\n      }\n\n      const handle = socket._handle;\n\n      // Remove handle from socket object\x2C it will be closed when the socket\n      // will be sent\n      if (!options.keepOpen) {\n        handle.onread = nop;\n        socket._handle = null;\n        socket.setTimeout(0);\n\n        if (freeParser === undefined)\n          freeParser = require('_http_common').freeParser;\n        if (HTTPParser === undefined)\n          HTTPParser = require('_http_common').HTTPParser;\n\n        // In case of an HTTP connection socket\x2C release the associated\n        // resources\n        if (socket.parser && socket.parser instanceof HTTPParser) {\n          freeParser(socket.parser\x2C null\x2C socket);\n          if (socket._httpMessage)\n            socket._httpMessage.detachSocket(socket);\n        }\n      }\n\n      return handle;\n    }\x2C\n\n    postSend(message\x2C handle\x2C options\x2C callback\x2C target) {\n      // Store the handle after successfully sending it\x2C so it can be closed\n      // when the NODE_HANDLE_ACK is received. If the handle could not be sent\x2C\n      // just close it.\n      if (handle && !options.keepOpen) {\n        if (target) {\n          // There can only be one _pendingMessage as passing handles are\n          // processed one at a time: handles are stored in _handleQueue while\n          // waiting for the NODE_HANDLE_ACK of the current passing handle.\n          assert(!target._pendingMessage);\n          target._pendingMessage =\n              { callback\x2C message\x2C handle\x2C options\x2C retransmissions: 0 };\n        } else {\n          handle.close();\n        }\n      }\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const socket = new net.Socket({\n        handle: handle\x2C\n        readable: true\x2C\n        writable: true\n      });\n\n      // If the socket was created by net.Server we will track the socket\n      if (message.key) {\n\n        // Add socket to connections list\n        const socketList = getSocketList('got'\x2C this\x2C message.key);\n        socketList.add({\n          socket: socket\n        });\n      }\n\n      emit(socket);\n    }\n  }\x2C\n\n  'dgram.Native': {\n    simultaneousAccepts: false\x2C\n\n    send(message\x2C handle\x2C options) {\n      return handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      emit(handle);\n    }\n  }\x2C\n\n  'dgram.Socket': {\n    simultaneousAccepts: false\x2C\n\n    send(message\x2C socket\x2C options) {\n      message.dgramType = socket.type;\n\n      return socket[kStateSymbol].handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const socket = new dgram.Socket(message.dgramType);\n\n      socket.bind(handle\x2C () => {\n        emit(socket);\n      });\n    }\n  }\n};\n\nfunction stdioStringToArray(stdio\x2C channel) {\n  const options = [];\n\n  switch (stdio) {\n    case 'ignore':\n    case 'overlapped':\n    case 'pipe': ArrayPrototypePush(options\x2C stdio\x2C stdio\x2C stdio); break;\n    case 'inherit': ArrayPrototypePush(options\x2C 0\x2C 1\x2C 2); break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n  }\n\n  if (channel) ArrayPrototypePush(options\x2C channel);\n\n  return options;\n}\n\nfunction ChildProcess() {\n  FunctionPrototypeCall(EventEmitter\x2C this);\n\n  this._closesNeeded = 1;\n  this._closesGot = 0;\n  this.connected = false;\n\n  this.signalCode = null;\n  this.exitCode = null;\n  this.killed = false;\n  this.spawnfile = null;\n\n  this._handle = new Process();\n  this._handle[owner_symbol] = this;\n\n  this._handle.onexit = (exitCode\x2C signalCode) => {\n    if (signalCode) {\n      this.signalCode = signalCode;\n    } else {\n      this.exitCode = exitCode;\n    }\n\n    if (this.stdin) {\n      this.stdin.destroy();\n    }\n\n    this._handle.close();\n    this._handle = null;\n\n    if (exitCode < 0) {\n      const syscall = this.spawnfile ? 'spawn ' + this.spawnfile : 'spawn';\n      const err = errnoException(exitCode\x2C syscall);\n\n      if (this.spawnfile)\n        err.path = this.spawnfile;\n\n      err.spawnargs = ArrayPrototypeSlice(this.spawnargs\x2C 1);\n      this.emit('error'\x2C err);\n    } else {\n      this.emit('exit'\x2C this.exitCode\x2C this.signalCode);\n    }\n\n    // If any of the stdio streams have not been touched\x2C\n    // then pull all the data through so that it can get the\n    // eof and emit a 'close' event.\n    // Do it on nextTick so that the user has one last chance\n    // to consume the output\x2C if for example they only want to\n    // start reading the data once the process exits.\n    process.nextTick(flushStdio\x2C this);\n\n    maybeClose(this);\n  };\n}\nObjectSetPrototypeOf(ChildProcess.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(ChildProcess\x2C EventEmitter);\n\n\nfunction flushStdio(subprocess) {\n  const stdio = subprocess.stdio;\n\n  if (stdio == null) return;\n\n  for (let i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    // TODO(addaleax): This doesn't necessarily account for all the ways in\n    // which data can be read from a stream\x2C e.g. being consumed on the\n    // native layer directly as a StreamBase.\n    if (!stream || !stream.readable || stream[kIsUsedAsStdio]) {\n      continue;\n    }\n    stream.resume();\n  }\n}\n\n\nfunction createSocket(pipe\x2C readable) {\n  return net.Socket({ handle: pipe\x2C readable });\n}\n\n\nfunction getHandleWrapType(stream) {\n  if (stream instanceof Pipe) return 'pipe';\n  if (stream instanceof TTY) return 'tty';\n  if (stream instanceof TCP) return 'tcp';\n  if (stream instanceof UDP) return 'udp';\n\n  return false;\n}\n\nfunction closePendingHandle(target) {\n  target._pendingMessage.handle.close();\n  target._pendingMessage = null;\n}\n\n\nChildProcess.prototype.spawn = function(options) {\n  let i = 0;\n\n  validateObject(options\x2C 'options');\n\n  // If no `stdio` option was given - use default\n  let stdio = options.stdio || 'pipe';\n\n  stdio = getValidStdio(stdio\x2C false);\n\n  const ipc = stdio.ipc;\n  const ipcFd = stdio.ipcFd;\n  stdio = options.stdio = stdio.stdio;\n\n\n  validateOneOf(options.serialization\x2C 'options.serialization'\x2C\n                [undefined\x2C 'json'\x2C 'advanced']);\n  const serialization = options.serialization || 'json';\n\n  if (ipc !== undefined) {\n    // Let child process know about opened IPC channel\n    if (options.envPairs === undefined)\n      options.envPairs = [];\n    else\n      validateArray(options.envPairs\x2C 'options.envPairs');\n\n    ArrayPrototypePush(options.envPairs\x2C `NODE_CHANNEL_FD=${ipcFd}`);\n    ArrayPrototypePush(options.envPairs\x2C\n                       `NODE_CHANNEL_SERIALIZATION_MODE=${serialization}`);\n  }\n\n  validateString(options.file\x2C 'options.file');\n  this.spawnfile = options.file;\n\n  if (options.args === undefined) {\n    this.spawnargs = [];\n  } else {\n    validateArray(options.args\x2C 'options.args');\n    this.spawnargs = options.args;\n  }\n\n  const err = this._handle.spawn(options);\n\n  // Run-time errors should emit an error\x2C not throw an exception.\n  if (err === UV_EACCES ||\n      err === UV_EAGAIN ||\n      err === UV_EMFILE ||\n      err === UV_ENFILE ||\n      err === UV_ENOENT) {\n    process.nextTick(onErrorNT\x2C this\x2C err);\n\n    // There is no point in continuing when we've hit EMFILE or ENFILE\n    // because we won't be able to set up the stdio file descriptors.\n    if (err === UV_EMFILE || err === UV_ENFILE)\n      return err;\n  } else if (err) {\n    // Close all opened fds on error\n    for (i = 0; i < stdio.length; i++) {\n      const stream = stdio[i];\n      if (stream.type === 'pipe') {\n        stream.handle.close();\n      }\n    }\n\n    this._handle.close();\n    this._handle = null;\n    throw errnoException(err\x2C 'spawn');\n  } else {\n    process.nextTick(onSpawnNT\x2C this);\n  }\n\n  this.pid = this._handle.pid;\n\n  for (i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    if (stream.type === 'ignore') continue;\n\n    if (stream.ipc) {\n      this._closesNeeded++;\n      continue;\n    }\n\n    // The stream is already cloned and piped\x2C thus stop its readable side\x2C\n    // otherwise we might attempt to read from the stream when at the same time\n    // the child process does.\n    if (stream.type === 'wrap') {\n      stream.handle.reading = false;\n      stream.handle.readStop();\n      stream._stdio.pause();\n      stream._stdio.readableFlowing = false;\n      stream._stdio._readableState.reading = false;\n      stream._stdio[kIsUsedAsStdio] = true;\n      continue;\n    }\n\n    if (stream.handle) {\n      stream.socket = createSocket(this.pid !== 0 ?\n        stream.handle : null\x2C i > 0);\n\n      if (i > 0 && this.pid !== 0) {\n        this._closesNeeded++;\n        stream.socket.on('close'\x2C () => {\n          maybeClose(this);\n        });\n      }\n    }\n  }\n\n  this.stdin = stdio.length >= 1 && stdio[0].socket !== undefined ?\n    stdio[0].socket : null;\n  this.stdout = stdio.length >= 2 && stdio[1].socket !== undefined ?\n    stdio[1].socket : null;\n  this.stderr = stdio.length >= 3 && stdio[2].socket !== undefined ?\n    stdio[2].socket : null;\n\n  this.stdio = [];\n\n  for (i = 0; i < stdio.length; i++)\n    ArrayPrototypePush(this.stdio\x2C\n                       stdio[i].socket === undefined ? null : stdio[i].socket);\n\n  // Add .send() method and start listening for IPC data\n  if (ipc !== undefined) setupChannel(this\x2C ipc\x2C serialization);\n\n  return err;\n};\n\n\nfunction onErrorNT(self\x2C err) {\n  self._handle.onexit(err);\n}\n\n\nfunction onSpawnNT(self) {\n  self.emit('spawn');\n}\n\n\nChildProcess.prototype.kill = function(sig) {\n\n  const signal = sig === 0 ? sig :\n    convertToValidSignal(sig === undefined ? 'SIGTERM' : sig);\n\n  if (this._handle) {\n    const err = this._handle.kill(signal);\n    if (err === 0) {\n      /* Success. */\n      this.killed = true;\n      return true;\n    }\n    if (err === UV_ESRCH) {\n      /* Already dead. */\n    } else if (err === UV_EINVAL || err === UV_ENOSYS) {\n      /* The underlying platform doesn't support this signal. */\n      throw errnoException(err\x2C 'kill');\n    } else {\n      /* Other error\x2C almost certainly EPERM. */\n      this.emit('error'\x2C errnoException(err\x2C 'kill'));\n    }\n  }\n\n  /* Kill didn't succeed. */\n  return false;\n};\n\n\nChildProcess.prototype.ref = function() {\n  if (this._handle) this._handle.ref();\n};\n\n\nChildProcess.prototype.unref = function() {\n  if (this._handle) this._handle.unref();\n};\n\nclass Control extends EventEmitter {\n  #channel = null;\n  #refs = 0;\n  #refExplicitlySet = false;\n\n  constructor(channel) {\n    super();\n    this.#channel = channel;\n    this[kPendingMessages] = [];\n  }\n\n  // The methods keeping track of the counter are being used to track the\n  // listener count on the child process object as well as when writes are\n  // in progress. Once the user has explicitly requested a certain state\x2C these\n  // methods become no-ops in order to not interfere with the user's intentions.\n  refCounted() {\n    if (++this.#refs === 1 && !this.#refExplicitlySet) {\n      this.#channel.ref();\n    }\n  }\n\n  unrefCounted() {\n    if (--this.#refs === 0 && !this.#refExplicitlySet) {\n      this.#channel.unref();\n      this.emit('unref');\n    }\n  }\n\n  ref() {\n    this.#refExplicitlySet = true;\n    this.#channel.ref();\n  }\n\n  unref() {\n    this.#refExplicitlySet = true;\n    this.#channel.unref();\n  }\n\n  get fd() {\n    return this.#channel ? this.#channel.fd : undefined;\n  }\n}\n\nconst channelDeprecationMsg = '_channel is deprecated. ' +\n                              'Use ChildProcess.channel instead.';\n\nlet serialization;\nfunction setupChannel(target\x2C channel\x2C serializationMode) {\n  const control = new Control(channel);\n  target.channel = control;\n  target[kChannelHandle] = channel;\n\n  ObjectDefineProperty(target\x2C '_channel'\x2C {\n    get: deprecate(() => {\n      return target.channel;\n    }\x2C channelDeprecationMsg\x2C 'DEP0129')\x2C\n    set: deprecate((val) => {\n      target.channel = val;\n    }\x2C channelDeprecationMsg\x2C 'DEP0129')\x2C\n    configurable: true\x2C\n    enumerable: false\n  });\n\n  target._handleQueue = null;\n  target._pendingMessage = null;\n\n  if (serialization === undefined)\n    serialization = require('internal/child_process/serialization');\n  const {\n    initMessageChannel\x2C\n    parseChannelMessages\x2C\n    writeChannelMessage\n  } = serialization[serializationMode];\n\n  let pendingHandle = null;\n  initMessageChannel(channel);\n  channel.pendingHandle = null;\n  channel.onread = function(arrayBuffer) {\n    const recvHandle = channel.pendingHandle;\n    channel.pendingHandle = null;\n    if (arrayBuffer) {\n      const nread = streamBaseState[kReadBytesOrError];\n      const offset = streamBaseState[kArrayBufferOffset];\n      const pool = new Uint8Array(arrayBuffer\x2C offset\x2C nread);\n      if (recvHandle)\n        pendingHandle = recvHandle;\n\n      for (const message of parseChannelMessages(channel\x2C pool)) {\n        // There will be at most one NODE_HANDLE message in every chunk we\n        // read because SCM_RIGHTS messages don't get coalesced. Make sure\n        // that we deliver the handle with the right message however.\n        if (isInternal(message)) {\n          if (message.cmd === 'NODE_HANDLE') {\n            handleMessage(message\x2C pendingHandle\x2C true);\n            pendingHandle = null;\n          } else {\n            handleMessage(message\x2C undefined\x2C true);\n          }\n        } else {\n          handleMessage(message\x2C undefined\x2C false);\n        }\n      }\n    } else {\n      this.buffering = false;\n      target.disconnect();\n      channel.onread = nop;\n      channel.close();\n      target.channel = null;\n      maybeClose(target);\n    }\n  };\n\n  // Object where socket lists will live\n  channel.sockets = { got: {}\x2C send: {} };\n\n  // Handlers will go through this\n  target.on('internalMessage'\x2C function(message\x2C handle) {\n    // Once acknowledged - continue sending handles.\n    if (message.cmd === 'NODE_HANDLE_ACK' ||\n        message.cmd === 'NODE_HANDLE_NACK') {\n\n      if (target._pendingMessage) {\n        if (message.cmd === 'NODE_HANDLE_ACK') {\n          closePendingHandle(target);\n        } else if (target._pendingMessage.retransmissions++ ===\n                   MAX_HANDLE_RETRANSMISSIONS) {\n          closePendingHandle(target);\n          process.emitWarning('Handle did not reach the receiving process ' +\n                              'correctly'\x2C 'SentHandleNotReceivedWarning');\n        }\n      }\n\n      assert(ArrayIsArray(target._handleQueue));\n      const queue = target._handleQueue;\n      target._handleQueue = null;\n\n      if (target._pendingMessage) {\n        target._send(target._pendingMessage.message\x2C\n                     target._pendingMessage.handle\x2C\n                     target._pendingMessage.options\x2C\n                     target._pendingMessage.callback);\n      }\n\n      for (let i = 0; i < queue.length; i++) {\n        const args = queue[i];\n        target._send(args.message\x2C args.handle\x2C args.options\x2C args.callback);\n      }\n\n      // Process a pending disconnect (if any).\n      if (!target.connected && target.channel && !target._handleQueue)\n        target._disconnect();\n\n      return;\n    }\n\n    if (message.cmd !== 'NODE_HANDLE') return;\n\n    // It is possible that the handle is not received because of some error on\n    // ancillary data reception such as MSG_CTRUNC. In this case\x2C report the\n    // sender about it by sending a NODE_HANDLE_NACK message.\n    if (!handle)\n      return target._send({ cmd: 'NODE_HANDLE_NACK' }\x2C null\x2C true);\n\n    // Acknowledge handle receival. Don't emit error events (for example if\n    // the other side has disconnected) because this call to send() is not\n    // initiated by the user and it shouldn't be fatal to be unable to ACK\n    // a message.\n    target._send({ cmd: 'NODE_HANDLE_ACK' }\x2C null\x2C true);\n\n    const obj = handleConversion[message.type];\n\n    // Update simultaneous accepts on Windows\n    if (process.platform === 'win32') {\n      handle.setSimultaneousAccepts(false);\n    }\n\n    // Convert handle object\n    obj.got.call(this\x2C message\x2C handle\x2C (handle) => {\n      handleMessage(message.msg\x2C handle\x2C isInternal(message.msg));\n    });\n  });\n\n  target.on('newListener'\x2C function() {\n\n    process.nextTick(() => {\n      if (!target.channel || !target.listenerCount('message'))\n        return;\n\n      const messages = target.channel[kPendingMessages];\n      const { length } = messages;\n      if (!length) return;\n\n      for (let i = 0; i < length; i++) {\n        ReflectApply(target.emit\x2C target\x2C messages[i]);\n      }\n\n      target.channel[kPendingMessages] = [];\n    });\n  });\n\n  target.send = function(message\x2C handle\x2C options\x2C callback) {\n    if (typeof handle === 'function') {\n      callback = handle;\n      handle = undefined;\n      options = undefined;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    } else if (options !== undefined) {\n      validateObject(options\x2C 'options');\n    }\n\n    options = { swallowErrors: false\x2C ...options };\n\n    if (this.connected) {\n      return this._send(message\x2C handle\x2C options\x2C callback);\n    }\n    const ex = new ERR_IPC_CHANNEL_CLOSED();\n    if (typeof callback === 'function') {\n      process.nextTick(callback\x2C ex);\n    } else {\n      process.nextTick(() => this.emit('error'\x2C ex));\n    }\n    return false;\n  };\n\n  target._send = function(message\x2C handle\x2C options\x2C callback) {\n    assert(this.connected || this.channel);\n\n    if (message === undefined)\n      throw new ERR_MISSING_ARGS('message');\n\n    // Non-serializable messages should not reach the remote\n    // end point; as any failure in the stringification there\n    // will result in error message that is weakly consumable.\n    // So perform a final check on message prior to sending.\n    if (typeof message !== 'string' &&\n        typeof message !== 'object' &&\n        typeof message !== 'number' &&\n        typeof message !== 'boolean') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'message'\x2C ['string'\x2C 'object'\x2C 'number'\x2C 'boolean']\x2C message);\n    }\n\n    // Support legacy function signature\n    if (typeof options === 'boolean') {\n      options = { swallowErrors: options };\n    }\n\n    let obj;\n\n    // Package messages with a handle object\n    if (handle) {\n      // This message will be handled by an internalMessage event handler\n      message = {\n        cmd: 'NODE_HANDLE'\x2C\n        type: null\x2C\n        msg: message\n      };\n\n      if (handle instanceof net.Socket) {\n        message.type = 'net.Socket';\n      } else if (handle instanceof net.Server) {\n        message.type = 'net.Server';\n      } else if (handle instanceof TCP || handle instanceof Pipe) {\n        message.type = 'net.Native';\n      } else if (handle instanceof dgram.Socket) {\n        message.type = 'dgram.Socket';\n      } else if (handle instanceof UDP) {\n        message.type = 'dgram.Native';\n      } else {\n        throw new ERR_INVALID_HANDLE_TYPE();\n      }\n\n      // Queue-up message and handle if we haven't received ACK yet.\n      if (this._handleQueue) {\n        ArrayPrototypePush(this._handleQueue\x2C {\n          callback: callback\x2C\n          handle: handle\x2C\n          options: options\x2C\n          message: message.msg\x2C\n        });\n        return this._handleQueue.length === 1;\n      }\n\n      obj = handleConversion[message.type];\n\n      // convert TCP object to native handle object\n      handle = ReflectApply(handleConversion[message.type].send\x2C\n                            target\x2C [message\x2C handle\x2C options]);\n\n      // If handle was sent twice\x2C or it is impossible to get native handle\n      // out of it - just send a text without the handle.\n      if (!handle)\n        message = message.msg;\n\n      // Update simultaneous accepts on Windows\n      if (obj.simultaneousAccepts && process.platform === 'win32') {\n        handle.setSimultaneousAccepts(true);\n      }\n    } else if (this._handleQueue &&\n               !(message && (message.cmd === 'NODE_HANDLE_ACK' ||\n                             message.cmd === 'NODE_HANDLE_NACK'))) {\n      // Queue request anyway to avoid out-of-order messages.\n      ArrayPrototypePush(this._handleQueue\x2C {\n        callback: callback\x2C\n        handle: null\x2C\n        options: options\x2C\n        message: message\x2C\n      });\n      return this._handleQueue.length === 1;\n    }\n\n    const req = new WriteWrap();\n\n    const err = writeChannelMessage(channel\x2C req\x2C message\x2C handle);\n    const wasAsyncWrite = streamBaseState[kLastWriteWasAsync];\n\n    if (err === 0) {\n      if (handle) {\n        if (!this._handleQueue)\n          this._handleQueue = [];\n        if (obj && obj.postSend)\n          obj.postSend(message\x2C handle\x2C options\x2C callback\x2C target);\n      }\n\n      if (wasAsyncWrite) {\n        req.oncomplete = () => {\n          control.unrefCounted();\n          if (typeof callback === 'function')\n            callback(null);\n        };\n        control.refCounted();\n      } else if (typeof callback === 'function') {\n        process.nextTick(callback\x2C null);\n      }\n    } else {\n      // Cleanup handle on error\n      if (obj && obj.postSend)\n        obj.postSend(message\x2C handle\x2C options\x2C callback);\n\n      if (!options.swallowErrors) {\n        const ex = errnoException(err\x2C 'write');\n        if (typeof callback === 'function') {\n          process.nextTick(callback\x2C ex);\n        } else {\n          process.nextTick(() => this.emit('error'\x2C ex));\n        }\n      }\n    }\n\n    /* If the primary is > 2 read() calls behind\x2C please stop sending. */\n    return channel.writeQueueSize < (65536 * 2);\n  };\n\n  // Connected will be set to false immediately when a disconnect() is\n  // requested\x2C even though the channel might still be alive internally to\n  // process queued messages. The three states are distinguished as follows:\n  // - disconnect() never requested: channel is not null and connected\n  //   is true\n  // - disconnect() requested\x2C messages in the queue: channel is not null\n  //   and connected is false\n  // - disconnect() requested\x2C channel actually disconnected: channel is\n  //   null and connected is false\n  target.connected = true;\n\n  target.disconnect = function() {\n    if (!this.connected) {\n      this.emit('error'\x2C new ERR_IPC_DISCONNECTED());\n      return;\n    }\n\n    // Do not allow any new messages to be written.\n    this.connected = false;\n\n    // If there are no queued messages\x2C disconnect immediately. Otherwise\x2C\n    // postpone the disconnect so that it happens internally after the\n    // queue is flushed.\n    if (!this._handleQueue)\n      this._disconnect();\n  };\n\n  target._disconnect = function() {\n    assert(this.channel);\n\n    // This marks the fact that the channel is actually disconnected.\n    this.channel = null;\n    this[kChannelHandle] = null;\n\n    if (this._pendingMessage)\n      closePendingHandle(this);\n\n    let fired = false;\n    function finish() {\n      if (fired) return;\n      fired = true;\n\n      channel.close();\n      target.emit('disconnect');\n    }\n\n    // If a message is being read\x2C then wait for it to complete.\n    if (channel.buffering) {\n      this.once('message'\x2C finish);\n      this.once('internalMessage'\x2C finish);\n\n      return;\n    }\n\n    process.nextTick(finish);\n  };\n\n  function emit(event\x2C message\x2C handle) {\n    if ('internalMessage' === event || target.listenerCount('message')) {\n      target.emit(event\x2C message\x2C handle);\n      return;\n    }\n\n    ArrayPrototypePush(\n      target.channel[kPendingMessages]\x2C\n      [event\x2C message\x2C handle]\n    );\n  }\n\n  function handleMessage(message\x2C handle\x2C internal) {\n    if (!target.channel)\n      return;\n\n    const eventName = (internal ? 'internalMessage' : 'message');\n\n    process.nextTick(emit\x2C eventName\x2C message\x2C handle);\n  }\n\n  channel.readStart();\n  return control;\n}\n\nconst INTERNAL_PREFIX = 'NODE_';\nfunction isInternal(message) {\n  return (message !== null &&\n          typeof message === 'object' &&\n          typeof message.cmd === 'string' &&\n          message.cmd.length > INTERNAL_PREFIX.length &&\n          StringPrototypeSlice(message.cmd\x2C 0\x2C INTERNAL_PREFIX.length) ===\n            INTERNAL_PREFIX);\n}\n\nconst nop = FunctionPrototype;\n\nfunction getValidStdio(stdio\x2C sync) {\n  let ipc;\n  let ipcFd;\n\n  // Replace shortcut with an array\n  if (typeof stdio === 'string') {\n    stdio = stdioStringToArray(stdio);\n  } else if (!ArrayIsArray(stdio)) {\n    throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n  }\n\n  // At least 3 stdio will be created\n  // Don't concat() a new Array() because it would be sparse\x2C and\n  // stdio.reduce() would skip the sparse elements of stdio.\n  // See https://stackoverflow.com/a/5501711/3561\n  while (stdio.length < 3) ArrayPrototypePush(stdio\x2C undefined);\n\n  // Translate stdio into C++-readable form\n  // (i.e. PipeWraps or fds)\n  stdio = ArrayPrototypeReduce(stdio\x2C (acc\x2C stdio\x2C i) => {\n    function cleanup() {\n      for (let i = 0; i < acc.length; i++) {\n        if ((acc[i].type === 'pipe' || acc[i].type === 'ipc') && acc[i].handle)\n          acc[i].handle.close();\n      }\n    }\n\n    // Defaults\n    if (stdio == null) {\n      stdio = i < 3 ? 'pipe' : 'ignore';\n    }\n\n    if (stdio === 'ignore') {\n      ArrayPrototypePush(acc\x2C { type: 'ignore' });\n    } else if (stdio === 'pipe' || stdio === 'overlapped' ||\n               (typeof stdio === 'number' && stdio < 0)) {\n      const a = {\n        type: stdio === 'overlapped' ? 'overlapped' : 'pipe'\x2C\n        readable: i === 0\x2C\n        writable: i !== 0\n      };\n\n      if (!sync)\n        a.handle = new Pipe(PipeConstants.SOCKET);\n\n      ArrayPrototypePush(acc\x2C a);\n    } else if (stdio === 'ipc') {\n      if (sync || ipc !== undefined) {\n        // Cleanup previously created pipes\n        cleanup();\n        if (!sync)\n          throw new ERR_IPC_ONE_PIPE();\n        else\n          throw new ERR_IPC_SYNC_FORK();\n      }\n\n      ipc = new Pipe(PipeConstants.IPC);\n      ipcFd = i;\n\n      ArrayPrototypePush(acc\x2C {\n        type: 'pipe'\x2C\n        handle: ipc\x2C\n        ipc: true\n      });\n    } else if (stdio === 'inherit') {\n      ArrayPrototypePush(acc\x2C {\n        type: 'inherit'\x2C\n        fd: i\n      });\n    } else if (typeof stdio === 'number' || typeof stdio.fd === 'number') {\n      ArrayPrototypePush(acc\x2C {\n        type: 'fd'\x2C\n        fd: typeof stdio === 'number' ? stdio : stdio.fd\n      });\n    } else if (getHandleWrapType(stdio) || getHandleWrapType(stdio.handle) ||\n               getHandleWrapType(stdio._handle)) {\n      const handle = getHandleWrapType(stdio) ?\n        stdio :\n        getHandleWrapType(stdio.handle) ? stdio.handle : stdio._handle;\n\n      ArrayPrototypePush(acc\x2C {\n        type: 'wrap'\x2C\n        wrapType: getHandleWrapType(handle)\x2C\n        handle: handle\x2C\n        _stdio: stdio\n      });\n    } else if (isArrayBufferView(stdio) || typeof stdio === 'string') {\n      if (!sync) {\n        cleanup();\n        throw new ERR_INVALID_SYNC_FORK_INPUT(inspect(stdio));\n      }\n    } else {\n      // Cleanup\n      cleanup();\n      throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n    }\n\n    return acc;\n  }\x2C []);\n\n  return { stdio\x2C ipc\x2C ipcFd };\n}\n\n\nfunction getSocketList(type\x2C worker\x2C key) {\n  const sockets = worker[kChannelHandle].sockets[type];\n  let socketList = sockets[key];\n  if (!socketList) {\n    const Construct = type === 'send' ? SocketListSend : SocketListReceive;\n    socketList = sockets[key] = new Construct(worker\x2C key);\n  }\n  return socketList;\n}\n\n\nfunction maybeClose(subprocess) {\n  subprocess._closesGot++;\n\n  if (subprocess._closesGot === subprocess._closesNeeded) {\n    subprocess.emit('close'\x2C subprocess.exitCode\x2C subprocess.signalCode);\n  }\n}\n\nfunction spawnSync(options) {\n  const result = spawn_sync.spawn(options);\n\n  if (result.output && options.encoding && options.encoding !== 'buffer') {\n    for (let i = 0; i < result.output.length; i++) {\n      if (!result.output[i])\n        continue;\n      result.output[i] = result.output[i].toString(options.encoding);\n    }\n  }\n\n  result.stdout = result.output && result.output[1];\n  result.stderr = result.output && result.output[2];\n\n  if (result.error) {\n    result.error = errnoException(result.error\x2C 'spawnSync ' + options.file);\n    result.error.path = options.file;\n    result.error.spawnargs = ArrayPrototypeSlice(options.args\x2C 1);\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  ChildProcess\x2C\n  kChannelHandle\x2C\n  setupChannel\x2C\n  getValidStdio\x2C\n  stdioStringToArray\x2C\n  spawnSync\n};\n
code-source-info,0x26b72db3ddc6,137,0,31406,C0O0C4O31406,,
code-creation,Function,10,63667,0x26b72db3f3e6,1265, node:internal/child_process:1:1,0x26b72db3dd40,~
code-source-info,0x26b72db3f3e6,137,0,31406,C0O0C296O25C302O41C308O63C314O87C320O110C325O131C331O156C337O180C342O204C348O220C354O244C359O254C365O564C371O564C376O294C387O325C393O351C399O378C405O407C411O440C417O468C423O494C429O516C435O539C441O674C447O674C452O602C458O619C464O637C470O654C476O727C482O727C486O727C488O758C494O758C498O758C500O788C506O788C510O788C512O822C518O822C523O854C527O822C529O879C535O879C539O879C541O928C544O928C549O916C555O1069C558O1069C563O971C569O984C575O1005C581O1027C587O1049C593O1144C596O1144C601O1109C607O1126C613O1190C616O1190C621O1182C627O1235C630O1235C635O1227C641O1280C644O1280C649O1272C655O1328C661O1328C666O1386C672O1386C677O1417C682O1369C688O1471C694O1471C699O1435C705O1457C711O1527C717O1527C722O1505C728O1578C731O1578C735O1578C737O1634C743O1634C748O1617C754O1776C757O1776C762O1672C768O1685C774O1698C780O1711C786O1724C792O1737C798O1750C804O1763C810O1808C816O1824C822O1980C823O1980C825O1996C826O1996C828O2044C830O2044C832O2070C835O2070C839O2070C841O2119C844O2119C848O2119C850O2170C853O2170C857O2170C859O2323C864O2341C869O2379C877O2445C891O2522C896O2560C904O2634C918O2798C923O2804C931O4365C939O5118C953O5598C958O5637C966O5703C980O5782C985O5821C993O5948C1009O2323C1011O7946C1019O7970C1024O7912C1029O7982C1032O7982C1037O8968C1046O8984C1050O12687C1059O12702C1063O13386C1072O13400C1076O13473C1085O13489C1137O13572C1193O13550C1195O14579C1200O14606C1203O14579C1205O14680C1206O14680C1208O26816C1210O26816C1212O27149C1214O27149C1216O31283C1223O31304C1229O31320C1235O31338C1241O31354C1247O31371C1253O31393C1259O31298C1264O31405,,
code-creation,Function,10,63709,0x26b72db3fb5e,35,<instance_members_initializer> node:internal/child_process:523:3,0x26b72db3eaa8,~
code-source-info,0x26b72db3fb5e,137,13589,13646,C3O13600C16O13616C26O13641C34O13646,,
tick,0x1bfcb1568,63750,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x26b72db3aaa2,0x105108d28,0x10510894c,0x26b72db38069,0x105108d28,0x10510894c,0x26b72db369b3,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x26b72db34a99,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,Eval,10,64084,0x2cbd76484c16,5, node:dgram:1:1,0x2cbd764846b0,~
script-source,138,node:dgram,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst errors = require('internal/errors');\nconst {\n  kStateSymbol\x2C\n  _createSocketHandle\x2C\n  newHandle\x2C\n} = require('internal/dgram');\nconst { guessHandleType } = internalBinding('util');\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_MISSING_ARGS\x2C\n  ERR_SOCKET_ALREADY_BOUND\x2C\n  ERR_SOCKET_BAD_BUFFER_SIZE\x2C\n  ERR_SOCKET_BUFFER_SIZE\x2C\n  ERR_SOCKET_DGRAM_IS_CONNECTED\x2C\n  ERR_SOCKET_DGRAM_NOT_CONNECTED\x2C\n  ERR_SOCKET_DGRAM_NOT_RUNNING\x2C\n  ERR_INVALID_FD_TYPE\n} = errors.codes;\nconst {\n  isInt32\x2C\n  validateAbortSignal\x2C\n  validateString\x2C\n  validateNumber\x2C\n  validatePort\x2C\n} = require('internal/validators');\nconst { Buffer } = require('buffer');\nconst { deprecate } = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nconst EventEmitter = require('events');\nconst {\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol\x2C owner_symbol }\n} = require('internal/async_hooks');\nconst { UV_UDP_REUSEADDR } = internalBinding('constants').os;\n\nconst {\n  constants: { UV_UDP_IPV6ONLY }\x2C\n  UDP\x2C\n  SendWrap\n} = internalBinding('udp_wrap');\n\nconst BIND_STATE_UNBOUND = 0;\nconst BIND_STATE_BINDING = 1;\nconst BIND_STATE_BOUND = 2;\n\nconst CONNECT_STATE_DISCONNECTED = 0;\nconst CONNECT_STATE_CONNECTING = 1;\nconst CONNECT_STATE_CONNECTED = 2;\n\nconst RECV_BUFFER = true;\nconst SEND_BUFFER = false;\n\n// Lazily loaded\nlet _cluster = null;\nfunction lazyLoadCluster() {\n  if (!_cluster) _cluster = require('cluster');\n  return _cluster;\n}\n\nconst errnoException = errors.errnoException;\nconst exceptionWithHostPort = errors.exceptionWithHostPort;\n\n\nfunction Socket(type\x2C listener) {\n  FunctionPrototypeCall(EventEmitter\x2C this);\n  let lookup;\n  let recvBufferSize;\n  let sendBufferSize;\n\n  let options;\n  if (type !== null && typeof type === 'object') {\n    options = type;\n    type = options.type;\n    lookup = options.lookup;\n    recvBufferSize = options.recvBufferSize;\n    sendBufferSize = options.sendBufferSize;\n  }\n\n  const handle = newHandle(type\x2C lookup);\n  handle[owner_symbol] = this;\n\n  this[async_id_symbol] = handle.getAsyncId();\n  this.type = type;\n\n  if (typeof listener === 'function')\n    this.on('message'\x2C listener);\n\n  this[kStateSymbol] = {\n    handle\x2C\n    receiving: false\x2C\n    bindState: BIND_STATE_UNBOUND\x2C\n    connectState: CONNECT_STATE_DISCONNECTED\x2C\n    queue: undefined\x2C\n    reuseAddr: options && options.reuseAddr\x2C // Use UV_UDP_REUSEADDR if true.\n    ipv6Only: options && options.ipv6Only\x2C\n    recvBufferSize\x2C\n    sendBufferSize\n  };\n\n  if (options?.signal !== undefined) {\n    const { signal } = options;\n    validateAbortSignal(signal\x2C 'options.signal');\n    const onAborted = () => {\n      this.close();\n    };\n    if (signal.aborted) {\n      onAborted();\n    } else {\n      signal.addEventListener('abort'\x2C onAborted);\n      this.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n    }\n  }\n}\nObjectSetPrototypeOf(Socket.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Socket\x2C EventEmitter);\n\n\nfunction createSocket(type\x2C listener) {\n  return new Socket(type\x2C listener);\n}\n\n\nfunction startListening(socket) {\n  const state = socket[kStateSymbol];\n\n  state.handle.onmessage = onMessage;\n  // Todo: handle errors\n  state.handle.recvStart();\n  state.receiving = true;\n  state.bindState = BIND_STATE_BOUND;\n\n  if (state.recvBufferSize)\n    bufferSize(socket\x2C state.recvBufferSize\x2C RECV_BUFFER);\n\n  if (state.sendBufferSize)\n    bufferSize(socket\x2C state.sendBufferSize\x2C SEND_BUFFER);\n\n  socket.emit('listening');\n}\n\nfunction replaceHandle(self\x2C newHandle) {\n  const state = self[kStateSymbol];\n  const oldHandle = state.handle;\n\n  // Set up the handle that we got from primary.\n  newHandle.lookup = oldHandle.lookup;\n  newHandle.bind = oldHandle.bind;\n  newHandle.send = oldHandle.send;\n  newHandle[owner_symbol] = self;\n\n  // Replace the existing handle by the handle we got from primary.\n  oldHandle.close();\n  state.handle = newHandle;\n}\n\nfunction bufferSize(self\x2C size\x2C buffer) {\n  if (size >>> 0 !== size)\n    throw new ERR_SOCKET_BAD_BUFFER_SIZE();\n\n  const ctx = {};\n  const ret = self[kStateSymbol].handle.bufferSize(size\x2C buffer\x2C ctx);\n  if (ret === undefined) {\n    throw new ERR_SOCKET_BUFFER_SIZE(ctx);\n  }\n  return ret;\n}\n\n// Query primary process to get the server handle and utilize it.\nfunction bindServerHandle(self\x2C options\x2C errCb) {\n  const cluster = lazyLoadCluster();\n\n  const state = self[kStateSymbol];\n  cluster._getServer(self\x2C options\x2C (err\x2C handle) => {\n    if (err) {\n      errCb(err);\n      return;\n    }\n\n    if (!state.handle) {\n      // Handle has been closed in the mean time.\n      return handle.close();\n    }\n\n    replaceHandle(self\x2C handle);\n    startListening(self);\n  });\n}\n\nSocket.prototype.bind = function(port_\x2C address_ /* \x2C callback */) {\n  let port = port_;\n\n  healthCheck(this);\n  const state = this[kStateSymbol];\n\n  if (state.bindState !== BIND_STATE_UNBOUND)\n    throw new ERR_SOCKET_ALREADY_BOUND();\n\n  state.bindState = BIND_STATE_BINDING;\n\n  const cb = arguments.length && arguments[arguments.length - 1];\n  if (typeof cb === 'function') {\n    function removeListeners() {\n      this.removeListener('error'\x2C removeListeners);\n      this.removeListener('listening'\x2C onListening);\n    }\n\n    function onListening() {\n      FunctionPrototypeCall(removeListeners\x2C this);\n      FunctionPrototypeCall(cb\x2C this);\n    }\n\n    this.on('error'\x2C removeListeners);\n    this.on('listening'\x2C onListening);\n  }\n\n  if (port !== null &&\n      typeof port === 'object' &&\n      typeof port.recvStart === 'function') {\n    replaceHandle(this\x2C port);\n    startListening(this);\n    return this;\n  }\n\n  // Open an existing fd instead of creating a new one.\n  if (port !== null && typeof port === 'object' &&\n      isInt32(port.fd) && port.fd > 0) {\n    const fd = port.fd;\n    const exclusive = !!port.exclusive;\n    const state = this[kStateSymbol];\n\n    const cluster = lazyLoadCluster();\n\n    if (cluster.isWorker && !exclusive) {\n      bindServerHandle(this\x2C {\n        address: null\x2C\n        port: null\x2C\n        addressType: this.type\x2C\n        fd\x2C\n        flags: null\n      }\x2C (err) => {\n        // Callback to handle error.\n        const ex = errnoException(err\x2C 'open');\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n      });\n      return this;\n    }\n\n    const type = guessHandleType(fd);\n    if (type !== 'UDP')\n      throw new ERR_INVALID_FD_TYPE(type);\n    const err = state.handle.open(fd);\n\n    if (err)\n      throw errnoException(err\x2C 'open');\n\n    startListening(this);\n    return this;\n  }\n\n  let address;\n  let exclusive;\n\n  if (port !== null && typeof port === 'object') {\n    address = port.address || '';\n    exclusive = !!port.exclusive;\n    port = port.port;\n  } else {\n    address = typeof address_ === 'function' ? '' : address_;\n    exclusive = false;\n  }\n\n  // Defaulting address for bind to all interfaces\n  if (!address) {\n    if (this.type === 'udp4')\n      address = '0.0.0.0';\n    else\n      address = '::';\n  }\n\n  // Resolve address first\n  state.handle.lookup(address\x2C (err\x2C ip) => {\n    if (err) {\n      state.bindState = BIND_STATE_UNBOUND;\n      this.emit('error'\x2C err);\n      return;\n    }\n\n    const cluster = lazyLoadCluster();\n\n    let flags = 0;\n    if (state.reuseAddr)\n      flags |= UV_UDP_REUSEADDR;\n    if (state.ipv6Only)\n      flags |= UV_UDP_IPV6ONLY;\n\n    if (cluster.isWorker && !exclusive) {\n      bindServerHandle(this\x2C {\n        address: ip\x2C\n        port: port\x2C\n        addressType: this.type\x2C\n        fd: -1\x2C\n        flags: flags\n      }\x2C (err) => {\n        // Callback to handle error.\n        const ex = exceptionWithHostPort(err\x2C 'bind'\x2C ip\x2C port);\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n      });\n    } else {\n      if (!state.handle)\n        return; // Handle has been closed in the mean time\n\n      const err = state.handle.bind(ip\x2C port || 0\x2C flags);\n      if (err) {\n        const ex = exceptionWithHostPort(err\x2C 'bind'\x2C ip\x2C port);\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n        // Todo: close?\n        return;\n      }\n\n      startListening(this);\n    }\n  });\n\n  return this;\n};\n\nSocket.prototype.connect = function(port\x2C address\x2C callback) {\n  port = validatePort(port\x2C 'Port'\x2C false);\n  if (typeof address === 'function') {\n    callback = address;\n    address = '';\n  } else if (address === undefined) {\n    address = '';\n  }\n\n  validateString(address\x2C 'address');\n\n  const state = this[kStateSymbol];\n\n  if (state.connectState !== CONNECT_STATE_DISCONNECTED)\n    throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\n\n  state.connectState = CONNECT_STATE_CONNECTING;\n  if (state.bindState === BIND_STATE_UNBOUND)\n    this.bind({ port: 0\x2C exclusive: true }\x2C null);\n\n  if (state.bindState !== BIND_STATE_BOUND) {\n    enqueue(this\x2C FunctionPrototypeBind(_connect\x2C this\x2C\n                                        port\x2C address\x2C callback));\n    return;\n  }\n\n  ReflectApply(_connect\x2C this\x2C [port\x2C address\x2C callback]);\n};\n\n\nfunction _connect(port\x2C address\x2C callback) {\n  const state = this[kStateSymbol];\n  if (callback)\n    this.once('connect'\x2C callback);\n\n  const afterDns = (ex\x2C ip) => {\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C\n      doConnect\x2C\n      ex\x2C this\x2C ip\x2C address\x2C port\x2C callback\n    );\n  };\n\n  state.handle.lookup(address\x2C afterDns);\n}\n\n\nfunction doConnect(ex\x2C self\x2C ip\x2C address\x2C port\x2C callback) {\n  const state = self[kStateSymbol];\n  if (!state.handle)\n    return;\n\n  if (!ex) {\n    const err = state.handle.connect(ip\x2C port);\n    if (err) {\n      ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port);\n    }\n  }\n\n  if (ex) {\n    state.connectState = CONNECT_STATE_DISCONNECTED;\n    return process.nextTick(() => {\n      if (callback) {\n        self.removeListener('connect'\x2C callback);\n        callback(ex);\n      } else {\n        self.emit('error'\x2C ex);\n      }\n    });\n  }\n\n  state.connectState = CONNECT_STATE_CONNECTED;\n  process.nextTick(() => self.emit('connect'));\n}\n\n\nSocket.prototype.disconnect = function() {\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\n\n  const err = state.handle.disconnect();\n  if (err)\n    throw errnoException(err\x2C 'connect');\n  else\n    state.connectState = CONNECT_STATE_DISCONNECTED;\n};\n\n\n// Thin wrapper around `send`\x2C here for compatibility with dgram_legacy.js\nSocket.prototype.sendto = function(buffer\x2C\n                                   offset\x2C\n                                   length\x2C\n                                   port\x2C\n                                   address\x2C\n                                   callback) {\n  validateNumber(offset\x2C 'offset');\n  validateNumber(length\x2C 'length');\n  validateNumber(port\x2C 'port');\n  validateString(address\x2C 'address');\n\n  this.send(buffer\x2C offset\x2C length\x2C port\x2C address\x2C callback);\n};\n\n\nfunction sliceBuffer(buffer\x2C offset\x2C length) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  } else if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE('buffer'\x2C\n                                   ['Buffer'\x2C\n                                    'TypedArray'\x2C\n                                    'DataView'\x2C\n                                    'string']\x2C\n                                   buffer);\n  }\n\n  offset = offset >>> 0;\n  length = length >>> 0;\n  if (offset > buffer.byteLength) {\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n  }\n\n  if (offset + length > buffer.byteLength) {\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n  }\n\n  return Buffer.from(buffer.buffer\x2C buffer.byteOffset + offset\x2C length);\n}\n\n\nfunction fixBufferList(list) {\n  const newlist = new Array(list.length);\n\n  for (let i = 0\x2C l = list.length; i < l; i++) {\n    const buf = list[i];\n    if (typeof buf === 'string')\n      newlist[i] = Buffer.from(buf);\n    else if (!isArrayBufferView(buf))\n      return null;\n    else\n      newlist[i] = Buffer.from(buf.buffer\x2C buf.byteOffset\x2C buf.byteLength);\n  }\n\n  return newlist;\n}\n\n\nfunction enqueue(self\x2C toEnqueue) {\n  const state = self[kStateSymbol];\n\n  // If the send queue hasn't been initialized yet\x2C do it\x2C and install an\n  // event handler that flushes the send queue after binding is done.\n  if (state.queue === undefined) {\n    state.queue = [];\n    self.once(EventEmitter.errorMonitor\x2C onListenError);\n    self.once('listening'\x2C onListenSuccess);\n  }\n  ArrayPrototypePush(state.queue\x2C toEnqueue);\n}\n\n\nfunction onListenSuccess() {\n  this.removeListener(EventEmitter.errorMonitor\x2C onListenError);\n  FunctionPrototypeCall(clearQueue\x2C this);\n}\n\n\nfunction onListenError(err) {\n  this.removeListener('listening'\x2C onListenSuccess);\n  this[kStateSymbol].queue = undefined;\n}\n\n\nfunction clearQueue() {\n  const state = this[kStateSymbol];\n  const queue = state.queue;\n  state.queue = undefined;\n\n  // Flush the send queue.\n  for (const queueEntry of queue)\n    queueEntry();\n}\n\n// valid combinations\n// For connectionless sockets\n// send(buffer\x2C offset\x2C length\x2C port\x2C address\x2C callback)\n// send(buffer\x2C offset\x2C length\x2C port\x2C address)\n// send(buffer\x2C offset\x2C length\x2C port\x2C callback)\n// send(buffer\x2C offset\x2C length\x2C port)\n// send(bufferOrList\x2C port\x2C address\x2C callback)\n// send(bufferOrList\x2C port\x2C address)\n// send(bufferOrList\x2C port\x2C callback)\n// send(bufferOrList\x2C port)\n// For connected sockets\n// send(buffer\x2C offset\x2C length\x2C callback)\n// send(buffer\x2C offset\x2C length)\n// send(bufferOrList\x2C callback)\n// send(bufferOrList)\nSocket.prototype.send = function(buffer\x2C\n                                 offset\x2C\n                                 length\x2C\n                                 port\x2C\n                                 address\x2C\n                                 callback) {\n\n  let list;\n  const state = this[kStateSymbol];\n  const connected = state.connectState === CONNECT_STATE_CONNECTED;\n  if (!connected) {\n    if (address || (port && typeof port !== 'function')) {\n      buffer = sliceBuffer(buffer\x2C offset\x2C length);\n    } else {\n      callback = port;\n      port = offset;\n      address = length;\n    }\n  } else {\n    if (typeof length === 'number') {\n      buffer = sliceBuffer(buffer\x2C offset\x2C length);\n      if (typeof port === 'function') {\n        callback = port;\n        port = null;\n      }\n    } else {\n      callback = offset;\n    }\n\n    if (port || address)\n      throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\n  }\n\n  if (!ArrayIsArray(buffer)) {\n    if (typeof buffer === 'string') {\n      list = [ Buffer.from(buffer) ];\n    } else if (!isArrayBufferView(buffer)) {\n      throw new ERR_INVALID_ARG_TYPE('buffer'\x2C\n                                     ['Buffer'\x2C\n                                      'TypedArray'\x2C\n                                      'DataView'\x2C\n                                      'string']\x2C\n                                     buffer);\n    } else {\n      list = [ buffer ];\n    }\n  } else if (!(list = fixBufferList(buffer))) {\n    throw new ERR_INVALID_ARG_TYPE('buffer list arguments'\x2C\n                                   ['Buffer'\x2C\n                                    'TypedArray'\x2C\n                                    'DataView'\x2C\n                                    'string']\x2C\n                                   buffer);\n  }\n\n  if (!connected)\n    port = validatePort(port\x2C 'Port'\x2C false);\n\n  // Normalize callback so it's either a function or undefined but not anything\n  // else.\n  if (typeof callback !== 'function')\n    callback = undefined;\n\n  if (typeof address === 'function') {\n    callback = address;\n    address = undefined;\n  } else if (address != null) {\n    validateString(address\x2C 'address');\n  }\n\n  healthCheck(this);\n\n  if (state.bindState === BIND_STATE_UNBOUND)\n    this.bind({ port: 0\x2C exclusive: true }\x2C null);\n\n  if (list.length === 0)\n    ArrayPrototypePush(list\x2C Buffer.alloc(0));\n\n  // If the socket hasn't been bound yet\x2C push the outbound packet onto the\n  // send queue and send after binding is complete.\n  if (state.bindState !== BIND_STATE_BOUND) {\n    enqueue(this\x2C FunctionPrototypeBind(this.send\x2C this\x2C\n                                        list\x2C port\x2C address\x2C callback));\n    return;\n  }\n\n  const afterDns = (ex\x2C ip) => {\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C\n      doSend\x2C\n      ex\x2C this\x2C ip\x2C list\x2C address\x2C port\x2C callback\n    );\n  };\n\n  if (!connected) {\n    state.handle.lookup(address\x2C afterDns);\n  } else {\n    afterDns(null\x2C null);\n  }\n};\n\nfunction doSend(ex\x2C self\x2C ip\x2C list\x2C address\x2C port\x2C callback) {\n  const state = self[kStateSymbol];\n\n  if (ex) {\n    if (typeof callback === 'function') {\n      process.nextTick(callback\x2C ex);\n      return;\n    }\n\n    process.nextTick(() => self.emit('error'\x2C ex));\n    return;\n  } else if (!state.handle) {\n    return;\n  }\n\n  const req = new SendWrap();\n  req.list = list;  // Keep reference alive.\n  req.address = address;\n  req.port = port;\n  if (callback) {\n    req.callback = callback;\n    req.oncomplete = afterSend;\n  }\n\n  let err;\n  if (port)\n    err = state.handle.send(req\x2C list\x2C list.length\x2C port\x2C ip\x2C !!callback);\n  else\n    err = state.handle.send(req\x2C list\x2C list.length\x2C !!callback);\n\n  if (err >= 1) {\n    // Synchronous finish. The return code is msg_length + 1 so that we can\n    // distinguish between synchronous success and asynchronous success.\n    if (callback)\n      process.nextTick(callback\x2C null\x2C err - 1);\n    return;\n  }\n\n  if (err && callback) {\n    // Don't emit as error\x2C dgram_legacy.js compatibility\n    const ex = exceptionWithHostPort(err\x2C 'send'\x2C address\x2C port);\n    process.nextTick(callback\x2C ex);\n  }\n}\n\nfunction afterSend(err\x2C sent) {\n  if (err) {\n    err = exceptionWithHostPort(err\x2C 'send'\x2C this.address\x2C this.port);\n  } else {\n    err = null;\n  }\n\n  this.callback(err\x2C sent);\n}\n\nSocket.prototype.close = function(callback) {\n  const state = this[kStateSymbol];\n  const queue = state.queue;\n\n  if (typeof callback === 'function')\n    this.on('close'\x2C callback);\n\n  if (queue !== undefined) {\n    ArrayPrototypePush(queue\x2C FunctionPrototypeBind(this.close\x2C this));\n    return this;\n  }\n\n  healthCheck(this);\n  stopReceiving(this);\n  state.handle.close();\n  state.handle = null;\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             socketCloseNT\x2C\n                             this);\n\n  return this;\n};\n\n\nfunction socketCloseNT(self) {\n  self.emit('close');\n}\n\n\nSocket.prototype.address = function() {\n  healthCheck(this);\n\n  const out = {};\n  const err = this[kStateSymbol].handle.getsockname(out);\n  if (err) {\n    throw errnoException(err\x2C 'getsockname');\n  }\n\n  return out;\n};\n\nSocket.prototype.remoteAddress = function() {\n  healthCheck(this);\n\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\n\n  const out = {};\n  const err = state.handle.getpeername(out);\n  if (err)\n    throw errnoException(err\x2C 'getpeername');\n\n  return out;\n};\n\n\nSocket.prototype.setBroadcast = function(arg) {\n  const err = this[kStateSymbol].handle.setBroadcast(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err\x2C 'setBroadcast');\n  }\n};\n\n\nSocket.prototype.setTTL = function(ttl) {\n  validateNumber(ttl\x2C 'ttl');\n\n  const err = this[kStateSymbol].handle.setTTL(ttl);\n  if (err) {\n    throw errnoException(err\x2C 'setTTL');\n  }\n\n  return ttl;\n};\n\n\nSocket.prototype.setMulticastTTL = function(ttl) {\n  validateNumber(ttl\x2C 'ttl');\n\n  const err = this[kStateSymbol].handle.setMulticastTTL(ttl);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastTTL');\n  }\n\n  return ttl;\n};\n\n\nSocket.prototype.setMulticastLoopback = function(arg) {\n  const err = this[kStateSymbol].handle.setMulticastLoopback(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastLoopback');\n  }\n\n  return arg; // 0.4 compatibility\n};\n\n\nSocket.prototype.setMulticastInterface = function(interfaceAddress) {\n  healthCheck(this);\n  validateString(interfaceAddress\x2C 'interfaceAddress');\n\n  const err = this[kStateSymbol].handle.setMulticastInterface(interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastInterface');\n  }\n};\n\nSocket.prototype.addMembership = function(multicastAddress\x2C\n                                          interfaceAddress) {\n  healthCheck(this);\n\n  if (!multicastAddress) {\n    throw new ERR_MISSING_ARGS('multicastAddress');\n  }\n\n  const { handle } = this[kStateSymbol];\n  const err = handle.addMembership(multicastAddress\x2C interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'addMembership');\n  }\n};\n\n\nSocket.prototype.dropMembership = function(multicastAddress\x2C\n                                           interfaceAddress) {\n  healthCheck(this);\n\n  if (!multicastAddress) {\n    throw new ERR_MISSING_ARGS('multicastAddress');\n  }\n\n  const { handle } = this[kStateSymbol];\n  const err = handle.dropMembership(multicastAddress\x2C interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'dropMembership');\n  }\n};\n\nSocket.prototype.addSourceSpecificMembership = function(sourceAddress\x2C\n                                                        groupAddress\x2C\n                                                        interfaceAddress) {\n  healthCheck(this);\n\n  validateString(sourceAddress\x2C 'sourceAddress');\n  validateString(groupAddress\x2C 'groupAddress');\n\n  const err =\n    this[kStateSymbol].handle.addSourceSpecificMembership(sourceAddress\x2C\n                                                          groupAddress\x2C\n                                                          interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'addSourceSpecificMembership');\n  }\n};\n\n\nSocket.prototype.dropSourceSpecificMembership = function(sourceAddress\x2C\n                                                         groupAddress\x2C\n                                                         interfaceAddress) {\n  healthCheck(this);\n\n  validateString(sourceAddress\x2C 'sourceAddress');\n  validateString(groupAddress\x2C 'groupAddress');\n\n  const err =\n    this[kStateSymbol].handle.dropSourceSpecificMembership(sourceAddress\x2C\n                                                           groupAddress\x2C\n                                                           interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'dropSourceSpecificMembership');\n  }\n};\n\n\nfunction healthCheck(socket) {\n  if (!socket[kStateSymbol].handle) {\n    // Error message from dgram_legacy.js.\n    throw new ERR_SOCKET_DGRAM_NOT_RUNNING();\n  }\n}\n\n\nfunction stopReceiving(socket) {\n  const state = socket[kStateSymbol];\n\n  if (!state.receiving)\n    return;\n\n  state.handle.recvStop();\n  state.receiving = false;\n}\n\n\nfunction onMessage(nread\x2C handle\x2C buf\x2C rinfo) {\n  const self = handle[owner_symbol];\n  if (nread < 0) {\n    return self.emit('error'\x2C errnoException(nread\x2C 'recvmsg'));\n  }\n  rinfo.size = buf.length; // compatibility\n  self.emit('message'\x2C buf\x2C rinfo);\n}\n\n\nSocket.prototype.ref = function() {\n  const handle = this[kStateSymbol].handle;\n\n  if (handle)\n    handle.ref();\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  const handle = this[kStateSymbol].handle;\n\n  if (handle)\n    handle.unref();\n\n  return this;\n};\n\n\nSocket.prototype.setRecvBufferSize = function(size) {\n  bufferSize(this\x2C size\x2C RECV_BUFFER);\n};\n\n\nSocket.prototype.setSendBufferSize = function(size) {\n  bufferSize(this\x2C size\x2C SEND_BUFFER);\n};\n\n\nSocket.prototype.getRecvBufferSize = function() {\n  return bufferSize(this\x2C 0\x2C RECV_BUFFER);\n};\n\n\nSocket.prototype.getSendBufferSize = function() {\n  return bufferSize(this\x2C 0\x2C SEND_BUFFER);\n};\n\n\n// Deprecated private APIs.\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].handle;\n  }\x2C 'Socket.prototype._handle is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].handle = val;\n  }\x2C 'Socket.prototype._handle is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_receiving'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].receiving;\n  }\x2C 'Socket.prototype._receiving is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].receiving = val;\n  }\x2C 'Socket.prototype._receiving is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_bindState'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].bindState;\n  }\x2C 'Socket.prototype._bindState is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].bindState = val;\n  }\x2C 'Socket.prototype._bindState is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_queue'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].queue;\n  }\x2C 'Socket.prototype._queue is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].queue = val;\n  }\x2C 'Socket.prototype._queue is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_reuseAddr'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].reuseAddr;\n  }\x2C 'Socket.prototype._reuseAddr is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].reuseAddr = val;\n  }\x2C 'Socket.prototype._reuseAddr is deprecated'\x2C 'DEP0112')\n});\n\n\nSocket.prototype._healthCheck = deprecate(function() {\n  healthCheck(this);\n}\x2C 'Socket.prototype._healthCheck() is deprecated'\x2C 'DEP0112');\n\n\nSocket.prototype._stopReceiving = deprecate(function() {\n  stopReceiving(this);\n}\x2C 'Socket.prototype._stopReceiving() is deprecated'\x2C 'DEP0112');\n\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(UDP.prototype\x2C 'owner'\x2C {\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\n});\n\n\nmodule.exports = {\n  _createSocketHandle: deprecate(\n    _createSocketHandle\x2C\n    'dgram._createSocketHandle() is deprecated'\x2C\n    'DEP0112'\n  )\x2C\n  createSocket\x2C\n  Socket\n};\n
code-source-info,0x2cbd76484c16,138,0,27222,C0O0C4O27222,,
code-creation,Function,10,65125,0x2cbd76486b26,1501, node:dgram:1:1,0x2cbd76484b90,~
code-source-info,0x2cbd76486b26,138,0,27222,C0O0C270O1159C276O1168C282O1184C288O1206C294O1231C300O1256C305O1280C310O1304C316O1351C322O1351C327O1443C333O1443C338O1389C344O1405C349O1428C355O1498C358O1498C363O1478C369O1819C374O1533C380O1561C386O1585C392O1605C398O1633C404O1663C410O1689C416O1722C422O1756C428O1788C434O1924C440O1924C445O1836C451O1847C457O1870C463O1888C469O1906C475O1975C481O1975C486O1964C492O2016C498O2016C503O2002C508O2072C514O2072C519O2050C525O2125C531O2125C535O2125C537O2231C543O2231C548O2154C559O2195C565O2212C571O2293C574O2293C579O2321C584O2272C590O2391C593O2391C598O2391C603O2350C609O2371C614O2378C620O2448C621O2448C623O2478C625O2478C627O2506C629O2506C631O2545C632O2545C634O2581C636O2581C638O2616C640O2616C642O2640C643O2640C645O2666C646O2666C648O2706C649O2706C651O2841C655O2834C657O2894C661O2887C663O4215C666O4243C674O4267C679O4215C684O4279C690O4279C695O6040C698O6047C707O6062C711O9508C714O9515C723O9533C727O11328C730O11335C739O11356C743O11744C746O11751C755O11768C759O14807C762O14814C771O14829C775O19046C778O19053C787O19069C791O19700C794O19707C803O19725C807O19920C810O19927C819O19951C823O20267C826O20274C835O20297C839O20451C842O20458C851O20475C855O20655C858O20662C867O20688C871O20886C874O20893C883O20924C887O21130C890O21137C899O21169C903O21436C906O21443C915O21467C919O21847C922O21854C931O21879C935O22261C938O22268C947O22306C951O22919C954O22926C963O22965C967O24174C970O24181C979O24195C983O24308C986O24315C995O24331C999O24446C1002O24453C1011O24481C1015O24544C1018O24551C1027O24579C1031O24642C1034O24649C1043O24677C1047O24740C1050O24747C1059O24775C1063O24866C1066O24894C1079O24925C1090O24925C1099O25052C1110O25052C1119O24866C1124O25179C1127O25207C1140O25241C1151O25241C1160O25374C1171O25374C1180O25179C1185O25507C1188O25535C1201O25569C1212O25569C1221O25702C1232O25702C1241O25507C1246O25835C1249O25863C1262O25893C1273O25893C1282O26018C1293O26018C1302O25835C1307O26143C1310O26171C1323O26205C1334O26205C1343O26338C1354O26338C1363O26143C1368O26471C1371O26478C1376O26503C1387O26503C1392O26501C1396O26613C1399O26620C1404O26647C1415O26647C1420O26645C1424O26936C1437O26960C1445O27000C1453O26911C1458O27048C1472O27090C1483O27196C1489O27212C1495O27063C1500O27221,,
tick,0x10035a704,65209,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x26b72db3f5e0,0x105108d28,0x10510894c,0x26b72db3aaa2,0x105108d28,0x10510894c,0x26b72db38069,0x105108d28,0x10510894c,0x26b72db369b3,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x26b72db34a99,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,Eval,10,65292,0x2cbd76489f2e,5, node:internal/dgram:1:1,0x2cbd76489d28,~
script-source,139,node:internal/dgram,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  Symbol\x2C\n} = primordials;\n\nconst { codes } = require('internal/errors');\nconst { UDP } = internalBinding('udp_wrap');\nconst { guessHandleType } = internalBinding('util');\nconst {\n  isInt32\x2C\n  validateFunction\x2C\n} = require('internal/validators');\nconst { UV_EINVAL } = internalBinding('uv');\nconst {\n  ERR_SOCKET_BAD_TYPE\x2C\n} = codes;\nconst kStateSymbol = Symbol('state symbol');\nlet dns;  // Lazy load for startup performance.\n\n\nfunction lookup4(lookup\x2C address\x2C callback) {\n  return lookup(address || '127.0.0.1'\x2C 4\x2C callback);\n}\n\n\nfunction lookup6(lookup\x2C address\x2C callback) {\n  return lookup(address || '::1'\x2C 6\x2C callback);\n}\n\nfunction newHandle(type\x2C lookup) {\n  if (lookup === undefined) {\n    if (dns === undefined) {\n      dns = require('dns');\n    }\n\n    lookup = dns.lookup;\n  } else {\n    validateFunction(lookup\x2C 'lookup');\n  }\n\n  if (type === 'udp4') {\n    const handle = new UDP();\n\n    handle.lookup = FunctionPrototypeBind(lookup4\x2C handle\x2C lookup);\n    return handle;\n  }\n\n  if (type === 'udp6') {\n    const handle = new UDP();\n\n    handle.lookup = FunctionPrototypeBind(lookup6\x2C handle\x2C lookup);\n    handle.bind = handle.bind6;\n    handle.connect = handle.connect6;\n    handle.send = handle.send6;\n    return handle;\n  }\n\n  throw new ERR_SOCKET_BAD_TYPE();\n}\n\n\nfunction _createSocketHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\n  const handle = newHandle(addressType);\n  let err;\n\n  if (isInt32(fd) && fd > 0) {\n    const type = guessHandleType(fd);\n    if (type !== 'UDP') {\n      err = UV_EINVAL;\n    } else {\n      err = handle.open(fd);\n    }\n  } else if (port || address) {\n    err = handle.bind(address\x2C port || 0\x2C flags);\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\n\nmodule.exports = {\n  kStateSymbol\x2C\n  _createSocketHandle\x2C\n  newHandle\n};\n
code-source-info,0x2cbd76489f2e,139,0,1849,C0O0C4O1849,,
code-creation,Function,10,65375,0x2cbd7648a1f6,196, node:internal/dgram:1:1,0x2cbd76489ea8,~
code-source-info,0x2cbd7648a1f6,139,0,1849,C0O0C56O25C62O50C67O94C73O94C78O84C83O138C86O138C91O130C97O195C100O195C105O175C111O263C117O263C122O230C128O241C134O317C137O317C142O303C148O350C154O403C157O403C162O431C163O431C165O1776C172O1797C178O1813C184O1836C190O1791C195O1848,,
code-creation,Eval,10,65542,0x2cbd7648dbe6,5, node:internal/socket_list:1:1,0x2cbd7648da90,~
script-source,140,node:internal/socket_list,'use strict';\n\nconst { ERR_CHILD_CLOSED_BEFORE_REPLY } = require('internal/errors').codes;\n\nconst EventEmitter = require('events');\n\n// This object keeps track of the sockets that are sent\nclass SocketListSend extends EventEmitter {\n  constructor(child\x2C key) {\n    super();\n    this.key = key;\n    this.child = child;\n    child.once('exit'\x2C () => this.emit('exit'\x2C this));\n  }\n\n  _request(msg\x2C cmd\x2C swallowErrors\x2C callback) {\n    const self = this;\n\n    if (!this.child.connected) return onclose();\n    this.child._send(msg\x2C undefined\x2C swallowErrors);\n\n    function onclose() {\n      self.child.removeListener('internalMessage'\x2C onreply);\n      callback(new ERR_CHILD_CLOSED_BEFORE_REPLY());\n    }\n\n    function onreply(msg) {\n      if (!(msg.cmd === cmd && msg.key === self.key)) return;\n      self.child.removeListener('disconnect'\x2C onclose);\n      self.child.removeListener('internalMessage'\x2C onreply);\n\n      callback(null\x2C msg);\n    }\n\n    this.child.once('disconnect'\x2C onclose);\n    this.child.on('internalMessage'\x2C onreply);\n  }\n\n  close(callback) {\n    this._request({\n      cmd: 'NODE_SOCKET_NOTIFY_CLOSE'\x2C\n      key: this.key\n    }\x2C 'NODE_SOCKET_ALL_CLOSED'\x2C true\x2C callback);\n  }\n\n  getConnections(callback) {\n    this._request({\n      cmd: 'NODE_SOCKET_GET_COUNT'\x2C\n      key: this.key\n    }\x2C 'NODE_SOCKET_COUNT'\x2C false\x2C (err\x2C msg) => {\n      if (err) return callback(err);\n      callback(null\x2C msg.count);\n    });\n  }\n}\n\n\n// This object keeps track of the sockets that are received\nclass SocketListReceive extends EventEmitter {\n  constructor(child\x2C key) {\n    super();\n\n    this.connections = 0;\n    this.key = key;\n    this.child = child;\n\n    function onempty(self) {\n      if (!self.child.connected) return;\n\n      self.child._send({\n        cmd: 'NODE_SOCKET_ALL_CLOSED'\x2C\n        key: self.key\n      }\x2C undefined\x2C true);\n    }\n\n    this.child.on('internalMessage'\x2C (msg) => {\n      if (msg.key !== this.key) return;\n\n      if (msg.cmd === 'NODE_SOCKET_NOTIFY_CLOSE') {\n        // Already empty\n        if (this.connections === 0) return onempty(this);\n\n        // Wait for sockets to get closed\n        this.once('empty'\x2C onempty);\n      } else if (msg.cmd === 'NODE_SOCKET_GET_COUNT') {\n        if (!this.child.connected) return;\n        this.child._send({\n          cmd: 'NODE_SOCKET_COUNT'\x2C\n          key: this.key\x2C\n          count: this.connections\n        });\n      }\n    });\n  }\n\n  add(obj) {\n    this.connections++;\n\n    // Notify the previous owner of the socket about its state change\n    obj.socket.once('close'\x2C () => {\n      this.connections--;\n\n      if (this.connections === 0) this.emit('empty'\x2C this);\n    });\n  }\n}\n\nmodule.exports = { SocketListSend\x2C SocketListReceive };\n
code-source-info,0x2cbd7648dbe6,140,0,2705,C0O0C4O2705,,
code-creation,Function,10,65625,0x2cbd7648e226,126, node:internal/socket_list:1:1,0x2cbd7648db60,~
code-source-info,0x2cbd7648e226,140,0,2705,C0O0C8O57C11O57C16O83C21O23C27O113C30O113C35O218C73O1525C101O2649C108O2668C114O2684C120O2664C125O2704,,
code-creation,LazyCompile,10,65709,0x2cbd7648eb16,14,customPromiseExecFunction node:child_process:230:35,0x26b72db3a3e0,~
code-source-info,0x2cbd7648eb16,136,6574,6938,C0O6574C9O6588C13O6936,,
tick,0x1008944e4,65792,0,0x0,0,0x0,0x26b72db3ab07,0x105108d28,0x10510894c,0x26b72db38069,0x105108d28,0x10510894c,0x26b72db369b3,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x26b72db34a99,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,Eval,10,65792,0x2cbd76490d66,5, node:internal/cluster/round_robin_handle:1:1,0x2cbd76490b50,~
script-source,141,node:internal/cluster/round_robin_handle,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  Boolean\x2C\n  ObjectCreate\x2C\n  SafeMap\x2C\n} = primordials;\n\nconst assert = require('internal/assert');\nconst net = require('net');\nconst { sendHelper } = require('internal/cluster/utils');\nconst { append\x2C init\x2C isEmpty\x2C peek\x2C remove } = require('internal/linkedlist');\nconst { constants } = internalBinding('tcp_wrap');\n\nmodule.exports = RoundRobinHandle;\n\nfunction RoundRobinHandle(key\x2C address\x2C { port\x2C fd\x2C flags\x2C backlog }) {\n  this.key = key;\n  this.all = new SafeMap();\n  this.free = new SafeMap();\n  this.handles = init(ObjectCreate(null));\n  this.handle = null;\n  this.server = net.createServer(assert.fail);\n\n  if (fd >= 0)\n    this.server.listen({ fd\x2C backlog });\n  else if (port >= 0) {\n    this.server.listen({\n      port\x2C\n      host: address\x2C\n      // Currently\x2C net module only supports `ipv6Only` option in `flags`.\n      ipv6Only: Boolean(flags & constants.UV_TCP_IPV6ONLY)\x2C\n      backlog\x2C\n    });\n  } else\n    this.server.listen(address\x2C backlog);  // UNIX socket path.\n\n  this.server.once('listening'\x2C () => {\n    this.handle = this.server._handle;\n    this.handle.onconnection = (err\x2C handle) => this.distribute(err\x2C handle);\n    this.server._handle = null;\n    this.server = null;\n  });\n}\n\nRoundRobinHandle.prototype.add = function(worker\x2C send) {\n  assert(this.all.has(worker.id) === false);\n  this.all.set(worker.id\x2C worker);\n\n  const done = () => {\n    if (this.handle.getsockname) {\n      const out = {};\n      this.handle.getsockname(out);\n      // TODO(bnoordhuis) Check err.\n      send(null\x2C { sockname: out }\x2C null);\n    } else {\n      send(null\x2C null\x2C null);  // UNIX socket.\n    }\n\n    this.handoff(worker);  // In case there are connections pending.\n  };\n\n  if (this.server === null)\n    return done();\n\n  // Still busy binding.\n  this.server.once('listening'\x2C done);\n  this.server.once('error'\x2C (err) => {\n    send(err.errno\x2C null);\n  });\n};\n\nRoundRobinHandle.prototype.remove = function(worker) {\n  const existed = this.all.delete(worker.id);\n\n  if (!existed)\n    return false;\n\n  this.free.delete(worker.id);\n\n  if (this.all.size !== 0)\n    return false;\n\n  while (!isEmpty(this.handles)) {\n    const handle = peek(this.handles);\n    handle.close();\n    remove(handle);\n  }\n\n  this.handle.close();\n  this.handle = null;\n  return true;\n};\n\nRoundRobinHandle.prototype.distribute = function(err\x2C handle) {\n  append(this.handles\x2C handle);\n  // eslint-disable-next-line node-core/no-array-destructuring\n  const [ workerEntry ] = this.free; // this.free is a SafeMap\n\n  if (ArrayIsArray(workerEntry)) {\n    const { 0: workerId\x2C 1: worker } = workerEntry;\n    this.free.delete(workerId);\n    this.handoff(worker);\n  }\n};\n\nRoundRobinHandle.prototype.handoff = function(worker) {\n  if (!this.all.has(worker.id)) {\n    return;  // Worker is closing (or has closed) the server.\n  }\n\n  const handle = peek(this.handles);\n\n  if (handle === null) {\n    this.free.set(worker.id\x2C worker);  // Add to ready queue again.\n    return;\n  }\n\n  remove(handle);\n\n  const message = { act: 'newconn'\x2C key: this.key };\n\n  sendHelper(worker.process\x2C message\x2C handle\x2C (reply) => {\n    if (reply.accepted)\n      handle.close();\n    else\n      this.distribute(0\x2C handle);  // Worker is shutting down. Send to another.\n\n    this.handoff(worker);\n  });\n};\n
code-source-info,0x2cbd76490d66,141,0,3291,C0O0C4O3291,,
code-creation,Function,10,65959,0x2cbd7649112e,217, node:internal/cluster/round_robin_handle:1:1,0x2cbd76490ce0,~
code-source-info,0x2cbd7649112e,141,0,3291,C0O0C49O25C55O41C61O52C67O68C73O110C76O110C80O110C82O150C85O150C89O150C91O189C94O189C99O174C105O272C108O272C113O232C119O240C125O246C131O255C137O261C143O326C146O326C151O312C157O356C159O371C163O1261C172O1275C176O1926C185O1943C189O2324C198O2345C202O2700C211O2718C216O3290,,
code-creation,Eval,10,66000,0x2cbd76491a4e,5, node:internal/cluster/utils:1:1,0x2cbd764918d8,~
script-source,142,node:internal/cluster/utils,'use strict';\n\nconst {\n  ReflectApply\x2C\n  SafeMap\x2C\n} = primordials;\n\nmodule.exports = {\n  sendHelper\x2C\n  internal\n};\n\nconst callbacks = new SafeMap();\nlet seq = 0;\n\nfunction sendHelper(proc\x2C message\x2C handle\x2C cb) {\n  if (!proc.connected)\n    return false;\n\n  // Mark message as internal. See INTERNAL_PREFIX\n  // in lib/internal/child_process.js\n  message = { cmd: 'NODE_CLUSTER'\x2C ...message\x2C seq };\n\n  if (typeof cb === 'function')\n    callbacks.set(seq\x2C cb);\n\n  seq += 1;\n  return proc.send(message\x2C handle);\n}\n\n// Returns an internalMessage listener that hands off normal messages\n// to the callback but intercepts and redirects ACK messages.\nfunction internal(worker\x2C cb) {\n  return function onInternalMessage(message\x2C handle) {\n    if (message.cmd !== 'NODE_CLUSTER')\n      return;\n\n    let fn = cb;\n\n    if (message.ack !== undefined) {\n      const callback = callbacks.get(message.ack);\n\n      if (callback !== undefined) {\n        fn = callback;\n        callbacks.delete(message.ack);\n      }\n    }\n\n    ReflectApply(fn\x2C worker\x2C arguments);\n  };\n}\n
code-source-info,0x2cbd76491a4e,142,0,1053,C0O0C4O1053,,
code-creation,Function,10,66042,0x2cbd76491c0e,72, node:internal/cluster/utils:1:1,0x2cbd764919c8,~
code-source-info,0x2cbd76491c0e,142,0,1053,C0O0C24O25C30O41C35O68C42O89C48O103C54O83C58O134C60O134C65O134C67O159C68O159C71O1052,,
code-creation,Eval,10,66084,0x2cbd7649221e,5, node:internal/cluster/shared_handle:1:1,0x2cbd76492098,~
script-source,143,node:internal/cluster/shared_handle,'use strict';\nconst { SafeMap } = primordials;\nconst assert = require('internal/assert');\nconst dgram = require('internal/dgram');\nconst net = require('net');\n\nmodule.exports = SharedHandle;\n\nfunction SharedHandle(key\x2C address\x2C { port\x2C addressType\x2C fd\x2C flags }) {\n  this.key = key;\n  this.workers = new SafeMap();\n  this.handle = null;\n  this.errno = 0;\n\n  let rval;\n  if (addressType === 'udp4' || addressType === 'udp6')\n    rval = dgram._createSocketHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n  else\n    rval = net._createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n\n  if (typeof rval === 'number')\n    this.errno = rval;\n  else\n    this.handle = rval;\n}\n\nSharedHandle.prototype.add = function(worker\x2C send) {\n  assert(!this.workers.has(worker.id));\n  this.workers.set(worker.id\x2C worker);\n  send(this.errno\x2C null\x2C this.handle);\n};\n\nSharedHandle.prototype.remove = function(worker) {\n  if (!this.workers.has(worker.id))\n    return false;\n\n  this.workers.delete(worker.id);\n\n  if (this.workers.size !== 0)\n    return false;\n\n  this.handle.close();\n  this.handle = null;\n  return true;\n};\n
code-source-info,0x2cbd7649221e,143,0,1102,C0O0C4O1102,,
code-creation,Function,10,66167,0x2cbd76492456,89, node:internal/cluster/shared_handle:1:1,0x2cbd76492198,~
code-source-info,0x2cbd76492456,143,0,1102,C0O0C22O22C28O62C31O62C35O62C37O104C40O104C44O104C46O143C49O143C53O143C55O160C57O175C61O685C70O699C74O861C83O878C88O1101,,
code-creation,Eval,10,66209,0x2cbd76492a3e,5, node:internal/cluster/worker:1:1,0x2cbd764928c8,~
script-source,144,node:internal/cluster/worker,'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\n\nmodule.exports = Worker;\n\n// Common Worker implementation shared between the cluster primary and workers.\nfunction Worker(options) {\n  if (!(this instanceof Worker))\n    return new Worker(options);\n\n  ReflectApply(EventEmitter\x2C this\x2C []);\n\n  if (options === null || typeof options !== 'object')\n    options = {};\n\n  this.exitedAfterDisconnect = undefined;\n\n  this.state = options.state || 'none';\n  this.id = options.id | 0;\n\n  if (options.process) {\n    this.process = options.process;\n    this.process.on('error'\x2C (code\x2C signal) =>\n      this.emit('error'\x2C code\x2C signal)\n    );\n    this.process.on('message'\x2C (message\x2C handle) =>\n      this.emit('message'\x2C message\x2C handle)\n    );\n  }\n}\n\nObjectSetPrototypeOf(Worker.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Worker\x2C EventEmitter);\n\nWorker.prototype.kill = function() {\n  ReflectApply(this.destroy\x2C this\x2C arguments);\n};\n\nWorker.prototype.send = function() {\n  return ReflectApply(this.process.send\x2C this.process\x2C arguments);\n};\n\nWorker.prototype.isDead = function() {\n  return this.process.exitCode != null || this.process.signalCode != null;\n};\n\nWorker.prototype.isConnected = function() {\n  return this.process.connected;\n};\n
code-source-info,0x2cbd76492a3e,144,0,1315,C0O0C4O1315,,
code-creation,Function,10,66250,0x2cbd76492da6,141, node:internal/cluster/worker:1:1,0x2cbd764929b8,~
code-source-info,0x2cbd76492da6,144,0,1315,C0O0C17O25C22O49C28O102C31O102C35O102C37O122C39O137C43O812C46O840C54O864C59O812C64O876C70O876C75O921C78O928C87O943C91O1009C94O1016C103O1031C107O1117C110O1124C119O1141C123O1235C126O1242C135O1264C140O1314,,
code-creation,LazyCompile,10,66292,0x2cbd764932f6,21,EventEmitter node:events:208:22,0x232faba263a0,~
code-source-info,0x2cbd764932f6,23,6267,6315,C0O6278C3O6291C8O6296C13O6296C20O6314,,
code-creation,LazyCompile,10,66334,0x2cbd7649343e,149,EventEmitter.init node:events:327:29,0x232faba26798,~
code-source-info,0x2cbd7649343e,23,9680,10269,C0O9701C6O9737C13O9749C16O9749C21O9775C25O9745C30O9791C32O9806C37O9806C41O9804C45O9830C46O9848C50O9886C60O9879C64O9918C71O9926C80O9953C85O9974C93O9953C98O10027C100O10032C105O10044C108O10057C113O10044C117O10042C123O10213C125O10218C131O10243C138O10253C140O10252C143O10228C148O10268,,
code-creation,LazyCompile,10,66375,0x2cbd76493996,151,getESMFacade node:internal/bootstrap/loaders:264:15,0x2b48e0c4fbf8,~
code-source-info,0x2cbd76493996,9,8232,8861,C0O8232C8O8250C14O8270C18O8277C19O8305C29O8305C34O8290C39O8353C42O8366C51O8397C53O8397C55O8427C62O8452C67O8427C72O8469C82O8469C87O8517C89O8569C102O8531C107O8529C111O8775C116O8782C121O8782C125O8806C130O8813C140O8813C146O8850C150O8857,,
code-creation,LazyCompile,10,66417,0x2cbd76493d7e,40, node:internal/bootstrap/loaders:273:15,0x2cbd76493890,~
code-source-info,0x2cbd76493d7e,9,8596,8701,C0O8609C5O8622C10O8622C14O8650C24O8671C27O8684C32O8650C39O8700,,
code-creation,LazyCompile,10,66459,0x2cbd76493ed6,89,syncExports node:internal/bootstrap/loaders:287:14,0x2b48e0c4fc68,~
code-source-info,0x2cbd76493ed6,9,9168,9501,C0O9196C5O9221C11O9250C13O9263C17O9255C22O9305C24O9310C28O9323C30O9338C35O9353C37O9376C42O9383C51O9435C54O9447C59O9473C67O9435C73O9383C79O9272C84O9237C88O9500,,
code-creation,LazyCompile,10,66459,0x2cbd7649403e,35,getOwn node:internal/bootstrap/loaders:180:16,0x2b48e0c4f900,~
code-source-info,0x2cbd7649403e,9,5498,5652,C0O5534C5O5541C14O5595C26O5595C34O5650,,
code-creation,Function,11,66500,0x10510b6c0,800,syncExports node:internal/bootstrap/loaders:287:14,0x2b48e0c4fc68,^
code-source-info,0x10510b6c0,9,9168,9501,,,
code-creation,Function,11,66500,0x10510ba40,344,validateString node:internal/validators:118:24,0x2b48e0c7bfe8,^
code-source-info,0x10510ba40,15,3417,3526,,,
code-creation,Function,11,66542,0x10510bc00,1536,dirname node:path:1275:10,0x815de63aee8,^
code-source-info,0x10510bc00,41,38741,39410,,,
code-creation,Function,11,66542,0x10510c260,1480,deprecate node:internal/util:96:19,0x232faba01bc8,^
code-source-info,0x10510c260,16,2408,3584,,,
code-creation,Function,11,66584,0x10510c8a0,384,getOwn node:internal/bootstrap/loaders:180:16,0x2b48e0c4f900,^
code-source-info,0x10510c8a0,9,5498,5652,,,
code-creation,RegExp,3,66667,0x10510ca80,1808,(?:^|\\/)\\.?\\.$
code-creation,Eval,10,66792,0x2cbd7649499e,5, /Users/vignesh/.nvm/versions/node/v17.7.1/lib/node_modules/0x/lib/preload/redir-stdout.js:1:1,0x2cbd764947f8,~
script-source,145,/Users/vignesh/.nvm/versions/node/v17.7.1/lib/node_modules/0x/lib/preload/redir-stdout.js,'use strict'\nconst net = require('net')\n\nlet isWorker = false\ntry {\n  // Skip redirecting stdout in Worker threads.\n  isWorker = !require('worker_threads').isMainThread\n} catch (e) {}\n\nif (!isWorker) {\n  const socket = new net.Socket({\n    fd: 3\x2C\n    readable: false\x2C\n    writable: true\n  })\n  Object.defineProperty(process\x2C 'stdout'\x2C {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get: () => socket\n  })\n  Object.defineProperty(process.stdout\x2C 'fd'\x2C {\n    value: socket._handle.fd\n  })\n}\n
code-source-info,0x2cbd7649499e,145,0,494,C0O0C4O494,,
code-creation,Function,10,66834,0x2cbd76494c46,157, /Users/vignesh/.nvm/versions/node/v17.7.1/lib/node_modules/0x/lib/preload/redir-stdout.js:1:1,0x2cbd76494918,~
code-source-info,0x2cbd76494c46,145,0,494,C0O25C3O25C8O56C13O118C16O130C21O155C30O127C42O185C53O227C65O219C70O219C72O294C76O301C81O316C93O392C101O301C106O412C110O419C115O434C119O442C135O476C140O484C148O419C156O493,,
code-creation,LazyCompile,10,66875,0x2cbd7649511e,37,get SocketAddress node:net:1830:20,0x120d44384128,~
code-source-info,0x2cbd7649511e,113,48921,49026,C0O48930C14O48948C19O48981C26O48944C32O49001C36O49022,,
code-creation,Eval,10,66917,0x2cbd764954e6,5, node:worker_threads:1:1,0x2cbd764953a0,~
script-source,146,node:worker_threads,'use strict';\n\nconst {\n  isMainThread\x2C\n  SHARE_ENV\x2C\n  resourceLimits\x2C\n  setEnvironmentData\x2C\n  getEnvironmentData\x2C\n  threadId\x2C\n  Worker\n} = require('internal/worker');\n\nconst {\n  MessagePort\x2C\n  MessageChannel\x2C\n  moveMessagePortToContext\x2C\n  receiveMessageOnPort\x2C\n  BroadcastChannel\x2C\n} = require('internal/worker/io');\n\nconst {\n  markAsUntransferable\x2C\n} = require('internal/buffer');\n\nmodule.exports = {\n  isMainThread\x2C\n  MessagePort\x2C\n  MessageChannel\x2C\n  markAsUntransferable\x2C\n  moveMessagePortToContext\x2C\n  receiveMessageOnPort\x2C\n  resourceLimits\x2C\n  threadId\x2C\n  SHARE_ENV\x2C\n  Worker\x2C\n  parentPort: null\x2C\n  workerData: null\x2C\n  BroadcastChannel\x2C\n  setEnvironmentData\x2C\n  getEnvironmentData\x2C\n};\n
code-source-info,0x2cbd764954e6,146,0,686,C0O0C4O686,,
code-creation,Function,10,66959,0x2cbd764956f6,180, node:worker_threads:1:1,0x2cbd76495460,~
code-source-info,0x2cbd764956f6,146,0,686,C0O139C3O139C8O25C13O41C18O54C23O72C28O94C33O116C38O128C43O285C46O285C51O178C56O193C61O211C66O239C71O263C76O353C79O353C84O327C89O382C96O403C102O419C108O434C114O452C120O476C126O504C132O528C138O546C144O558C150O571C156O621C162O641C168O663C174O397C179O685,,
tick,0x10093dd38,67042,1,0x10041f4d8,2,0x0,0x105108c5c,0x10510894c,0x2cbd764956f9,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd76494c56,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,Eval,10,67167,0x2cbd7649669e,5, node:internal/worker:1:1,0x2cbd764960c0,~
script-source,147,node:internal/worker,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  Float64Array\x2C\n  FunctionPrototypeBind\x2C\n  JSONStringify\x2C\n  MathMax\x2C\n  ObjectCreate\x2C\n  ObjectEntries\x2C\n  Promise\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  TypedArrayPrototypeFill\x2C\n  Uint32Array\x2C\n  globalThis: { Atomics\x2C SharedArrayBuffer }\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\nconst assert = require('internal/assert');\nconst path = require('path');\nconst { now } = require('internal/perf/utils');\n\nconst errorCodes = require('internal/errors').codes;\nconst {\n  ERR_WORKER_NOT_RUNNING\x2C\n  ERR_WORKER_PATH\x2C\n  ERR_WORKER_UNSERIALIZABLE_ERROR\x2C\n  ERR_WORKER_INVALID_EXEC_ARGV\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n} = errorCodes;\nconst { getOptionValue } = require('internal/options');\n\nconst workerIo = require('internal/worker/io');\nconst {\n  drainMessagePort\x2C\n  MessageChannel\x2C\n  messageTypes\x2C\n  kPort\x2C\n  kIncrementsPortRef\x2C\n  kWaitingStreams\x2C\n  kStdioWantsMoreDataCallback\x2C\n  setupPortReferencing\x2C\n  ReadableWorkerStdio\x2C\n  WritableWorkerStdio\n} = workerIo;\nconst { deserializeError } = require('internal/error_serdes');\nconst { fileURLToPath\x2C isURLInstance\x2C pathToFileURL } = require('internal/url');\nconst { validateArray } = require('internal/validators');\n\nconst {\n  ownsProcessState\x2C\n  isMainThread\x2C\n  resourceLimits: resourceLimitsRaw\x2C\n  threadId\x2C\n  Worker: WorkerImpl\x2C\n  kMaxYoungGenerationSizeMb\x2C\n  kMaxOldGenerationSizeMb\x2C\n  kCodeRangeSizeMb\x2C\n  kStackSizeMb\x2C\n  kTotalResourceLimitCount\n} = internalBinding('worker');\n\nconst kHandle = Symbol('kHandle');\nconst kPublicPort = Symbol('kPublicPort');\nconst kDispose = Symbol('kDispose');\nconst kOnExit = Symbol('kOnExit');\nconst kOnMessage = Symbol('kOnMessage');\nconst kOnCouldNotSerializeErr = Symbol('kOnCouldNotSerializeErr');\nconst kOnErrorMessage = Symbol('kOnErrorMessage');\nconst kParentSideStdio = Symbol('kParentSideStdio');\nconst kLoopStartTime = Symbol('kLoopStartTime');\nconst kIsOnline = Symbol('kIsOnline');\n\nconst SHARE_ENV = SymbolFor('nodejs.worker_threads.SHARE_ENV');\nlet debug = require('internal/util/debuglog').debuglog('worker'\x2C (fn) => {\n  debug = fn;\n});\n\nlet cwdCounter;\n\nconst environmentData = new SafeMap();\n\nif (isMainThread) {\n  cwdCounter = new Uint32Array(new SharedArrayBuffer(4));\n  const originalChdir = process.chdir;\n  process.chdir = function(path) {\n    Atomics.add(cwdCounter\x2C 0\x2C 1);\n    originalChdir(path);\n  };\n}\n\nfunction setEnvironmentData(key\x2C value) {\n  if (value === undefined)\n    environmentData.delete(key);\n  else\n    environmentData.set(key\x2C value);\n}\n\nfunction getEnvironmentData(key) {\n  return environmentData.get(key);\n}\n\nfunction assignEnvironmentData(data) {\n  if (data === undefined) return;\n  data.forEach((value\x2C key) => {\n    environmentData.set(key\x2C value);\n  });\n}\n\nclass Worker extends EventEmitter {\n  constructor(filename\x2C options = {}) {\n    super();\n    debug(`[${threadId}] create new worker`\x2C filename\x2C options);\n    if (options.execArgv)\n      validateArray(options.execArgv\x2C 'options.execArgv');\n\n    let argv;\n    if (options.argv) {\n      validateArray(options.argv\x2C 'options.argv');\n      argv = ArrayPrototypeMap(options.argv\x2C String);\n    }\n\n    let url\x2C doEval;\n    if (options.eval) {\n      if (typeof filename !== 'string') {\n        throw new ERR_INVALID_ARG_VALUE(\n          'options.eval'\x2C\n          options.eval\x2C\n          'must be false when \\'filename\\' is not a string'\n        );\n      }\n      url = null;\n      doEval = 'classic';\n    } else if (isURLInstance(filename) && filename.protocol === 'data:') {\n      url = null;\n      doEval = 'module';\n      filename = `import ${JSONStringify(`${filename}`)}`;\n    } else {\n      doEval = false;\n      if (isURLInstance(filename)) {\n        url = filename;\n        filename = fileURLToPath(filename);\n      } else if (typeof filename !== 'string') {\n        throw new ERR_INVALID_ARG_TYPE(\n          'filename'\x2C\n          ['string'\x2C 'URL']\x2C\n          filename\n        );\n      } else if (path.isAbsolute(filename) ||\n                 RegExpPrototypeTest(/^\\.\\.?[\\\\/]/\x2C filename)) {\n        filename = path.resolve(filename);\n        url = pathToFileURL(filename);\n      } else {\n        throw new ERR_WORKER_PATH(filename);\n      }\n    }\n\n    let env;\n    if (typeof options.env === 'object' && options.env !== null) {\n      env = ObjectCreate(null);\n      ArrayPrototypeForEach(\n        ObjectEntries(options.env)\x2C\n        ({ 0: key\x2C 1: value }) => { env[key] = `${value}`; }\n      );\n    } else if (options.env == null) {\n      env = process.env;\n    } else if (options.env !== SHARE_ENV) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.env'\x2C\n        ['object'\x2C 'undefined'\x2C 'null'\x2C 'worker_threads.SHARE_ENV']\x2C\n        options.env);\n    }\n\n    // Set up the C++ handle for the worker\x2C as well as some internal wiring.\n    this[kHandle] = new WorkerImpl(url\x2C\n                                   env === process.env ? null : env\x2C\n                                   options.execArgv\x2C\n                                   parseResourceLimits(options.resourceLimits)\x2C\n                                   !!(options.trackUnmanagedFds ?? true));\n    if (this[kHandle].invalidExecArgv) {\n      throw new ERR_WORKER_INVALID_EXEC_ARGV(this[kHandle].invalidExecArgv);\n    }\n    if (this[kHandle].invalidNodeOptions) {\n      throw new ERR_WORKER_INVALID_EXEC_ARGV(\n        this[kHandle].invalidNodeOptions\x2C 'invalid NODE_OPTIONS env variable');\n    }\n    this[kHandle].onexit = (code\x2C customErr\x2C customErrReason) => {\n      this[kOnExit](code\x2C customErr\x2C customErrReason);\n    };\n    this[kPort] = this[kHandle].messagePort;\n    this[kPort].on('message'\x2C (data) => this[kOnMessage](data));\n    this[kPort].start();\n    this[kPort].unref();\n    this[kPort][kWaitingStreams] = 0;\n    debug(`[${threadId}] created Worker with ID ${this.threadId}`);\n\n    let stdin = null;\n    if (options.stdin)\n      stdin = new WritableWorkerStdio(this[kPort]\x2C 'stdin');\n    const stdout = new ReadableWorkerStdio(this[kPort]\x2C 'stdout');\n    if (!options.stdout) {\n      stdout[kIncrementsPortRef] = false;\n      pipeWithoutWarning(stdout\x2C process.stdout);\n    }\n    const stderr = new ReadableWorkerStdio(this[kPort]\x2C 'stderr');\n    if (!options.stderr) {\n      stderr[kIncrementsPortRef] = false;\n      pipeWithoutWarning(stderr\x2C process.stderr);\n    }\n\n    this[kParentSideStdio] = { stdin\x2C stdout\x2C stderr };\n\n    const { port1\x2C port2 } = new MessageChannel();\n    const transferList = [port2];\n    // If transferList is provided.\n    if (options.transferList)\n      ArrayPrototypePush(transferList\x2C\n                         ...new SafeArrayIterator(options.transferList));\n\n    this[kPublicPort] = port1;\n    ArrayPrototypeForEach(['message'\x2C 'messageerror']\x2C (event) => {\n      this[kPublicPort].on(event\x2C (message) => this.emit(event\x2C message));\n    });\n    setupPortReferencing(this[kPublicPort]\x2C this\x2C 'message');\n    this[kPort].postMessage({\n      argv\x2C\n      type: messageTypes.LOAD_SCRIPT\x2C\n      filename\x2C\n      doEval\x2C\n      cwdCounter: cwdCounter || workerIo.sharedCwdCounter\x2C\n      workerData: options.workerData\x2C\n      environmentData\x2C\n      publicPort: port2\x2C\n      manifestURL: getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').url :\n        null\x2C\n      manifestSrc: getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').src :\n        null\x2C\n      hasStdin: !!options.stdin\n    }\x2C transferList);\n    // Use this to cache the Worker's loopStart value once available.\n    this[kLoopStartTime] = -1;\n    this[kIsOnline] = false;\n    this.performance = {\n      eventLoopUtilization: FunctionPrototypeBind(eventLoopUtilization\x2C this)\x2C\n    };\n    // Actually start the new thread now that everything is in place.\n    this[kHandle].startThread();\n\n    process.nextTick(() => process.emit('worker'\x2C this));\n  }\n\n  [kOnExit](code\x2C customErr\x2C customErrReason) {\n    debug(`[${threadId}] hears end event for Worker ${this.threadId}`);\n    drainMessagePort(this[kPublicPort]);\n    drainMessagePort(this[kPort]);\n    this.removeAllListeners('message');\n    this.removeAllListeners('messageerrors');\n    this[kPublicPort].unref();\n    this[kPort].unref();\n    this[kDispose]();\n    if (customErr) {\n      debug(`[${threadId}] failing with custom error ${customErr} \\\n        and with reason ${customErrReason}`);\n      this.emit('error'\x2C new errorCodes[customErr](customErrReason));\n    }\n    this.emit('exit'\x2C code);\n    this.removeAllListeners();\n  }\n\n  [kOnCouldNotSerializeErr]() {\n    this.emit('error'\x2C new ERR_WORKER_UNSERIALIZABLE_ERROR());\n  }\n\n  [kOnErrorMessage](serialized) {\n    // This is what is called for uncaught exceptions.\n    const error = deserializeError(serialized);\n    this.emit('error'\x2C error);\n  }\n\n  [kOnMessage](message) {\n    switch (message.type) {\n      case messageTypes.UP_AND_RUNNING:\n        this[kIsOnline] = true;\n        return this.emit('online');\n      case messageTypes.COULD_NOT_SERIALIZE_ERROR:\n        return this[kOnCouldNotSerializeErr]();\n      case messageTypes.ERROR_MESSAGE:\n        return this[kOnErrorMessage](message.error);\n      case messageTypes.STDIO_PAYLOAD:\n      {\n        const { stream\x2C chunks } = message;\n        const readable = this[kParentSideStdio][stream];\n        ArrayPrototypeForEach(chunks\x2C ({ chunk\x2C encoding }) => {\n          readable.push(chunk\x2C encoding);\n        });\n        return;\n      }\n      case messageTypes.STDIO_WANTS_MORE_DATA:\n      {\n        const { stream } = message;\n        return this[kParentSideStdio][stream][kStdioWantsMoreDataCallback]();\n      }\n    }\n\n    assert.fail(`Unknown worker message type ${message.type}`);\n  }\n\n  [kDispose]() {\n    this[kHandle].onexit = null;\n    this[kHandle] = null;\n    this[kPort] = null;\n    this[kPublicPort] = null;\n\n    const { stdout\x2C stderr } = this[kParentSideStdio];\n\n    if (!stdout.readableEnded) {\n      debug(`[${threadId}] explicitly closes stdout for ${this.threadId}`);\n      stdout.push(null);\n    }\n    if (!stderr.readableEnded) {\n      debug(`[${threadId}] explicitly closes stderr for ${this.threadId}`);\n      stderr.push(null);\n    }\n  }\n\n  postMessage(...args) {\n    if (this[kPublicPort] === null) return;\n\n    ReflectApply(this[kPublicPort].postMessage\x2C this[kPublicPort]\x2C args);\n  }\n\n  terminate(callback) {\n    debug(`[${threadId}] terminates Worker with ID ${this.threadId}`);\n\n    this.ref();\n\n    if (typeof callback === 'function') {\n      process.emitWarning(\n        'Passing a callback to worker.terminate() is deprecated. ' +\n        'It returns a Promise instead.'\x2C\n        'DeprecationWarning'\x2C 'DEP0132');\n      if (this[kHandle] === null) return PromiseResolve();\n      this.once('exit'\x2C (exitCode) => callback(null\x2C exitCode));\n    }\n\n    if (this[kHandle] === null) return PromiseResolve();\n\n    this[kHandle].stopThread();\n\n    // Do not use events.once() here\x2C because the 'exit' event will always be\n    // emitted regardless of any errors\x2C and the point is to only resolve\n    // once the thread has actually stopped.\n    return new Promise((resolve) => {\n      this.once('exit'\x2C resolve);\n    });\n  }\n\n  ref() {\n    if (this[kHandle] === null) return;\n\n    this[kHandle].ref();\n    this[kPublicPort].ref();\n  }\n\n  unref() {\n    if (this[kHandle] === null) return;\n\n    this[kHandle].unref();\n    this[kPublicPort].unref();\n  }\n\n  get threadId() {\n    if (this[kHandle] === null) return -1;\n\n    return this[kHandle].threadId;\n  }\n\n  get stdin() {\n    return this[kParentSideStdio].stdin;\n  }\n\n  get stdout() {\n    return this[kParentSideStdio].stdout;\n  }\n\n  get stderr() {\n    return this[kParentSideStdio].stderr;\n  }\n\n  get resourceLimits() {\n    if (this[kHandle] === null) return {};\n\n    return makeResourceLimits(this[kHandle].getResourceLimits());\n  }\n\n  getHeapSnapshot() {\n    const heapSnapshotTaker = this[kHandle] && this[kHandle].takeHeapSnapshot();\n    return new Promise((resolve\x2C reject) => {\n      if (!heapSnapshotTaker) return reject(new ERR_WORKER_NOT_RUNNING());\n      heapSnapshotTaker.ondone = (handle) => {\n        const { HeapSnapshotStream } = require('internal/heap_utils');\n        resolve(new HeapSnapshotStream(handle));\n      };\n    });\n  }\n}\n\nfunction pipeWithoutWarning(source\x2C dest) {\n  const sourceMaxListeners = source._maxListeners;\n  const destMaxListeners = dest._maxListeners;\n  source.setMaxListeners(Infinity);\n  dest.setMaxListeners(Infinity);\n\n  source.pipe(dest);\n\n  source._maxListeners = sourceMaxListeners;\n  dest._maxListeners = destMaxListeners;\n}\n\nconst resourceLimitsArray = new Float64Array(kTotalResourceLimitCount);\nfunction parseResourceLimits(obj) {\n  const ret = resourceLimitsArray;\n  TypedArrayPrototypeFill(ret\x2C -1);\n  if (typeof obj !== 'object' || obj === null) return ret;\n\n  if (typeof obj.maxOldGenerationSizeMb === 'number')\n    ret[kMaxOldGenerationSizeMb] = MathMax(obj.maxOldGenerationSizeMb\x2C 2);\n  if (typeof obj.maxYoungGenerationSizeMb === 'number')\n    ret[kMaxYoungGenerationSizeMb] = obj.maxYoungGenerationSizeMb;\n  if (typeof obj.codeRangeSizeMb === 'number')\n    ret[kCodeRangeSizeMb] = obj.codeRangeSizeMb;\n  if (typeof obj.stackSizeMb === 'number')\n    ret[kStackSizeMb] = obj.stackSizeMb;\n  return ret;\n}\n\nfunction makeResourceLimits(float64arr) {\n  return {\n    maxYoungGenerationSizeMb: float64arr[kMaxYoungGenerationSizeMb]\x2C\n    maxOldGenerationSizeMb: float64arr[kMaxOldGenerationSizeMb]\x2C\n    codeRangeSizeMb: float64arr[kCodeRangeSizeMb]\x2C\n    stackSizeMb: float64arr[kStackSizeMb]\n  };\n}\n\nfunction eventLoopUtilization(util1\x2C util2) {\n  // TODO(trevnorris): Works to solve the thread-safe read/write issue of\n  // loopTime\x2C but has the drawback that it can't be set until the event loop\n  // has had a chance to turn. So it will be impossible to read the ELU of\n  // a worker thread immediately after it's been created.\n  if (!this[kIsOnline] || !this[kHandle]) {\n    return { idle: 0\x2C active: 0\x2C utilization: 0 };\n  }\n\n  // Cache loopStart\x2C since it's only written to once.\n  if (this[kLoopStartTime] === -1) {\n    this[kLoopStartTime] = this[kHandle].loopStartTime();\n    if (this[kLoopStartTime] === -1)\n      return { idle: 0\x2C active: 0\x2C utilization: 0 };\n  }\n\n  if (util2) {\n    const idle = util1.idle - util2.idle;\n    const active = util1.active - util2.active;\n    return { idle\x2C active\x2C utilization: active / (idle + active) };\n  }\n\n  const idle = this[kHandle].loopIdleTime();\n\n  // Using performance.now() here is fine since it's always the time from\n  // the beginning of the process\x2C and is why it needs to be offset by the\n  // loopStart time (which is also calculated from the beginning of the\n  // process).\n  const active = now() - this[kLoopStartTime] - idle;\n\n  if (!util1) {\n    return { idle\x2C active\x2C utilization: active / (idle + active) };\n  }\n\n  const idle_delta = idle - util1.idle;\n  const active_delta = active - util1.active;\n  const utilization = active_delta / (idle_delta + active_delta);\n  return { idle: idle_delta\x2C active: active_delta\x2C utilization };\n}\n\nmodule.exports = {\n  ownsProcessState\x2C\n  isMainThread\x2C\n  SHARE_ENV\x2C\n  resourceLimits:\n    !isMainThread ? makeResourceLimits(resourceLimitsRaw) : {}\x2C\n  setEnvironmentData\x2C\n  getEnvironmentData\x2C\n  assignEnvironmentData\x2C\n  threadId\x2C\n  Worker\x2C\n};\n
code-source-info,0x2cbd7649669e,147,0,15348,C0O0C4O15348,,
code-creation,Function,10,67750,0x2cbd764979ee,1185, node:internal/worker:1:1,0x2cbd76496618,~
code-source-info,0x2cbd764979ee,147,0,15348,C0O0C244O25C250O50C256O71C262O93C267O109C273O134C279O151C285O162C291O178C297O195C303O206C309O224C315O240C321O263C327O284C332O295C338O305C343O315C348O328C354O355C365O384C371O393C376O453C384O453C389O487C397O487C401O487C403O528C411O528C415O528C417O561C425O561C431O553C437O613C445O613C451O639C455O613C457O820C461O657C467O683C473O702C479O737C485O769C491O793C497O859C505O859C511O840C517O906C525O906C529O906C531O1153C535O947C541O967C547O985C553O1001C559O1010C565O1032C571O1051C577O1082C583O1106C589O1129C595O1192C603O1192C609O1171C615O1282C623O1282C629O1234C635O1249C641O1264C647O1333C655O1333C661O1315C667O1604C671O1604C677O1376C682O1396C687O1428C692O1449C698O1469C704O1483C710O1512C716O1539C722O1559C728O1575C733O1648C737O1648C741O1648C743O1687C747O1687C751O1687C753O1727C757O1727C761O1727C763O1763C767O1763C771O1763C773O1801C777O1801C781O1801C783O1855C787O1855C791O1855C793O1914C797O1914C801O1914C803O1966C807O1966C811O1966C813O2017C817O2017C821O2017C823O2061C827O2061C831O2061C833O2101C837O2101C841O2101C843O2159C851O2159C857O2192C873O2193C879O2159C881O2245C882O2245C884O2282C886O2282C891O2282C893O2298C904O2320C910O2349C919O2333C924O2331C928O2400C934O2408C938O2400C940O2417C950O2431C956O2913C966O7967C976O8603C986O8703C996O8876C1006O9773C1092O12655C1094O12655C1099O12655C1101O15104C1109O15125C1115O15145C1121O15161C1130O15195C1136O15210C1149O15256C1155O15278C1161O15300C1167O15325C1173O15337C1179O15119C1184O15347,,
code-creation,Eval,10,67917,0x2cbd7649991e,5, node:internal/error_serdes:1:1,0x2cbd76499658,~
script-source,148,node:internal/error_serdes,'use strict';\n\nconst Buffer = require('buffer').Buffer;\nconst {\n  ArrayPrototypeForEach\x2C\n  Error\x2C\n  EvalError\x2C\n  FunctionPrototypeCall\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeToString\x2C\n  RangeError\x2C\n  ReferenceError\x2C\n  SafeSet\x2C\n  SymbolToStringTag\x2C\n  SyntaxError\x2C\n  TypeError\x2C\n  URIError\x2C\n} = primordials;\n\nconst kSerializedError = 0;\nconst kSerializedObject = 1;\nconst kInspectedError = 2;\n\nconst errors = {\n  Error\x2C TypeError\x2C RangeError\x2C URIError\x2C SyntaxError\x2C ReferenceError\x2C EvalError\n};\nconst errorConstructorNames = new SafeSet(ObjectKeys(errors));\n\nfunction TryGetAllProperties(object\x2C target = object) {\n  const all = ObjectCreate(null);\n  if (object === null)\n    return all;\n  ObjectAssign(all\x2C\n               TryGetAllProperties(ObjectGetPrototypeOf(object)\x2C target));\n  const keys = ObjectGetOwnPropertyNames(object);\n  ArrayPrototypeForEach(keys\x2C (key) => {\n    let descriptor;\n    try {\n      descriptor = ObjectGetOwnPropertyDescriptor(object\x2C key);\n    } catch { return; }\n    const getter = descriptor.get;\n    if (getter && key !== '__proto__') {\n      try {\n        descriptor.value = FunctionPrototypeCall(getter\x2C target);\n      } catch {\n        // Continue regardless of error.\n      }\n    }\n    if ('value' in descriptor && typeof descriptor.value !== 'function') {\n      delete descriptor.get;\n      delete descriptor.set;\n      all[key] = descriptor;\n    }\n  });\n  return all;\n}\n\nfunction GetConstructors(object) {\n  const constructors = [];\n\n  for (let current = object;\n    current !== null;\n    current = ObjectGetPrototypeOf(current)) {\n    const desc = ObjectGetOwnPropertyDescriptor(current\x2C 'constructor');\n    if (desc && desc.value) {\n      ObjectDefineProperty(constructors\x2C constructors.length\x2C {\n        value: desc.value\x2C enumerable: true\n      });\n    }\n  }\n\n  return constructors;\n}\n\nfunction GetName(object) {\n  const desc = ObjectGetOwnPropertyDescriptor(object\x2C 'name');\n  return desc && desc.value;\n}\n\nlet internalUtilInspect;\nfunction inspect(...args) {\n  if (!internalUtilInspect) {\n    internalUtilInspect = require('internal/util/inspect');\n  }\n  return internalUtilInspect.inspect(...args);\n}\n\nlet serialize;\nfunction serializeError(error) {\n  if (!serialize) serialize = require('v8').serialize;\n  try {\n    if (typeof error === 'object' &&\n        ObjectPrototypeToString(error) === '[object Error]') {\n      const constructors = GetConstructors(error);\n      for (let i = 0; i < constructors.length; i++) {\n        const name = GetName(constructors[i]);\n        if (errorConstructorNames.has(name)) {\n          const serialized = serialize({\n            constructor: name\x2C\n            properties: TryGetAllProperties(error)\n          });\n          return Buffer.concat([Buffer.from([kSerializedError])\x2C serialized]);\n        }\n      }\n    }\n  } catch {\n    // Continue regardless of error.\n  }\n  try {\n    const serialized = serialize(error);\n    return Buffer.concat([Buffer.from([kSerializedObject])\x2C serialized]);\n  } catch {\n    // Continue regardless of error.\n  }\n  return Buffer.concat([Buffer.from([kInspectedError])\x2C\n                        Buffer.from(inspect(error)\x2C 'utf8')]);\n}\n\nlet deserialize;\nfunction deserializeError(error) {\n  if (!deserialize) deserialize = require('v8').deserialize;\n  switch (error[0]) {\n    case kSerializedError: {\n      const { constructor\x2C properties } = deserialize(error.subarray(1));\n      const ctor = errors[constructor];\n      ObjectDefineProperty(properties\x2C SymbolToStringTag\x2C {\n        value: { value: 'Error'\x2C configurable: true }\x2C\n        enumerable: true\n      });\n      return ObjectCreate(ctor.prototype\x2C properties);\n    }\n    case kSerializedObject:\n      return deserialize(error.subarray(1));\n    case kInspectedError: {\n      const buf = Buffer.from(error.buffer\x2C\n                              error.byteOffset + 1\x2C\n                              error.byteLength - 1);\n      return buf.toString('utf8');\n    }\n  }\n  require('assert').fail('This should not happen');\n}\n\nmodule.exports = { serializeError\x2C deserializeError };\n
code-source-info,0x2cbd7649991e,148,0,4174,C0O0C4O4174,,
code-creation,Function,10,68084,0x2cbd76499d3e,335, node:internal/error_serdes:1:1,0x2cbd76499898,~
code-source-info,0x2cbd76499d3e,148,0,4174,C0O0C100O30C106O30C111O47C115O30C117O66C123O91C128O100C133O113C139O138C145O154C151O170C157O194C163O228C169O257C175O281C180O295C186O322C191O336C196O354C201O365C207O386C212O401C217O414C222O467C223O467C225O496C227O496C229O523C231O523C233O542C240O546C246O553C252O564C258O576C264O586C270O599C276O615C282O542C284O658C287O670C294O658C299O658C301O2086C302O2086C304O2283C305O2283C307O3284C308O3284C310O4119C317O4138C323O4154C329O4134C334O4173,,
code-creation,LazyCompile,10,68250,0x2cbd7649b336,914,Socket node:net:285:16,0x120d44381ff0,~
code-source-info,0x2cbd7649b336,113,7179,11637,C0O7193C2O7204C7O7224C12O7231C17O7251C18O7254C25O7265C34O7285C42O7360C52O7291C57O7285C58O7413C65O7424C81O7455C90O7483C98O7550C115O7639C121O7669C131O7489C136O7483C137O7727C144O7745C155O7792C167O7821C178O7792C183O7902C189O7924C194O7937C195O7967C199O7985C200O8001C204O8205C206O8210C211O8227C215O8235C216O8250C220O8261C222O8266C226O8275C230O8285C231O8298C235O8308C236O8319C240O8329C242O8334C246O8355C250O8362C252O8367C256O8377C260O8387C262O8392C266O8401C270O8411C272O8416C276O8427C280O8437C282O8442C286O8454C290O8465C296O8502C303O8518C314O8561C320O8640C322O8664C325O8680C330O8664C334O8662C338O8754C339O8772C343O8783C344O8803C348O8843C349O8865C353O8876C358O8883C363O8890C368O8890C374O8926C380O8963C384O8953C388O8986C390O8991C396O9029C401O9010C405O9008C411O9060C417O9092C422O9116C424O9234C429O9249C434O9247C438O9290C443O9298C448O9298C454O9555C456O9570C464O9576C469O9570C470O9610C472O9615C475O9639C480O9647C485O9647C489O9632C493O9666C495O9674C502O9686C507O9710C514O9729C516O9718C523O9738C527O9820C532O9828C539O9828C545O9853C547O9870C555O9876C560O9870C561O9919C562O9932C566O9946C568O9960C571O9960C575O9958C579O10151C584O10177C597O10151C602O10283C607O10293C617O10353C620O10373C625O10353C631O10398C639O10444C647O10493C655O10524C657O10529C661O10538C665O10552C667O10557C670O10578C674O10569C680O10605C682O10610C685O10628C689O10619C693O10646C695O10651C698O10671C702O10662C706O10688C708O10693C713O10708C716O10724C721O10708C725O10706C729O10736C731O10741C736O10758C739O10774C744O10758C748O10756C752O10788C754O10793C757O10833C761O10855C767O10823C769O10822C771O10820C775O10927C786O10927C792O10962C795O10962C799O10989C800O11007C804O11017C806O11039C810O11180C816O11199C822O11208C827O11237C833O11324C839O11340C843O11360C848O11368C853O11368C857O11386C858O11407C864O11440C870O11466C877O11466C882O11512C883O11524C887O11534C888O11547C892O11587C894O11592C898O11604C902O11611C904O11616C908O11631C913O11636,,
code-creation,LazyCompile,10,68334,0x2cbd7649bac6,169,Duplex node:internal/streams/duplex:54:16,0x174551ee8ba8,~
script-source,56,node:internal/streams/duplex,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance\x2C this class\n// prototypically inherits from Readable\x2C and then parasitically from\n// Writable.\n\n'use strict';\n\nconst {\n  ObjectDefineProperties\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nmodule.exports = Duplex;\n\nconst Readable = require('internal/streams/readable');\nconst Writable = require('internal/streams/writable');\n\nObjectSetPrototypeOf(Duplex.prototype\x2C Readable.prototype);\nObjectSetPrototypeOf(Duplex\x2C Readable);\n\n{\n  const keys = ObjectKeys(Writable.prototype);\n  // Allow the keys array to be GC'ed.\n  for (let i = 0; i < keys.length; i++) {\n    const method = keys[i];\n    if (!Duplex.prototype[method])\n      Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this\x2C options);\n  Writable.call(this\x2C options);\n\n  if (options) {\n    this.allowHalfOpen = options.allowHalfOpen !== false;\n\n    if (options.readable === false) {\n      this._readableState.readable = false;\n      this._readableState.ended = true;\n      this._readableState.endEmitted = true;\n    }\n\n    if (options.writable === false) {\n      this._writableState.writable = false;\n      this._writableState.ending = true;\n      this._writableState.ended = true;\n      this._writableState.finished = true;\n    }\n  } else {\n    this.allowHalfOpen = true;\n  }\n}\n\nObjectDefineProperties(Duplex.prototype\x2C {\n  writable:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writable')\x2C\n  writableHighWaterMark:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableHighWaterMark')\x2C\n  writableObjectMode:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableObjectMode')\x2C\n  writableBuffer:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableBuffer')\x2C\n  writableLength:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableLength')\x2C\n  writableFinished:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableFinished')\x2C\n  writableCorked:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableCorked')\x2C\n  writableEnded:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableEnded')\x2C\n  writableNeedDrain:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableNeedDrain')\x2C\n\n  destroyed: {\n    get() {\n      if (this._readableState === undefined ||\n        this._writableState === undefined) {\n        return false;\n      }\n      return this._readableState.destroyed && this._writableState.destroyed;\n    }\x2C\n    set(value) {\n      // Backward compatibility\x2C the user is explicitly\n      // managing destroyed.\n      if (this._readableState && this._writableState) {\n        this._readableState.destroyed = value;\n        this._writableState.destroyed = value;\n      }\n    }\n  }\n});\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nDuplex.fromWeb = function(pair\x2C options) {\n  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(\n    pair\x2C\n    options);\n};\n\nDuplex.toWeb = function(duplex) {\n  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n};\n\nlet duplexify;\n\nDuplex.from = function(body) {\n  if (!duplexify) {\n    duplexify = require('internal/streams/duplexify');\n  }\n  return duplexify(body\x2C 'body');\n};\n
code-source-info,0x2cbd7649bac6,56,2011,2663,C0O2025C2O2036C7O2060C12O2067C17O2087C18O2091C23O2100C28O2100C34O2123C39O2132C44O2132C50O2156C54O2204C60O2218C64O2194C68O2246C74O2255C79O2279C85O2303C89O2323C95O2344C99O2363C105O2389C109O2420C115O2429C120O2453C126O2477C130O2497C136O2519C140O2538C146O2559C150O2578C156O2602C162O2631C163O2650C168O2662,,
tick,0x1bfd3cab0,68542,0,0x0,3,0x0,0x2cbd76494c87,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,LazyCompile,10,68625,0x2cbd7649c27e,220,Readable node:internal/streams/readable:186:18,0x174551ef3de8,~
script-source,57,node:internal/streams/readable,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  NumberIsInteger\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperties\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  SafeSet\x2C\n  SymbolAsyncIterator\x2C\n  Symbol\n} = primordials;\n\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\n\nconst EE = require('events');\nconst { Stream\x2C prependListener } = require('internal/streams/legacy');\nconst { Buffer } = require('buffer');\n\nconst {\n  addAbortSignal\x2C\n} = require('internal/streams/add-abort-signal');\nconst eos = require('internal/streams/end-of-stream');\n\nlet debug = require('internal/util/debuglog').debuglog('stream'\x2C (fn) => {\n  debug = fn;\n});\nconst BufferList = require('internal/streams/buffer_list');\nconst destroyImpl = require('internal/streams/destroy');\nconst {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\n} = require('internal/streams/state');\n\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_STREAM_PUSH_AFTER_EOF\x2C\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\x2C\n  }\n} = require('internal/errors');\nconst { validateObject } = require('internal/validators');\n\nconst kPaused = Symbol('kPaused');\n\nconst { StringDecoder } = require('string_decoder');\nconst from = require('internal/streams/from');\n\nObjectSetPrototypeOf(Readable.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(Readable\x2C Stream);\nconst nop = () => {};\n\nconst { errorOrDestroy } = destroyImpl;\n\nfunction ReadableState(options\x2C stream\x2C isDuplex) {\n  // Duplex streams are both readable and writable\x2C but share\n  // the same options object.\n  // However\x2C some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean')\n    isDuplex = stream instanceof Stream.Duplex;\n\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  this.objectMode = !!(options && options.objectMode);\n\n  if (isDuplex)\n    this.objectMode = this.objectMode ||\n      !!(options && options.readableObjectMode);\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value\x2C means "don't call _read preemptively ever"\n  this.highWaterMark = options ?\n    getHighWaterMark(this\x2C options\x2C 'readableHighWaterMark'\x2C isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = [];\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in\x2C therefore we start as\n  // constructed.\n  this.constructed = true;\n\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately\x2C or on a later tick.  We set this to true at first\x2C because\n  // any actions that shouldn't happen until "later" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // Whenever we return null\x2C then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this[kPaused] = null;\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  this.autoDestroy = !options || options.autoDestroy !== false;\n\n  // Has it been destroyed.\n  this.destroyed = false;\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls\x2C 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null;\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false;\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false;\n\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8'\x2C though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null;\n  this.multiAwaitDrain = false;\n\n  // If true\x2C a maybeReadMore has been scheduled.\n  this.readingMore = false;\n\n  this.dataEmitted = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor\x2C at least with V8 6.5.\n  const isDuplex = this instanceof Stream.Duplex;\n\n  this._readableState = new ReadableState(options\x2C this\x2C isDuplex);\n\n  if (options) {\n    if (typeof options.read === 'function')\n      this._read = options.read;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal && !isDuplex)\n      addAbortSignal(options.signal\x2C this);\n  }\n\n  Stream.call(this\x2C options);\n\n  destroyImpl.construct(this\x2C () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this\x2C this._readableState);\n    }\n  });\n}\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function(err\x2C cb) {\n  cb(err);\n};\n\nReadable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet\x2C\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk\x2C encoding) {\n  return readableAddChunk(this\x2C chunk\x2C encoding\x2C false);\n};\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function(chunk\x2C encoding) {\n  return readableAddChunk(this\x2C chunk\x2C encoding\x2C true);\n};\n\nfunction readableAddChunk(stream\x2C chunk\x2C encoding\x2C addToFront) {\n  debug('readableAddChunk'\x2C chunk);\n  const state = stream._readableState;\n\n  let err;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting\x2C if state.encoding is set\x2C we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk\x2C encoding).toString(state.encoding);\n        } else {\n          chunk = Buffer.from(chunk\x2C encoding);\n          encoding = '';\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = '';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = '';\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n    }\n  }\n\n  if (err) {\n    errorOrDestroy(stream\x2C err);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream\x2C state);\n  } else if (state.objectMode || (chunk && chunk.length > 0)) {\n    if (addToFront) {\n      if (state.endEmitted)\n        errorOrDestroy(stream\x2C new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n      else if (state.destroyed || state.errored)\n        return false;\n      else\n        addChunk(stream\x2C state\x2C chunk\x2C true);\n    } else if (state.ended) {\n      errorOrDestroy(stream\x2C new ERR_STREAM_PUSH_AFTER_EOF());\n    } else if (state.destroyed || state.errored) {\n      return false;\n    } else {\n      state.reading = false;\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk);\n        if (state.objectMode || chunk.length !== 0)\n          addChunk(stream\x2C state\x2C chunk\x2C false);\n        else\n          maybeReadMore(stream\x2C state);\n      } else {\n        addChunk(stream\x2C state\x2C chunk\x2C false);\n      }\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n    maybeReadMore(stream\x2C state);\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also\x2C if we have no data yet\x2C we can stand some more bytes.\n  // This is to work around cases where hwm=0\x2C such as the repl.\n  return !state.ended &&\n    (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream\x2C state\x2C chunk\x2C addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync &&\n      stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n\n    state.dataEmitted = true;\n    stream.emit('data'\x2C chunk);\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront)\n      state.buffer.unshift(chunk);\n    else\n      state.buffer.push(chunk);\n\n    if (state.needReadable)\n      emitReadable(stream);\n  }\n  maybeReadMore(stream\x2C state);\n}\n\nReadable.prototype.isPaused = function() {\n  const state = this._readableState;\n  return state[kPaused] === true || state.flowing === false;\n};\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  const decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null)\x2C decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  const buffer = this._readableState.buffer;\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = '';\n  for (const data of buffer) {\n    content += decoder.write(data);\n  }\n  buffer.clear();\n  if (content !== '')\n    buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size'\x2C '<= 1GiB'\x2C n);\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable\x2C so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n\x2C state) {\n  if (n <= 0 || (state.length === 0 && state.ended))\n    return 0;\n  if (state.objectMode)\n    return 1;\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length)\n      return state.buffer.first().length;\n    return state.length;\n  }\n  if (n <= state.length)\n    return n;\n  return state.ended ? state.length : 0;\n}\n\n// You can override either this method\x2C or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read'\x2C n);\n  // Same as parseInt(undefined\x2C 10)\x2C however V8 7.3 performance regressed\n  // in this scenario\x2C so we are doing it manually.\n  if (n === undefined) {\n    n = NaN;\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n\x2C 10);\n  }\n  const state = this._readableState;\n  const nOrig = n;\n\n  // If we're asking for more than the current hwm\x2C then raise the hwm.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n\n  if (n !== 0)\n    state.emittedReadable = false;\n\n  // If we're doing read(0) to trigger a readable event\x2C but we\n  // already have a bunch of data in the buffer\x2C then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      ((state.highWaterMark !== 0 ?\n        state.length >= state.highWaterMark :\n        state.length > 0) ||\n       state.ended)) {\n    debug('read: emitReadable'\x2C state.length\x2C state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n\x2C state);\n\n  // If we've ended\x2C and we're now clear\x2C then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases\x2C such as passthrough streams\x2C _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer\x2C providing enough data when\n  // before there was *not* enough.\n  //\n  // So\x2C the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read\x2C then call _read.\n  // Note that this may be asynchronous\x2C or synchronous.  Yes\x2C it is\n  // deeply ugly to write APIs this way\x2C but that still doesn't mean\n  // that the Readable class should behave improperly\x2C as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie\x2C if the read call\n  // has returned yet)\x2C so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event\x2C then we need to do some reading.\n  let doRead = state.needReadable;\n  debug('need readable'\x2C doRead);\n\n  // If we currently have less than the highWaterMark\x2C then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark'\x2C doRead);\n  }\n\n  // However\x2C if we've ended\x2C then there's no point\x2C if we're already\n  // reading\x2C then it's unnecessary\x2C if we're constructing we have to wait\x2C\n  // and if we're destroyed or errored\x2C then it's not allowed\x2C\n  if (state.ended || state.reading || state.destroyed || state.errored ||\n      !state.constructed) {\n    doRead = false;\n    debug('reading\x2C ended or constructing'\x2C doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // If the length is currently zero\x2C then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n\n    // Call internal read method\n    try {\n      const result = this._read(state.highWaterMark);\n      if (result != null) {\n        const then = result.then;\n        if (typeof then === 'function') {\n          then.call(\n            result\x2C\n            nop\x2C\n            function(err) {\n              errorOrDestroy(this\x2C err);\n            });\n        }\n      }\n    } catch (err) {\n      errorOrDestroy(this\x2C err);\n    }\n\n    state.sync = false;\n    // If _read pushed data synchronously\x2C then `reading` will be false\x2C\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading)\n      n = howMuchToRead(nOrig\x2C state);\n  }\n\n  let ret;\n  if (n > 0)\n    ret = fromList(n\x2C state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer\x2C then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended)\n      state.needReadable = true;\n\n    // If we tried to read() past the EOF\x2C then emit end on the next tick.\n    if (nOrig !== n && state.ended)\n      endReadable(this);\n  }\n\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true;\n    this.emit('data'\x2C ret);\n  }\n\n  return ret;\n};\n\nfunction onEofChunk(stream\x2C state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    const chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  if (state.sync) {\n    // If we are sync\x2C wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream);\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    state.emittedReadable = true;\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream);\n  }\n}\n\n// Don't emit readable right away in sync mode\x2C because this can trigger\n// another read() call => stack overflow.  This way\x2C it might trigger\n// a nextTick recursion warning\x2C but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState;\n  debug('emitReadable'\x2C state.needReadable\x2C state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable'\x2C state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_\x2C stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  const state = stream._readableState;\n  debug('emitReadable_'\x2C state.destroyed\x2C state.length\x2C state.ended);\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing\x2C as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark\x2C so we can schedule\n  //    another readable later.\n  state.needReadable =\n    !state.flowing &&\n    !state.ended &&\n    state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n\n// At this point\x2C the user has presumably seen the 'readable' event\x2C\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call\x2C in which case reading = true if\n// it's in progress.\n// However\x2C if we're not ended\x2C or reading\x2C and the length < hwm\x2C\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream\x2C state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_\x2C stream\x2C state);\n  }\n}\n\nfunction maybeReadMore_(stream\x2C state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer\x2C and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data\x2C the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method\x2C but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended &&\n         (state.length < state.highWaterMark ||\n          (state.flowing && state.length === 0))) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // Didn't get any data\x2C stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er\x2C data) where data is <= n in length.\n// for virtual (non-string\x2C non-buffer) streams\x2C "length" is somewhat\n// arbitrary\x2C and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()');\n};\n\nReadable.prototype.pipe = function(dest\x2C pipeOpts) {\n  const src = this;\n  const state = this._readableState;\n\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true;\n      state.awaitDrainWriters = new SafeSet(\n        state.awaitDrainWriters ? [state.awaitDrainWriters] : []\n      );\n    }\n  }\n\n  state.pipes.push(dest);\n  debug('pipe count=%d opts=%j'\x2C state.pipes.length\x2C pipeOpts);\n\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  const endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end'\x2C endFn);\n\n  dest.on('unpipe'\x2C onunpipe);\n  function onunpipe(readable\x2C unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  let ondrain;\n\n  let cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close'\x2C onclose);\n    dest.removeListener('finish'\x2C onfinish);\n    if (ondrain) {\n      dest.removeListener('drain'\x2C ondrain);\n    }\n    dest.removeListener('error'\x2C onerror);\n    dest.removeListener('unpipe'\x2C onunpipe);\n    src.removeListener('end'\x2C onend);\n    src.removeListener('end'\x2C unpipe);\n    src.removeListener('data'\x2C ondata);\n\n    cleanedUp = true;\n\n    // If the reader is waiting for a drain event from this\n    // specific writer\x2C then it would cause it to never start\n    // flowing again.\n    // So\x2C if this is awaiting a drain\x2C then we just call it now.\n    // If we don't know\x2C then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  function pause() {\n    // If the user unpiped during `dest.write()`\x2C it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response\x2C pause'\x2C 0);\n        state.awaitDrainWriters = dest;\n        state.multiAwaitDrain = false;\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response\x2C pause'\x2C state.awaitDrainWriters.size);\n        state.awaitDrainWriters.add(dest);\n      }\n      src.pause();\n    }\n    if (!ondrain) {\n      // When the dest drains\x2C it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow()\x2C but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src\x2C dest);\n      dest.on('drain'\x2C ondrain);\n    }\n  }\n\n  src.on('data'\x2C ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    const ret = dest.write(chunk);\n    debug('dest.write'\x2C ret);\n    if (ret === false) {\n      pause();\n    }\n  }\n\n  // If the dest has an error\x2C then stop piping into it.\n  // However\x2C don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror'\x2C er);\n    unpipe();\n    dest.removeListener('error'\x2C onerror);\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState;\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest\x2C er);\n      } else {\n        dest.emit('error'\x2C er);\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest\x2C 'error'\x2C onerror);\n\n  // Both close and finish should trigger unpipe\x2C but only once.\n  function onclose() {\n    dest.removeListener('finish'\x2C onfinish);\n    unpipe();\n  }\n  dest.once('close'\x2C onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close'\x2C onclose);\n    unpipe();\n  }\n  dest.once('finish'\x2C onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe'\x2C src);\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    if (state.flowing) {\n      pause();\n    }\n  } else if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src\x2C dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState;\n\n    // `ondrain` will call directly\x2C\n    // `this` maybe not a reference to dest\x2C\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain'\x2C 1);\n      state.awaitDrainWriters = null;\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain'\x2C state.awaitDrainWriters.size);\n      state.awaitDrainWriters.delete(dest);\n    }\n\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) &&\n      src.listenerCount('data')) {\n      src.resume();\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  const state = this._readableState;\n  const unpipeInfo = { hasUnpiped: false };\n\n  // If we're not piping anywhere\x2C then do nothing.\n  if (state.pipes.length === 0)\n    return this;\n\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes;\n    state.pipes = [];\n    this.pause();\n\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe'\x2C this\x2C { hasUnpiped: false });\n    return this;\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes\x2C dest);\n  if (index === -1)\n    return this;\n\n  state.pipes.splice(index\x2C 1);\n  if (state.pipes.length === 0)\n    this.pause();\n\n  dest.emit('unpipe'\x2C this\x2C unpipeInfo);\n\n  return this;\n};\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function(ev\x2C fn) {\n  const res = Stream.prototype.on.call(this\x2C ev\x2C fn);\n  const state = this._readableState;\n\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false)\n      this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable'\x2C state.length\x2C state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick\x2C this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function(ev\x2C fn) {\n  const res = Stream.prototype.removeListener.call(this\x2C\n                                                   ev\x2C fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable'\x2C fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening\x2C this);\n  }\n\n  return res;\n};\nReadable.prototype.off = Readable.prototype.removeListener;\n\nReadable.prototype.removeAllListeners = function(ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this\x2C\n                                                        arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable'\x2C fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening\x2C this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now\x2C otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  } else if (!state.readableListening) {\n    state.flowing = null;\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them\x2C then switch into old mode.\nReadable.prototype.resume = function() {\n  const state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // We flow only if there is no one listening\n    // for readable\x2C but we still have to call\n    // resume().\n    state.flowing = !state.readableListening;\n    resume(this\x2C state);\n  }\n  state[kPaused] = false;\n  return this;\n};\n\nfunction resume(stream\x2C state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_\x2C stream\x2C state);\n  }\n}\n\nfunction resume_(stream\x2C state) {\n  debug('resume'\x2C state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j'\x2C this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState[kPaused] = true;\n  return this;\n};\n\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow'\x2C state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  let paused = false;\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method\x2C e.g. Readable.wrap(stream).\n\n  stream.on('data'\x2C (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  stream.on('end'\x2C () => {\n    this.push(null);\n  });\n\n  stream.on('error'\x2C (err) => {\n    errorOrDestroy(this\x2C err);\n  });\n\n  stream.on('close'\x2C () => {\n    this.destroy();\n  });\n\n  stream.on('destroy'\x2C () => {\n    this.destroy();\n  });\n\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream);\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j];\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream);\n    }\n  }\n\n  return this;\n};\n\nReadable.prototype[SymbolAsyncIterator] = function() {\n  return streamToAsyncIterator(this);\n};\n\nReadable.prototype.iterator = function(options) {\n  if (options !== undefined) {\n    validateObject(options\x2C 'options');\n  }\n  return streamToAsyncIterator(this\x2C options);\n};\n\nfunction streamToAsyncIterator(stream\x2C options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream\x2C { objectMode: true });\n  }\n\n  const iter = createAsyncIterator(stream\x2C options);\n  iter.stream = stream;\n  return iter;\n}\n\nasync function* createAsyncIterator(stream\x2C options) {\n  let callback = nop;\n\n  function next(resolve) {\n    if (this === stream) {\n      callback();\n      callback = nop;\n    } else {\n      callback = resolve;\n    }\n  }\n\n  stream.on('readable'\x2C next);\n\n  let error;\n  eos(stream\x2C { writable: false }\x2C (err) => {\n    error = err ? aggregateTwoErrors(error\x2C err) : null;\n    callback();\n    callback = nop;\n  });\n\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read();\n      if (chunk !== null) {\n        yield chunk;\n      } else if (error) {\n        throw error;\n      } else if (error === null) {\n        return;\n      } else {\n        await new Promise(next);\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error\x2C err);\n    throw error;\n  } finally {\n    if (\n      (error || options?.destroyOnReturn !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream\x2C null);\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype\x2C {\n  readable: {\n    get() {\n      const r = this._readableState;\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted &&\n        !r.endEmitted;\n    }\x2C\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val;\n      }\n    }\n  }\x2C\n\n  readableDidRead: {\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.dataEmitted;\n    }\n  }\x2C\n\n  readableAborted: {\n    enumerable: false\x2C\n    get: function() {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      );\n    }\n  }\x2C\n\n  readableHighWaterMark: {\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.highWaterMark;\n    }\n  }\x2C\n\n  readableBuffer: {\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState && this._readableState.buffer;\n    }\n  }\x2C\n\n  readableFlowing: {\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.flowing;\n    }\x2C\n    set: function(state) {\n      if (this._readableState) {\n        this._readableState.flowing = state;\n      }\n    }\n  }\x2C\n\n  readableLength: {\n    enumerable: false\x2C\n    get() {\n      return this._readableState.length;\n    }\n  }\x2C\n\n  readableObjectMode: {\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.objectMode : false;\n    }\n  }\x2C\n\n  readableEncoding: {\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.encoding : null;\n    }\n  }\x2C\n\n  destroyed: {\n    enumerable: false\x2C\n    get() {\n      if (this._readableState === undefined) {\n        return false;\n      }\n      return this._readableState.destroyed;\n    }\x2C\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return;\n      }\n\n      // Backward compatibility\x2C the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value;\n    }\n  }\x2C\n\n  readableEnded: {\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false;\n    }\n  }\x2C\n\n});\n\nObjectDefineProperties(ReadableState.prototype\x2C {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    get() {\n      return this.pipes.length;\n    }\n  }\x2C\n\n  // Legacy property for `paused`.\n  paused: {\n    get() {\n      return this[kPaused] !== false;\n    }\x2C\n    set(value) {\n      this[kPaused] = !!value;\n    }\n  }\n});\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable\x2C so please take care when making\n// changes to the function body.\nfunction fromList(n\x2C state) {\n  // nothing buffered.\n  if (state.length === 0)\n    return null;\n\n  let ret;\n  if (state.objectMode)\n    ret = state.buffer.shift();\n  else if (!n || n >= state.length) {\n    // Read it all\x2C truncate the list.\n    if (state.decoder)\n      ret = state.buffer.join('');\n    else if (state.buffer.length === 1)\n      ret = state.buffer.first();\n    else\n      ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n\x2C state.decoder);\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  const state = stream._readableState;\n\n  debug('endReadable'\x2C state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT\x2C state\x2C stream);\n  }\n}\n\nfunction endReadableNT(state\x2C stream) {\n  debug('endReadableNT'\x2C state.endEmitted\x2C state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted &&\n      !state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.emit('end');\n\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT\x2C stream);\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState;\n      const autoDestroy = !wState || (\n        wState.autoDestroy &&\n        // We don't expect the writable to ever 'finish'\n        // if writable is explicitly set to false.\n        (wState.finished || wState.writable === false)\n      );\n\n      if (autoDestroy) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded &&\n    !stream.destroyed;\n  if (writable) {\n    stream.end();\n  }\n}\n\nReadable.from = function(iterable\x2C opts) {\n  return from(Readable\x2C iterable\x2C opts);\n};\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nReadable.fromWeb = function(readableStream\x2C options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(\n    readableStream\x2C\n    options);\n};\n\nReadable.toWeb = function(streamReadable) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable);\n};\n\nReadable.wrap = function(src\x2C options) {\n  return new Readable({\n    objectMode: src.readableObjectMode ?? src.objectMode ?? true\x2C\n    ...options\x2C\n    destroy(err\x2C callback) {\n      destroyImpl.destroyer(src\x2C err);\n      callback(err);\n    }\n  }).wrap(src);\n};\n
code-source-info,0x2cbd7649c27e,57,6353,7224,C0O6353C9O6367C16O6378C21O6404C28O6411C33O6433C34O6588C41O6604C44O6611C48O6593C52O6622C71O6644C76O6642C80O6691C84O6729C92O6756C95O6777C99O6767C103O6807C111O6837C114O6861C118O6851C122O6894C130O6926C133O6952C137O6942C141O6980C149O6991C151O7007C158O7030C166O7007C171O7052C178O7059C186O7059C192O7083C199O7095C212O7095C219O7223,,
code-creation,LazyCompile,10,70084,0x2cbd7649f0ce,18,Stream node:internal/streams/legacy:10:16,0x174551ef6738,~
script-source,58,node:internal/streams/legacy,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst EE = require('events');\n\nfunction Stream(opts) {\n  EE.call(this\x2C opts);\n}\nObjectSetPrototypeOf(Stream.prototype\x2C EE.prototype);\nObjectSetPrototypeOf(Stream\x2C EE);\n\nStream.prototype.pipe = function(dest\x2C options) {\n  const source = this;\n\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause();\n    }\n  }\n\n  source.on('data'\x2C ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain'\x2C ondrain);\n\n  // If the 'end' option is not supplied\x2C dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end'\x2C onend);\n    source.on('close'\x2C onclose);\n  }\n\n  let didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this\x2C 'error') === 0) {\n      this.emit('error'\x2C er);\n    }\n  }\n\n  prependListener(source\x2C 'error'\x2C onerror);\n  prependListener(dest\x2C 'error'\x2C onerror);\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data'\x2C ondata);\n    dest.removeListener('drain'\x2C ondrain);\n\n    source.removeListener('end'\x2C onend);\n    source.removeListener('close'\x2C onclose);\n\n    source.removeListener('error'\x2C onerror);\n    dest.removeListener('error'\x2C onerror);\n\n    source.removeListener('end'\x2C cleanup);\n    source.removeListener('close'\x2C cleanup);\n\n    dest.removeListener('close'\x2C cleanup);\n  }\n\n  source.on('end'\x2C cleanup);\n  source.on('close'\x2C cleanup);\n\n  dest.on('close'\x2C cleanup);\n  dest.emit('pipe'\x2C source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\nfunction prependListener(emitter\x2C event\x2C fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function')\n    return emitter.prependListener(event\x2C fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event])\n    emitter.on(event\x2C fn);\n  else if (ArrayIsArray(emitter._events[event]))\n    emitter._events[event].unshift(fn);\n  else\n    emitter._events[event] = [fn\x2C emitter._events[event]];\n}\n\nmodule.exports = { Stream\x2C prependListener };\n
code-source-info,0x2cbd7649f0ce,58,127,160,C0O138C5O141C10O141C17O159,,
tick,0x10152dccc,70209,0,0x0,3,0x0,0x2cbd76494c87,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,LazyCompile,10,70250,0x2cbd7649f926,354,ReadableState node:internal/streams/readable:83:23,0x174551ef3d98,~
code-source-info,0x2cbd7649f926,57,2626,6333,C0O2964C6O3003C8O3032C11O3039C15O3021C20O3172C25O3193C27O3212C33O3188C37O3228C41O3269C52O3292C54O3311C60O3262C64O3477C69O3498C73O3512C88O3512C97O3585C102O3585C106O3496C110O3788C112O3806C115O3802C120O3800C124O3822C125O3834C129O3841C131O3852C135O3860C136O3873C140O3883C141O3894C145O3905C146O3921C150O3932C151O3945C155O4139C156O4156C160O4436C161O4446C165O4567C166O4585C170O4596C171O4617C175O4628C176O4651C180O4662C181O4683C185O4694C187O4699C191O4708C195O4794C196O4812C200O4883C202O4901C208O4920C214O4930C218O4898C222O5017C224O5037C230O5056C236O5068C240O5034C244O5110C245O5125C249O5378C250O5391C254O5461C255O5473C259O5577C260O5595C264O5802C269O5826C271O5845C279O5823C283O5978C284O6001C288O6011C289O6032C293O6094C294O6111C298O6123C299O6140C303O6152C304O6165C308O6175C309O6189C313O6199C317O6222C323O6238C325O6257C328O6279C335O6253C340O6251C344O6318C348O6308C353O6332,,
code-creation,LazyCompile,10,70334,0x2cbd7649fd36,98,getHighWaterMark node:internal/streams/state:19:26,0x174551ef9150,~
script-source,61,node:internal/streams/state,'use strict';\n\nconst {\n  MathFloor\x2C\n  NumberIsInteger\x2C\n} = primordials;\n\nconst { ERR_INVALID_ARG_VALUE } = require('internal/errors').codes;\n\nfunction highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark :\n    isDuplex ? options[duplexKey] : null;\n}\n\nfunction getDefaultHighWaterMark(objectMode) {\n  return objectMode ? 16 : 16 * 1024;\n}\n\nfunction getHighWaterMark(state\x2C options\x2C duplexKey\x2C isDuplex) {\n  const hwm = highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey);\n  if (hwm != null) {\n    if (!NumberIsInteger(hwm) || hwm < 0) {\n      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark';\n      throw new ERR_INVALID_ARG_VALUE(name\x2C hwm);\n    }\n    return MathFloor(hwm);\n  }\n\n  // Default value\n  return getDefaultHighWaterMark(state.objectMode);\n}\n\nmodule.exports = {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\n};\n
code-source-info,0x2cbd7649fd36,61,424,832,C0O478C12O478C18O529C21O552C26O557C33O585C38O611C47O633C56O678C69O684C74O678C75O732C80O739C84O754C85O781C88O818C93O788C97O830,,
code-creation,LazyCompile,10,70375,0x2cbd7649ffce,26,highWaterMarkFrom node:internal/streams/state:10:27,0x174551ef8ff0,~
code-source-info,0x2cbd7649ffce,61,168,309,C0O218C7O250C15O270C19O288C25O307,,
code-creation,LazyCompile,10,70375,0x2cbd764a00a6,13,getDefaultHighWaterMark node:internal/streams/state:15:33,0x174551ef9100,~
code-source-info,0x2cbd764a00a6,61,343,397,C0O360C12O395,,
code-creation,LazyCompile,10,70417,0x2cbd764a0186,17,BufferList node:internal/streams/buffer_list:14:14,0x174551ef84d0,~
script-source,60,node:internal/streams/buffer_list,'use strict';\n\nconst {\n  StringPrototypeSlice\x2C\n  SymbolIterator\x2C\n  TypedArrayPrototypeSet\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst { inspect } = require('internal/util/inspect');\n\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  push(v) {\n    const entry = { data: v\x2C next: null };\n    if (this.length > 0)\n      this.tail.next = entry;\n    else\n      this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  }\n\n  unshift(v) {\n    const entry = { data: v\x2C next: this.head };\n    if (this.length === 0)\n      this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  }\n\n  shift() {\n    if (this.length === 0)\n      return;\n    const ret = this.head.data;\n    if (this.length === 1)\n      this.head = this.tail = null;\n    else\n      this.head = this.head.next;\n    --this.length;\n    return ret;\n  }\n\n  clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  }\n\n  join(s) {\n    if (this.length === 0)\n      return '';\n    let p = this.head;\n    let ret = '' + p.data;\n    while ((p = p.next) !== null)\n      ret += s + p.data;\n    return ret;\n  }\n\n  concat(n) {\n    if (this.length === 0)\n      return Buffer.alloc(0);\n    const ret = Buffer.allocUnsafe(n >>> 0);\n    let p = this.head;\n    let i = 0;\n    while (p) {\n      TypedArrayPrototypeSet(ret\x2C p.data\x2C i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n\x2C hasStrings) {\n    const data = this.head.data;\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0\x2C n);\n      this.head.data = data.slice(n);\n      return slice;\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift();\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n);\n  }\n\n  first() {\n    return this.head.data;\n  }\n\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data;\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = '';\n    let p = this.head;\n    let c = 0;\n    do {\n      const str = p.data;\n      if (n > str.length) {\n        ret += str;\n        n -= str.length;\n      } else {\n        if (n === str.length) {\n          ret += str;\n          ++c;\n          if (p.next)\n            this.head = p.next;\n          else\n            this.head = this.tail = null;\n        } else {\n          ret += StringPrototypeSlice(str\x2C 0\x2C n);\n          this.head = p;\n          p.data = StringPrototypeSlice(str\x2C n);\n        }\n        break;\n      }\n      ++c;\n    } while ((p = p.next) !== null);\n    this.length -= c;\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n);\n    const retLen = n;\n    let p = this.head;\n    let c = 0;\n    do {\n      const buf = p.data;\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret\x2C buf\x2C retLen - n);\n        n -= buf.length;\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret\x2C buf\x2C retLen - n);\n          ++c;\n          if (p.next)\n            this.head = p.next;\n          else\n            this.head = this.tail = null;\n        } else {\n          TypedArrayPrototypeSet(ret\x2C\n                                 new Uint8Array(buf.buffer\x2C buf.byteOffset\x2C n)\x2C\n                                 retLen - n);\n          this.head = p;\n          p.data = buf.slice(n);\n        }\n        break;\n      }\n      ++c;\n    } while ((p = p.next) !== null);\n    this.length -= c;\n    return ret;\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [inspect.custom](_\x2C options) {\n    return inspect(this\x2C {\n      ...options\x2C\n      // Only inspect one level.\n      depth: 0\x2C\n      // It should not recurse.\n      customInspect: false\n    });\n  }\n};\n
code-source-info,0x2cbd764a0186,60,265,338,C0O274C1O284C5O296C6O306C10O318C11O330C16O337,,
code-creation,LazyCompile,10,70584,0x2cbd764a08b6,98,construct node:internal/streams/destroy:232:19,0x174551ee7520,~
script-source,55,node:internal/streams/destroy,'use strict';\n\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_MULTIPLE_CALLBACK\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\nconst {\n  Symbol\x2C\n} = primordials;\nconst {\n  kDestroyed\x2C\n  isDestroyed\x2C\n  isFinished\x2C\n  isServerRequest\n} = require('internal/streams/utils');\n\nconst kDestroy = Symbol('kDestroy');\nconst kConstruct = Symbol('kConstruct');\n\nfunction checkError(err\x2C w\x2C r) {\n  if (err) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack; // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n  }\n}\n\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction destroy(err\x2C cb) {\n  const r = this._readableState;\n  const w = this._writableState;\n  // With duplex streams we use the writable side for state.\n  const s = w || r;\n\n  if ((w && w.destroyed) || (r && r.destroyed)) {\n    if (typeof cb === 'function') {\n      cb();\n    }\n\n    return this;\n  }\n\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n  checkError(err\x2C w\x2C r);\n\n  if (w) {\n    w.destroyed = true;\n  }\n  if (r) {\n    r.destroyed = true;\n  }\n\n  // If still constructing then defer calling _destroy.\n  if (!s.constructed) {\n    this.once(kDestroy\x2C function(er) {\n      _destroy(this\x2C aggregateTwoErrors(er\x2C err)\x2C cb);\n    });\n  } else {\n    _destroy(this\x2C err\x2C cb);\n  }\n\n  return this;\n}\n\nfunction _destroy(self\x2C err\x2C cb) {\n  let called = false;\n\n  function onDestroy(err) {\n    if (called) {\n      return;\n    }\n    called = true;\n\n    const r = self._readableState;\n    const w = self._writableState;\n\n    checkError(err\x2C w\x2C r);\n\n    if (w) {\n      w.closed = true;\n    }\n    if (r) {\n      r.closed = true;\n    }\n\n    if (typeof cb === 'function') {\n      cb(err);\n    }\n\n    if (err) {\n      process.nextTick(emitErrorCloseNT\x2C self\x2C err);\n    } else {\n      process.nextTick(emitCloseNT\x2C self);\n    }\n  }\n  try {\n    const result = self._destroy(err || null\x2C onDestroy);\n    if (result != null) {\n      const then = result.then;\n      if (typeof then === 'function') {\n        then.call(\n          result\x2C\n          function() {\n            process.nextTick(onDestroy\x2C null);\n          }\x2C\n          function(err) {\n            process.nextTick(onDestroy\x2C err);\n          });\n      }\n    }\n  } catch (err) {\n    onDestroy(err);\n  }\n}\n\nfunction emitErrorCloseNT(self\x2C err) {\n  emitErrorNT(self\x2C err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  const r = self._readableState;\n  const w = self._writableState;\n\n  if (w) {\n    w.closeEmitted = true;\n  }\n  if (r) {\n    r.closeEmitted = true;\n  }\n\n  if ((w && w.emitClose) || (r && r.emitClose)) {\n    self.emit('close');\n  }\n}\n\nfunction emitErrorNT(self\x2C err) {\n  const r = self._readableState;\n  const w = self._writableState;\n\n  if ((w && w.errorEmitted) || (r && r.errorEmitted)) {\n    return;\n  }\n\n  if (w) {\n    w.errorEmitted = true;\n  }\n  if (r) {\n    r.errorEmitted = true;\n  }\n\n  self.emit('error'\x2C err);\n}\n\nfunction undestroy() {\n  const r = this._readableState;\n  const w = this._writableState;\n\n  if (r) {\n    r.constructed = true;\n    r.closed = false;\n    r.closeEmitted = false;\n    r.destroyed = false;\n    r.errored = null;\n    r.errorEmitted = false;\n    r.reading = false;\n    r.ended = r.readable === false;\n    r.endEmitted = r.readable === false;\n  }\n\n  if (w) {\n    w.constructed = true;\n    w.destroyed = false;\n    w.closed = false;\n    w.closeEmitted = false;\n    w.errored = null;\n    w.errorEmitted = false;\n    w.finalCalled = false;\n    w.prefinished = false;\n    w.ended = w.writable === false;\n    w.ending = w.writable === false;\n    w.finished = w.writable === false;\n  }\n}\n\nfunction errorOrDestroy(stream\x2C err\x2C sync) {\n  // We have tests that rely on errors being emitted\n  // in the same tick\x2C so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const r = stream._readableState;\n  const w = stream._writableState;\n\n  if ((w && w.destroyed) || (r && r.destroyed)) {\n    return this;\n  }\n\n  if ((r && r.autoDestroy) || (w && w.autoDestroy))\n    stream.destroy(err);\n  else if (err) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack; // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n    if (sync) {\n      process.nextTick(emitErrorNT\x2C stream\x2C err);\n    } else {\n      emitErrorNT(stream\x2C err);\n    }\n  }\n}\n\nfunction construct(stream\x2C cb) {\n  if (typeof stream._construct !== 'function') {\n    return;\n  }\n\n  const r = stream._readableState;\n  const w = stream._writableState;\n\n  if (r) {\n    r.constructed = false;\n  }\n  if (w) {\n    w.constructed = false;\n  }\n\n  stream.once(kConstruct\x2C cb);\n\n  if (stream.listenerCount(kConstruct) > 1) {\n    // Duplex\n    return;\n  }\n\n  process.nextTick(constructNT\x2C stream);\n}\n\nfunction constructNT(stream) {\n  let called = false;\n\n  function onConstruct(err) {\n    if (called) {\n      errorOrDestroy(stream\x2C err ?? new ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n\n    const r = stream._readableState;\n    const w = stream._writableState;\n    const s = w || r;\n\n    if (r) {\n      r.constructed = true;\n    }\n    if (w) {\n      w.constructed = true;\n    }\n\n    if (s.destroyed) {\n      stream.emit(kDestroy\x2C err);\n    } else if (err) {\n      errorOrDestroy(stream\x2C err\x2C true);\n    } else {\n      process.nextTick(emitConstructNT\x2C stream);\n    }\n  }\n\n  try {\n    const result = stream._construct(onConstruct);\n    if (result != null) {\n      const then = result.then;\n      if (typeof then === 'function') {\n        then.call(\n          result\x2C\n          function() {\n            if (!called) {\n              process.nextTick(onConstruct\x2C null);\n            }\n          }\x2C\n          function(err) {\n            if (!called) {\n              process.nextTick(onConstruct\x2C err);\n            }\n          });\n      }\n    }\n  } catch (err) {\n    onConstruct(err);\n  }\n}\n\nfunction emitConstructNT(stream) {\n  stream.emit(kConstruct);\n}\n\nfunction isRequest(stream) {\n  return stream && stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction emitCloseLegacy(stream) {\n  stream.emit('close');\n}\n\nfunction emitErrorCloseLegacy(stream\x2C err) {\n  stream.emit('error'\x2C err);\n  process.nextTick(emitCloseLegacy\x2C stream);\n}\n\n// Normalize destroy for legacy.\nfunction destroyer(stream\x2C err) {\n  if (!stream || isDestroyed(stream)) {\n    return;\n  }\n\n  if (!err && !isFinished(stream)) {\n    err = new AbortError();\n  }\n\n  // TODO: Remove isRequest branches.\n  if (isServerRequest(stream)) {\n    stream.socket = null;\n    stream.destroy(err);\n  } else if (isRequest(stream)) {\n    stream.abort();\n  } else if (isRequest(stream.req)) {\n    stream.req.abort();\n  } else if (typeof stream.destroy === 'function') {\n    stream.destroy(err);\n  } else if (typeof stream.close === 'function') {\n    // TODO: Don't lose err?\n    stream.close();\n  } else if (err) {\n    process.nextTick(emitErrorCloseLegacy\x2C stream);\n  } else {\n    process.nextTick(emitCloseLegacy\x2C stream);\n  }\n\n  if (!stream.destroyed) {\n    stream[kDestroyed] = true;\n  }\n}\n\nmodule.exports = {\n  construct\x2C\n  destroyer\x2C\n  destroy\x2C\n  undestroy\x2C\n  errorOrDestroy\n};\n
code-source-info,0x2cbd764a08b6,55,4823,5211,C0O4858C8O4891C9O4898C10O4923C15O4958C20O4977C24O4990C25O5004C29O5019C33O5032C34O5046C38O5069C45O5074C48O5069C54O5105C61O5119C64O5105C72O5131C77O5156C78O5163C79O5171C82O5179C90O5179C97O5210,,
tick,0x1007bc9f8,70917,0,0x0,3,0x0,0x2cbd7649c352,0x2cbd7649bae2,0x2cbd7649b4a6,0x2cbd76494c87,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,LazyCompile,10,70959,0x2cbd764a16ce,266,Writable node:internal/streams/writable:219:18,0xd2efcc07e90,~
script-source,64,node:internal/streams/writable,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk\x2C encoding\x2C cb)\x2C and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  FunctionPrototypeSymbolHasInstance\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n  SymbolHasInstance\x2C\n} = primordials;\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nconst EE = require('events');\nconst Stream = require('internal/streams/legacy').Stream;\nconst { Buffer } = require('buffer');\nconst destroyImpl = require('internal/streams/destroy');\n\nconst {\n  addAbortSignal\x2C\n} = require('internal/streams/add-abort-signal');\n\nconst {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\n} = require('internal/streams/state');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_METHOD_NOT_IMPLEMENTED\x2C\n  ERR_MULTIPLE_CALLBACK\x2C\n  ERR_STREAM_CANNOT_PIPE\x2C\n  ERR_STREAM_DESTROYED\x2C\n  ERR_STREAM_ALREADY_FINISHED\x2C\n  ERR_STREAM_NULL_VALUES\x2C\n  ERR_STREAM_WRITE_AFTER_END\x2C\n  ERR_UNKNOWN_ENCODING\n} = require('internal/errors').codes;\n\nconst { errorOrDestroy } = destroyImpl;\n\nObjectSetPrototypeOf(Writable.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(Writable\x2C Stream);\n\nfunction nop() {}\n\nconst kOnFinished = Symbol('kOnFinished');\n\nfunction WritableState(options\x2C stream\x2C isDuplex) {\n  // Duplex streams are both readable and writable\x2C but share\n  // the same options object.\n  // However\x2C some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream\x2C\n  // e.g. options.readableObjectMode vs. options.writableObjectMode\x2C etc.\n  if (typeof isDuplex !== 'boolean')\n    isDuplex = stream instanceof Stream.Duplex;\n\n  // Object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!(options && options.objectMode);\n\n  if (isDuplex)\n    this.objectMode = this.objectMode ||\n      !!(options && options.writableObjectMode);\n\n  // The point at which write() starts returning false\n  // Note: 0 is a valid value\x2C means that we always return false if\n  // the entire buffer is not flushed immediately on write().\n  this.highWaterMark = options ?\n    getHighWaterMark(this\x2C options\x2C 'writableHighWaterMark'\x2C isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  // if _final has been called.\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // At the start of calling end()\n  this.ending = false;\n  // When end() has been called\x2C and returned.\n  this.ended = false;\n  // When 'finish' is emitted.\n  this.finished = false;\n\n  // Has it been destroyed\n  this.destroyed = false;\n\n  // Should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  const noDecode = !!(options && options.decodeStrings === false);\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8'\x2C though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';\n\n  // Not an actual buffer we keep track of\x2C but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // A flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // When true all writes will be buffered until .uncork() call.\n  this.corked = 0;\n\n  // A flag to be able to tell if the onwrite cb is called immediately\x2C\n  // or on a later tick.  We set this to true at first\x2C because any\n  // actions that shouldn't happen until "later" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // A flag to know if we're processing previously buffered items\x2C which\n  // may call the _write() callback in the same tick\x2C so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // The callback that's passed to _write(chunk\x2C cb).\n  this.onwrite = onwrite.bind(undefined\x2C stream);\n\n  // The callback that the user supplies to write(chunk\x2C encoding\x2C cb).\n  this.writecb = null;\n\n  // The amount that is being written when _write is called.\n  this.writelen = 0;\n\n  // Storage for data passed to the afterWrite() callback in case of\n  // synchronous _write() completion.\n  this.afterWriteTickInfo = null;\n\n  resetBuffer(this);\n\n  // Number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted.\n  this.pendingcb = 0;\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in\x2C therefore we start as\n  // constructed.\n  this.constructed = true;\n\n  // Emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams.\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end').\n  this.autoDestroy = !options || options.autoDestroy !== false;\n\n  // Indicates whether the stream has errored. When true all write() calls\n  // should return false. This is needed since when autoDestroy\n  // is disabled we need a way to tell whether the stream has failed.\n  this.errored = null;\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false;\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false;\n\n  this[kOnFinished] = [];\n}\n\nfunction resetBuffer(state) {\n  state.buffered = [];\n  state.bufferedIndex = 0;\n  state.allBuffers = true;\n  state.allNoop = true;\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  return ArrayPrototypeSlice(this.buffered\x2C this.bufferedIndex);\n};\n\nObjectDefineProperty(WritableState.prototype\x2C 'bufferedRequestCount'\x2C {\n  get() {\n    return this.buffered.length - this.bufferedIndex;\n  }\n});\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes\x2C too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false\x2C as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation\x2C which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor\x2C at least with V8 6.5.\n  const isDuplex = (this instanceof Stream.Duplex);\n\n  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable\x2C this))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options\x2C this\x2C isDuplex);\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.final === 'function')\n      this._final = options.final;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal)\n      addAbortSignal(options.signal\x2C this);\n  }\n\n  Stream.call(this\x2C options);\n\n  destroyImpl.construct(this\x2C () => {\n    const state = this._writableState;\n\n    if (!state.writing) {\n      clearBuffer(this\x2C state);\n    }\n\n    finishMaybe(this\x2C state);\n  });\n}\n\nObjectDefineProperty(Writable\x2C SymbolHasInstance\x2C {\n  value: function(object) {\n    if (FunctionPrototypeSymbolHasInstance(this\x2C object)) return true;\n    if (this !== Writable) return false;\n\n    return object && object._writableState instanceof WritableState;\n  }\x2C\n});\n\n// Otherwise people can pipe Writable streams\x2C which is just wrong.\nWritable.prototype.pipe = function() {\n  errorOrDestroy(this\x2C new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction _write(stream\x2C chunk\x2C encoding\x2C cb) {\n  const state = stream._writableState;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = state.defaultEncoding;\n  } else {\n    if (!encoding)\n      encoding = state.defaultEncoding;\n    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding))\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (typeof cb !== 'function')\n      cb = nop;\n  }\n\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES();\n  } else if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      if (state.decodeStrings !== false) {\n        chunk = Buffer.from(chunk\x2C encoding);\n        encoding = 'buffer';\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = 'buffer';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = 'buffer';\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n    }\n  }\n\n  let err;\n  if (state.ending) {\n    err = new ERR_STREAM_WRITE_AFTER_END();\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('write');\n  }\n\n  if (err) {\n    process.nextTick(cb\x2C err);\n    errorOrDestroy(stream\x2C err\x2C true);\n    return err;\n  }\n  state.pendingcb++;\n  return writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C cb);\n}\n\nWritable.prototype.write = function(chunk\x2C encoding\x2C cb) {\n  return _write(this\x2C chunk\x2C encoding\x2C cb) === true;\n};\n\nWritable.prototype.cork = function() {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  const state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing)\n      clearBuffer(this\x2C state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = StringPrototypeToLowerCase(encoding);\n  if (!Buffer.isEncoding(encoding))\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\n// If we're already writing something\x2C then just put this\n// in the queue\x2C and wait our turn.  Otherwise\x2C call _write\n// If we return false\x2C then we need a drain event\x2C so set that flag.\nfunction writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C callback) {\n  const len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  // stream._write resets state.length\n  const ret = state.length < state.highWaterMark;\n  // We must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked || state.errored || !state.constructed) {\n    state.buffered.push({ chunk\x2C encoding\x2C callback });\n    if (state.allBuffers && encoding !== 'buffer') {\n      state.allBuffers = false;\n    }\n    if (state.allNoop && callback !== nop) {\n      state.allNoop = false;\n    }\n  } else {\n    state.writelen = len;\n    state.writecb = callback;\n    state.writing = true;\n    state.sync = true;\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\n    state.sync = false;\n  }\n\n  // Return false if errored or destroyed in order to break\n  // any synchronous while(stream.write(data)) loops.\n  return ret && !state.errored && !state.destroyed;\n}\n\nfunction doWrite(stream\x2C state\x2C writev\x2C len\x2C chunk\x2C encoding\x2C cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed)\n    state.onwrite(new ERR_STREAM_DESTROYED('write'));\n  else if (writev)\n    stream._writev(chunk\x2C state.onwrite);\n  else\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream\x2C state\x2C er\x2C cb) {\n  --state.pendingcb;\n\n  cb(er);\n  // Ensure callbacks are invoked even when autoDestroy is\n  // not enabled. Passing `er` here doesn't make sense since\n  // it's related to one specific write\x2C not to the buffered\n  // writes.\n  errorBuffer(state);\n  // This can emit error\x2C but error must always follow cb.\n  errorOrDestroy(stream\x2C er);\n}\n\nfunction onwrite(stream\x2C er) {\n  const state = stream._writableState;\n  const sync = state.sync;\n  const cb = state.writecb;\n\n  if (typeof cb !== 'function') {\n    errorOrDestroy(stream\x2C new ERR_MULTIPLE_CALLBACK());\n    return;\n  }\n\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n\n  if (er) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    er.stack; // eslint-disable-line no-unused-expressions\n\n    if (!state.errored) {\n      state.errored = er;\n    }\n\n    // In case of duplex streams we need to notify the readable side of the\n    // error.\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er;\n    }\n\n    if (sync) {\n      process.nextTick(onwriteError\x2C stream\x2C state\x2C er\x2C cb);\n    } else {\n      onwriteError(stream\x2C state\x2C er\x2C cb);\n    }\n  } else {\n    if (state.buffered.length > state.bufferedIndex) {\n      clearBuffer(stream\x2C state);\n    }\n\n    if (sync) {\n      // It is a common case that the callback passed to .write() is always\n      // the same. In that case\x2C we do not schedule a new nextTick()\x2C but\n      // rather just increase a counter\x2C to improve performance and avoid\n      // memory allocations.\n      if (state.afterWriteTickInfo !== null &&\n          state.afterWriteTickInfo.cb === cb) {\n        state.afterWriteTickInfo.count++;\n      } else {\n        state.afterWriteTickInfo = { count: 1\x2C cb\x2C stream\x2C state };\n        process.nextTick(afterWriteTick\x2C state.afterWriteTickInfo);\n      }\n    } else {\n      afterWrite(stream\x2C state\x2C 1\x2C cb);\n    }\n  }\n}\n\nfunction afterWriteTick({ stream\x2C state\x2C count\x2C cb }) {\n  state.afterWriteTickInfo = null;\n  return afterWrite(stream\x2C state\x2C count\x2C cb);\n}\n\nfunction afterWrite(stream\x2C state\x2C count\x2C cb) {\n  const needDrain = !state.ending && !stream.destroyed && state.length === 0 &&\n    state.needDrain;\n  if (needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n\n  while (count-- > 0) {\n    state.pendingcb--;\n    cb();\n  }\n\n  if (state.destroyed) {\n    errorBuffer(state);\n  }\n\n  finishMaybe(stream\x2C state);\n}\n\n// If there's something in the buffer waiting\x2C then invoke callbacks.\nfunction errorBuffer(state) {\n  if (state.writing) {\n    return;\n  }\n\n  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n    const { chunk\x2C callback } = state.buffered[n];\n    const len = state.objectMode ? 1 : chunk.length;\n    state.length -= len;\n    callback(state.errored ?? new ERR_STREAM_DESTROYED('write'));\n  }\n\n  const onfinishCallbacks = state[kOnFinished].splice(0);\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i](state.errored ?? new ERR_STREAM_DESTROYED('end'));\n  }\n\n  resetBuffer(state);\n}\n\n// If there's something in the buffer waiting\x2C then process it.\nfunction clearBuffer(stream\x2C state) {\n  if (state.corked ||\n      state.bufferProcessing ||\n      state.destroyed ||\n      !state.constructed) {\n    return;\n  }\n\n  const { buffered\x2C bufferedIndex\x2C objectMode } = state;\n  const bufferedLength = buffered.length - bufferedIndex;\n\n  if (!bufferedLength) {\n    return;\n  }\n\n  let i = bufferedIndex;\n\n  state.bufferProcessing = true;\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1;\n\n    const callback = state.allNoop ? nop : (err) => {\n      for (let n = i; n < buffered.length; ++n) {\n        buffered[n].callback(err);\n      }\n    };\n    // Make a copy of `buffered` if it's going to be used by `callback` above\x2C\n    // since `doWrite` will mutate the array.\n    const chunks = state.allNoop && i === 0 ?\n      buffered : ArrayPrototypeSlice(buffered\x2C i);\n    chunks.allBuffers = state.allBuffers;\n\n    doWrite(stream\x2C state\x2C true\x2C state.length\x2C chunks\x2C ''\x2C callback);\n\n    resetBuffer(state);\n  } else {\n    do {\n      const { chunk\x2C encoding\x2C callback } = buffered[i];\n      buffered[i++] = null;\n      const len = objectMode ? 1 : chunk.length;\n      doWrite(stream\x2C state\x2C false\x2C len\x2C chunk\x2C encoding\x2C callback);\n    } while (i < buffered.length && !state.writing);\n\n    if (i === buffered.length) {\n      resetBuffer(state);\n    } else if (i > 256) {\n      buffered.splice(0\x2C i);\n      state.bufferedIndex = 0;\n    } else {\n      state.bufferedIndex = i;\n    }\n  }\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk\x2C encoding\x2C cb) {\n  if (this._writev) {\n    this._writev([{ chunk\x2C encoding }]\x2C cb);\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()');\n  }\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk\x2C encoding\x2C cb) {\n  const state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  let err;\n\n  if (chunk !== null && chunk !== undefined) {\n    const ret = _write(this\x2C chunk\x2C encoding);\n    if (ret instanceof Error) {\n      err = ret;\n    }\n  }\n\n  // .end() fully uncorks.\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  if (err) {\n    // Do nothing...\n  } else if (!state.errored && !state.ending) {\n    // This is forgiving in terms of unnecessary calls to end() and can hide\n    // logic errors. However\x2C usually such errors are harmless and causing a\n    // hard error can be disproportionately destructive. It is not always\n    // trivial for the user to determine whether end() needs to be called\n    // or not.\n\n    state.ending = true;\n    finishMaybe(this\x2C state\x2C true);\n    state.ended = true;\n  } else if (state.finished) {\n    err = new ERR_STREAM_ALREADY_FINISHED('end');\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('end');\n  }\n\n  if (typeof cb === 'function') {\n    if (err || state.finished) {\n      process.nextTick(cb\x2C err);\n    } else {\n      state[kOnFinished].push(cb);\n    }\n  }\n\n  return this;\n};\n\nfunction needFinish(state) {\n  return (state.ending &&\n          state.constructed &&\n          state.length === 0 &&\n          !state.errored &&\n          state.buffered.length === 0 &&\n          !state.finished &&\n          !state.writing &&\n          !state.errorEmitted &&\n          !state.closeEmitted);\n}\n\nfunction callFinal(stream\x2C state) {\n  let called = false;\n\n  function onFinish(err) {\n    if (called) {\n      errorOrDestroy(stream\x2C err ?? ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n\n    state.pendingcb--;\n    if (err) {\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i](err);\n      }\n      errorOrDestroy(stream\x2C err\x2C state.sync);\n    } else if (needFinish(state)) {\n      state.prefinished = true;\n      stream.emit('prefinish');\n      // Backwards compat. Don't check state.sync here.\n      // Some streams assume 'finish' will be emitted\n      // asynchronously relative to _final callback.\n      state.pendingcb++;\n      process.nextTick(finish\x2C stream\x2C state);\n    }\n  }\n\n  state.sync = true;\n  state.pendingcb++;\n\n  try {\n    const result = stream._final(onFinish);\n    if (result != null) {\n      const then = result.then;\n      if (typeof then === 'function') {\n        then.call(\n          result\x2C\n          function() {\n            if (!called) {\n              process.nextTick(onFinish\x2C null);\n            }\n          }\x2C\n          function(err) {\n            if (!called) {\n              process.nextTick(onFinish\x2C err);\n            }\n          });\n      }\n    }\n  } catch (err) {\n    onFinish(err);\n  }\n\n  state.sync = false;\n}\n\nfunction prefinish(stream\x2C state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.finalCalled = true;\n      callFinal(stream\x2C state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream\x2C state\x2C sync) {\n  if (needFinish(state)) {\n    prefinish(stream\x2C state);\n    if (state.pendingcb === 0 && needFinish(state)) {\n      state.pendingcb++;\n      if (sync) {\n        process.nextTick(finish\x2C stream\x2C state);\n      } else {\n        finish(stream\x2C state);\n      }\n    }\n  }\n}\n\nfunction finish(stream\x2C state) {\n  state.pendingcb--;\n  state.finished = true;\n\n  const onfinishCallbacks = state[kOnFinished].splice(0);\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i]();\n  }\n\n  stream.emit('finish');\n\n  if (state.autoDestroy) {\n    // In case of duplex streams we need a way to detect\n    // if the readable side is ready for autoDestroy as well.\n    const rState = stream._readableState;\n    const autoDestroy = !rState || (\n      rState.autoDestroy &&\n      // We don't expect the readable to ever 'end'\n      // if readable is explicitly set to false.\n      (rState.endEmitted || rState.readable === false)\n    );\n    if (autoDestroy) {\n      stream.destroy();\n    }\n  }\n}\n\nObjectDefineProperties(Writable.prototype\x2C {\n\n  destroyed: {\n    get() {\n      return this._writableState ? this._writableState.destroyed : false;\n    }\x2C\n    set(value) {\n      // Backward compatibility\x2C the user is explicitly managing destroyed.\n      if (this._writableState) {\n        this._writableState.destroyed = value;\n      }\n    }\n  }\x2C\n\n  writable: {\n    get() {\n      const w = this._writableState;\n      // w.writable === false means that this is part of a Duplex stream\n      // where the writable side was disabled upon construction.\n      // Compat. The user might manually disable writable side through\n      // deprecated setter.\n      return !!w && w.writable !== false && !w.destroyed && !w.errored &&\n        !w.ending && !w.ended;\n    }\x2C\n    set(val) {\n      // Backwards compatible.\n      if (this._writableState) {\n        this._writableState.writable = !!val;\n      }\n    }\n  }\x2C\n\n  writableFinished: {\n    get() {\n      return this._writableState ? this._writableState.finished : false;\n    }\n  }\x2C\n\n  writableObjectMode: {\n    get() {\n      return this._writableState ? this._writableState.objectMode : false;\n    }\n  }\x2C\n\n  writableBuffer: {\n    get() {\n      return this._writableState && this._writableState.getBuffer();\n    }\n  }\x2C\n\n  writableEnded: {\n    get() {\n      return this._writableState ? this._writableState.ending : false;\n    }\n  }\x2C\n\n  writableNeedDrain: {\n    get() {\n      const wState = this._writableState;\n      if (!wState) return false;\n      return !wState.destroyed && !wState.ending && wState.needDrain;\n    }\n  }\x2C\n\n  writableHighWaterMark: {\n    get() {\n      return this._writableState && this._writableState.highWaterMark;\n    }\n  }\x2C\n\n  writableCorked: {\n    get() {\n      return this._writableState ? this._writableState.corked : 0;\n    }\n  }\x2C\n\n  writableLength: {\n    get() {\n      return this._writableState && this._writableState.length;\n    }\n  }\n});\n\nconst destroy = destroyImpl.destroy;\nWritable.prototype.destroy = function(err\x2C cb) {\n  const state = this._writableState;\n\n  // Invoke pending callbacks.\n  if (!state.destroyed &&\n    (state.bufferedIndex < state.buffered.length ||\n      state[kOnFinished].length)) {\n    process.nextTick(errorBuffer\x2C state);\n  }\n\n  destroy.call(this\x2C err\x2C cb);\n  return this;\n};\n\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err\x2C cb) {\n  cb(err);\n};\n\nWritable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nWritable.fromWeb = function(writableStream\x2C options) {\n  return lazyWebStreams().newStreamWritableFromWritableStream(\n    writableStream\x2C\n    options);\n};\n\nWritable.toWeb = function(streamWritable) {\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n};\n
code-source-info,0x2cbd764a16ce,64,7399,8910,C0O7399C9O7973C16O7990C19O7997C23O7979C27O8009C33O8027C44O8027C51O8083C58O8090C63O8112C64O8116C83O8138C88O8136C92O8185C96O8223C104O8251C107O8273C111O8263C115O8304C123O8333C126O8356C130O8346C134O8388C142O8418C145O8442C149O8432C153O8475C161O8503C164O8525C168O8515C172O8556C180O8588C183O8614C187O8604C191O8642C197O8656C204O8679C212O8656C217O8701C224O8708C232O8708C238O8732C245O8744C258O8744C265O8909,,
code-creation,LazyCompile,10,71875,0x2cbd764a37c6,341,WritableState node:internal/streams/writable:77:23,0xd2efcc07d30,~
code-source-info,0x2cbd764a37c6,64,2472,6973,C0O2806C6O2845C8O2874C11O2881C15O2863C20O2989C25O3010C27O3029C33O3005C37O3045C41O3086C52O3109C54O3128C60O3079C64O3337C69O3358C73O3372C88O3372C97O3445C102O3445C106O3356C110O3512C111O3529C115O3564C116O3579C120O3625C121O3637C125O3695C126O3706C130O3748C131O3762C135O3801C136O3816C140O4015C144O4037C150O4051C156O4065C158O4087C159O4084C163O4295C168O4319C170O4338C178O4316C182O4516C183O4528C187O4592C188O4605C192O4682C193O4694C197O4958C198O4968C202O5171C203O5193C207O5259C210O5282C217O5282C223O5272C227O5382C228O5395C232O5467C233O5481C237O5596C238O5620C242O5631C245O5631C249O5758C250O5773C254O5963C255O5980C259O6118C260O6135C264O6222C265O6240C269O6311C271O6329C277O6348C283O6358C287O6326C291O6445C293O6465C299O6484C305O6496C309O6462C313O6719C314O6732C318O6802C319O6814C323O6918C324O6936C328O6948C330O6953C335O6966C340O6972,,
code-creation,LazyCompile,10,71959,0x2cbd764a3bd6,23,resetBuffer node:internal/streams/writable:202:21,0xd2efcc07d80,~
code-source-info,0x2cbd764a3bd6,64,6995,7107,C0O7007C2O7022C6O7030C7O7050C11O7057C12O7074C16O7084C17O7098C22O7106,,
code-creation,LazyCompile,10,71959,0x2cbd764a3d36,131,createHandle node:net:137:22,0x120d44381dc0,~
code-source-info,0x2cbd764a3d36,113,3609,3969,C0O3629C13O3629C18O3672C23O3672C28O3695C30O3704C35O3722C42O3745C46O3757C49O3771C57O3780C60O3794C67O3729C72O3807C73O3815C75O3824C80O3841C87O3863C91O3875C94O3888C102O3897C105O3910C112O3848C117O3923C118O3931C125O3937C130O3931,,
code-creation,LazyCompile,10,72042,0x2cbd764a3ed6,14,set node:net:1754:6,0x120d44383e00,~
code-source-info,0x2cbd764a3ed6,113,47015,47048,C0O47021C2O47033C7O47042C13O47046,,
code-creation,LazyCompile,10,72042,0x2cbd764a3fc6,8,get node:net:1753:6,0x120d44383db0,~
code-source-info,0x2cbd764a3fc6,113,46980,47008,C0O46985C2O46997C4O46996C7O47006,,
tick,0x1bfd394f0,72084,1,0x10047939c,6,0x0,0x2cbd764a3d79,0x2cbd7649b4e3,0x2cbd76494c87,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db1a0fb,0x26b72db19ead,0x3172a1b0b49c,0x3172a1b05aed
code-creation,LazyCompile,10,72125,0x2cbd764a4176,196,Readable.on node:internal/streams/readable:897:33,0x174551ef46c8,~
code-source-info,0x2cbd764a4176,57,28293,29192,C0O28318C5O28325C10O28335C15O28338C29O28338C35O28379C40O28398C42O28405C47O28587C55O28587C62O28613C65O28580C69O28706C75O28714C80O28736C85O28736C91O28755C93O28762C98O28795C104O28816C110O28843C112O28888C118O28867C122O28902C123O28916C127O28931C128O28953C132O28968C140O28995C145O29009C150O28968C155O29035C161O29053C164O29053C170O29097C176O29116C179O29124C187O29124C193O29179C195O29190,,
code-creation,LazyCompile,10,72167,0x2cbd764a43ee,135,initSocketHandle node:net:254:26,0x120d44381fa0,~
code-source-info,0x2cbd764a43ee,113,6333,6911,C0O6349C5O6349C9O6365C10O6380C14O6466C20O6486C27O6494C32O6508C36O6525C43O6542C45O6540C49O6560C51O6565C57O6603C62O6584C66O6582C70O6632C72O6637C74O6636C78O6651C80O6687C82O6692C84O6691C88O6711C90O6752C94O6770C99O6775C105O6808C106O6815C107O6824C109O6829C114O6838C118O6868C123O6876C128O6876C134O6910,,
code-creation,LazyCompile,10,72209,0x2cbd764a462e,160,undestroy node:internal/streams/destroy:167:19,0x174551ee7460,~
code-source-info,0x2cbd764a462e,55,3186,3858,C0O3208C5O3241C10O3260C14O3273C15O3287C19O3299C20O3308C24O3321C25O3336C29O3349C30O3361C34O3374C35O3384C39O3396C40O3411C44O3424C45O3434C49O3459C55O3468C58O3455C62O3500C68O3509C71O3496C75O3527C79O3540C80O3554C84O3566C85O3578C89O3591C90O3600C94O3613C95O3628C99O3641C100O3651C104O3663C105O3678C109O3691C110O3705C114O3718C115O3732C119O3757C125O3766C128O3753C132O3794C138O3803C141O3790C145O3833C151O3842C154O3829C159O3857,,
code-creation,LazyCompile,10,72250,0x2cbd764a48e6,32,getNewAsyncId node:net:156:23,0x120d44381e10,~
code-source-info,0x2cbd764a48e6,113,3994,4110,C0O4007C4O4040C14O4073C17O4073C22O4095C27O4095C31O4108,,
code-creation,LazyCompile,10,72250,0x2cbd764a49e6,5,get node:internal/bootstrap/pre_execution:394:8,0x3172a1b27730,~
code-source-info,0x2cbd764a49e6,96,12231,12264,C0O12242C4O12258,,
code-creation,LazyCompile,10,72250,0x2cbd764a4abe,5,get /Users/vignesh/.nvm/versions/node/v17.7.1/lib/node_modules/0x/lib/preload/redir-stdout.js:19:10,0x2cbd764949d0,~
code-source-info,0x2cbd764a4abe,145,392,404,C0O398C4O404,,
code-creation,Function,11,72417,0x10510d200,8104,realpathSync node:fs:2425:22,0xd2efcc368a0,^
code-source-info,0x10510d200,81,64403,68304,,,
code-creation,Function,11,72417,0x10510f220,264, node:vm:313:27,0x26b72db330c8,^
code-source-info,0x10510f220,89,9752,9803,,,
code-creation,Function,11,72417,0x10510f3a0,96,isUint32 node:internal/validators:40:18,0x2b48e0c7be38,^
code-source-info,0x10510f3a0,15,796,841,,,
code-creation,Function,11,72417,0x10510f460,64,noop node:internal/util/debuglog:47:14,0x232faba1d250,^
code-source-info,0x10510f460,22,1419,1427,,,
code-creation,Function,11,72459,0x10510f500,1064,debuglog node:internal/util/debuglog:71:18,0x232faba1d2f0,^
code-source-info,0x10510f500,22,2232,3219,,,
code-creation,Function,11,72459,0x10510f9a0,304,canBeRequiredByUsers node:internal/bootstrap/loaders:240:30,0x2b48e0c4fb08,^
code-source-info,0x10510f9a0,9,7354,7450,,,
code-creation,Eval,10,72542,0x2cbd764a58b6,5, /Users/vignesh/.nvm/versions/node/v17.7.1/lib/node_modules/0x/lib/preload/soft-exit.js:1:1,0x2cbd764a5770,~
script-source,149,/Users/vignesh/.nvm/versions/node/v17.7.1/lib/node_modules/0x/lib/preload/soft-exit.js,'use strict'\n\nprocess.on('SIGINT'\x2C process.exit)\nprocess.on('SIGTERM'\x2C process.exit)\n
code-source-info,0x2cbd764a58b6,149,0,85,C0O0C4O85,,
code-creation,Function,10,72584,0x2cbd764a5956,56, /Users/vignesh/.nvm/versions/node/v17.7.1/lib/node_modules/0x/lib/preload/soft-exit.js:1:1,0x2cbd764a5830,~
code-source-info,0x2cbd764a5956,149,0,85,C0O14C4O22C12O35C16O43C21O22C27O49C31O57C39O71C43O79C48O57C55O84,,
code-creation,LazyCompile,10,72625,0x2cbd764a5fb6,50,initializeFrozenIntrinsics node:internal/bootstrap/pre_execution:546:36,0x3172a1b08220,~
code-source-info,0x2cbd764a5fb6,96,17162,17384,C0O17169C8O17173C14O17218C17O17226C28O17226C34O17338C40O17338C45O17375C49O17383,,
code-creation,LazyCompile,10,72667,0x2cbd764a60de,80,executeUserEntryPoint node:internal/modules/run_main:70:31,0x26b72db19258,~
code-source-info,0x2cbd764a60de,132,2162,2467,C7O2178C14O2182C22O2212C25O2212C30O2258C33O2258C38O2294C40O2318C45O2329C50O2318C56O2430C61O2437C73O2437C79O2466,,
code-creation,LazyCompile,10,72667,0x2cbd764a650e,68,resolveMainPath node:internal/modules/run_main:15:25,0x26b72db19118,~
code-source-info,0x2cbd764a650e,132,398,812,C0O570C5O577C12O587C15O592C20O592C30O577C36O622C38O641C39O648C40O681C48O681C53O727C55O758C60O769C65O794C67O810,,
code-creation,LazyCompile,10,72750,0x2cbd764a6866,109,shouldUseESMLoader node:internal/modules/run_main:30:28,0x26b72db19168,~
code-source-info,0x2cbd764a6866,132,841,1401,C0O875C8O875C13O918C15O938C16O950C17O993C25O993C30O1050C32O1082C37O1098C38O1110C39O1158C45O1174C51O1174C58O1221C59O1233C60O1236C66O1253C72O1253C79O1300C80O1313C81O1328C86O1328C91O1358C93O1376C98O1381C105O1386C108O1399,,
code-creation,Eval,10,72834,0x2cbd764a6cce,5, /Users/vignesh/Projects/HTTP2/index.js:1:1,0x2cbd764a6b58,~
script-source,150,/Users/vignesh/Projects/HTTP2/index.js,/*\n * Primary file for API\n *\n */\n\n// Dependencies\nvar server = require('./lib/server');\nvar workers = require('./lib/workers');\nvar cli = require('./lib/cli');\n\n// Declare the app\nvar app = {};\n\n// Init function\napp.init = function(callback){\n\n  // Start the server\n  server.init();\n\n  // Start the workers\n  workers.init();\n\n  // Start the CLI\x2C but make sure it starts last\n  setTimeout(function(){\n    cli.init();\n    callback();\n  }\x2C50);\n\n};\n\n// Self invoking only if required directly\nif(require.main === module){\n  app.init(function(){});\n}\n\n\n// Export the app\nmodule.exports = app;\n
code-source-info,0x2cbd764a6cce,150,0,589,C0O0C4O589,,
code-creation,Function,10,72875,0x2cbd764a6e86,77, /Users/vignesh/Projects/HTTP2/index.js:1:1,0x2cbd764a6c48,~
code-source-info,0x2cbd764a6e86,150,0,589,C0O0C5O64C8O64C12O64C14O103C17O103C21O103C23O139C26O139C30O139C32O191C34O213C38O222C42O501C49O506C54O525C64O525C69O567C71O582C76O588,,
code-creation,LazyCompile,10,72917,0x2cbd764a72c6,195,resolveExports node:internal/modules/cjs/loader:472:24,0x3172a1b2a9f0,~
code-source-info,0x2cbd764a72c6,103,13559,14235,C0O13697C7O13727C10O13697C20O13665C27O13674C38O13753C42O13768C43O13775C44O13794C49O13799C54O13799C61O13836C64O13836C69O13860C74O13867C87O13904C92O13933C97O13964C102O13986C106O13964C116O14010C124O14042C130O13933C141O13911C146O14073C158O14098C161O14104C168O14109C173O14145C180O14189C184O14151C189O14145C190O14215C192O14215C194O14234,,
code-creation,Function,11,73042,0x10510fb40,3024,basename node:path:1306:11,0x815de63af38,^
code-source-info,0x10510fb40,41,39511,41903,,,
code-creation,Function,11,73042,0x105110780,96,isInt32 node:internal/validators:36:17,0x2b48e0c7b928,^
code-source-info,0x105110780,15,734,777,,,
code-creation,Function,11,73084,0x105110840,1352,readPackageScope node:internal/modules/cjs/loader:321:26,0x3172a1b2a770,^
code-source-info,0x105110840,103,8919,9437,,,
code-creation,Function,11,73084,0x105110e00,200,isUint8Array node:internal/util/types:13:22,0x232faba033f0,^
code-source-info,0x105110e00,17,257,342,,,
code-creation,LazyCompile,10,73125,0x2cbd764a79a6,71,createUnsafeBuffer node:internal/buffer:1059:28,0x232faba3ee30,~
code-source-info,0x2cbd764a79a6,25,30321,30430,C0O30332C8O30344C15O30361C22O30368C39O30408C48O30420C70O30429,,
code-creation,Eval,10,73250,0x2cbd764a832e,5, /Users/vignesh/Projects/HTTP2/lib/server.js:1:1,0x2cbd764a8178,~
script-source,151,/Users/vignesh/Projects/HTTP2/lib/server.js,/*\n * Server-related tasks\n *\n */\n\n // Dependencies\n var http = require('http');\n var https = require('https');\n var url = require('url');\n var StringDecoder = require('string_decoder').StringDecoder;\n var config = require('./config');\n var fs = require('fs');\n var handlers = require('./handlers');\n var helpers = require('./helpers');\n var path = require('path');\n var util = require('util');\n var debug = util.debuglog('server');\n\n// Instantiate the server module object\nvar server = {};\n\n // Instantiate the HTTP server\nserver.httpServer = http.createServer(function(req\x2Cres){\n   server.unifiedServer(req\x2Cres);\n });\n\n // Instantiate the HTTPS server\nserver.httpsServerOptions = {\n   'key': fs.readFileSync(path.join(__dirname\x2C'/../https/key.pem'))\x2C\n   'cert': fs.readFileSync(path.join(__dirname\x2C'/../https/cert.pem'))\n };\n server.httpsServer = https.createServer(server.httpsServerOptions\x2Cfunction(req\x2Cres){\n   server.unifiedServer(req\x2Cres);\n });\n\n // All the server logic for both the http and https server\nserver.unifiedServer = function(req\x2Cres){\n\n   // Parse the url\n   var parsedUrl = url.parse(req.url\x2C true);\n\n   // Get the path\n   var path = parsedUrl.pathname;\n   var trimmedPath = path.replace(/^\\/+|\\/+$/g\x2C '');\n\n   // Get the query string as an object\n   var queryStringObject = parsedUrl.query;\n\n   // Get the HTTP method\n   var method = req.method.toLowerCase();\n\n   //Get the headers as an object\n   var headers = req.headers;\n\n   // Get the payload\x2Cif any\n   var decoder = new StringDecoder('utf-8');\n   var buffer = '';\n   req.on('data'\x2C function(data) {\n       buffer += decoder.write(data);\n   });\n   req.on('end'\x2C function() {\n       buffer += decoder.end();\n\n       // Check the router for a matching path for a handler. If one is not found\x2C use the notFound handler instead.\n       var chosenHandler = typeof(server.router[trimmedPath]) !== 'undefined' ? server.router[trimmedPath] : handlers.notFound;\n\n       // If the request is within the public directory use to the public handler instead\n       chosenHandler = trimmedPath.indexOf('public/') > -1 ? handlers.public : chosenHandler;\n\n       // Construct the data object to send to the handler\n       var data = {\n         'trimmedPath' : trimmedPath\x2C\n         'queryStringObject' : queryStringObject\x2C\n         'method' : method\x2C\n         'headers' : headers\x2C\n         'payload' : helpers.parseJsonToObject(buffer)\n       };\n\n       // Route the request to the handler specified in the router\n       try{\n         chosenHandler(data\x2Cfunction(statusCode\x2Cpayload\x2CcontentType){\n           server.processHandlerResponse(res\x2Cmethod\x2CtrimmedPath\x2CstatusCode\x2Cpayload\x2CcontentType);\n\n         });\n       }catch(e){\n         debug(e);\n         server.processHandlerResponse(res\x2Cmethod\x2CtrimmedPath\x2C500\x2C{'Error' : 'An unknown error has occured'}\x2C'json');\n       }\n   });\n };\n\n // Process the response from the handler\n server.processHandlerResponse = function(res\x2Cmethod\x2CtrimmedPath\x2CstatusCode\x2Cpayload\x2CcontentType){\n   // Determine the type of response (fallback to JSON)\n   contentType = typeof(contentType) == 'string' ? contentType : 'json';\n\n   // Use the status code returned from the handler\x2C or set the default status code to 200\n   statusCode = typeof(statusCode) == 'number' ? statusCode : 200;\n\n   // Return the response parts that are content-type specific\n   var payloadString = '';\n   if(contentType == 'json'){\n     res.setHeader('Content-Type'\x2C 'application/json');\n     payload = typeof(payload) == 'object'? payload : {};\n     payloadString = JSON.stringify(payload);\n   }\n\n   if(contentType == 'html'){\n     res.setHeader('Content-Type'\x2C 'text/html');\n     payloadString = typeof(payload) == 'string'? payload : '';\n   }\n\n   if(contentType == 'favicon'){\n     res.setHeader('Content-Type'\x2C 'image/x-icon');\n     payloadString = typeof(payload) !== 'undefined' ? payload : '';\n   }\n\n   if(contentType == 'plain'){\n     res.setHeader('Content-Type'\x2C 'text/plain');\n     payloadString = typeof(payload) !== 'undefined' ? payload : '';\n   }\n\n   if(contentType == 'css'){\n     res.setHeader('Content-Type'\x2C 'text/css');\n     payloadString = typeof(payload) !== 'undefined' ? payload : '';\n   }\n\n   if(contentType == 'png'){\n     res.setHeader('Content-Type'\x2C 'image/png');\n     payloadString = typeof(payload) !== 'undefined' ? payload : '';\n   }\n\n   if(contentType == 'jpg'){\n     res.setHeader('Content-Type'\x2C 'image/jpeg');\n     payloadString = typeof(payload) !== 'undefined' ? payload : '';\n   }\n\n   // Return the response-parts common to all content-types\n   res.writeHead(statusCode);\n   res.end(payloadString);\n\n   // If the response is 200\x2C print green\x2C otherwise print red\n   if(statusCode == 200){\n     debug('\\x1b[32m%s\\x1b[0m'\x2Cmethod.toUpperCase()+' /'+trimmedPath+' '+statusCode);\n   } else {\n     debug('\\x1b[31m%s\\x1b[0m'\x2Cmethod.toUpperCase()+' /'+trimmedPath+' '+statusCode);\n   }\n };\n\n // Define the request router\nserver.router = {\n  '' : handlers.index\x2C\n  'account/create' : handlers.accountCreate\x2C\n  'account/edit' : handlers.accountEdit\x2C\n  'account/deleted' : handlers.accountDeleted\x2C\n  'session/create' : handlers.sessionCreate\x2C\n  'session/deleted' : handlers.sessionDeleted\x2C\n  'checks/all' : handlers.checksList\x2C\n  'checks/create' : handlers.checksCreate\x2C\n  'checks/edit' : handlers.checksEdit\x2C\n  'ping' : handlers.ping\x2C\n  'api/users' : handlers.users\x2C\n  'api/tokens' : handlers.tokens\x2C\n  'api/checks' : handlers.checks\x2C\n  'favicon.ico' : handlers.favicon\x2C\n  'public' : handlers.public\x2C\n  'examples/error' : handlers.exampleError\n};\n\n // Init script\nserver.init = function(){\n  // Start the HTTP server\n  server.httpServer.listen(config.httpPort\x2Cfunction(){\n    console.log('\\x1b[36m%s\\x1b[0m'\x2C'The HTTP server is running on port '+config.httpPort);\n  });\n\n  // Start the HTTPS server\n  server.httpsServer.listen(config.httpsPort\x2Cfunction(){\n    console.log('\\x1b[35m%s\\x1b[0m'\x2C'The HTTPS server is running on port '+config.httpsPort);\n  });\n};\n\n\n // Export the module\n module.exports = server;\n
code-source-info,0x2cbd764a832e,151,0,5999,C0O0C4O5999,,
code-creation,Function,10,73500,0x2cbd764a89ce,469, /Users/vignesh/Projects/HTTP2/lib/server.js:1:1,0x2cbd764a82a8,~
code-source-info,0x2cbd764a89ce,151,0,5999,C0O0C5O64C8O64C13O94C16O94C21O123C24O123C28O123C30O160C33O160C38O185C42O160C44O215C47O215C51O215C53O246C56O246C61O277C64O277C68O277C70O315C73O315C77O315C79O349C82O349C87O378C90O378C95O413C103O413C108O408C110O487C111O487C113O524C116O549C126O549C131O542C135O654C143O697C148O715C156O715C163O697C172O767C177O785C185O785C192O767C203O680C207O828C210O855C218O875C228O855C234O847C238O1013C245O1034C249O2886C256O2916C260O4913C271O4947C282O4984C293O5027C304O5071C315O5117C326O5163C337O5205C348O5246C359O5287C370O5319C381O5350C392O5383C403O5417C414O5452C425O5483C436O5521C446O4927C450O5554C457O5566C461O5974C463O5989C468O5998,,
tick,0x10152dccc,73542,1,0x1003cc7d8,3,0x0,0x26b72db3352e,0x26b72db32c8f,0x26b72db31625,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,73584,0x2cbd764a98fe,5, node:http:1:1,0x2cbd764a9758,~
script-source,152,node:http,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  ObjectDefineProperty\x2C\n} = primordials;\n\nconst httpAgent = require('_http_agent');\nconst { ClientRequest } = require('_http_client');\nconst { methods } = require('_http_common');\nconst { IncomingMessage } = require('_http_incoming');\nconst {\n  validateHeaderName\x2C\n  validateHeaderValue\x2C\n  OutgoingMessage\n} = require('_http_outgoing');\nconst {\n  _connectionListener\x2C\n  STATUS_CODES\x2C\n  Server\x2C\n  ServerResponse\n} = require('_http_server');\nlet maxHeaderSize;\n\n/**\n * Returns a new instance of `http.Server`.\n * @param {{\n *   IncomingMessage?: IncomingMessage;\n *   ServerResponse?: ServerResponse;\n *   insecureHTTPParser?: boolean;\n *   maxHeaderSize?: number;\n *   }} [opts]\n * @param {Function} [requestListener]\n * @returns {Server}\n */\nfunction createServer(opts\x2C requestListener) {\n  return new Server(opts\x2C requestListener);\n}\n\n/**\n * @typedef {object} HTTPRequestOptions\n * @property {httpAgent.Agent | boolean} [agent]\n * @property {string} [auth]\n * @property {Function} [createConnection]\n * @property {number} [defaultPort]\n * @property {number} [family]\n * @property {object} [headers]\n * @property {number} [hints]\n * @property {string} [host]\n * @property {string} [hostname]\n * @property {boolean} [insecureHTTPParser]\n * @property {string} [localAddress]\n * @property {number} [localPort]\n * @property {Function} [lookup]\n * @property {number} [maxHeaderSize]\n * @property {string} [method]\n * @property {string} [path]\n * @property {number} [port]\n * @property {string} [protocol]\n * @property {boolean} [setHost]\n * @property {string} [socketPath]\n * @property {number} [timeout]\n * @property {AbortSignal} [signal]\n */\n\n/**\n * Makes an HTTP request.\n * @param {string | URL} url\n * @param {HTTPRequestOptions} [options]\n * @param {Function} [cb]\n * @returns {ClientRequest}\n */\nfunction request(url\x2C options\x2C cb) {\n  return new ClientRequest(url\x2C options\x2C cb);\n}\n\n/**\n * Makes a `GET` HTTP request.\n * @param {string | URL} url\n * @param {HTTPRequestOptions} [options]\n * @param {Function} [cb]\n * @returns {ClientRequest}\n */\nfunction get(url\x2C options\x2C cb) {\n  const req = request(url\x2C options\x2C cb);\n  req.end();\n  return req;\n}\n\nmodule.exports = {\n  _connectionListener\x2C\n  METHODS: ArrayPrototypeSort(ArrayPrototypeSlice(methods))\x2C\n  STATUS_CODES\x2C\n  Agent: httpAgent.Agent\x2C\n  ClientRequest\x2C\n  IncomingMessage\x2C\n  OutgoingMessage\x2C\n  Server\x2C\n  ServerResponse\x2C\n  createServer\x2C\n  validateHeaderName\x2C\n  validateHeaderValue\x2C\n  get\x2C\n  request\n};\n\nObjectDefineProperty(module.exports\x2C 'maxHeaderSize'\x2C {\n  configurable: true\x2C\n  enumerable: true\x2C\n  get() {\n    if (maxHeaderSize === undefined) {\n      const { getOptionValue } = require('internal/options');\n      maxHeaderSize = getOptionValue('--max-http-header-size');\n    }\n\n    return maxHeaderSize;\n  }\n});\n\nObjectDefineProperty(module.exports\x2C 'globalAgent'\x2C {\n  configurable: true\x2C\n  enumerable: true\x2C\n  get() {\n    return httpAgent.globalAgent;\n  }\x2C\n  set(value) {\n    httpAgent.globalAgent = value;\n  }\n});\n
code-source-info,0x2cbd764a98fe,152,0,4182,C0O0C4O4182,,
code-creation,Function,10,73750,0x2cbd764a9e1e,349, node:http:1:1,0x2cbd764a9878,~
code-source-info,0x2cbd764a9e1e,152,0,4182,C0O0C37O1159C42O1182C47O1204C52O1262C58O1262C62O1262C64O1312C70O1312C75O1294C81O1357C87O1357C92O1345C97O1410C103O1410C108O1390C113O1512C119O1512C124O1447C129O1469C134O1492C139O1617C145O1617C150O1549C155O1572C160O1588C166O1598C171O1646C172O1646C174O3354C181O3375C185O3426C191O3407C201O3459C209O3492C219O3501C225O3518C231O3537C237O3556C243O3566C249O3584C255O3600C261O3622C267O3645C273O3652C279O3369C283O3692C298O3764C306O3664C311O4007C326O4077C334O4126C342O3979C348O4181,,
code-creation,Eval,10,73959,0x2cbd764aaf9e,5, node:_http_agent:1:1,0x2cbd764aac08,~
script-source,153,node:_http_agent,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSome\x2C\n  ArrayPrototypeSplice\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectValues\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeSubstr\x2C\n  Symbol\x2C\n} = primordials;\n\nconst net = require('net');\nconst EventEmitter = require('events');\nlet debug = require('internal/util/debuglog').debuglog('http'\x2C (fn) => {\n  debug = fn;\n});\nconst { AsyncResource } = require('async_hooks');\nconst { async_id_symbol } = require('internal/async_hooks').symbols;\nconst {\n  codes: {\n    ERR_OUT_OF_RANGE\x2C\n  }\x2C\n} = require('internal/errors');\nconst { once } = require('internal/util');\nconst {\n  validateNumber\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst kOnKeylog = Symbol('onkeylog');\nconst kRequestOptions = Symbol('requestOptions');\nconst kRequestAsyncResource = Symbol('requestAsyncResource');\n// New Agent code.\n\n// The largest departure from the previous implementation is that\n// an Agent instance holds connections for a variable number of host:ports.\n// Surprisingly\x2C this is still API compatible as far as third parties are\n// concerned. The only code that really notices the difference is the\n// request object.\n\n// Another departure is that all code related to HTTP parsing is in\n// ClientRequest.onSocket(). The Agent is now *strictly*\n// concerned with managing a connection pool.\n\nclass ReusedHandle {\n  constructor(type\x2C handle) {\n    this.type = type;\n    this.handle = handle;\n  }\n}\n\nfunction freeSocketErrorListener(err) {\n  const socket = this;\n  debug('SOCKET ERROR on FREE socket:'\x2C err.message\x2C err.stack);\n  socket.destroy();\n  socket.emit('agentRemove');\n}\n\nfunction Agent(options) {\n  if (!(this instanceof Agent))\n    return new Agent(options);\n\n  FunctionPrototypeCall(EventEmitter\x2C this);\n\n  this.defaultPort = 80;\n  this.protocol = 'http:';\n\n  this.options = { __proto__: null\x2C ...options };\n\n  // Don't confuse net and make it think that we're connecting to a pipe\n  this.options.path = null;\n  this.requests = ObjectCreate(null);\n  this.sockets = ObjectCreate(null);\n  this.freeSockets = ObjectCreate(null);\n  this.keepAliveMsecs = this.options.keepAliveMsecs || 1000;\n  this.keepAlive = this.options.keepAlive || false;\n  this.maxSockets = this.options.maxSockets || Agent.defaultMaxSockets;\n  this.maxFreeSockets = this.options.maxFreeSockets || 256;\n  this.scheduling = this.options.scheduling || 'lifo';\n  this.maxTotalSockets = this.options.maxTotalSockets;\n  this.totalSocketCount = 0;\n\n  validateOneOf(this.scheduling\x2C 'scheduling'\x2C ['fifo'\x2C 'lifo']);\n\n  if (this.maxTotalSockets !== undefined) {\n    validateNumber(this.maxTotalSockets\x2C 'maxTotalSockets');\n    if (this.maxTotalSockets <= 0 || NumberIsNaN(this.maxTotalSockets))\n      throw new ERR_OUT_OF_RANGE('maxTotalSockets'\x2C '> 0'\x2C\n                                 this.maxTotalSockets);\n  } else {\n    this.maxTotalSockets = Infinity;\n  }\n\n  this.on('free'\x2C (socket\x2C options) => {\n    const name = this.getName(options);\n    debug('agent.on(free)'\x2C name);\n\n    // TODO(ronag): socket.destroy(err) might have been called\n    // before coming here and have an 'error' scheduled. In the\n    // case of socket.destroy() below this 'error' has no handler\n    // and could cause unhandled exception.\n\n    if (!socket.writable) {\n      socket.destroy();\n      return;\n    }\n\n    const requests = this.requests[name];\n    if (requests && requests.length) {\n      const req = ArrayPrototypeShift(requests);\n      const reqAsyncRes = req[kRequestAsyncResource];\n      if (reqAsyncRes) {\n        // Run request within the original async context.\n        reqAsyncRes.runInAsyncScope(() => {\n          asyncResetHandle(socket);\n          setRequestSocket(this\x2C req\x2C socket);\n        });\n        req[kRequestAsyncResource] = null;\n      } else {\n        setRequestSocket(this\x2C req\x2C socket);\n      }\n      if (requests.length === 0) {\n        delete this.requests[name];\n      }\n      return;\n    }\n\n    // If there are no pending requests\x2C then put it in\n    // the freeSockets pool\x2C but only if we're allowed to do so.\n    const req = socket._httpMessage;\n    if (!req || !req.shouldKeepAlive || !this.keepAlive) {\n      socket.destroy();\n      return;\n    }\n\n    const freeSockets = this.freeSockets[name] || [];\n    const freeLen = freeSockets.length;\n    let count = freeLen;\n    if (this.sockets[name])\n      count += this.sockets[name].length;\n\n    if (this.totalSocketCount > this.maxTotalSockets ||\n        count > this.maxSockets ||\n        freeLen >= this.maxFreeSockets ||\n        !this.keepSocketAlive(socket)) {\n      socket.destroy();\n      return;\n    }\n\n    this.freeSockets[name] = freeSockets;\n    socket[async_id_symbol] = -1;\n    socket._httpMessage = null;\n    this.removeSocket(socket\x2C options);\n\n    socket.once('error'\x2C freeSocketErrorListener);\n    ArrayPrototypePush(freeSockets\x2C socket);\n  });\n\n  // Don't emit keylog events unless there is a listener for them.\n  this.on('newListener'\x2C maybeEnableKeylog);\n}\nObjectSetPrototypeOf(Agent.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Agent\x2C EventEmitter);\n\nfunction maybeEnableKeylog(eventName) {\n  if (eventName === 'keylog') {\n    this.removeListener('newListener'\x2C maybeEnableKeylog);\n    // Future sockets will listen on keylog at creation.\n    const agent = this;\n    this[kOnKeylog] = function onkeylog(keylog) {\n      agent.emit('keylog'\x2C keylog\x2C this);\n    };\n    // Existing sockets will start listening on keylog now.\n    const sockets = ObjectValues(this.sockets);\n    for (let i = 0; i < sockets.length; i++) {\n      sockets[i].on('keylog'\x2C this[kOnKeylog]);\n    }\n  }\n}\n\nAgent.defaultMaxSockets = Infinity;\n\nAgent.prototype.createConnection = net.createConnection;\n\n// Get the key for a given set of request options\nAgent.prototype.getName = function getName(options = {}) {\n  let name = options.host || 'localhost';\n\n  name += ':';\n  if (options.port)\n    name += options.port;\n\n  name += ':';\n  if (options.localAddress)\n    name += options.localAddress;\n\n  // Pacify parallel/test-http-agent-getname by only appending\n  // the ':' when options.family is set.\n  if (options.family === 4 || options.family === 6)\n    name += `:${options.family}`;\n\n  if (options.socketPath)\n    name += `:${options.socketPath}`;\n\n  return name;\n};\n\nAgent.prototype.addRequest = function addRequest(req\x2C options\x2C port/* legacy */\x2C\n                                                 localAddress/* legacy */) {\n  // Legacy API: addRequest(req\x2C host\x2C port\x2C localAddress)\n  if (typeof options === 'string') {\n    options = {\n      __proto__: null\x2C\n      host: options\x2C\n      port\x2C\n      localAddress\n    };\n  }\n\n  options = { __proto__: null\x2C ...options\x2C ...this.options };\n  if (options.socketPath)\n    options.path = options.socketPath;\n\n  if (!options.servername && options.servername !== '')\n    options.servername = calculateServerName(options\x2C req);\n\n  const name = this.getName(options);\n  if (!this.sockets[name]) {\n    this.sockets[name] = [];\n  }\n\n  const freeSockets = this.freeSockets[name];\n  let socket;\n  if (freeSockets) {\n    while (freeSockets.length && freeSockets[0].destroyed) {\n      ArrayPrototypeShift(freeSockets);\n    }\n    socket = this.scheduling === 'fifo' ?\n      ArrayPrototypeShift(freeSockets) :\n      ArrayPrototypePop(freeSockets);\n    if (!freeSockets.length)\n      delete this.freeSockets[name];\n  }\n\n  const freeLen = freeSockets ? freeSockets.length : 0;\n  const sockLen = freeLen + this.sockets[name].length;\n\n  if (socket) {\n    asyncResetHandle(socket);\n    this.reuseSocket(socket\x2C req);\n    setRequestSocket(this\x2C req\x2C socket);\n    ArrayPrototypePush(this.sockets[name]\x2C socket);\n  } else if (sockLen < this.maxSockets &&\n             this.totalSocketCount < this.maxTotalSockets) {\n    debug('call onSocket'\x2C sockLen\x2C freeLen);\n    // If we are under maxSockets create a new one.\n    this.createSocket(req\x2C options\x2C (err\x2C socket) => {\n      if (err)\n        req.onSocket(socket\x2C err);\n      else\n        setRequestSocket(this\x2C req\x2C socket);\n    });\n  } else {\n    debug('wait for socket');\n    // We are over limit so we'll add it to the queue.\n    if (!this.requests[name]) {\n      this.requests[name] = [];\n    }\n\n    // Used to create sockets for pending requests from different origin\n    req[kRequestOptions] = options;\n    // Used to capture the original async context.\n    req[kRequestAsyncResource] = new AsyncResource('QueuedRequest');\n\n    ArrayPrototypePush(this.requests[name]\x2C req);\n  }\n};\n\nAgent.prototype.createSocket = function createSocket(req\x2C options\x2C cb) {\n  options = { __proto__: null\x2C ...options\x2C ...this.options };\n  if (options.socketPath)\n    options.path = options.socketPath;\n\n  if (!options.servername && options.servername !== '')\n    options.servername = calculateServerName(options\x2C req);\n\n  const name = this.getName(options);\n  options._agentKey = name;\n\n  debug('createConnection'\x2C name\x2C options);\n  options.encoding = null;\n\n  const oncreate = once((err\x2C s) => {\n    if (err)\n      return cb(err);\n    if (!this.sockets[name]) {\n      this.sockets[name] = [];\n    }\n    ArrayPrototypePush(this.sockets[name]\x2C s);\n    this.totalSocketCount++;\n    debug('sockets'\x2C name\x2C this.sockets[name].length\x2C this.totalSocketCount);\n    installListeners(this\x2C s\x2C options);\n    cb(null\x2C s);\n  });\n\n  const newSocket = this.createConnection(options\x2C oncreate);\n  if (newSocket)\n    oncreate(null\x2C newSocket);\n};\n\nfunction calculateServerName(options\x2C req) {\n  let servername = options.host;\n  const hostHeader = req.getHeader('host');\n  if (hostHeader) {\n    validateString(hostHeader\x2C 'options.headers.host');\n\n    // abc => abc\n    // abc:123 => abc\n    // [::1] => ::1\n    // [::1]:123 => ::1\n    if (StringPrototypeStartsWith(hostHeader\x2C '[')) {\n      const index = StringPrototypeIndexOf(hostHeader\x2C ']');\n      if (index === -1) {\n        // Leading '['\x2C but no ']'. Need to do something...\n        servername = hostHeader;\n      } else {\n        servername = StringPrototypeSubstr(hostHeader\x2C 1\x2C index - 1);\n      }\n    } else {\n      servername = StringPrototypeSplit(hostHeader\x2C ':'\x2C 1)[0];\n    }\n  }\n  // Don't implicitly set invalid (IP) servernames.\n  if (net.isIP(servername))\n    servername = '';\n  return servername;\n}\n\nfunction installListeners(agent\x2C s\x2C options) {\n  function onFree() {\n    debug('CLIENT socket onFree');\n    agent.emit('free'\x2C s\x2C options);\n  }\n  s.on('free'\x2C onFree);\n\n  function onClose(err) {\n    debug('CLIENT socket onClose');\n    // This is the only place where sockets get removed from the Agent.\n    // If you want to remove a socket from the pool\x2C just close it.\n    // All socket errors end in a close event anyway.\n    agent.totalSocketCount--;\n    agent.removeSocket(s\x2C options);\n  }\n  s.on('close'\x2C onClose);\n\n  function onTimeout() {\n    debug('CLIENT socket onTimeout');\n\n    // Destroy if in free list.\n    // TODO(ronag): Always destroy\x2C even if not in free list.\n    const sockets = agent.freeSockets;\n    if (ArrayPrototypeSome(ObjectKeys(sockets)\x2C (name) =>\n      ArrayPrototypeIncludes(sockets[name]\x2C s)\n    )) {\n      return s.destroy();\n    }\n  }\n  s.on('timeout'\x2C onTimeout);\n\n  function onRemove() {\n    // We need this function for cases like HTTP 'upgrade'\n    // (defined by WebSockets) where we need to remove a socket from the\n    // pool because it'll be locked up indefinitely\n    debug('CLIENT socket onRemove');\n    agent.totalSocketCount--;\n    agent.removeSocket(s\x2C options);\n    s.removeListener('close'\x2C onClose);\n    s.removeListener('free'\x2C onFree);\n    s.removeListener('timeout'\x2C onTimeout);\n    s.removeListener('agentRemove'\x2C onRemove);\n  }\n  s.on('agentRemove'\x2C onRemove);\n\n  if (agent[kOnKeylog]) {\n    s.on('keylog'\x2C agent[kOnKeylog]);\n  }\n}\n\nAgent.prototype.removeSocket = function removeSocket(s\x2C options) {\n  const name = this.getName(options);\n  debug('removeSocket'\x2C name\x2C 'writable:'\x2C s.writable);\n  const sets = [this.sockets];\n\n  // If the socket was destroyed\x2C remove it from the free buffers too.\n  if (!s.writable)\n    ArrayPrototypePush(sets\x2C this.freeSockets);\n\n  for (let sk = 0; sk < sets.length; sk++) {\n    const sockets = sets[sk];\n\n    if (sockets[name]) {\n      const index = ArrayPrototypeIndexOf(sockets[name]\x2C s);\n      if (index !== -1) {\n        ArrayPrototypeSplice(sockets[name]\x2C index\x2C 1);\n        // Don't leak\n        if (sockets[name].length === 0)\n          delete sockets[name];\n      }\n    }\n  }\n\n  let req;\n  if (this.requests[name] && this.requests[name].length) {\n    debug('removeSocket\x2C have a request\x2C make a socket');\n    req = this.requests[name][0];\n  } else {\n    // TODO(rickyes): this logic will not be FIFO across origins.\n    // There might be older requests in a different origin\x2C but\n    // if the origin which releases the socket has pending requests\n    // that will be prioritized.\n    const keys = ObjectKeys(this.requests);\n    for (let i = 0; i < keys.length; i++) {\n      const prop = keys[i];\n      // Check whether this specific origin is already at maxSockets\n      if (this.sockets[prop] && this.sockets[prop].length) break;\n      debug('removeSocket\x2C have a request with different origin\x2C' +\n        ' make a socket');\n      req = this.requests[prop][0];\n      options = req[kRequestOptions];\n      break;\n    }\n  }\n\n  if (req && options) {\n    req[kRequestOptions] = undefined;\n    // If we have pending requests and a socket gets closed make a new one\n    this.createSocket(req\x2C options\x2C (err\x2C socket) => {\n      if (err)\n        req.onSocket(socket\x2C err);\n      else\n        socket.emit('free');\n    });\n  }\n\n};\n\nAgent.prototype.keepSocketAlive = function keepSocketAlive(socket) {\n  socket.setKeepAlive(true\x2C this.keepAliveMsecs);\n  socket.unref();\n\n  const agentTimeout = this.options.timeout || 0;\n  if (socket.timeout !== agentTimeout) {\n    socket.setTimeout(agentTimeout);\n  }\n\n  return true;\n};\n\nAgent.prototype.reuseSocket = function reuseSocket(socket\x2C req) {\n  debug('have free socket');\n  socket.removeListener('error'\x2C freeSocketErrorListener);\n  req.reusedSocket = true;\n  socket.ref();\n};\n\nAgent.prototype.destroy = function destroy() {\n  const sets = [this.freeSockets\x2C this.sockets];\n  for (let s = 0; s < sets.length; s++) {\n    const set = sets[s];\n    const keys = ObjectKeys(set);\n    for (let v = 0; v < keys.length; v++) {\n      const setName = set[keys[v]];\n      for (let n = 0; n < setName.length; n++) {\n        setName[n].destroy();\n      }\n    }\n  }\n};\n\nfunction setRequestSocket(agent\x2C req\x2C socket) {\n  req.onSocket(socket);\n  const agentTimeout = agent.options.timeout || 0;\n  if (req.timeout === undefined || req.timeout === agentTimeout) {\n    return;\n  }\n  socket.setTimeout(req.timeout);\n}\n\nfunction asyncResetHandle(socket) {\n  // Guard against an uninitialized or user supplied Socket.\n  const handle = socket._handle;\n  if (handle && typeof handle.asyncReset === 'function') {\n    // Assign the handle a new asyncId and run any destroy()/init() hooks.\n    handle.asyncReset(new ReusedHandle(handle.getProviderType()\x2C handle));\n    socket[async_id_symbol] = handle.getAsyncId();\n  }\n}\n\nmodule.exports = {\n  Agent\x2C\n  globalAgent: new Agent()\n};\n
code-source-info,0x2cbd764aaf9e,153,0,16463,C0O0C4O16463,,
code-creation,Function,10,74542,0x2cbd764ab92e,636, node:_http_agent:1:1,0x2cbd764aaf18,~
code-source-info,0x2cbd764ab92e,153,0,16463,C0O0C137O1159C143O1185C149O1210C155O1231C161O1253C167O1276C173O1298C179O1322C185O1347C191O1362C197O1378C203O1392C208O1416C214O1432C220O1458C226O1482C232O1511C238O1536C243O1574C246O1574C250O1574C252O1611C255O1611C259O1611C261O1642C264O1642C269O1675C282O1676C288O1642C290O1747C293O1747C298O1729C304O1799C307O1799C312O1830C317O1779C323O1890C326O1890C331O1890C336O1863C342O1935C345O1935C350O1926C356O2026C359O2026C364O1971C370O1989C376O2006C382O2077C385O2077C389O2077C391O2121C394O2121C398O2121C400O2177C403O2177C407O2177C430O2707C432O6330C435O6357C443O6381C448O6330C453O6393C459O6393C464O6964C467O6990C470O6988C474O7001C477O7007C485O7040C489O7034C493O7109C496O7115C505O7133C509O7626C512O7632C521O7653C525O9820C528O9826C537O9849C541O13061C544O13067C553O13090C557O14896C560O14902C569O14928C573O15186C576O15192C585O15214C589O15387C592O15393C601O15411C605O16405C612O16426C619O16448C630O16420C635O16462,,
tick,0x1bfd8d2bc,74625,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x2cbd764a9e58,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89d6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,74709,0x2cbd764ad606,505,Agent node:_http_agent:93:15,0x2cbd764ab020,~
code-source-info,0x2cbd764ad606,153,3008,6329,C0O3008C9O3022C16O3033C21O3056C28O3063C33O3082C34O3086C45O3108C51O3086C56O3132C61O3149C65O3157C70O3171C74O3185C88O3222C94O3198C98O3309C101O3314C107O3327C111O3337C118O3353C123O3353C127O3351C131O3375C138O3390C143O3390C147O3388C151O3412C158O3431C163O3431C167O3429C171O3453C177O3480C182O3488C192O3473C196O3514C202O3536C207O3544C214O3529C218O3566C224O3589C229O3597C240O3617C244O3582C248O3638C254O3665C259O3673C269O3658C273O3698C279O3721C284O3729C292O3714C296O3753C302O3781C307O3789C311O3774C315O3808C319O3830C323O3838C333O3857C346O3838C351O3905C354O3914C360O3951C370O3971C378O3951C383O4012C386O4021C392O4037C401O4045C407O4062C412O4045C418O4086C434O4177C441O4092C446O4086C449O4210C452O4233C455O4231C459O4250C462O4255C475O4255C481O6285C484O6290C497O6290C504O6328,,
new,MemoryChunk,0xb72c03c0000,262144
code-creation,LazyCompile,10,74792,0x2cbd764aec06,75, node:internal/validators:128:39,0x2b48e0c7c0d8,~
code-source-info,0x2cbd764aec06,15,3700,4033,C0O3728C5O3733C12O3793C19O3819C22O3837C27O3819C36O3793C42O3940C47O3959C51O3974C67O3980C72O3974C74O4032,,
code-creation,Eval,10,75042,0x2cbd764afb16,5, node:_http_client:1:1,0x2cbd764af560,~
script-source,154,node:_http_client,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  Boolean\x2C\n  Error\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsFinite\x2C\n  ObjectAssign\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeToUpperCase\x2C\n  Symbol\x2C\n  TypedArrayPrototypeSlice\x2C\n} = primordials;\n\nconst net = require('net');\nconst assert = require('internal/assert');\nconst { once } = require('internal/util');\nconst {\n  _checkIsHttpToken: checkIsHttpToken\x2C\n  freeParser\x2C\n  parsers\x2C\n  HTTPParser\x2C\n  isLenient\x2C\n  prepareError\x2C\n} = require('_http_common');\nconst { OutgoingMessage } = require('_http_outgoing');\nconst Agent = require('_http_agent');\nconst { Buffer } = require('buffer');\nconst { defaultTriggerAsyncIdScope } = require('internal/async_hooks');\nconst { URL\x2C urlToHttpOptions\x2C searchParamsSymbol } = require('internal/url');\nconst { kOutHeaders\x2C kNeedDrain } = require('internal/http');\nconst { connResetException\x2C codes } = require('internal/errors');\nconst {\n  ERR_HTTP_HEADERS_SENT\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_HTTP_TOKEN\x2C\n  ERR_INVALID_PROTOCOL\x2C\n  ERR_UNESCAPED_CHARACTERS\n} = codes;\nconst {\n  validateInteger\x2C\n} = require('internal/validators');\nconst { getTimerDuration } = require('internal/timers');\nconst {\n  DTRACE_HTTP_CLIENT_REQUEST\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE\n} = require('internal/dtrace');\n\nconst { addAbortSignal\x2C finished } = require('stream');\n\nlet debug = require('internal/util/debuglog').debuglog('http'\x2C (fn) => {\n  debug = fn;\n});\n\nconst INVALID_PATH_REGEX = /[^\\u0021-\\u00ff]/;\nconst kError = Symbol('kError');\n\nconst kLenientAll = HTTPParser.kLenientAll | 0;\nconst kLenientNone = HTTPParser.kLenientNone | 0;\n\nfunction validateHost(host\x2C name) {\n  if (host !== null && host !== undefined && typeof host !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE(`options.${name}`\x2C\n                                   ['string'\x2C 'undefined'\x2C 'null']\x2C\n                                   host);\n  }\n  return host;\n}\n\nclass HTTPClientAsyncResource {\n  constructor(type\x2C req) {\n    this.type = type;\n    this.req = req;\n  }\n}\n\nfunction ClientRequest(input\x2C options\x2C cb) {\n  FunctionPrototypeCall(OutgoingMessage\x2C this);\n\n  if (typeof input === 'string') {\n    const urlStr = input;\n    input = urlToHttpOptions(new URL(urlStr));\n  } else if (input && input[searchParamsSymbol] &&\n             input[searchParamsSymbol][searchParamsSymbol]) {\n    // url.URL instance\n    input = urlToHttpOptions(input);\n  } else {\n    cb = options;\n    options = input;\n    input = null;\n  }\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = input || {};\n  } else {\n    options = ObjectAssign(input || {}\x2C options);\n  }\n\n  let agent = options.agent;\n  const defaultAgent = options._defaultAgent || Agent.globalAgent;\n  if (agent === false) {\n    agent = new defaultAgent.constructor();\n  } else if (agent === null || agent === undefined) {\n    if (typeof options.createConnection !== 'function') {\n      agent = defaultAgent;\n    }\n    // Explicitly pass through this statement as agent will not be used\n    // when createConnection is provided.\n  } else if (typeof agent.addRequest !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('options.agent'\x2C\n                                   ['Agent-like Object'\x2C 'undefined'\x2C 'false']\x2C\n                                   agent);\n  }\n  this.agent = agent;\n\n  const protocol = options.protocol || defaultAgent.protocol;\n  let expectedProtocol = defaultAgent.protocol;\n  if (this.agent && this.agent.protocol)\n    expectedProtocol = this.agent.protocol;\n\n  if (options.path) {\n    const path = String(options.path);\n    if (RegExpPrototypeTest(INVALID_PATH_REGEX\x2C path))\n      throw new ERR_UNESCAPED_CHARACTERS('Request path');\n  }\n\n  if (protocol !== expectedProtocol) {\n    throw new ERR_INVALID_PROTOCOL(protocol\x2C expectedProtocol);\n  }\n\n  const defaultPort = options.defaultPort ||\n                    (this.agent && this.agent.defaultPort);\n\n  const port = options.port = options.port || defaultPort || 80;\n  const host = options.host = validateHost(options.hostname\x2C 'hostname') ||\n                            validateHost(options.host\x2C 'host') || 'localhost';\n\n  const setHost = (options.setHost === undefined || Boolean(options.setHost));\n\n  this.socketPath = options.socketPath;\n\n  if (options.timeout !== undefined)\n    this.timeout = getTimerDuration(options.timeout\x2C 'timeout');\n\n  const signal = options.signal;\n  if (signal) {\n    addAbortSignal(signal\x2C this);\n  }\n  let method = options.method;\n  const methodIsString = (typeof method === 'string');\n  if (method !== null && method !== undefined && !methodIsString) {\n    throw new ERR_INVALID_ARG_TYPE('options.method'\x2C 'string'\x2C method);\n  }\n\n  if (methodIsString && method) {\n    if (!checkIsHttpToken(method)) {\n      throw new ERR_INVALID_HTTP_TOKEN('Method'\x2C method);\n    }\n    method = this.method = StringPrototypeToUpperCase(method);\n  } else {\n    method = this.method = 'GET';\n  }\n\n  const maxHeaderSize = options.maxHeaderSize;\n  if (maxHeaderSize !== undefined)\n    validateInteger(maxHeaderSize\x2C 'maxHeaderSize'\x2C 0);\n  this.maxHeaderSize = maxHeaderSize;\n\n  const insecureHTTPParser = options.insecureHTTPParser;\n  if (insecureHTTPParser !== undefined &&\n      typeof insecureHTTPParser !== 'boolean') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'options.insecureHTTPParser'\x2C 'boolean'\x2C insecureHTTPParser);\n  }\n  this.insecureHTTPParser = insecureHTTPParser;\n\n  this.path = options.path || '/';\n  if (cb) {\n    this.once('response'\x2C cb);\n  }\n\n  if (method === 'GET' ||\n      method === 'HEAD' ||\n      method === 'DELETE' ||\n      method === 'OPTIONS' ||\n      method === 'TRACE' ||\n      method === 'CONNECT') {\n    this.useChunkedEncodingByDefault = false;\n  } else {\n    this.useChunkedEncodingByDefault = true;\n  }\n\n  this._ended = false;\n  this.res = null;\n  this.aborted = false;\n  this.timeoutCb = null;\n  this.upgradeOrConnect = false;\n  this.parser = null;\n  this.maxHeadersCount = null;\n  this.reusedSocket = false;\n  this.host = host;\n  this.protocol = protocol;\n\n  if (this.agent) {\n    // If there is an agent we should default to Connection:keep-alive\x2C\n    // but only if the Agent will actually reuse the connection!\n    // If it's not a keepAlive agent\x2C and the maxSockets==Infinity\x2C then\n    // there's never a case where this socket will actually be reused\n    if (!this.agent.keepAlive && !NumberIsFinite(this.agent.maxSockets)) {\n      this._last = true;\n      this.shouldKeepAlive = false;\n    } else {\n      this._last = false;\n      this.shouldKeepAlive = true;\n    }\n  }\n\n  const headersArray = ArrayIsArray(options.headers);\n  if (!headersArray) {\n    if (options.headers) {\n      const keys = ObjectKeys(options.headers);\n      // Retain for(;;) loop for performance reasons\n      // Refs: https://github.com/nodejs/node/pull/30958\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        this.setHeader(key\x2C options.headers[key]);\n      }\n    }\n\n    if (host && !this.getHeader('host') && setHost) {\n      let hostHeader = host;\n\n      // For the Host header\x2C ensure that IPv6 addresses are enclosed\n      // in square brackets\x2C as defined by URI formatting\n      // https://tools.ietf.org/html/rfc3986#section-3.2.2\n      const posColon = StringPrototypeIndexOf(hostHeader\x2C ':');\n      if (posColon !== -1 &&\n          StringPrototypeIncludes(hostHeader\x2C ':'\x2C posColon + 1) &&\n          StringPrototypeCharCodeAt(hostHeader\x2C 0) !== 91/* '[' */) {\n        hostHeader = `[${hostHeader}]`;\n      }\n\n      if (port && +port !== defaultPort) {\n        hostHeader += ':' + port;\n      }\n      this.setHeader('Host'\x2C hostHeader);\n    }\n\n    if (options.auth && !this.getHeader('Authorization')) {\n      this.setHeader('Authorization'\x2C 'Basic ' +\n                     Buffer.from(options.auth).toString('base64'));\n    }\n\n    if (this.getHeader('expect')) {\n      if (this._header) {\n        throw new ERR_HTTP_HEADERS_SENT('render');\n      }\n\n      this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\r\\n'\x2C\n                        this[kOutHeaders]);\n    }\n  } else {\n    this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\r\\n'\x2C\n                      options.headers);\n  }\n\n  let optsWithoutSignal = options;\n  if (optsWithoutSignal.signal) {\n    optsWithoutSignal = ObjectAssign({}\x2C options);\n    delete optsWithoutSignal.signal;\n  }\n\n  // initiate connection\n  if (this.agent) {\n    this.agent.addRequest(this\x2C optsWithoutSignal);\n  } else {\n    // No agent\x2C default to Connection:close.\n    this._last = true;\n    this.shouldKeepAlive = false;\n    if (typeof optsWithoutSignal.createConnection === 'function') {\n      const oncreate = once((err\x2C socket) => {\n        if (err) {\n          process.nextTick(() => this.emit('error'\x2C err));\n        } else {\n          this.onSocket(socket);\n        }\n      });\n\n      try {\n        const newSocket = optsWithoutSignal.createConnection(optsWithoutSignal\x2C\n                                                             oncreate);\n        if (newSocket) {\n          oncreate(null\x2C newSocket);\n        }\n      } catch (err) {\n        oncreate(err);\n      }\n    } else {\n      debug('CLIENT use net.createConnection'\x2C optsWithoutSignal);\n      this.onSocket(net.createConnection(optsWithoutSignal));\n    }\n  }\n}\nObjectSetPrototypeOf(ClientRequest.prototype\x2C OutgoingMessage.prototype);\nObjectSetPrototypeOf(ClientRequest\x2C OutgoingMessage);\n\nClientRequest.prototype._finish = function _finish() {\n  DTRACE_HTTP_CLIENT_REQUEST(this\x2C this.socket);\n  FunctionPrototypeCall(OutgoingMessage.prototype._finish\x2C this);\n};\n\nClientRequest.prototype._implicitHeader = function _implicitHeader() {\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT('render');\n  }\n  this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\r\\n'\x2C\n                    this[kOutHeaders]);\n};\n\nClientRequest.prototype.abort = function abort() {\n  if (this.aborted) {\n    return;\n  }\n  this.aborted = true;\n  process.nextTick(emitAbortNT\x2C this);\n  this.destroy();\n};\n\nClientRequest.prototype.destroy = function destroy(err) {\n  if (this.destroyed) {\n    return this;\n  }\n  this.destroyed = true;\n\n  // If we're aborting\x2C we don't care about any more response data.\n  if (this.res) {\n    this.res._dump();\n  }\n\n  this[kError] = err;\n  this.socket?.destroy(err);\n\n  return this;\n};\n\nfunction emitAbortNT(req) {\n  req.emit('abort');\n}\n\nfunction ondrain() {\n  const msg = this._httpMessage;\n  if (msg && !msg.finished && msg[kNeedDrain]) {\n    msg[kNeedDrain] = false;\n    msg.emit('drain');\n  }\n}\n\nfunction socketCloseListener() {\n  const socket = this;\n  const req = socket._httpMessage;\n  debug('HTTP socket close');\n\n  // NOTE: It's important to get parser here\x2C because it could be freed by\n  // the `socketOnData`.\n  const parser = socket.parser;\n  const res = req.res;\n\n  req.destroyed = true;\n  if (res) {\n    // Socket closed before we emitted 'end' below.\n    if (!res.complete) {\n      res.destroy(connResetException('aborted'));\n    }\n    req._closed = true;\n    req.emit('close');\n    if (!res.aborted && res.readable) {\n      res.push(null);\n    }\n  } else {\n    if (!req.socket._hadError) {\n      // This socket error fired before we started to\n      // receive a response. The error needs to\n      // fire on the request.\n      req.socket._hadError = true;\n      req.emit('error'\x2C connResetException('socket hang up'));\n    }\n    req._closed = true;\n    req.emit('close');\n  }\n\n  // Too bad.  That output wasn't getting written.\n  // This is pretty terrible that it doesn't raise an error.\n  // Fixed better in v0.10\n  if (req.outputData)\n    req.outputData.length = 0;\n\n  if (parser) {\n    parser.finish();\n    freeParser(parser\x2C req\x2C socket);\n  }\n}\n\nfunction socketErrorListener(err) {\n  const socket = this;\n  const req = socket._httpMessage;\n  debug('SOCKET ERROR:'\x2C err.message\x2C err.stack);\n\n  if (req) {\n    // For Safety. Some additional errors might fire later on\n    // and we need to make sure we don't double-fire the error event.\n    req.socket._hadError = true;\n    req.emit('error'\x2C err);\n  }\n\n  const parser = socket.parser;\n  if (parser) {\n    parser.finish();\n    freeParser(parser\x2C req\x2C socket);\n  }\n\n  // Ensure that no further data will come out of the socket\n  socket.removeListener('data'\x2C socketOnData);\n  socket.removeListener('end'\x2C socketOnEnd);\n  socket.destroy();\n}\n\nfunction socketOnEnd() {\n  const socket = this;\n  const req = this._httpMessage;\n  const parser = this.parser;\n\n  if (!req.res && !req.socket._hadError) {\n    // If we don't have a response then we know that the socket\n    // ended prematurely and we need to emit an error on the request.\n    req.socket._hadError = true;\n    req.emit('error'\x2C connResetException('socket hang up'));\n  }\n  if (parser) {\n    parser.finish();\n    freeParser(parser\x2C req\x2C socket);\n  }\n  socket.destroy();\n}\n\nfunction socketOnData(d) {\n  const socket = this;\n  const req = this._httpMessage;\n  const parser = this.parser;\n\n  assert(parser && parser.socket === socket);\n\n  const ret = parser.execute(d);\n  if (ret instanceof Error) {\n    prepareError(ret\x2C parser\x2C d);\n    debug('parse error'\x2C ret);\n    freeParser(parser\x2C req\x2C socket);\n    socket.removeListener('data'\x2C socketOnData);\n    socket.removeListener('end'\x2C socketOnEnd);\n    socket.destroy();\n    req.socket._hadError = true;\n    req.emit('error'\x2C ret);\n  } else if (parser.incoming && parser.incoming.upgrade) {\n    // Upgrade (if status code 101) or CONNECT\n    const bytesParsed = ret;\n    const res = parser.incoming;\n    req.res = res;\n\n    socket.removeListener('data'\x2C socketOnData);\n    socket.removeListener('end'\x2C socketOnEnd);\n    socket.removeListener('drain'\x2C ondrain);\n\n    if (req.timeoutCb) socket.removeListener('timeout'\x2C req.timeoutCb);\n    socket.removeListener('timeout'\x2C responseOnTimeout);\n\n    parser.finish();\n    freeParser(parser\x2C req\x2C socket);\n\n    const bodyHead = TypedArrayPrototypeSlice(d\x2C bytesParsed\x2C d.length);\n\n    const eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\n    if (req.listenerCount(eventName) > 0) {\n      req.upgradeOrConnect = true;\n\n      // detach the socket\n      socket.emit('agentRemove');\n      socket.removeListener('close'\x2C socketCloseListener);\n      socket.removeListener('error'\x2C socketErrorListener);\n\n      socket._httpMessage = null;\n      socket.readableFlowing = null;\n\n      req.emit(eventName\x2C res\x2C socket\x2C bodyHead);\n      req.destroyed = true;\n      req._closed = true;\n      req.emit('close');\n    } else {\n      // Requested Upgrade or used CONNECT method\x2C but have no handler.\n      socket.destroy();\n    }\n  } else if (parser.incoming && parser.incoming.complete &&\n             // When the status code is informational (100\x2C 102-199)\x2C\n             // the server will send a final response after this client\n             // sends a request body\x2C so we must not free the parser.\n             // 101 (Switching Protocols) and all other status codes\n             // should be processed normally.\n             !statusIsInformational(parser.incoming.statusCode)) {\n    socket.removeListener('data'\x2C socketOnData);\n    socket.removeListener('end'\x2C socketOnEnd);\n    socket.removeListener('drain'\x2C ondrain);\n    freeParser(parser\x2C req\x2C socket);\n  }\n}\n\nfunction statusIsInformational(status) {\n  // 100 (Continue)    RFC7231 Section 6.2.1\n  // 102 (Processing)  RFC2518\n  // 103 (Early Hints) RFC8297\n  // 104-199 (Unassigned)\n  return (status < 200 && status >= 100 && status !== 101);\n}\n\n// client\nfunction parserOnIncomingClient(res\x2C shouldKeepAlive) {\n  const socket = this.socket;\n  const req = socket._httpMessage;\n\n  debug('AGENT incoming response!');\n\n  if (req.res) {\n    // We already have a response object\x2C this means the server\n    // sent a double response.\n    socket.destroy();\n    return 0;  // No special treatment.\n  }\n  req.res = res;\n\n  // Skip body and treat as Upgrade.\n  if (res.upgrade)\n    return 2;\n\n  // Responses to CONNECT request is handled as Upgrade.\n  const method = req.method;\n  if (method === 'CONNECT') {\n    res.upgrade = true;\n    return 2;  // Skip body and treat as Upgrade.\n  }\n\n  if (statusIsInformational(res.statusCode)) {\n    // Restart the parser\x2C as this is a 1xx informational message.\n    req.res = null; // Clear res so that we don't hit double-responses.\n    // Maintain compatibility by sending 100-specific events\n    if (res.statusCode === 100) {\n      req.emit('continue');\n    }\n    // Send information events to all 1xx responses except 101 Upgrade.\n    req.emit('information'\x2C {\n      statusCode: res.statusCode\x2C\n      statusMessage: res.statusMessage\x2C\n      httpVersion: res.httpVersion\x2C\n      httpVersionMajor: res.httpVersionMajor\x2C\n      httpVersionMinor: res.httpVersionMinor\x2C\n      headers: res.headers\x2C\n      rawHeaders: res.rawHeaders\n    });\n\n    return 1;  // Skip body but don't treat as Upgrade.\n  }\n\n  if (req.shouldKeepAlive && !shouldKeepAlive && !req.upgradeOrConnect) {\n    // Server MUST respond with Connection:keep-alive for us to enable it.\n    // If we've been upgraded (via WebSockets) we also shouldn't try to\n    // keep the connection open.\n    req.shouldKeepAlive = false;\n  }\n\n  DTRACE_HTTP_CLIENT_RESPONSE(socket\x2C req);\n  req.res = res;\n  res.req = req;\n\n  // Add our listener first\x2C so that we guarantee socket cleanup\n  res.on('end'\x2C responseOnEnd);\n  req.on('prefinish'\x2C requestOnPrefinish);\n  socket.on('timeout'\x2C responseOnTimeout);\n\n  // If the user did not listen for the 'response' event\x2C then they\n  // can't possibly read the data\x2C so we ._dump() it into the void\n  // so that the socket doesn't hang there in a paused state.\n  if (req.aborted || !req.emit('response'\x2C res))\n    res._dump();\n\n  if (method === 'HEAD')\n    return 1;  // Skip body but don't treat as Upgrade.\n\n  if (res.statusCode === 304) {\n    res.complete = true;\n    return 1; // Skip body as there won't be any\n  }\n\n  return 0;  // No special treatment.\n}\n\n// client\nfunction responseKeepAlive(req) {\n  const socket = req.socket;\n\n  debug('AGENT socket keep-alive');\n  if (req.timeoutCb) {\n    socket.setTimeout(0\x2C req.timeoutCb);\n    req.timeoutCb = null;\n  }\n  socket.removeListener('close'\x2C socketCloseListener);\n  socket.removeListener('error'\x2C socketErrorListener);\n  socket.removeListener('data'\x2C socketOnData);\n  socket.removeListener('end'\x2C socketOnEnd);\n\n  // TODO(ronag): Between here and emitFreeNT the socket\n  // has no 'error' handler.\n\n  // There are cases where _handle === null. Avoid those. Passing undefined to\n  // nextTick() will call getDefaultTriggerAsyncId() to retrieve the id.\n  const asyncId = socket._handle ? socket._handle.getAsyncId() : undefined;\n  // Mark this socket as available\x2C AFTER user-added end\n  // handlers have a chance to run.\n  defaultTriggerAsyncIdScope(asyncId\x2C process.nextTick\x2C emitFreeNT\x2C req);\n\n  req.destroyed = true;\n  if (req.res) {\n    // Detach socket from IncomingMessage to avoid destroying the freed\n    // socket in IncomingMessage.destroy().\n    req.res.socket = null;\n  }\n}\n\nfunction responseOnEnd() {\n  const req = this.req;\n  const socket = req.socket;\n\n  if (socket) {\n    if (req.timeoutCb) socket.removeListener('timeout'\x2C emitRequestTimeout);\n    socket.removeListener('timeout'\x2C responseOnTimeout);\n  }\n\n  req._ended = true;\n\n  if (!req.shouldKeepAlive) {\n    if (socket.writable) {\n      debug('AGENT socket.destroySoon()');\n      if (typeof socket.destroySoon === 'function')\n        socket.destroySoon();\n      else\n        socket.end();\n    }\n    assert(!socket.writable);\n  } else if (req.finished && !this.aborted) {\n    // We can assume `req.finished` means all data has been written since:\n    // - `'responseOnEnd'` means we have been assigned a socket.\n    // - when we have a socket we write directly to it without buffering.\n    // - `req.finished` means `end()` has been called and no further data.\n    //   can be written\n    responseKeepAlive(req);\n  }\n}\n\nfunction responseOnTimeout() {\n  const req = this._httpMessage;\n  if (!req) return;\n  const res = req.res;\n  if (!res) return;\n  res.emit('timeout');\n}\n\nfunction requestOnPrefinish() {\n  const req = this;\n\n  if (req.shouldKeepAlive && req._ended)\n    responseKeepAlive(req);\n}\n\nfunction emitFreeNT(req) {\n  req._closed = true;\n  req.emit('close');\n  if (req.socket) {\n    req.socket.emit('free');\n  }\n}\n\nfunction tickOnSocket(req\x2C socket) {\n  const parser = parsers.alloc();\n  req.socket = socket;\n  const lenient = req.insecureHTTPParser === undefined ?\n    isLenient() : req.insecureHTTPParser;\n  parser.initialize(HTTPParser.RESPONSE\x2C\n                    new HTTPClientAsyncResource('HTTPINCOMINGMESSAGE'\x2C req)\x2C\n                    req.maxHeaderSize || 0\x2C\n                    lenient ? kLenientAll : kLenientNone\x2C\n                    0);\n  parser.socket = socket;\n  parser.outgoing = req;\n  req.parser = parser;\n\n  socket.parser = parser;\n  socket._httpMessage = req;\n\n  // Propagate headers limit from request object to parser\n  if (typeof req.maxHeadersCount === 'number') {\n    parser.maxHeaderPairs = req.maxHeadersCount << 1;\n  }\n\n  parser.onIncoming = parserOnIncomingClient;\n  socket.on('error'\x2C socketErrorListener);\n  socket.on('data'\x2C socketOnData);\n  socket.on('end'\x2C socketOnEnd);\n  socket.on('close'\x2C socketCloseListener);\n  socket.on('drain'\x2C ondrain);\n\n  if (\n    req.timeout !== undefined ||\n    (req.agent && req.agent.options && req.agent.options.timeout)\n  ) {\n    listenSocketTimeout(req);\n  }\n  req.emit('socket'\x2C socket);\n}\n\nfunction emitRequestTimeout() {\n  const req = this._httpMessage;\n  if (req) {\n    req.emit('timeout');\n  }\n}\n\nfunction listenSocketTimeout(req) {\n  if (req.timeoutCb) {\n    return;\n  }\n  // Set timeoutCb so it will get cleaned up on request end.\n  req.timeoutCb = emitRequestTimeout;\n  // Delegate socket timeout event.\n  if (req.socket) {\n    req.socket.once('timeout'\x2C emitRequestTimeout);\n  } else {\n    req.on('socket'\x2C (socket) => {\n      socket.once('timeout'\x2C emitRequestTimeout);\n    });\n  }\n}\n\nClientRequest.prototype.onSocket = function onSocket(socket\x2C err) {\n  // TODO(ronag): Between here and onSocketNT the socket\n  // has no 'error' handler.\n  process.nextTick(onSocketNT\x2C this\x2C socket\x2C err);\n};\n\nfunction onSocketNT(req\x2C socket\x2C err) {\n  if (req.destroyed || err) {\n    req.destroyed = true;\n\n    function _destroy(req\x2C err) {\n      if (!req.aborted && !err) {\n        err = connResetException('socket hang up');\n      }\n      if (err) {\n        req.emit('error'\x2C err);\n      }\n      req._closed = true;\n      req.emit('close');\n    }\n\n    if (socket) {\n      if (!err && req.agent && !socket.destroyed) {\n        socket.emit('free');\n      } else {\n        finished(socket.destroy(err || req[kError])\x2C (er) => {\n          if (er?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n            er = null;\n          }\n          _destroy(req\x2C er || err);\n        });\n        return;\n      }\n    }\n\n    _destroy(req\x2C err || req[kError]);\n  } else {\n    tickOnSocket(req\x2C socket);\n    req._flush();\n  }\n}\n\nClientRequest.prototype._deferToConnect = _deferToConnect;\nfunction _deferToConnect(method\x2C arguments_) {\n  // This function is for calls that need to happen once the socket is\n  // assigned to this request and writable. It's an important promisy\n  // thing for all the socket calls that happen either now\n  // (when a socket is assigned) or in the future (when a socket gets\n  // assigned out of the pool and is eventually writable).\n\n  const callSocketMethod = () => {\n    if (method)\n      ReflectApply(this.socket[method]\x2C this.socket\x2C arguments_);\n  };\n\n  const onSocket = () => {\n    if (this.socket.writable) {\n      callSocketMethod();\n    } else {\n      this.socket.once('connect'\x2C callSocketMethod);\n    }\n  };\n\n  if (!this.socket) {\n    this.once('socket'\x2C onSocket);\n  } else {\n    onSocket();\n  }\n}\n\nClientRequest.prototype.setTimeout = function setTimeout(msecs\x2C callback) {\n  if (this._ended) {\n    return this;\n  }\n\n  listenSocketTimeout(this);\n  msecs = getTimerDuration(msecs\x2C 'msecs');\n  if (callback) this.once('timeout'\x2C callback);\n\n  if (this.socket) {\n    setSocketTimeout(this.socket\x2C msecs);\n  } else {\n    this.once('socket'\x2C (sock) => setSocketTimeout(sock\x2C msecs));\n  }\n\n  return this;\n};\n\nfunction setSocketTimeout(sock\x2C msecs) {\n  if (sock.connecting) {\n    sock.once('connect'\x2C function() {\n      sock.setTimeout(msecs);\n    });\n  } else {\n    sock.setTimeout(msecs);\n  }\n}\n\nClientRequest.prototype.setNoDelay = function setNoDelay(noDelay) {\n  this._deferToConnect('setNoDelay'\x2C [noDelay]);\n};\n\nClientRequest.prototype.setSocketKeepAlive =\n    function setSocketKeepAlive(enable\x2C initialDelay) {\n      this._deferToConnect('setKeepAlive'\x2C [enable\x2C initialDelay]);\n    };\n\nClientRequest.prototype.clearTimeout = function clearTimeout(cb) {\n  this.setTimeout(0\x2C cb);\n};\n\nmodule.exports = {\n  ClientRequest\n};\n
code-source-info,0x2cbd764afb16,154,0,25994,C0O0C4O25994,,
code-creation,Function,10,76000,0x2cbd764b0ad6,940, node:_http_client:1:1,0x2cbd764afa90,~
code-source-info,0x2cbd764b0ad6,154,0,25994,C0O0C286O1159C292O1175C298O1186C304O1195C310O1220C316O1238C322O1254C328O1268C333O1292C339O1308C345O1331C351O1341C357O1370C363O1397C369O1423C375O1453C380O1463C386O1519C389O1519C393O1519C395O1550C398O1550C402O1550C404O1595C407O1595C412O1586C418O1740C421O1740C426O1650C432O1670C438O1684C444O1695C450O1709C456O1722C462O1793C465O1793C470O1773C476O1834C479O1834C483O1834C485O1877C488O1877C493O1866C499O1935C502O1935C507O1904C513O2022C516O2022C521O1976C527O1981C533O1999C539O2083C542O2083C547O2055C553O2068C559O2147C562O2147C567O2117C573O2137C578O2185C584O2210C590O2234C596O2260C602O2284C608O2351C611O2351C616O2330C622O2412C625O2412C630O2391C636O2512C639O2512C644O2450C650O2480C656O2578C659O2578C664O2549C670O2565C676O2610C679O2610C684O2643C697O2644C703O2610C705O2717C709O2717C711O2752C714O2752C718O2752C720O2791C723O2802C727O2814C730O2791C732O2840C735O2851C739O2864C742O2840C765O3165C767O10531C775O10558C780O10496C785O10570C788O10570C793O10639C802O10657C806O10813C815O10839C819O11070C828O11086C832O11243C841O11261C845O23164C854O23183C858O24169C865O24195C869O24982C878O25003C882O25575C891O25596C895O25696C904O25725C908O25873C917O25896C921O25956C928O25977C934O25971C939O25993,,
tick,0x1bfd70c28,76084,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x2cbd764a9e64,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89d6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,76209,0x2cbd764b3a36,5, node:_http_common:1:1,0x2cbd764b3700,~
script-source,155,node:_http_common,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  MathMin\x2C\n  Symbol\x2C\n  RegExpPrototypeTest\x2C\n} = primordials;\nconst { setImmediate } = require('timers');\n\nconst { methods\x2C HTTPParser } = internalBinding('http_parser');\nconst { getOptionValue } = require('internal/options');\nconst insecureHTTPParser = getOptionValue('--insecure-http-parser');\n\nconst FreeList = require('internal/freelist');\nconst incoming = require('_http_incoming');\nconst {\n  IncomingMessage\x2C\n  readStart\x2C\n  readStop\n} = incoming;\n\nlet debug = require('internal/util/debuglog').debuglog('http'\x2C (fn) => {\n  debug = fn;\n});\n\nconst kIncomingMessage = Symbol('IncomingMessage');\nconst kRequestTimeout = Symbol('RequestTimeout');\nconst kOnMessageBegin = HTTPParser.kOnMessageBegin | 0;\nconst kOnHeaders = HTTPParser.kOnHeaders | 0;\nconst kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;\nconst kOnBody = HTTPParser.kOnBody | 0;\nconst kOnMessageComplete = HTTPParser.kOnMessageComplete | 0;\nconst kOnExecute = HTTPParser.kOnExecute | 0;\nconst kOnTimeout = HTTPParser.kOnTimeout | 0;\n\nconst MAX_HEADER_PAIRS = 2000;\n\n// Only called in the slow case where slow means\n// that the request headers were either fragmented\n// across multiple TCP packets or too large to be\n// processed in a single run. This method is also\n// called to process trailing HTTP headers.\nfunction parserOnHeaders(headers\x2C url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers.push(...headers);\n  }\n  this._url += url;\n}\n\n// `headers` and `url` are set only if .onHeaders() has not been called for\n// this request.\n// `url` is not set for response parsers but that's not applicable here since\n// all our parsers are request parsers.\nfunction parserOnHeadersComplete(versionMajor\x2C versionMinor\x2C headers\x2C method\x2C\n                                 url\x2C statusCode\x2C statusMessage\x2C upgrade\x2C\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  if (socket) {\n    debug('requestTimeout timer moved to req');\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\n    incoming.socket[kRequestTimeout] = undefined;\n  }\n\n  let n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = MathMin(n\x2C parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers\x2C n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming\x2C shouldKeepAlive);\n}\n\nfunction parserOnBody(b\x2C start\x2C len) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed\x2C then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    const slice = b.slice(start\x2C start + len);\n    const ret = stream.push(slice);\n    if (!ret)\n      readStop(this.socket);\n  }\n}\n\nfunction parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers\x2C headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n}\n\n\nconst parsers = new FreeList('parsers'\x2C 1000\x2C function parsersCb() {\n  const parser = new HTTPParser();\n\n  cleanParser(parser);\n\n  parser[kOnHeaders] = parserOnHeaders;\n  parser[kOnHeadersComplete] = parserOnHeadersComplete;\n  parser[kOnBody] = parserOnBody;\n  parser[kOnMessageComplete] = parserOnMessageComplete;\n\n  return parser;\n});\n\nfunction closeParserInstance(parser) { parser.close(); }\n\n// Free the parser and also break any links that it\n// might have to any other things.\n// TODO: All parser data should be attached to a\n// single object\x2C so that it can be easily cleaned\n// up by doing `parser.data = {}`\x2C which should\n// be done in FreeList.free.  `parsers.free(parser)`\n// should be all that is needed.\nfunction freeParser(parser\x2C req\x2C socket) {\n  if (parser) {\n    if (parser._consumed)\n      parser.unconsume();\n    cleanParser(parser);\n    if (parsers.free(parser) === false) {\n      // Make sure the parser's stack has unwound before deleting the\n      // corresponding C++ object through .close().\n      setImmediate(closeParserInstance\x2C parser);\n    } else {\n      // Since the Parser destructor isn't going to run the destroy() callbacks\n      // it needs to be triggered manually.\n      parser.free();\n    }\n  }\n  if (req) {\n    req.parser = null;\n  }\n  if (socket) {\n    socket.parser = null;\n  }\n}\n\nconst tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/;\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nfunction checkIsHttpToken(val) {\n  return RegExpPrototypeTest(tokenRegExp\x2C val);\n}\n\nconst headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n/**\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */\nfunction checkInvalidHeaderChar(val) {\n  return RegExpPrototypeTest(headerCharRegex\x2C val);\n}\n\nfunction cleanParser(parser) {\n  parser._headers = [];\n  parser._url = '';\n  parser.socket = null;\n  parser.incoming = null;\n  parser.outgoing = null;\n  parser.maxHeaderPairs = MAX_HEADER_PAIRS;\n  parser[kOnMessageBegin] = null;\n  parser[kOnExecute] = null;\n  parser[kOnTimeout] = null;\n  parser._consumed = false;\n  parser.onIncoming = null;\n}\n\nfunction prepareError(err\x2C parser\x2C rawPacket) {\n  err.rawPacket = rawPacket || parser.getCurrentBuffer();\n  if (typeof err.reason === 'string')\n    err.message = `Parse Error: ${err.reason}`;\n}\n\nlet warnedLenient = false;\n\nfunction isLenient() {\n  if (insecureHTTPParser && !warnedLenient) {\n    warnedLenient = true;\n    process.emitWarning('Using insecure HTTP parsing');\n  }\n  return insecureHTTPParser;\n}\n\nmodule.exports = {\n  _checkInvalidHeaderChar: checkInvalidHeaderChar\x2C\n  _checkIsHttpToken: checkIsHttpToken\x2C\n  chunkExpression: /(?:^|\\W)chunked(?:$|\\W)/i\x2C\n  continueExpression: /(?:^|\\W)100-continue(?:$|\\W)/i\x2C\n  CRLF: '\\r\\n'\x2C // TODO: Deprecate this.\n  freeParser\x2C\n  methods\x2C\n  parsers\x2C\n  kIncomingMessage\x2C\n  kRequestTimeout\x2C\n  HTTPParser\x2C\n  isLenient\x2C\n  prepareError\x2C\n};\n
code-source-info,0x2cbd764b3a36,155,0,8466,C0O0C4O8466,,
code-creation,Function,10,76500,0x2cbd764b416e,512, node:_http_common:1:1,0x2cbd764b39b0,~
code-source-info,0x2cbd764b416e,155,0,8466,C0O0C142O1159C148O1170C153O1180C159O1243C162O1243C167O1226C173O1295C176O1295C181O1271C187O1280C193O1354C196O1354C201O1335C206O1410C209O1410C213O1410C215O1470C218O1470C223O1517C226O1517C231O1554C237O1573C243O1586C249O1622C252O1622C257O1655C270O1656C276O1622C278O1727C281O1727C285O1727C287O1778C290O1778C294O1778C296O1828C299O1839C303O1855C306O1828C308O1879C311O1890C315O1901C318O1879C320O1933C323O1944C327O1963C330O1933C332O1984C335O1995C339O2003C342O1984C344O2035C347O2046C351O2065C354O2035C356O2089C359O2100C363O2111C366O2089C368O2135C371O2146C375O2157C378O2135C380O2188C384O2188C386O5382C401O5382C406O5382C408O6709C412O6709C414O7007C418O7007C420O7898C421O7898C423O8093C430O8139C436O8184C440O8221C448O8271C458O8347C464O8361C470O8372C476O8383C482O8403C488O8422C494O8436C500O8449C506O8108C511O8465,,
code-creation,Eval,10,76625,0x2cbd764b5efe,5, node:internal/freelist:1:1,0x2cbd764b5da8,~
script-source,156,node:internal/freelist,'use strict';\n\nconst {\n  ReflectApply\x2C\n} = primordials;\n\nclass FreeList {\n  constructor(name\x2C max\x2C ctor) {\n    this.name = name;\n    this.ctor = ctor;\n    this.max = max;\n    this.list = [];\n  }\n\n  alloc() {\n    return this.list.length > 0 ?\n      this.list.pop() :\n      ReflectApply(this.ctor\x2C this\x2C arguments);\n  }\n\n  free(obj) {\n    if (this.list.length < this.max) {\n      this.list.push(obj);\n      return true;\n    }\n    return false;\n  }\n}\n\nmodule.exports = FreeList;\n
code-source-info,0x2cbd764b5efe,156,0,476,C0O0C4O476,,
code-creation,Function,10,76667,0x2cbd764b6206,54, node:internal/freelist:1:1,0x2cbd764b5e78,~
code-source-info,0x2cbd764b6206,156,0,476,C0O0C8O25C46O449C48O464C53O475,,
code-creation,Eval,10,76792,0x2cbd764b691e,5, node:_http_incoming:1:1,0x2cbd764b6708,~
script-source,157,node:_http_incoming,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\n} = primordials;\n\nconst { Readable\x2C finished } = require('stream');\n\nconst kHeaders = Symbol('kHeaders');\nconst kHeadersCount = Symbol('kHeadersCount');\nconst kTrailers = Symbol('kTrailers');\nconst kTrailersCount = Symbol('kTrailersCount');\n\nfunction readStart(socket) {\n  if (socket && !socket._paused && socket.readable)\n    socket.resume();\n}\n\nfunction readStop(socket) {\n  if (socket)\n    socket.pause();\n}\n\n/* Abstract base class for ServerRequest and ClientResponse. */\nfunction IncomingMessage(socket) {\n  let streamOptions;\n\n  if (socket) {\n    streamOptions = {\n      highWaterMark: socket.readableHighWaterMark\n    };\n  }\n\n  Readable.call(this\x2C streamOptions);\n\n  this._readableState.readingMore = true;\n\n  this.socket = socket;\n\n  this.httpVersionMajor = null;\n  this.httpVersionMinor = null;\n  this.httpVersion = null;\n  this.complete = false;\n  this[kHeaders] = null;\n  this[kHeadersCount] = 0;\n  this.rawHeaders = [];\n  this[kTrailers] = null;\n  this[kTrailersCount] = 0;\n  this.rawTrailers = [];\n\n  this.aborted = false;\n\n  this.upgrade = null;\n\n  // request (server) only\n  this.url = '';\n  this.method = null;\n\n  // response (client) only\n  this.statusCode = null;\n  this.statusMessage = null;\n  this.client = socket;\n\n  this._consuming = false;\n  // Flag for when we decide that this message cannot possibly be\n  // read by the user\x2C so there's no point continuing to handle it.\n  this._dumped = false;\n}\nObjectSetPrototypeOf(IncomingMessage.prototype\x2C Readable.prototype);\nObjectSetPrototypeOf(IncomingMessage\x2C Readable);\n\nObjectDefineProperty(IncomingMessage.prototype\x2C 'connection'\x2C {\n  get: function() {\n    return this.socket;\n  }\x2C\n  set: function(val) {\n    this.socket = val;\n  }\n});\n\nObjectDefineProperty(IncomingMessage.prototype\x2C 'headers'\x2C {\n  get: function() {\n    if (!this[kHeaders]) {\n      this[kHeaders] = {};\n\n      const src = this.rawHeaders;\n      const dst = this[kHeaders];\n\n      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n        this._addHeaderLine(src[n + 0]\x2C src[n + 1]\x2C dst);\n      }\n    }\n    return this[kHeaders];\n  }\x2C\n  set: function(val) {\n    this[kHeaders] = val;\n  }\n});\n\nObjectDefineProperty(IncomingMessage.prototype\x2C 'trailers'\x2C {\n  get: function() {\n    if (!this[kTrailers]) {\n      this[kTrailers] = {};\n\n      const src = this.rawTrailers;\n      const dst = this[kTrailers];\n\n      for (let n = 0; n < this[kTrailersCount]; n += 2) {\n        this._addHeaderLine(src[n + 0]\x2C src[n + 1]\x2C dst);\n      }\n    }\n    return this[kTrailers];\n  }\x2C\n  set: function(val) {\n    this[kTrailers] = val;\n  }\n});\n\nIncomingMessage.prototype.setTimeout = function setTimeout(msecs\x2C callback) {\n  if (callback)\n    this.on('timeout'\x2C callback);\n  this.socket.setTimeout(msecs);\n  return this;\n};\n\n// Argument n cannot be factored out due to the overhead of\n// argument adaptor frame creation inside V8 in case that number of actual\n// arguments is different from expected arguments.\n// Ref: https://bugs.chromium.org/p/v8/issues/detail?id=10201\n// NOTE: Argument adapt frame issue might be solved in V8 engine v8.9.\n// Refactoring `n` out might be possible when V8 is upgraded to that\n// version.\n// Ref: https://v8.dev/blog/v8-release-89\nIncomingMessage.prototype._read = function _read(n) {\n  if (!this._consuming) {\n    this._readableState.readingMore = false;\n    this._consuming = true;\n  }\n\n  // We actually do almost nothing here\x2C because the parserOnBody\n  // function fills up our internal buffer directly.  However\x2C we\n  // do need to unpause the underlying socket so that it flows.\n  if (this.socket.readable)\n    readStart(this.socket);\n};\n\n// It's possible that the socket will be destroyed\x2C and removed from\n// any messages\x2C before ever calling this.  In that case\x2C just skip\n// it\x2C since something else is destroying this connection anyway.\nIncomingMessage.prototype._destroy = function _destroy(err\x2C cb) {\n  if (!this.readableEnded || !this.complete) {\n    this.aborted = true;\n    this.emit('aborted');\n  }\n\n  // If aborted and the underlying socket is not already destroyed\x2C\n  // destroy it.\n  // We have to check if the socket is already destroyed because finished\n  // does not call the callback when this method is invoked from `_http_client`\n  // in `test/parallel/test-http-client-spurious-aborted.js`\n  if (this.socket && !this.socket.destroyed && this.aborted) {\n    this.socket.destroy(err);\n    const cleanup = finished(this.socket\x2C (e) => {\n      if (e?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n        e = null;\n      }\n      cleanup();\n      process.nextTick(onError\x2C this\x2C e || err\x2C cb);\n    });\n  } else {\n    process.nextTick(onError\x2C this\x2C err\x2C cb);\n  }\n};\n\nIncomingMessage.prototype._addHeaderLines = _addHeaderLines;\nfunction _addHeaderLines(headers\x2C n) {\n  if (headers && headers.length) {\n    let dest;\n    if (this.complete) {\n      this.rawTrailers = headers;\n      this[kTrailersCount] = n;\n      dest = this[kTrailers];\n    } else {\n      this.rawHeaders = headers;\n      this[kHeadersCount] = n;\n      dest = this[kHeaders];\n    }\n\n    if (dest) {\n      for (let i = 0; i < n; i += 2) {\n        this._addHeaderLine(headers[i]\x2C headers[i + 1]\x2C dest);\n      }\n    }\n  }\n}\n\n\n// This function is used to help avoid the lowercasing of a field name if it\n// matches a 'traditional cased' version of a field name. It then returns the\n// lowercased name to both avoid calling toLowerCase() a second time and to\n// indicate whether the field was a 'no duplicates' field. If a field is not a\n// 'no duplicates' field\x2C a `0` byte is prepended as a flag. The one exception\n// to this is the Set-Cookie header which is indicated by a `1` byte flag\x2C since\n// it is an 'array' field and thus is treated differently in _addHeaderLines().\n// TODO: perhaps http_parser could be returning both raw and lowercased versions\n// of known header names to avoid us having to call toLowerCase() for those\n// headers.\nfunction matchKnownFields(field\x2C lowercased) {\n  switch (field.length) {\n    case 3:\n      if (field === 'Age' || field === 'age') return 'age';\n      break;\n    case 4:\n      if (field === 'Host' || field === 'host') return 'host';\n      if (field === 'From' || field === 'from') return 'from';\n      if (field === 'ETag' || field === 'etag') return 'etag';\n      if (field === 'Date' || field === 'date') return '\\u0000date';\n      if (field === 'Vary' || field === 'vary') return '\\u0000vary';\n      break;\n    case 6:\n      if (field === 'Server' || field === 'server') return 'server';\n      if (field === 'Cookie' || field === 'cookie') return '\\u0002cookie';\n      if (field === 'Origin' || field === 'origin') return '\\u0000origin';\n      if (field === 'Expect' || field === 'expect') return '\\u0000expect';\n      if (field === 'Accept' || field === 'accept') return '\\u0000accept';\n      break;\n    case 7:\n      if (field === 'Referer' || field === 'referer') return 'referer';\n      if (field === 'Expires' || field === 'expires') return 'expires';\n      if (field === 'Upgrade' || field === 'upgrade') return '\\u0000upgrade';\n      break;\n    case 8:\n      if (field === 'Location' || field === 'location')\n        return 'location';\n      if (field === 'If-Match' || field === 'if-match')\n        return '\\u0000if-match';\n      break;\n    case 10:\n      if (field === 'User-Agent' || field === 'user-agent')\n        return 'user-agent';\n      if (field === 'Set-Cookie' || field === 'set-cookie')\n        return '\\u0001';\n      if (field === 'Connection' || field === 'connection')\n        return '\\u0000connection';\n      break;\n    case 11:\n      if (field === 'Retry-After' || field === 'retry-after')\n        return 'retry-after';\n      break;\n    case 12:\n      if (field === 'Content-Type' || field === 'content-type')\n        return 'content-type';\n      if (field === 'Max-Forwards' || field === 'max-forwards')\n        return 'max-forwards';\n      break;\n    case 13:\n      if (field === 'Authorization' || field === 'authorization')\n        return 'authorization';\n      if (field === 'Last-Modified' || field === 'last-modified')\n        return 'last-modified';\n      if (field === 'Cache-Control' || field === 'cache-control')\n        return '\\u0000cache-control';\n      if (field === 'If-None-Match' || field === 'if-none-match')\n        return '\\u0000if-none-match';\n      break;\n    case 14:\n      if (field === 'Content-Length' || field === 'content-length')\n        return 'content-length';\n      break;\n    case 15:\n      if (field === 'Accept-Encoding' || field === 'accept-encoding')\n        return '\\u0000accept-encoding';\n      if (field === 'Accept-Language' || field === 'accept-language')\n        return '\\u0000accept-language';\n      if (field === 'X-Forwarded-For' || field === 'x-forwarded-for')\n        return '\\u0000x-forwarded-for';\n      break;\n    case 16:\n      if (field === 'Content-Encoding' || field === 'content-encoding')\n        return '\\u0000content-encoding';\n      if (field === 'X-Forwarded-Host' || field === 'x-forwarded-host')\n        return '\\u0000x-forwarded-host';\n      break;\n    case 17:\n      if (field === 'If-Modified-Since' || field === 'if-modified-since')\n        return 'if-modified-since';\n      if (field === 'Transfer-Encoding' || field === 'transfer-encoding')\n        return '\\u0000transfer-encoding';\n      if (field === 'X-Forwarded-Proto' || field === 'x-forwarded-proto')\n        return '\\u0000x-forwarded-proto';\n      break;\n    case 19:\n      if (field === 'Proxy-Authorization' || field === 'proxy-authorization')\n        return 'proxy-authorization';\n      if (field === 'If-Unmodified-Since' || field === 'if-unmodified-since')\n        return 'if-unmodified-since';\n      break;\n  }\n  if (lowercased) {\n    return '\\u0000' + field;\n  }\n  return matchKnownFields(StringPrototypeToLowerCase(field)\x2C true);\n}\n// Add the given (field\x2C value) pair to the message\n//\n// Per RFC2616\x2C section 4.2 it is acceptable to join multiple instances of the\n// same header with a '\x2C ' if the header in question supports specification of\n// multiple values this way. The one exception to this is the Cookie header\x2C\n// which has multiple values joined with a '; ' instead. If a header's values\n// cannot be joined in either of these ways\x2C we declare the first instance the\n// winner and drop the second. Extended header fields (those beginning with\n// 'x-') are always joined.\nIncomingMessage.prototype._addHeaderLine = _addHeaderLine;\nfunction _addHeaderLine(field\x2C value\x2C dest) {\n  field = matchKnownFields(field);\n  const flag = StringPrototypeCharCodeAt(field\x2C 0);\n  if (flag === 0 || flag === 2) {\n    field = StringPrototypeSlice(field\x2C 1);\n    // Make a delimited list\n    if (typeof dest[field] === 'string') {\n      dest[field] += (flag === 0 ? '\x2C ' : '; ') + value;\n    } else {\n      dest[field] = value;\n    }\n  } else if (flag === 1) {\n    // Array header -- only Set-Cookie at the moment\n    if (dest['set-cookie'] !== undefined) {\n      dest['set-cookie'].push(value);\n    } else {\n      dest['set-cookie'] = [value];\n    }\n  } else if (dest[field] === undefined) {\n    // Drop duplicates\n    dest[field] = value;\n  }\n}\n\n\n// Call this instead of resume() if we want to just\n// dump all the data to /dev/null\nIncomingMessage.prototype._dump = function _dump() {\n  if (!this._dumped) {\n    this._dumped = true;\n    // If there is buffered data\x2C it may trigger 'data' events.\n    // Remove 'data' event listeners explicitly.\n    this.removeAllListeners('data');\n    this.resume();\n  }\n};\n\nfunction onError(self\x2C error\x2C cb) {\n  // This is to keep backward compatible behavior.\n  // An error is emitted only if there are listeners attached to the event.\n  if (self.listenerCount('error') === 0) {\n    cb();\n  } else {\n    cb(error);\n  }\n}\n\nmodule.exports = {\n  IncomingMessage\x2C\n  readStart\x2C\n  readStop\n};\n
code-source-info,0x2cbd764b691e,157,0,13066,C0O0C4O13066,,
code-creation,Function,10,77292,0x2cbd764b72be,396, node:_http_incoming:1:1,0x2cbd764b6898,~
code-source-info,0x2cbd764b72be,157,0,13066,C0O0C74O1159C79O1183C84O1207C90O1236C96O1260C102O1290C107O1346C110O1346C115O1323C121O1333C127O1383C130O1383C134O1383C136O1425C139O1425C143O1425C145O1468C148O1468C152O1468C154O1512C157O1512C161O1512C163O2757C171O2777C176O2720C181O2789C184O2789C189O2876C202O2910C210O2959C218O2839C223O3044C236O3075C244O3381C252O3007C257O3469C270O3501C278O3813C286O3432C291O3881C300O3902C304O4503C313O4519C317O5120C326O5139C330O5956C337O5982C341O11644C348O11669C352O12490C361O12506C365O13001C372O13022C378O13041C384O13054C390O13016C395O13065,,
tick,0x10055878c,77292,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x2cbd764b4250,0x105108d28,0x10510894c,0x2cbd764b0c7b,0x105108d28,0x10510894c,0x2cbd764a9e64,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89d6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,77334,0x2cbd764b86e6,26,FreeList node:internal/freelist:8:14,0x2cbd764b5f30,~
code-source-info,0x2cbd764b86e6,156,87,194,C0O111C2O121C6O133C8O143C12O155C14O164C18O175C20O185C25O193,,
code-creation,Eval,10,77667,0x2cbd764b96be,5, node:_http_outgoing:1:1,0x2cbd764b9208,~
script-source,158,node:_http_outgoing,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  MathFloor\x2C\n  NumberPrototypeToString\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectValues\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeTest\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n} = primordials;\n\nconst { getDefaultHighWaterMark } = require('internal/streams/state');\nconst assert = require('internal/assert');\nconst EE = require('events');\nconst Stream = require('stream');\nconst internalUtil = require('internal/util');\nconst { kOutHeaders\x2C utcDate\x2C kNeedDrain } = require('internal/http');\nconst { Buffer } = require('buffer');\nconst {\n  _checkIsHttpToken: checkIsHttpToken\x2C\n  _checkInvalidHeaderChar: checkInvalidHeaderChar\x2C\n  chunkExpression: RE_TE_CHUNKED\x2C\n} = require('_http_common');\nconst {\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol }\n} = require('internal/async_hooks');\nconst {\n  codes: {\n    ERR_HTTP_HEADERS_SENT\x2C\n    ERR_HTTP_INVALID_HEADER_VALUE\x2C\n    ERR_HTTP_TRAILER_INVALID\x2C\n    ERR_INVALID_HTTP_TOKEN\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_CHAR\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n    ERR_STREAM_CANNOT_PIPE\x2C\n    ERR_STREAM_ALREADY_FINISHED\x2C\n    ERR_STREAM_WRITE_AFTER_END\x2C\n    ERR_STREAM_NULL_VALUES\x2C\n    ERR_STREAM_DESTROYED\n  }\x2C\n  hideStackFrames\n} = require('internal/errors');\nconst { validateString } = require('internal/validators');\nconst { isUint8Array } = require('internal/util/types');\n\nlet debug = require('internal/util/debuglog').debuglog('http'\x2C (fn) => {\n  debug = fn;\n});\n\nconst HIGH_WATER_MARK = getDefaultHighWaterMark();\n\nconst kCorked = Symbol('corked');\n\nconst nop = () => {};\n\nconst RE_CONN_CLOSE = /(?:^|\\W)close(?:$|\\W)/i;\n\n// isCookieField performs a case-insensitive comparison of a provided string\n// against the word "cookie." As of V8 6.6 this is faster than handrolling or\n// using a case-insensitive RegExp.\nfunction isCookieField(s) {\n  return s.length === 6 && StringPrototypeToLowerCase(s) === 'cookie';\n}\n\nfunction OutgoingMessage() {\n  Stream.call(this);\n\n  // Queue that holds all currently pending data\x2C until the response will be\n  // assigned to the socket (until it will its turn in the HTTP pipeline).\n  this.outputData = [];\n\n  // `outputSize` is an approximate measure of how much data is queued on this\n  // response. `_onPendingData` will be invoked to update similar global\n  // per-connection counter. That counter will be used to pause/unpause the\n  // TCP socket and HTTP Parser and thus handle the backpressure.\n  this.outputSize = 0;\n\n  this.writable = true;\n  this.destroyed = false;\n\n  this._last = false;\n  this.chunkedEncoding = false;\n  this.shouldKeepAlive = true;\n  this.maxRequestsOnConnectionReached = false;\n  this._defaultKeepAlive = true;\n  this.useChunkedEncodingByDefault = true;\n  this.sendDate = false;\n  this._removedConnection = false;\n  this._removedContLen = false;\n  this._removedTE = false;\n\n  this._contentLength = null;\n  this._hasBody = true;\n  this._trailer = '';\n  this[kNeedDrain] = false;\n\n  this.finished = false;\n  this._headerSent = false;\n  this[kCorked] = 0;\n  this._closed = false;\n\n  this.socket = null;\n  this._header = null;\n  this[kOutHeaders] = null;\n\n  this._keepAliveTimeout = 0;\n\n  this._onPendingData = nop;\n}\nObjectSetPrototypeOf(OutgoingMessage.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(OutgoingMessage\x2C Stream);\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableFinished'\x2C {\n  get() {\n    return (\n      this.finished &&\n      this.outputSize === 0 &&\n      (!this.socket || this.socket.writableLength === 0)\n    );\n  }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableObjectMode'\x2C {\n  get() {\n    return false;\n  }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableLength'\x2C {\n  get() {\n    return this.outputSize + (this.socket ? this.socket.writableLength : 0);\n  }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableHighWaterMark'\x2C {\n  get() {\n    return this.socket ? this.socket.writableHighWaterMark : HIGH_WATER_MARK;\n  }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableCorked'\x2C {\n  get() {\n    const corked = this.socket ? this.socket.writableCorked : 0;\n    return corked + this[kCorked];\n  }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C '_headers'\x2C {\n  get: internalUtil.deprecate(function() {\n    return this.getHeaders();\n  }\x2C 'OutgoingMessage.prototype._headers is deprecated'\x2C 'DEP0066')\x2C\n  set: internalUtil.deprecate(function(val) {\n    if (val == null) {\n      this[kOutHeaders] = null;\n    } else if (typeof val === 'object') {\n      const headers = this[kOutHeaders] = ObjectCreate(null);\n      const keys = ObjectKeys(val);\n      // Retain for(;;) loop for performance reasons\n      // Refs: https://github.com/nodejs/node/pull/30958\n      for (let i = 0; i < keys.length; ++i) {\n        const name = keys[i];\n        headers[StringPrototypeToLowerCase(name)] = [name\x2C val[name]];\n      }\n    }\n  }\x2C 'OutgoingMessage.prototype._headers is deprecated'\x2C 'DEP0066')\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'connection'\x2C {\n  get: function() {\n    return this.socket;\n  }\x2C\n  set: function(val) {\n    this.socket = val;\n  }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C '_headerNames'\x2C {\n  get: internalUtil.deprecate(function() {\n    const headers = this[kOutHeaders];\n    if (headers !== null) {\n      const out = ObjectCreate(null);\n      const keys = ObjectKeys(headers);\n      // Retain for(;;) loop for performance reasons\n      // Refs: https://github.com/nodejs/node/pull/30958\n      for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const val = headers[key][0];\n        out[key] = val;\n      }\n      return out;\n    }\n    return null;\n  }\x2C 'OutgoingMessage.prototype._headerNames is deprecated'\x2C 'DEP0066')\x2C\n  set: internalUtil.deprecate(function(val) {\n    if (typeof val === 'object' && val !== null) {\n      const headers = this[kOutHeaders];\n      if (!headers)\n        return;\n      const keys = ObjectKeys(val);\n      // Retain for(;;) loop for performance reasons\n      // Refs: https://github.com/nodejs/node/pull/30958\n      for (let i = 0; i < keys.length; ++i) {\n        const header = headers[keys[i]];\n        if (header)\n          header[0] = val[keys[i]];\n      }\n    }\n  }\x2C 'OutgoingMessage.prototype._headerNames is deprecated'\x2C 'DEP0066')\n});\n\n\nOutgoingMessage.prototype._renderHeaders = function _renderHeaders() {\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT('render');\n  }\n\n  const headersMap = this[kOutHeaders];\n  const headers = {};\n\n  if (headersMap !== null) {\n    const keys = ObjectKeys(headersMap);\n    // Retain for(;;) loop for performance reasons\n    // Refs: https://github.com/nodejs/node/pull/30958\n    for (let i = 0\x2C l = keys.length; i < l; i++) {\n      const key = keys[i];\n      headers[headersMap[key][0]] = headersMap[key][1];\n    }\n  }\n  return headers;\n};\n\nOutgoingMessage.prototype.cork = function() {\n  if (this.socket) {\n    this.socket.cork();\n  } else {\n    this[kCorked]++;\n  }\n};\n\nOutgoingMessage.prototype.uncork = function() {\n  if (this.socket) {\n    this.socket.uncork();\n  } else if (this[kCorked]) {\n    this[kCorked]--;\n  }\n};\n\nOutgoingMessage.prototype.setTimeout = function setTimeout(msecs\x2C callback) {\n\n  if (callback) {\n    this.on('timeout'\x2C callback);\n  }\n\n  if (!this.socket) {\n    this.once('socket'\x2C function socketSetTimeoutOnConnect(socket) {\n      socket.setTimeout(msecs);\n    });\n  } else {\n    this.socket.setTimeout(msecs);\n  }\n  return this;\n};\n\n\n// It's possible that the socket will be destroyed\x2C and removed from\n// any messages\x2C before ever calling this.  In that case\x2C just skip\n// it\x2C since something else is destroying this connection anyway.\nOutgoingMessage.prototype.destroy = function destroy(error) {\n  if (this.destroyed) {\n    return this;\n  }\n  this.destroyed = true;\n\n  if (this.socket) {\n    this.socket.destroy(error);\n  } else {\n    this.once('socket'\x2C function socketDestroyOnConnect(socket) {\n      socket.destroy(error);\n    });\n  }\n\n  return this;\n};\n\n\n// This abstract either writing directly to the socket or buffering it.\nOutgoingMessage.prototype._send = function _send(data\x2C encoding\x2C callback) {\n  // This is a shameful hack to get the headers and first body chunk onto\n  // the same packet. Future versions of Node are going to take care of\n  // this at a lower level and in a more general way.\n  if (!this._headerSent) {\n    if (typeof data === 'string' &&\n        (encoding === 'utf8' || encoding === 'latin1' || !encoding)) {\n      data = this._header + data;\n    } else {\n      const header = this._header;\n      this.outputData.unshift({\n        data: header\x2C\n        encoding: 'latin1'\x2C\n        callback: null\n      });\n      this.outputSize += header.length;\n      this._onPendingData(header.length);\n    }\n    this._headerSent = true;\n  }\n  return this._writeRaw(data\x2C encoding\x2C callback);\n};\n\n\nOutgoingMessage.prototype._writeRaw = _writeRaw;\nfunction _writeRaw(data\x2C encoding\x2C callback) {\n  const conn = this.socket;\n  if (conn && conn.destroyed) {\n    // The socket was destroyed. If we're still trying to write to it\x2C\n    // then we haven't gotten the 'close' event yet.\n    return false;\n  }\n\n  if (typeof encoding === 'function') {\n    callback = encoding;\n    encoding = null;\n  }\n\n  if (conn && conn._httpMessage === this && conn.writable) {\n    // There might be pending data in the this.output buffer.\n    if (this.outputData.length) {\n      this._flushOutput(conn);\n    }\n    // Directly write to socket.\n    return conn.write(data\x2C encoding\x2C callback);\n  }\n  // Buffer\x2C as long as we're not destroyed.\n  this.outputData.push({ data\x2C encoding\x2C callback });\n  this.outputSize += data.length;\n  this._onPendingData(data.length);\n  return this.outputSize < HIGH_WATER_MARK;\n}\n\n\nOutgoingMessage.prototype._storeHeader = _storeHeader;\nfunction _storeHeader(firstLine\x2C headers) {\n  // firstLine in the case of request is: 'GET /index.html HTTP/1.1\\r\\n'\n  // in the case of response it is: 'HTTP/1.1 200 OK\\r\\n'\n  const state = {\n    connection: false\x2C\n    contLen: false\x2C\n    te: false\x2C\n    date: false\x2C\n    expect: false\x2C\n    trailer: false\x2C\n    header: firstLine\n  };\n\n  if (headers) {\n    if (headers === this[kOutHeaders]) {\n      for (const key in headers) {\n        const entry = headers[key];\n        processHeader(this\x2C state\x2C entry[0]\x2C entry[1]\x2C false);\n      }\n    } else if (ArrayIsArray(headers)) {\n      if (headers.length && ArrayIsArray(headers[0])) {\n        for (let i = 0; i < headers.length; i++) {\n          const entry = headers[i];\n          processHeader(this\x2C state\x2C entry[0]\x2C entry[1]\x2C true);\n        }\n      } else {\n        if (headers.length % 2 !== 0) {\n          throw new ERR_INVALID_ARG_VALUE('headers'\x2C headers);\n        }\n\n        for (let n = 0; n < headers.length; n += 2) {\n          processHeader(this\x2C state\x2C headers[n + 0]\x2C headers[n + 1]\x2C true);\n        }\n      }\n    } else {\n      for (const key in headers) {\n        if (ObjectPrototypeHasOwnProperty(headers\x2C key)) {\n          processHeader(this\x2C state\x2C key\x2C headers[key]\x2C true);\n        }\n      }\n    }\n  }\n\n  let { header } = state;\n\n  // Date header\n  if (this.sendDate && !state.date) {\n    header += 'Date: ' + utcDate() + '\\r\\n';\n  }\n\n  // Force the connection to close when the response is a 204 No Content or\n  // a 304 Not Modified and the user has set a "Transfer-Encoding: chunked"\n  // header.\n  //\n  // RFC 2616 mandates that 204 and 304 responses MUST NOT have a body but\n  // node.js used to send out a zero chunk anyway to accommodate clients\n  // that don't have special handling for those responses.\n  //\n  // It was pointed out that this might confuse reverse proxies to the point\n  // of creating security liabilities\x2C so suppress the zero chunk and force\n  // the connection to close.\n  if (this.chunkedEncoding && (this.statusCode === 204 ||\n                               this.statusCode === 304)) {\n    debug(this.statusCode + ' response should not use chunked encoding\x2C' +\n          ' closing connection.');\n    this.chunkedEncoding = false;\n    this.shouldKeepAlive = false;\n  }\n\n  // keep-alive logic\n  if (this._removedConnection) {\n    this._last = true;\n    this.shouldKeepAlive = false;\n  } else if (!state.connection) {\n    const shouldSendKeepAlive = this.shouldKeepAlive &&\n        (state.contLen || this.useChunkedEncodingByDefault || this.agent);\n    if (shouldSendKeepAlive && this.maxRequestsOnConnectionReached) {\n      header += 'Connection: close\\r\\n';\n    } else if (shouldSendKeepAlive) {\n      header += 'Connection: keep-alive\\r\\n';\n      if (this._keepAliveTimeout && this._defaultKeepAlive) {\n        const timeoutSeconds = MathFloor(this._keepAliveTimeout / 1000);\n        header += `Keep-Alive: timeout=${timeoutSeconds}\\r\\n`;\n      }\n    } else {\n      this._last = true;\n      header += 'Connection: close\\r\\n';\n    }\n  }\n\n  if (!state.contLen && !state.te) {\n    if (!this._hasBody) {\n      // Make sure we don't end the 0\\r\\n\\r\\n at the end of the message.\n      this.chunkedEncoding = false;\n    } else if (!this.useChunkedEncodingByDefault) {\n      this._last = true;\n    } else if (!state.trailer &&\n               !this._removedContLen &&\n               typeof this._contentLength === 'number') {\n      header += 'Content-Length: ' + this._contentLength + '\\r\\n';\n    } else if (!this._removedTE) {\n      header += 'Transfer-Encoding: chunked\\r\\n';\n      this.chunkedEncoding = true;\n    } else {\n      // We should only be able to get here if both Content-Length and\n      // Transfer-Encoding are removed by the user.\n      // See: test/parallel/test-http-remove-header-stays-removed.js\n      debug('Both Content-Length and Transfer-Encoding are removed');\n    }\n  }\n\n  // Test non-chunked message does not have trailer header set\x2C\n  // message will be terminated by the first empty line after the\n  // header fields\x2C regardless of the header fields present in the\n  // message\x2C and thus cannot contain a message body or 'trailers'.\n  if (this.chunkedEncoding !== true && state.trailer) {\n    throw new ERR_HTTP_TRAILER_INVALID();\n  }\n\n  this._header = header + '\\r\\n';\n  this._headerSent = false;\n\n  // Wait until the first body chunk\x2C or close()\x2C is sent to flush\x2C\n  // UNLESS we're sending Expect: 100-continue.\n  if (state.expect) this._send('');\n}\n\nfunction processHeader(self\x2C state\x2C key\x2C value\x2C validate) {\n  if (validate)\n    validateHeaderName(key);\n  if (ArrayIsArray(value)) {\n    if (value.length < 2 || !isCookieField(key)) {\n      // Retain for(;;) loop for performance reasons\n      // Refs: https://github.com/nodejs/node/pull/30958\n      for (let i = 0; i < value.length; i++)\n        storeHeader(self\x2C state\x2C key\x2C value[i]\x2C validate);\n      return;\n    }\n    value = ArrayPrototypeJoin(value\x2C '; ');\n  }\n  storeHeader(self\x2C state\x2C key\x2C value\x2C validate);\n}\n\nfunction storeHeader(self\x2C state\x2C key\x2C value\x2C validate) {\n  if (validate)\n    validateHeaderValue(key\x2C value);\n  state.header += key + ': ' + value + '\\r\\n';\n  matchHeader(self\x2C state\x2C key\x2C value);\n}\n\nfunction matchHeader(self\x2C state\x2C field\x2C value) {\n  if (field.length < 4 || field.length > 17)\n    return;\n  field = StringPrototypeToLowerCase(field);\n  switch (field) {\n    case 'connection':\n      state.connection = true;\n      self._removedConnection = false;\n      if (RegExpPrototypeTest(RE_CONN_CLOSE\x2C value))\n        self._last = true;\n      else\n        self.shouldKeepAlive = true;\n      break;\n    case 'transfer-encoding':\n      state.te = true;\n      self._removedTE = false;\n      if (RegExpPrototypeTest(RE_TE_CHUNKED\x2C value))\n        self.chunkedEncoding = true;\n      break;\n    case 'content-length':\n      state.contLen = true;\n      self._removedContLen = false;\n      break;\n    case 'date':\n    case 'expect':\n    case 'trailer':\n      state[field] = true;\n      break;\n    case 'keep-alive':\n      self._defaultKeepAlive = false;\n      break;\n  }\n}\n\nconst validateHeaderName = hideStackFrames((name) => {\n  if (typeof name !== 'string' || !name || !checkIsHttpToken(name)) {\n    throw new ERR_INVALID_HTTP_TOKEN('Header name'\x2C name);\n  }\n});\n\nconst validateHeaderValue = hideStackFrames((name\x2C value) => {\n  if (value === undefined) {\n    throw new ERR_HTTP_INVALID_HEADER_VALUE(value\x2C name);\n  }\n  if (checkInvalidHeaderChar(value)) {\n    debug('Header "%s" contains invalid characters'\x2C name);\n    throw new ERR_INVALID_CHAR('header content'\x2C name);\n  }\n});\n\nOutgoingMessage.prototype.setHeader = function setHeader(name\x2C value) {\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT('set');\n  }\n  validateHeaderName(name);\n  validateHeaderValue(name\x2C value);\n\n  let headers = this[kOutHeaders];\n  if (headers === null)\n    this[kOutHeaders] = headers = ObjectCreate(null);\n\n  headers[StringPrototypeToLowerCase(name)] = [name\x2C value];\n  return this;\n};\n\n\nOutgoingMessage.prototype.getHeader = function getHeader(name) {\n  validateString(name\x2C 'name');\n\n  const headers = this[kOutHeaders];\n  if (headers === null)\n    return;\n\n  const entry = headers[StringPrototypeToLowerCase(name)];\n  return entry && entry[1];\n};\n\n\n// Returns an array of the names of the current outgoing headers.\nOutgoingMessage.prototype.getHeaderNames = function getHeaderNames() {\n  return this[kOutHeaders] !== null ? ObjectKeys(this[kOutHeaders]) : [];\n};\n\n\n// Returns an array of the names of the current outgoing raw headers.\nOutgoingMessage.prototype.getRawHeaderNames = function getRawHeaderNames() {\n  const headersMap = this[kOutHeaders];\n  if (headersMap === null) return [];\n\n  const values = ObjectValues(headersMap);\n  const headers = Array(values.length);\n  // Retain for(;;) loop for performance reasons\n  // Refs: https://github.com/nodejs/node/pull/30958\n  for (let i = 0\x2C l = values.length; i < l; i++) {\n    headers[i] = values[i][0];\n  }\n\n  return headers;\n};\n\n\n// Returns a shallow copy of the current outgoing headers.\nOutgoingMessage.prototype.getHeaders = function getHeaders() {\n  const headers = this[kOutHeaders];\n  const ret = ObjectCreate(null);\n  if (headers) {\n    const keys = ObjectKeys(headers);\n    // Retain for(;;) loop for performance reasons\n    // Refs: https://github.com/nodejs/node/pull/30958\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      const val = headers[key][1];\n      ret[key] = val;\n    }\n  }\n  return ret;\n};\n\n\nOutgoingMessage.prototype.hasHeader = function hasHeader(name) {\n  validateString(name\x2C 'name');\n  return this[kOutHeaders] !== null &&\n    !!this[kOutHeaders][StringPrototypeToLowerCase(name)];\n};\n\n\nOutgoingMessage.prototype.removeHeader = function removeHeader(name) {\n  validateString(name\x2C 'name');\n\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT('remove');\n  }\n\n  const key = StringPrototypeToLowerCase(name);\n\n  switch (key) {\n    case 'connection':\n      this._removedConnection = true;\n      break;\n    case 'content-length':\n      this._removedContLen = true;\n      break;\n    case 'transfer-encoding':\n      this._removedTE = true;\n      break;\n    case 'date':\n      this.sendDate = false;\n      break;\n  }\n\n  if (this[kOutHeaders] !== null) {\n    delete this[kOutHeaders][key];\n  }\n};\n\n\nOutgoingMessage.prototype._implicitHeader = function _implicitHeader() {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_implicitHeader()');\n};\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'headersSent'\x2C {\n  configurable: true\x2C\n  enumerable: true\x2C\n  get: function() { return !!this._header; }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableEnded'\x2C {\n  get: function() { return this.finished; }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableNeedDrain'\x2C {\n  get: function() {\n    return !this.destroyed && !this.finished && this[kNeedDrain];\n  }\n});\n\nconst crlf_buf = Buffer.from('\\r\\n');\nOutgoingMessage.prototype.write = function write(chunk\x2C encoding\x2C callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding;\n    encoding = null;\n  }\n\n  const ret = write_(this\x2C chunk\x2C encoding\x2C callback\x2C false);\n  if (!ret)\n    this[kNeedDrain] = true;\n  return ret;\n};\n\nfunction onError(msg\x2C err\x2C callback) {\n  const triggerAsyncId = msg.socket ? msg.socket[async_id_symbol] : undefined;\n  defaultTriggerAsyncIdScope(triggerAsyncId\x2C\n                             process.nextTick\x2C\n                             emitErrorNt\x2C\n                             msg\x2C\n                             err\x2C\n                             callback);\n}\n\nfunction emitErrorNt(msg\x2C err\x2C callback) {\n  callback(err);\n  if (typeof msg.emit === 'function' && !msg._closed) {\n    msg.emit('error'\x2C err);\n  }\n}\n\nfunction write_(msg\x2C chunk\x2C encoding\x2C callback\x2C fromEnd) {\n  if (typeof callback !== 'function')\n    callback = nop;\n\n  let len;\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk === 'string') {\n    len = Buffer.byteLength(chunk\x2C encoding);\n  } else if (isUint8Array(chunk)) {\n    len = chunk.length;\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(\n      'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n  }\n\n  let err;\n  if (msg.finished) {\n    err = new ERR_STREAM_WRITE_AFTER_END();\n  } else if (msg.destroyed) {\n    err = new ERR_STREAM_DESTROYED('write');\n  }\n\n  if (err) {\n    if (!msg.destroyed) {\n      onError(msg\x2C err\x2C callback);\n    } else {\n      process.nextTick(callback\x2C err);\n    }\n    return false;\n  }\n\n  if (!msg._header) {\n    if (fromEnd) {\n      msg._contentLength = len;\n    }\n    msg._implicitHeader();\n  }\n\n  if (!msg._hasBody) {\n    debug('This type of response MUST NOT have a body. ' +\n          'Ignoring write() calls.');\n    process.nextTick(callback);\n    return true;\n  }\n\n  if (!fromEnd && msg.socket && !msg.socket.writableCorked) {\n    msg.socket.cork();\n    process.nextTick(connectionCorkNT\x2C msg.socket);\n  }\n\n  let ret;\n  if (msg.chunkedEncoding && chunk.length !== 0) {\n    msg._send(NumberPrototypeToString(len\x2C 16)\x2C 'latin1'\x2C null);\n    msg._send(crlf_buf\x2C null\x2C null);\n    msg._send(chunk\x2C encoding\x2C null);\n    ret = msg._send(crlf_buf\x2C null\x2C callback);\n  } else {\n    ret = msg._send(chunk\x2C encoding\x2C callback);\n  }\n\n  debug('write ret = ' + ret);\n  return ret;\n}\n\n\nfunction connectionCorkNT(conn) {\n  conn.uncork();\n}\n\n\nOutgoingMessage.prototype.addTrailers = function addTrailers(headers) {\n  this._trailer = '';\n  const keys = ObjectKeys(headers);\n  const isArray = ArrayIsArray(headers);\n  // Retain for(;;) loop for performance reasons\n  // Refs: https://github.com/nodejs/node/pull/30958\n  for (let i = 0\x2C l = keys.length; i < l; i++) {\n    let field\x2C value;\n    const key = keys[i];\n    if (isArray) {\n      field = headers[key][0];\n      value = headers[key][1];\n    } else {\n      field = key;\n      value = headers[key];\n    }\n    if (typeof field !== 'string' || !field || !checkIsHttpToken(field)) {\n      throw new ERR_INVALID_HTTP_TOKEN('Trailer name'\x2C field);\n    }\n    if (checkInvalidHeaderChar(value)) {\n      debug('Trailer "%s" contains invalid characters'\x2C field);\n      throw new ERR_INVALID_CHAR('trailer content'\x2C field);\n    }\n    this._trailer += field + ': ' + value + '\\r\\n';\n  }\n};\n\nfunction onFinish(outmsg) {\n  if (outmsg && outmsg.socket && outmsg.socket._hadError) return;\n  outmsg.emit('finish');\n}\n\nOutgoingMessage.prototype.end = function end(chunk\x2C encoding\x2C callback) {\n  if (typeof chunk === 'function') {\n    callback = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    callback = encoding;\n    encoding = null;\n  }\n\n  if (chunk) {\n    if (this.finished) {\n      onError(this\x2C\n              new ERR_STREAM_WRITE_AFTER_END()\x2C\n              typeof callback !== 'function' ? nop : callback);\n      return this;\n    }\n\n    if (this.socket) {\n      this.socket.cork();\n    }\n\n    write_(this\x2C chunk\x2C encoding\x2C null\x2C true);\n  } else if (this.finished) {\n    if (typeof callback === 'function') {\n      if (!this.writableFinished) {\n        this.on('finish'\x2C callback);\n      } else {\n        callback(new ERR_STREAM_ALREADY_FINISHED('end'));\n      }\n    }\n    return this;\n  } else if (!this._header) {\n    if (this.socket) {\n      this.socket.cork();\n    }\n\n    this._contentLength = 0;\n    this._implicitHeader();\n  }\n\n  if (typeof callback === 'function')\n    this.once('finish'\x2C callback);\n\n  const finish = onFinish.bind(undefined\x2C this);\n\n  if (this._hasBody && this.chunkedEncoding) {\n    this._send('0\\r\\n' + this._trailer + '\\r\\n'\x2C 'latin1'\x2C finish);\n  } else if (!this._headerSent || this.writableLength || chunk) {\n    this._send(''\x2C 'latin1'\x2C finish);\n  } else {\n    process.nextTick(finish);\n  }\n\n  if (this.socket) {\n    // Fully uncork connection on end().\n    this.socket._writableState.corked = 1;\n    this.socket.uncork();\n  }\n  this[kCorked] = 0;\n\n  this.finished = true;\n\n  // There is the first message on the outgoing queue\x2C and we've sent\n  // everything to the socket.\n  debug('outgoing message end.');\n  if (this.outputData.length === 0 &&\n      this.socket &&\n      this.socket._httpMessage === this) {\n    this._finish();\n  }\n\n  return this;\n};\n\n\nOutgoingMessage.prototype._finish = function _finish() {\n  assert(this.socket);\n  this.emit('prefinish');\n};\n\n\n// This logic is probably a bit confusing. Let me explain a bit:\n//\n// In both HTTP servers and clients it is possible to queue up several\n// outgoing messages. This is easiest to imagine in the case of a client.\n// Take the following situation:\n//\n//    req1 = client.request('GET'\x2C '/');\n//    req2 = client.request('POST'\x2C '/');\n//\n// When the user does\n//\n//   req2.write('hello world\\n');\n//\n// it's possible that the first request has not been completely flushed to\n// the socket yet. Thus the outgoing messages need to be prepared to queue\n// up data internally before sending it on further to the socket's queue.\n//\n// This function\x2C outgoingFlush()\x2C is called by both the Server and Client\n// to attempt to flush any pending messages out to the socket.\nOutgoingMessage.prototype._flush = function _flush() {\n  const socket = this.socket;\n\n  if (socket && socket.writable) {\n    // There might be remaining data in this.output; write it out\n    const ret = this._flushOutput(socket);\n\n    if (this.finished) {\n      // This is a queue to the server or client to bring in the next this.\n      this._finish();\n    } else if (ret && this[kNeedDrain]) {\n      this[kNeedDrain] = false;\n      this.emit('drain');\n    }\n  }\n};\n\nOutgoingMessage.prototype._flushOutput = function _flushOutput(socket) {\n  while (this[kCorked]) {\n    this[kCorked]--;\n    socket.cork();\n  }\n\n  const outputLength = this.outputData.length;\n  if (outputLength <= 0)\n    return undefined;\n\n  const outputData = this.outputData;\n  socket.cork();\n  let ret;\n  // Retain for(;;) loop for performance reasons\n  // Refs: https://github.com/nodejs/node/pull/30958\n  for (let i = 0; i < outputLength; i++) {\n    const { data\x2C encoding\x2C callback } = outputData[i];\n    ret = socket.write(data\x2C encoding\x2C callback);\n  }\n  socket.uncork();\n\n  this.outputData = [];\n  this._onPendingData(-this.outputSize);\n  this.outputSize = 0;\n\n  return ret;\n};\n\n\nOutgoingMessage.prototype.flushHeaders = function flushHeaders() {\n  if (!this._header) {\n    this._implicitHeader();\n  }\n\n  // Force-flush the headers.\n  this._send('');\n};\n\nOutgoingMessage.prototype.pipe = function pipe() {\n  // OutgoingMessage should be write-only. Piping from it is disabled.\n  this.emit('error'\x2C new ERR_STREAM_CANNOT_PIPE());\n};\n\nOutgoingMessage.prototype[EE.captureRejectionSymbol] =\nfunction(err\x2C event) {\n  this.destroy(err);\n};\n\nmodule.exports = {\n  validateHeaderName\x2C\n  validateHeaderValue\x2C\n  OutgoingMessage\n};\n
code-source-info,0x2cbd764b96be,158,0,28763,C0O0C4O28763,,
code-creation,Function,10,78750,0x2cbd764bb19e,1459, node:_http_outgoing:1:1,0x2cbd764b9638,~
code-source-info,0x2cbd764bb19e,158,0,28763,C0O0C213O1159C219O1168C225O1184C231O1206C237O1219C243O1246C249O1262C254O1286C260O1300C266O1316C272O1349C277O1373C283O1396C289O1426C294O1488C297O1488C302O1460C307O1538C310O1538C314O1538C316O1577C319O1577C324O1611C327O1611C331O1611C333O1651C336O1651C341O1722C344O1722C349O1685C355O1698C361O1707C367O1767C370O1767C375O1756C381O1922C384O1922C389O1815C395O1860C401O1903C407O2020C410O2020C415O1957C426O1998C432O2472C435O2472C440O2472C445O2076C451O2103C457O2138C463O2168C469O2196C475O2222C481O2249C487O2271C493O2303C499O2331C505O2364C511O2396C517O2424C523O2452C528O2527C531O2527C536O2508C542O2584C545O2584C550O2567C556O2629C559O2629C564O2662C577O2663C583O2629C585O2733C588O2733C590O2777C593O2777C597O2777C599O2808C603O2808C605O2841C609O2841C611O4463C619O4481C624O4426C629O4493C632O4493C637O4578C650O4613C658O4541C663O4798C676O4835C684O4761C689O4907C702O4940C710O4870C715O5071C728O5111C736O5034C741O5243C754O5276C762O5206C767O5430C780O5475C802O5475C811O5617C833O5617C842O5393C847O6219C860O6253C868O6302C876O6182C881O6387C894O6436C916O6436C925O6992C947O6992C956O6350C961O7543C970O7568C974O8093C983O8108C987O8224C996O8241C1000O8378C1009O8399C1013O8918C1022O8936C1026O9315C1035O9331C1039O10100C1046O10120C1050O10991C1057O11014C1061O17124C1066O17124C1070O17124C1072O17318C1077O17318C1081O17318C1083O17624C1092O17644C1096O18026C1105O18046C1109O18356C1118O18381C1122O18576C1131O18604C1135O19086C1144O19107C1148O19538C1157O19558C1161O19738C1170O19761C1174O20348C1183O20374C1187O20507C1200O20584C1208O20470C1213O20664C1226O20701C1234O20627C1239O20780C1252O20821C1260O20743C1265O20926C1268O20933C1276O20933C1281O20926C1283O20963C1292O20979C1296O23375C1305O23397C1309O24388C1318O24402C1322O26209C1331O26227C1335O27082C1344O27099C1348O27550C1357O27573C1361O28238C1370O28261C1374O28413C1383O28428C1387O28591C1392O28604C1401O28628C1409O28678C1419O28699C1429O28721C1439O28744C1449O28693C1458O28762,,
tick,0x1bfd70e80,78834,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x2cbd764b0ca7,0x105108d28,0x10510894c,0x2cbd764a9e64,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89d6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,78875,0x2cbd764be416,5, node:internal/http:1:1,0x2cbd764be220,~
script-source,159,node:internal/http,'use strict';\n\nconst {\n  Symbol\x2C\n  Date\x2C\n  DatePrototypeGetMilliseconds\x2C\n  DatePrototypeToUTCString\x2C\n} = primordials;\n\nconst { setUnrefTimeout } = require('internal/timers');\n\nconst { InternalPerformanceEntry } = require('internal/perf/performance_entry');\n\nconst {\n  enqueue\x2C\n  hasObserver\x2C\n} = require('internal/perf/observe');\n\nlet utcCache;\n\nfunction utcDate() {\n  if (!utcCache) cache();\n  return utcCache;\n}\n\nfunction cache() {\n  const d = new Date();\n  utcCache = DatePrototypeToUTCString(d);\n  setUnrefTimeout(resetCache\x2C 1000 - DatePrototypeGetMilliseconds(d));\n}\n\nfunction resetCache() {\n  utcCache = undefined;\n}\n\nfunction emitStatistics(statistics) {\n  if (!hasObserver('http') || statistics == null) return;\n  const startTime = statistics.startTime;\n  const diff = process.hrtime(startTime);\n  const entry = new InternalPerformanceEntry(\n    'HttpRequest'\x2C\n    'http'\x2C\n    startTime[0] * 1000 + startTime[1] / 1e6\x2C\n    diff[0] * 1000 + diff[1] / 1e6\x2C\n    undefined\x2C\n  );\n  enqueue(entry);\n}\n\nmodule.exports = {\n  kOutHeaders: Symbol('kOutHeaders')\x2C\n  kNeedDrain: Symbol('kNeedDrain')\x2C\n  utcDate\x2C\n  emitStatistics\x2C\n};\n
code-source-info,0x2cbd764be416,159,0,1130,C0O0C4O1130,,
code-creation,Function,10,78959,0x2cbd764be6d6,176, node:internal/http:1:1,0x2cbd764be390,~
code-source-info,0x2cbd764be6d6,159,0,1130,C0O0C55O25C60O35C66O43C72O75C78O147C81O147C86O127C92O213C95O213C100O184C106O296C109O296C114O268C120O279C126O335C127O335C129O1005C137O1039C148O1076C158O1100C164O1111C170O1020C175O1129,,
new,MemoryChunk,0x29d5d5b80000,262144
code-creation,LazyCompile,10,79084,0x2cbd764bef16,43,hideStackFrames node:internal/errors:383:25,0x2b48e0c65510,~
script-source,11,node:internal/errors,/* eslint node-core/documented-errors: "error" */\n/* eslint node-core/alphabetize-errors: "error" */\n/* eslint node-core/prefer-util-format-errors: "error" */\n\n'use strict';\n\n// The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change\x2C the code should not.\n\nconst {\n  AggregateError\x2C\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  ErrorPrototypeToString\x2C\n  JSONStringify\x2C\n  MapPrototypeGet\x2C\n  MathAbs\x2C\n  MathMax\x2C\n  Number\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectIsExtensible\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RangeError\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SyntaxError\x2C\n  TypeError\x2C\n  URIError\x2C\n} = primordials;\n\nconst kIsNodeError = Symbol('kIsNodeError');\n\nconst isWindows = process.platform === 'win32';\n\nconst messages = new SafeMap();\nconst codes = {};\n\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\n// Sorted by a rough estimate on most frequently used entries.\nconst kTypes = [\n  'string'\x2C\n  'function'\x2C\n  'number'\x2C\n  'object'\x2C\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function'\x2C\n  'Object'\x2C\n  'boolean'\x2C\n  'bigint'\x2C\n  'symbol'\x2C\n];\n\nconst MainContextError = Error;\nconst overrideStackTrace = new SafeWeakMap();\nconst kNoOverride = Symbol('kNoOverride');\nlet userStackTraceLimit;\nconst nodeInternalPrefix = '__node_internal_';\nconst prepareStackTrace = (globalThis\x2C error\x2C trace) => {\n  // API for node internals to override error stack formatting\n  // without interfering with userland code.\n  if (overrideStackTrace.has(error)) {\n    const f = overrideStackTrace.get(error);\n    overrideStackTrace.delete(error);\n    return f(error\x2C trace);\n  }\n\n  const firstFrame = trace[0]?.getFunctionName();\n  if (firstFrame && StringPrototypeStartsWith(firstFrame\x2C nodeInternalPrefix)) {\n    for (let l = trace.length - 1; l >= 0; l--) {\n      const fn = trace[l]?.getFunctionName();\n      if (fn && StringPrototypeStartsWith(fn\x2C nodeInternalPrefix)) {\n        ArrayPrototypeSplice(trace\x2C 0\x2C l + 1);\n        break;\n      }\n    }\n    // `userStackTraceLimit` is the user value for `Error.stackTraceLimit`\x2C\n    // it is updated at every new exception in `captureLargerStackTrace`.\n    if (trace.length > userStackTraceLimit)\n      ArrayPrototypeSplice(trace\x2C userStackTraceLimit);\n  }\n\n  const globalOverride =\n    maybeOverridePrepareStackTrace(globalThis\x2C error\x2C trace);\n  if (globalOverride !== kNoOverride) return globalOverride;\n\n  // Normal error formatting:\n  //\n  // Error: Message\n  //     at function (file)\n  //     at file\n  let errorString;\n  if (kIsNodeError in error) {\n    errorString = `${error.name} [${error.code}]: ${error.message}`;\n  } else {\n    errorString = ErrorPrototypeToString(error);\n  }\n  if (trace.length === 0) {\n    return errorString;\n  }\n  return `${errorString}\\n    at ${ArrayPrototypeJoin(trace\x2C '\\n    at ')}`;\n};\n\nconst maybeOverridePrepareStackTrace = (globalThis\x2C error\x2C trace) => {\n  // Polyfill of V8's Error.prepareStackTrace API.\n  // https://crbug.com/v8/7848\n  // `globalThis` is the global that contains the constructor which\n  // created `error`.\n  if (typeof globalThis.Error?.prepareStackTrace === 'function') {\n    return globalThis.Error.prepareStackTrace(error\x2C trace);\n  }\n  // We still have legacy usage that depends on the main context's `Error`\n  // being used\x2C even when the error is from a different context.\n  // TODO(devsnek): evaluate if this can be eventually deprecated/removed.\n  if (typeof MainContextError.prepareStackTrace === 'function') {\n    return MainContextError.prepareStackTrace(error\x2C trace);\n  }\n\n  return kNoOverride;\n};\n\nconst aggregateTwoErrors = hideStackFrames((innerError\x2C outerError) => {\n  if (innerError && outerError && innerError !== outerError) {\n    if (ArrayIsArray(outerError.errors)) {\n      // If `outerError` is already an `AggregateError`.\n      ArrayPrototypePush(outerError.errors\x2C innerError);\n      return outerError;\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new AggregateError(new SafeArrayIterator([\n      outerError\x2C\n      innerError\x2C\n    ])\x2C outerError.message);\n    err.code = outerError.code;\n    return err;\n  }\n  return innerError || outerError;\n});\n\n// Lazily loaded\nlet util;\nlet assert;\n\nlet internalUtil = null;\nfunction lazyInternalUtil() {\n  if (!internalUtil) {\n    internalUtil = require('internal/util');\n  }\n  return internalUtil;\n}\n\nlet internalUtilInspect = null;\nfunction lazyInternalUtilInspect() {\n  if (!internalUtilInspect) {\n    internalUtilInspect = require('internal/util/inspect');\n  }\n  return internalUtilInspect;\n}\n\nlet buffer;\nfunction lazyBuffer() {\n  if (buffer === undefined)\n    buffer = require('buffer').Buffer;\n  return buffer;\n}\n\nfunction isErrorStackTraceLimitWritable() {\n  const desc = ObjectGetOwnPropertyDescriptor(Error\x2C 'stackTraceLimit');\n  if (desc === undefined) {\n    return ObjectIsExtensible(Error);\n  }\n\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'writable') ?\n    desc.writable :\n    desc.set !== undefined;\n}\n\n// A specialized Error that includes an additional info property with\n// additional information about the error condition.\n// It has the properties present in a UVException but with a custom error\n// message followed by the uv error code and uv error message.\n// It also has its own error code with the original uv error context put into\n// `err.info`.\n// The context passed into this error must have .code\x2C .syscall and .message\x2C\n// and may have .path and .dest.\nclass SystemError extends Error {\n  constructor(key\x2C context) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    super();\n    // Reset the limit and setting the name property.\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n    const prefix = getMessage(key\x2C []\x2C this);\n    let message = `${prefix}: ${context.syscall} returned ` +\n                  `${context.code} (${context.message})`;\n\n    if (context.path !== undefined)\n      message += ` ${context.path}`;\n    if (context.dest !== undefined)\n      message += ` => ${context.dest}`;\n\n    captureLargerStackTrace(this);\n\n    this.code = key;\n\n    ObjectDefineProperties(this\x2C {\n      [kIsNodeError]: {\n        value: true\x2C\n        enumerable: false\x2C\n        writable: false\x2C\n        configurable: true\x2C\n      }\x2C\n      name: {\n        value: 'SystemError'\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      message: {\n        value: message\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      info: {\n        value: context\x2C\n        enumerable: true\x2C\n        configurable: true\x2C\n        writable: false\x2C\n      }\x2C\n      errno: {\n        get() {\n          return context.errno;\n        }\x2C\n        set: (value) => {\n          context.errno = value;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      syscall: {\n        get() {\n          return context.syscall;\n        }\x2C\n        set: (value) => {\n          context.syscall = value;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\x2C\n      }\x2C\n    });\n\n    if (context.path !== undefined) {\n      // TODO(BridgeAR): Investigate why and when the `.toString()` was\n      // introduced. The `path` and `dest` properties in the context seem to\n      // always be of type string. We should probably just remove the\n      // `.toString()` and `Buffer.from()` operations and set the value on the\n      // context as the user did.\n      ObjectDefineProperty(this\x2C 'path'\x2C {\n        get() {\n          return context.path != null ?\n            context.path.toString() : context.path;\n        }\x2C\n        set: (value) => {\n          context.path = value ?\n            lazyBuffer().from(value.toString()) : undefined;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\n      });\n    }\n\n    if (context.dest !== undefined) {\n      ObjectDefineProperty(this\x2C 'dest'\x2C {\n        get() {\n          return context.dest != null ?\n            context.dest.toString() : context.dest;\n        }\x2C\n        set: (value) => {\n          context.dest = value ?\n            lazyBuffer().from(value.toString()) : undefined;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\n      });\n    }\n  }\n\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n\n  [SymbolFor('nodejs.util.inspect.custom')](recurseTimes\x2C ctx) {\n    return lazyInternalUtilInspect().inspect(this\x2C {\n      ...ctx\x2C\n      getters: true\x2C\n      customInspect: false\n    });\n  }\n}\n\nfunction makeSystemErrorWithCode(key) {\n  return class NodeError extends SystemError {\n    constructor(ctx) {\n      super(key\x2C ctx);\n    }\n  };\n}\n\nfunction makeNodeErrorWithCode(Base\x2C key) {\n  return function NodeError(...args) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    const error = new Base();\n    // Reset the limit and setting the name property.\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n    const message = getMessage(key\x2C args\x2C error);\n    ObjectDefineProperties(error\x2C {\n      [kIsNodeError]: {\n        value: true\x2C\n        enumerable: false\x2C\n        writable: false\x2C\n        configurable: true\x2C\n      }\x2C\n      message: {\n        value: message\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      toString: {\n        value() {\n          return `${this.name} [${key}]: ${this.message}`;\n        }\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n    });\n    captureLargerStackTrace(error);\n    error.code = key;\n    return error;\n  };\n}\n\n/**\n * This function removes unnecessary frames from Node.js core errors.\n * @template {(...args: any[]) => any} T\n * @type {(fn: T) => T}\n */\nfunction hideStackFrames(fn) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + fn.name;\n  ObjectDefineProperty(fn\x2C 'name'\x2C { value: hidden });\n  return fn;\n}\n\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\nfunction E(sym\x2C val\x2C def\x2C ...otherClasses) {\n  // Special case for SystemError that formats the error message differently\n  // The SystemErrors only have SystemError as their base classes.\n  messages.set(sym\x2C val);\n  if (def === SystemError) {\n    def = makeSystemErrorWithCode(sym);\n  } else {\n    def = makeNodeErrorWithCode(def\x2C sym);\n  }\n\n  if (otherClasses.length !== 0) {\n    otherClasses.forEach((clazz) => {\n      def[clazz.name] = makeNodeErrorWithCode(clazz\x2C sym);\n    });\n  }\n  codes[sym] = def;\n}\n\nfunction getMessage(key\x2C args\x2C self) {\n  const msg = messages.get(key);\n\n  if (assert === undefined) assert = require('internal/assert');\n\n  if (typeof msg === 'function') {\n    assert(\n      msg.length <= args.length\x2C // Default options do not count.\n      `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n        `match the required ones (${msg.length}).`\n    );\n    return ReflectApply(msg\x2C self\x2C args);\n  }\n\n  const expectedLength =\n    (StringPrototypeMatch(msg\x2C /%[dfijoOs]/g) || []).length;\n  assert(\n    expectedLength === args.length\x2C\n    `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n      `match the required ones (${expectedLength}).`\n  );\n  if (args.length === 0)\n    return msg;\n\n  ArrayPrototypeUnshift(args\x2C msg);\n  return ReflectApply(lazyInternalUtilInspect().format\x2C null\x2C args);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  if (!uvBinding) {\n    uvBinding = internalBinding('uv');\n  }\n  return uvBinding;\n}\n\nconst uvUnmappedError = ['UNKNOWN'\x2C 'unknown error'];\n\nfunction uvErrmapGet(name) {\n  uvBinding = lazyUv();\n  if (!uvBinding.errmap) {\n    uvBinding.errmap = uvBinding.getErrorMap();\n  }\n  return MapPrototypeGet(uvBinding.errmap\x2C name);\n}\n\nconst captureLargerStackTrace = hideStackFrames(\n  function captureLargerStackTrace(err) {\n    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\n    if (stackTraceLimitIsWritable) {\n      userStackTraceLimit = Error.stackTraceLimit;\n      Error.stackTraceLimit = Infinity;\n    }\n    ErrorCaptureStackTrace(err);\n    // Reset the limit\n    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;\n\n    return err;\n  });\n\n/**\n * This creates an error compatible with errors produced in the C++\n * function UVException using a context object with data assembled in C++.\n * The goal is to migrate them to ERR_* errors later when compatibility is\n * not a concern.\n *\n * @param {object} ctx\n * @returns {Error}\n */\nconst uvException = hideStackFrames(function uvException(ctx) {\n  const { 0: code\x2C 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;\n  let message = `${code}: ${ctx.message || uvmsg}\x2C ${ctx.syscall}`;\n\n  let path;\n  let dest;\n  if (ctx.path) {\n    path = ctx.path.toString();\n    message += ` '${path}'`;\n  }\n  if (ctx.dest) {\n    dest = ctx.dest.toString();\n    message += ` -> '${dest}'`;\n  }\n\n  // Reducing the limit improves the performance significantly. We do not lose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // Pass the message to the constructor instead of setting it on the object\n  // to make sure it is the same as the one created in C++\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n\n  for (const prop of ObjectKeys(ctx)) {\n    if (prop === 'message' || prop === 'path' || prop === 'dest') {\n      continue;\n    }\n    err[prop] = ctx[prop];\n  }\n\n  err.code = code;\n  if (path) {\n    err.path = path;\n  }\n  if (dest) {\n    err.dest = dest;\n  }\n\n  return captureLargerStackTrace(err);\n});\n\n/**\n * This creates an error compatible with errors produced in the C++\n * This function should replace the deprecated\n * `exceptionWithHostPort()` function.\n *\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} address\n * @param {number} [port]\n * @returns {Error}\n */\nconst uvExceptionWithHostPort = hideStackFrames(\n  function uvExceptionWithHostPort(err\x2C syscall\x2C address\x2C port) {\n    const { 0: code\x2C 1: uvmsg } = uvErrmapGet(err) || uvUnmappedError;\n    const message = `${syscall} ${code}: ${uvmsg}`;\n    let details = '';\n\n    if (port && port > 0) {\n      details = ` ${address}:${port}`;\n    } else if (address) {\n      details = ` ${address}`;\n    }\n\n    // Reducing the limit improves the performance significantly. We do not\n    // lose the stack frames due to the `captureStackTrace()` function that\n    // is called later.\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(`${message}${details}`);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.code = code;\n    ex.errno = err;\n    ex.syscall = syscall;\n    ex.address = address;\n    if (port) {\n      ex.port = port;\n    }\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * This used to be util._errnoException().\n *\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} [original]\n * @returns {Error}\n */\nconst errnoException = hideStackFrames(\n  function errnoException(err\x2C syscall\x2C original) {\n    // TODO(joyeecheung): We have to use the type-checked\n    // getSystemErrorName(err) to guard against invalid arguments from users.\n    // This can be replaced with [ code ] = errmap.get(err) when this method\n    // is no longer exposed to user land.\n    if (util === undefined) util = require('util');\n    const code = util.getSystemErrorName(err);\n    const message = original ?\n      `${syscall} ${code} ${original}` : `${syscall} ${code}`;\n\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(message);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.errno = err;\n    ex.code = code;\n    ex.syscall = syscall;\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * Deprecated\x2C new function is `uvExceptionWithHostPort()`\n * New function added the error description directly\n * from C++. this method for backwards compatibility\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} address\n * @param {number} [port]\n * @param {string} [additional]\n * @returns {Error}\n */\nconst exceptionWithHostPort = hideStackFrames(\n  function exceptionWithHostPort(err\x2C syscall\x2C address\x2C port\x2C additional) {\n    // TODO(joyeecheung): We have to use the type-checked\n    // getSystemErrorName(err) to guard against invalid arguments from users.\n    // This can be replaced with [ code ] = errmap.get(err) when this method\n    // is no longer exposed to user land.\n    if (util === undefined) util = require('util');\n    const code = util.getSystemErrorName(err);\n    let details = '';\n    if (port && port > 0) {\n      details = ` ${address}:${port}`;\n    } else if (address) {\n      details = ` ${address}`;\n    }\n    if (additional) {\n      details += ` - Local (${additional})`;\n    }\n\n    // Reducing the limit improves the performance significantly. We do not\n    // lose the stack frames due to the `captureStackTrace()` function that\n    // is called later.\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(`${syscall} ${code}${details}`);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.errno = err;\n    ex.code = code;\n    ex.syscall = syscall;\n    ex.address = address;\n    if (port) {\n      ex.port = port;\n    }\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * @param {number|string} code - A libuv error number or a c-ares error code\n * @param {string} syscall\n * @param {string} [hostname]\n * @returns {Error}\n */\nconst dnsException = hideStackFrames(function(code\x2C syscall\x2C hostname) {\n  let errno;\n  // If `code` is of type number\x2C it is a libuv error number\x2C else it is a\n  // c-ares error code.\n  // TODO(joyeecheung): translate c-ares error codes into numeric ones and\n  // make them available in a property that's not error.errno (since they\n  // can be in conflict with libuv error codes). Also make sure\n  // util.getSystemErrorName() can understand them when an being informed that\n  // the number is a c-ares error code.\n  if (typeof code === 'number') {\n    errno = code;\n    // ENOTFOUND is not a proper POSIX error\x2C but this error has been in place\n    // long enough that it's not practical to remove it.\n    if (code === lazyUv().UV_EAI_NODATA || code === lazyUv().UV_EAI_NONAME) {\n      code = 'ENOTFOUND'; // Fabricated error name.\n    } else {\n      code = lazyInternalUtil().getSystemErrorName(code);\n    }\n  }\n  const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ''}`;\n  // Reducing the limit improves the performance significantly. We do not lose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n  ex.errno = errno;\n  ex.code = code;\n  ex.syscall = syscall;\n  if (hostname) {\n    ex.hostname = hostname;\n  }\n\n  return captureLargerStackTrace(ex);\n});\n\nfunction connResetException(msg) {\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(msg);\n  ex.code = 'ECONNRESET';\n  return ex;\n}\n\nlet maxStack_ErrorName;\nlet maxStack_ErrorMessage;\n/**\n * Returns true if `err.name` and `err.message` are equal to engine-specific\n * values indicating max call stack size has been exceeded.\n * "Maximum call stack size exceeded" in V8.\n *\n * @param {Error} err\n * @returns {boolean}\n */\nfunction isStackOverflowError(err) {\n  if (maxStack_ErrorMessage === undefined) {\n    try {\n      function overflowStack() { overflowStack(); }\n      overflowStack();\n    } catch (err) {\n      maxStack_ErrorMessage = err.message;\n      maxStack_ErrorName = err.name;\n    }\n  }\n\n  return err && err.name === maxStack_ErrorName &&\n         err.message === maxStack_ErrorMessage;\n}\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = '';\n  let i = val.length;\n  const start = val[0] === '-' ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    res = `_${StringPrototypeSlice(val\x2C i - 3\x2C i)}${res}`;\n  }\n  return `${StringPrototypeSlice(val\x2C 0\x2C i)}${res}`;\n}\n\n// Used to enhance the stack that will be picked up by the inspector\nconst kEnhanceStackBeforeInspector = Symbol('kEnhanceStackBeforeInspector');\n\n// These are supposed to be called only on fatal exceptions before\n// the process exits.\nconst fatalExceptionStackEnhancers = {\n  beforeInspector(error) {\n    if (typeof error[kEnhanceStackBeforeInspector] !== 'function') {\n      return error.stack;\n    }\n\n    try {\n      // Set the error.stack here so it gets picked up by the\n      // inspector.\n      error.stack = error[kEnhanceStackBeforeInspector]();\n    } catch {\n      // We are just enhancing the error. If it fails\x2C ignore it.\n    }\n    return error.stack;\n  }\x2C\n  afterInspector(error) {\n    const originalStack = error.stack;\n    let useColors = true;\n    // Some consoles do not convert ANSI escape sequences to colors\x2C\n    // rather display them directly to the stdout. On those consoles\x2C\n    // libuv emulates colors by intercepting stdout stream and calling\n    // corresponding Windows API functions for setting console colors.\n    // However\x2C fatal error are handled differently and we cannot easily\n    // highlight them. On Windows\x2C detecting whether a console supports\n    // ANSI escape sequences is not reliable.\n    if (process.platform === 'win32') {\n      const info = internalBinding('os').getOSInformation();\n      const ver = ArrayPrototypeMap(StringPrototypeSplit(info[2]\x2C '.')\x2C\n                                    Number);\n      if (ver[0] !== 10 || ver[2] < 14393) {\n        useColors = false;\n      }\n    }\n    const {\n      inspect\x2C\n      inspectDefaultOptions: {\n        colors: defaultColors\n      }\n    } = lazyInternalUtilInspect();\n    const colors = useColors &&\n                   ((internalBinding('util').guessHandleType(2) === 'TTY' &&\n                   require('internal/tty').hasColors()) ||\n                   defaultColors);\n    try {\n      return inspect(error\x2C {\n        colors\x2C\n        customInspect: false\x2C\n        depth: MathMax(inspect.defaultOptions.depth\x2C 5)\n      });\n    } catch {\n      return originalStack;\n    }\n  }\n};\n\n// Ensures the printed error line is from user code.\nlet _kArrowMessagePrivateSymbol\x2C _setHiddenValue;\nfunction setArrowMessage(err\x2C arrowMessage) {\n  if (!_kArrowMessagePrivateSymbol) {\n    ({\n      arrow_message_private_symbol: _kArrowMessagePrivateSymbol\x2C\n      setHiddenValue: _setHiddenValue\x2C\n    } = internalBinding('util'));\n  }\n  _setHiddenValue(err\x2C _kArrowMessagePrivateSymbol\x2C arrowMessage);\n}\n\n// Hide stack lines before the first user code line.\nfunction hideInternalStackFrames(error) {\n  overrideStackTrace.set(error\x2C (error\x2C stackFrames) => {\n    let frames = stackFrames;\n    if (typeof stackFrames === 'object') {\n      frames = ArrayPrototypeFilter(\n        stackFrames\x2C\n        (frm) => !StringPrototypeStartsWith(frm.getFileName() || ''\x2C\n                                            'node:internal')\n      );\n    }\n    ArrayPrototypeUnshift(frames\x2C error);\n    return ArrayPrototypeJoin(frames\x2C '\\n    at ');\n  });\n}\n\n// Node uses an AbortError that isn't exactly the same as the DOMException\n// to make usage of the error in userland and readable-stream easier.\n// It is a regular error with `.code` and `.name`.\nclass AbortError extends Error {\n  constructor(message = 'The operation was aborted'\x2C options = undefined) {\n    if (options !== undefined && typeof options !== 'object') {\n      throw new codes.ERR_INVALID_ARG_TYPE('options'\x2C 'Object'\x2C options);\n    }\n    super(message\x2C options);\n    this.code = 'ABORT_ERR';\n    this.name = 'AbortError';\n  }\n}\n\n/**\n * This creates a generic Node.js error.\n *\n * @param {string} message The error message.\n * @param {object} errorProperties Object with additional properties to be added to the error.\n * @returns {Error}\n */\nconst genericNodeError = hideStackFrames(function genericNodeError(message\x2C errorProperties) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  ObjectAssign(err\x2C errorProperties);\n  return err;\n});\n\nmodule.exports = {\n  AbortError\x2C\n  aggregateTwoErrors\x2C\n  captureLargerStackTrace\x2C\n  codes\x2C\n  connResetException\x2C\n  dnsException\x2C\n  // This is exported only to facilitate testing.\n  E\x2C\n  errnoException\x2C\n  exceptionWithHostPort\x2C\n  fatalExceptionStackEnhancers\x2C\n  genericNodeError\x2C\n  getMessage\x2C\n  hideInternalStackFrames\x2C\n  hideStackFrames\x2C\n  isErrorStackTraceLimitWritable\x2C\n  isStackOverflowError\x2C\n  kEnhanceStackBeforeInspector\x2C\n  kIsNodeError\x2C\n  kNoOverride\x2C\n  maybeOverridePrepareStackTrace\x2C\n  overrideStackTrace\x2C\n  prepareStackTrace\x2C\n  setArrowMessage\x2C\n  SystemError\x2C\n  uvErrmapGet\x2C\n  uvException\x2C\n  uvExceptionWithHostPort\x2C\n};\n\n// To declare an error message\x2C use the E(sym\x2C val\x2C def) function above. The sym\n// must be an upper case string. The val can be either a function or a string.\n// The def must be an error class.\n// The return value of the function must be a string.\n// Examples:\n// E('EXAMPLE_KEY1'\x2C 'This is the error value'\x2C Error);\n// E('EXAMPLE_KEY2'\x2C (a\x2C b) => return `${a} ${b}`\x2C RangeError);\n//\n// Once an error code has been assigned\x2C the code itself MUST NOT change and\n// any given error code must never be reused to identify a different error.\n//\n// Any error code added here should also be added to the documentation\n//\n// Note: Please try to keep these in alphabetical order\n//\n// Note: Node.js specific errors must begin with the prefix ERR_\n\nE('ERR_AMBIGUOUS_ARGUMENT'\x2C 'The "%s" argument is ambiguous. %s'\x2C TypeError);\nE('ERR_ARG_NOT_ITERABLE'\x2C '%s must be iterable'\x2C TypeError);\nE('ERR_ASSERTION'\x2C '%s'\x2C Error);\nE('ERR_ASYNC_CALLBACK'\x2C '%s must be a function'\x2C TypeError);\nE('ERR_ASYNC_TYPE'\x2C 'Invalid name for async "type": %s'\x2C TypeError);\nE('ERR_BROTLI_INVALID_PARAM'\x2C '%s is not a valid Brotli parameter'\x2C RangeError);\nE('ERR_BUFFER_OUT_OF_BOUNDS'\x2C\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (name = undefined) => {\n    if (name) {\n      return `"${name}" is outside of buffer bounds`;\n    }\n    return 'Attempt to access memory outside buffer bounds';\n  }\x2C RangeError);\nE('ERR_BUFFER_TOO_LARGE'\x2C\n  'Cannot create a Buffer larger than %s bytes'\x2C\n  RangeError);\nE('ERR_CANNOT_WATCH_SIGINT'\x2C 'Cannot watch for SIGINT signals'\x2C Error);\nE('ERR_CHILD_CLOSED_BEFORE_REPLY'\x2C\n  'Child closed before reply received'\x2C Error);\nE('ERR_CHILD_PROCESS_IPC_REQUIRED'\x2C\n  "Forked processes must have an IPC channel\x2C missing value 'ipc' in %s"\x2C\n  Error);\nE('ERR_CHILD_PROCESS_STDIO_MAXBUFFER'\x2C '%s maxBuffer length exceeded'\x2C\n  RangeError);\nE('ERR_CONSOLE_WRITABLE_STREAM'\x2C\n  'Console expects a writable stream instance for %s'\x2C TypeError);\nE('ERR_CONTEXT_NOT_INITIALIZED'\x2C 'context used is not initialized'\x2C Error);\nE('ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED'\x2C\n  'Custom engines not supported by this OpenSSL'\x2C Error);\nE('ERR_CRYPTO_ECDH_INVALID_FORMAT'\x2C 'Invalid ECDH format: %s'\x2C TypeError);\nE('ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY'\x2C\n  'Public key is not valid for specified curve'\x2C Error);\nE('ERR_CRYPTO_ENGINE_UNKNOWN'\x2C 'Engine "%s" was not found'\x2C Error);\nE('ERR_CRYPTO_FIPS_FORCED'\x2C\n  'Cannot set FIPS mode\x2C it was forced with --force-fips at startup.'\x2C Error);\nE('ERR_CRYPTO_FIPS_UNAVAILABLE'\x2C 'Cannot set FIPS mode in a non-FIPS build.'\x2C\n  Error);\nE('ERR_CRYPTO_HASH_FINALIZED'\x2C 'Digest already called'\x2C Error);\nE('ERR_CRYPTO_HASH_UPDATE_FAILED'\x2C 'Hash update failed'\x2C Error);\nE('ERR_CRYPTO_INCOMPATIBLE_KEY'\x2C 'Incompatible %s: %s'\x2C Error);\nE('ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS'\x2C 'The selected key encoding %s %s.'\x2C\n  Error);\nE('ERR_CRYPTO_INVALID_DIGEST'\x2C 'Invalid digest: %s'\x2C TypeError);\nE('ERR_CRYPTO_INVALID_JWK'\x2C 'Invalid JWK data'\x2C TypeError);\nE('ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE'\x2C\n  'Invalid key object type %s\x2C expected %s.'\x2C TypeError);\nE('ERR_CRYPTO_INVALID_STATE'\x2C 'Invalid state for operation %s'\x2C Error);\nE('ERR_CRYPTO_PBKDF2_ERROR'\x2C 'PBKDF2 error'\x2C Error);\nE('ERR_CRYPTO_SCRYPT_INVALID_PARAMETER'\x2C 'Invalid scrypt parameter'\x2C Error);\nE('ERR_CRYPTO_SCRYPT_NOT_SUPPORTED'\x2C 'Scrypt algorithm not supported'\x2C Error);\n// Switch to TypeError. The current implementation does not seem right.\nE('ERR_CRYPTO_SIGN_KEY_REQUIRED'\x2C 'No key provided to sign'\x2C Error);\nE('ERR_DEBUGGER_ERROR'\x2C '%s'\x2C Error);\nE('ERR_DEBUGGER_STARTUP_ERROR'\x2C '%s'\x2C Error);\nE('ERR_DIR_CLOSED'\x2C 'Directory handle was closed'\x2C Error);\nE('ERR_DIR_CONCURRENT_OPERATION'\x2C\n  'Cannot do synchronous work on directory handle with concurrent ' +\n  'asynchronous operations'\x2C Error);\nE('ERR_DNS_SET_SERVERS_FAILED'\x2C 'c-ares failed to set servers: "%s" [%s]'\x2C\n  Error);\nE('ERR_DOMAIN_CALLBACK_NOT_AVAILABLE'\x2C\n  'A callback was registered through ' +\n     'process.setUncaughtExceptionCaptureCallback()\x2C which is mutually ' +\n     'exclusive with using the `domain` module'\x2C\n  Error);\nE('ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE'\x2C\n  'The `domain` module is in use\x2C which is mutually exclusive with calling ' +\n     'process.setUncaughtExceptionCaptureCallback()'\x2C\n  Error);\nE('ERR_ENCODING_INVALID_ENCODED_DATA'\x2C function(encoding\x2C ret) {\n  this.errno = ret;\n  return `The encoded data was not valid for encoding ${encoding}`;\n}\x2C TypeError);\nE('ERR_ENCODING_NOT_SUPPORTED'\x2C 'The "%s" encoding is not supported'\x2C\n  RangeError);\nE('ERR_EVAL_ESM_CANNOT_PRINT'\x2C '--print cannot be used with ESM input'\x2C Error);\nE('ERR_EVENT_RECURSION'\x2C 'The event "%s" is already being dispatched'\x2C Error);\nE('ERR_FALSY_VALUE_REJECTION'\x2C function(reason) {\n  this.reason = reason;\n  return 'Promise was rejected with falsy value';\n}\x2C Error);\nE('ERR_FEATURE_UNAVAILABLE_ON_PLATFORM'\x2C\n  'The feature %s is unavailable on the current platform' +\n  '\x2C which is being used to run Node.js'\x2C\n  TypeError);\nE('ERR_FS_CP_DIR_TO_NON_DIR'\x2C\n  'Cannot overwrite directory with non-directory'\x2C SystemError);\nE('ERR_FS_CP_EEXIST'\x2C 'Target already exists'\x2C SystemError);\nE('ERR_FS_CP_EINVAL'\x2C 'Invalid src or dest'\x2C SystemError);\nE('ERR_FS_CP_FIFO_PIPE'\x2C 'Cannot copy a FIFO pipe'\x2C SystemError);\nE('ERR_FS_CP_NON_DIR_TO_DIR'\x2C\n  'Cannot overwrite non-directory with directory'\x2C SystemError);\nE('ERR_FS_CP_SOCKET'\x2C 'Cannot copy a socket file'\x2C SystemError);\nE('ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY'\x2C\n  'Cannot overwrite symlink in subdirectory of self'\x2C SystemError);\nE('ERR_FS_CP_UNKNOWN'\x2C 'Cannot copy an unknown file type'\x2C SystemError);\nE('ERR_FS_EISDIR'\x2C 'Path is a directory'\x2C SystemError);\nE('ERR_FS_FILE_TOO_LARGE'\x2C 'File size (%s) is greater than 2 GB'\x2C RangeError);\nE('ERR_FS_INVALID_SYMLINK_TYPE'\x2C\n  'Symlink type must be one of "dir"\x2C "file"\x2C or "junction". Received "%s"'\x2C\n  Error); // Switch to TypeError. The current implementation does not seem right\nE('ERR_HTTP2_ALTSVC_INVALID_ORIGIN'\x2C\n  'HTTP/2 ALTSVC frames require a valid origin'\x2C TypeError);\nE('ERR_HTTP2_ALTSVC_LENGTH'\x2C\n  'HTTP/2 ALTSVC frames are limited to 16382 bytes'\x2C TypeError);\nE('ERR_HTTP2_CONNECT_AUTHORITY'\x2C\n  ':authority header is required for CONNECT requests'\x2C Error);\nE('ERR_HTTP2_CONNECT_PATH'\x2C\n  'The :path header is forbidden for CONNECT requests'\x2C Error);\nE('ERR_HTTP2_CONNECT_SCHEME'\x2C\n  'The :scheme header is forbidden for CONNECT requests'\x2C Error);\nE('ERR_HTTP2_GOAWAY_SESSION'\x2C\n  'New streams cannot be created after receiving a GOAWAY'\x2C Error);\nE('ERR_HTTP2_HEADERS_AFTER_RESPOND'\x2C\n  'Cannot specify additional headers after response initiated'\x2C Error);\nE('ERR_HTTP2_HEADERS_SENT'\x2C 'Response has already been initiated.'\x2C Error);\nE('ERR_HTTP2_HEADER_SINGLE_VALUE'\x2C\n  'Header field "%s" must only have a single value'\x2C TypeError);\nE('ERR_HTTP2_INFO_STATUS_NOT_ALLOWED'\x2C\n  'Informational status codes cannot be used'\x2C RangeError);\nE('ERR_HTTP2_INVALID_CONNECTION_HEADERS'\x2C\n  'HTTP/1 Connection specific headers are forbidden: "%s"'\x2C TypeError);\nE('ERR_HTTP2_INVALID_HEADER_VALUE'\x2C\n  'Invalid value "%s" for header "%s"'\x2C TypeError);\nE('ERR_HTTP2_INVALID_INFO_STATUS'\x2C\n  'Invalid informational status code: %s'\x2C RangeError);\nE('ERR_HTTP2_INVALID_ORIGIN'\x2C\n  'HTTP/2 ORIGIN frames require a valid origin'\x2C TypeError);\nE('ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH'\x2C\n  'Packed settings length must be a multiple of six'\x2C RangeError);\nE('ERR_HTTP2_INVALID_PSEUDOHEADER'\x2C\n  '"%s" is an invalid pseudoheader or is used incorrectly'\x2C TypeError);\nE('ERR_HTTP2_INVALID_SESSION'\x2C 'The session has been destroyed'\x2C Error);\nE('ERR_HTTP2_INVALID_SETTING_VALUE'\x2C\n  // Using default arguments here is important so the arguments are not counted\n  // towards `Function#length`.\n  function(name\x2C actual\x2C min = undefined\x2C max = undefined) {\n    this.actual = actual;\n    if (min !== undefined) {\n      this.min = min;\n      this.max = max;\n    }\n    return `Invalid value for setting "${name}": ${actual}`;\n  }\x2C TypeError\x2C RangeError);\nE('ERR_HTTP2_INVALID_STREAM'\x2C 'The stream has been destroyed'\x2C Error);\nE('ERR_HTTP2_MAX_PENDING_SETTINGS_ACK'\x2C\n  'Maximum number of pending settings acknowledgements'\x2C Error);\nE('ERR_HTTP2_NESTED_PUSH'\x2C\n  'A push stream cannot initiate another push stream.'\x2C Error);\nE('ERR_HTTP2_NO_MEM'\x2C 'Out of memory'\x2C Error);\nE('ERR_HTTP2_NO_SOCKET_MANIPULATION'\x2C\n  'HTTP/2 sockets should not be directly manipulated (e.g. read and written)'\x2C\n  Error);\nE('ERR_HTTP2_ORIGIN_LENGTH'\x2C\n  'HTTP/2 ORIGIN frames are limited to 16382 bytes'\x2C TypeError);\nE('ERR_HTTP2_OUT_OF_STREAMS'\x2C\n  'No stream ID is available because maximum stream ID has been reached'\x2C\n  Error);\nE('ERR_HTTP2_PAYLOAD_FORBIDDEN'\x2C\n  'Responses with %s status must not have a payload'\x2C Error);\nE('ERR_HTTP2_PING_CANCEL'\x2C 'HTTP2 ping cancelled'\x2C Error);\nE('ERR_HTTP2_PING_LENGTH'\x2C 'HTTP2 ping payload must be 8 bytes'\x2C RangeError);\nE('ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED'\x2C\n  'Cannot set HTTP/2 pseudo-headers'\x2C TypeError);\nE('ERR_HTTP2_PUSH_DISABLED'\x2C 'HTTP/2 client has disabled push streams'\x2C Error);\nE('ERR_HTTP2_SEND_FILE'\x2C 'Directories cannot be sent'\x2C Error);\nE('ERR_HTTP2_SEND_FILE_NOSEEK'\x2C\n  'Offset or length can only be specified for regular files'\x2C Error);\nE('ERR_HTTP2_SESSION_ERROR'\x2C 'Session closed with error code %s'\x2C Error);\nE('ERR_HTTP2_SETTINGS_CANCEL'\x2C 'HTTP2 session settings canceled'\x2C Error);\nE('ERR_HTTP2_SOCKET_BOUND'\x2C\n  'The socket is already bound to an Http2Session'\x2C Error);\nE('ERR_HTTP2_SOCKET_UNBOUND'\x2C\n  'The socket has been disconnected from the Http2Session'\x2C Error);\nE('ERR_HTTP2_STATUS_101'\x2C\n  'HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2'\x2C Error);\nE('ERR_HTTP2_STATUS_INVALID'\x2C 'Invalid status code: %s'\x2C RangeError);\nE('ERR_HTTP2_STREAM_CANCEL'\x2C function(error) {\n  let msg = 'The pending stream has been canceled';\n  if (error) {\n    this.cause = error;\n    if (typeof error.message === 'string')\n      msg += ` (caused by: ${error.message})`;\n  }\n  return msg;\n}\x2C Error);\nE('ERR_HTTP2_STREAM_ERROR'\x2C 'Stream closed with error code %s'\x2C Error);\nE('ERR_HTTP2_STREAM_SELF_DEPENDENCY'\x2C\n  'A stream cannot depend on itself'\x2C Error);\nE('ERR_HTTP2_TOO_MANY_INVALID_FRAMES'\x2C 'Too many invalid HTTP/2 frames'\x2C Error);\nE('ERR_HTTP2_TRAILERS_ALREADY_SENT'\x2C\n  'Trailing headers have already been sent'\x2C Error);\nE('ERR_HTTP2_TRAILERS_NOT_READY'\x2C\n  'Trailing headers cannot be sent until after the wantTrailers event is ' +\n  'emitted'\x2C Error);\nE('ERR_HTTP2_UNSUPPORTED_PROTOCOL'\x2C 'protocol "%s" is unsupported.'\x2C Error);\nE('ERR_HTTP_HEADERS_SENT'\x2C\n  'Cannot %s headers after they are sent to the client'\x2C Error);\nE('ERR_HTTP_INVALID_HEADER_VALUE'\x2C\n  'Invalid value "%s" for header "%s"'\x2C TypeError);\nE('ERR_HTTP_INVALID_STATUS_CODE'\x2C 'Invalid status code: %s'\x2C RangeError);\nE('ERR_HTTP_REQUEST_TIMEOUT'\x2C 'Request timeout'\x2C Error);\nE('ERR_HTTP_SOCKET_ENCODING'\x2C\n  'Changing the socket encoding is not allowed per RFC7230 Section 3.'\x2C Error);\nE('ERR_HTTP_TRAILER_INVALID'\x2C\n  'Trailers are invalid with this transfer encoding'\x2C Error);\nE('ERR_ILLEGAL_CONSTRUCTOR'\x2C 'Illegal constructor'\x2C TypeError);\nE('ERR_IMPORT_ASSERTION_TYPE_FAILED'\x2C\n  'Module "%s" is not of type "%s"'\x2C TypeError);\nE('ERR_IMPORT_ASSERTION_TYPE_MISSING'\x2C\n  'Module "%s" needs an import assertion of type "%s"'\x2C TypeError);\nE('ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED'\x2C\n  'Import assertion type "%s" is unsupported'\x2C TypeError);\nE('ERR_INCOMPATIBLE_OPTION_PAIR'\x2C\n  'Option "%s" cannot be used in combination with option "%s"'\x2C TypeError);\nE('ERR_INPUT_TYPE_NOT_ALLOWED'\x2C '--input-type can only be used with string ' +\n  'input via --eval\x2C --print\x2C or STDIN'\x2C Error);\nE('ERR_INSPECTOR_ALREADY_ACTIVATED'\x2C\n  'Inspector is already activated. Close it with inspector.close() ' +\n  'before activating it again.'\x2C\n  Error);\nE('ERR_INSPECTOR_ALREADY_CONNECTED'\x2C '%s is already connected'\x2C Error);\nE('ERR_INSPECTOR_CLOSED'\x2C 'Session was closed'\x2C Error);\nE('ERR_INSPECTOR_COMMAND'\x2C 'Inspector error %d: %s'\x2C Error);\nE('ERR_INSPECTOR_NOT_ACTIVE'\x2C 'Inspector is not active'\x2C Error);\nE('ERR_INSPECTOR_NOT_AVAILABLE'\x2C 'Inspector is not available'\x2C Error);\nE('ERR_INSPECTOR_NOT_CONNECTED'\x2C 'Session is not connected'\x2C Error);\nE('ERR_INSPECTOR_NOT_WORKER'\x2C 'Current thread is not a worker'\x2C Error);\nE('ERR_INTERNAL_ASSERTION'\x2C (message) => {\n  const suffix = 'This is caused by either a bug in Node.js ' +\n    'or incorrect usage of Node.js internals.\\n' +\n    'Please open an issue with this stack trace at ' +\n    'https://github.com/nodejs/node/issues\\n';\n  return message === undefined ? suffix : `${message}\\n${suffix}`;\n}\x2C Error);\nE('ERR_INVALID_ADDRESS_FAMILY'\x2C function(addressType\x2C host\x2C port) {\n  this.host = host;\n  this.port = port;\n  return `Invalid address family: ${addressType} ${host}:${port}`;\n}\x2C RangeError);\nE('ERR_INVALID_ARG_TYPE'\x2C\n  (name\x2C expected\x2C actual) => {\n    assert(typeof name === 'string'\x2C "'name' must be a string");\n    if (!ArrayIsArray(expected)) {\n      expected = [expected];\n    }\n\n    let msg = 'The ';\n    if (StringPrototypeEndsWith(name\x2C ' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `;\n    } else {\n      const type = StringPrototypeIncludes(name\x2C '.') ? 'property' : 'argument';\n      msg += `"${name}" ${type} `;\n    }\n    msg += 'must be ';\n\n    const types = [];\n    const instances = [];\n    const other = [];\n\n    for (const value of expected) {\n      assert(typeof value === 'string'\x2C\n             'All expected entries have to be of type string');\n      if (ArrayPrototypeIncludes(kTypes\x2C value)) {\n        ArrayPrototypePush(types\x2C StringPrototypeToLowerCase(value));\n      } else if (RegExpPrototypeTest(classRegExp\x2C value)) {\n        ArrayPrototypePush(instances\x2C value);\n      } else {\n        assert(value !== 'object'\x2C\n               'The value "object" should be written as "Object"');\n        ArrayPrototypePush(other\x2C value);\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = ArrayPrototypeIndexOf(types\x2C 'object');\n      if (pos !== -1) {\n        ArrayPrototypeSplice(types\x2C pos\x2C 1);\n        ArrayPrototypePush(instances\x2C 'Object');\n      }\n    }\n\n    if (types.length > 0) {\n      if (types.length > 2) {\n        const last = ArrayPrototypePop(types);\n        msg += `one of type ${ArrayPrototypeJoin(types\x2C '\x2C ')}\x2C or ${last}`;\n      } else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}`;\n      } else {\n        msg += `of type ${types[0]}`;\n      }\n      if (instances.length > 0 || other.length > 0)\n        msg += ' or ';\n    }\n\n    if (instances.length > 0) {\n      if (instances.length > 2) {\n        const last = ArrayPrototypePop(instances);\n        msg +=\n          `an instance of ${ArrayPrototypeJoin(instances\x2C '\x2C ')}\x2C or ${last}`;\n      } else {\n        msg += `an instance of ${instances[0]}`;\n        if (instances.length === 2) {\n          msg += ` or ${instances[1]}`;\n        }\n      }\n      if (other.length > 0)\n        msg += ' or ';\n    }\n\n    if (other.length > 0) {\n      if (other.length > 2) {\n        const last = ArrayPrototypePop(other);\n        msg += `one of ${ArrayPrototypeJoin(other\x2C '\x2C ')}\x2C or ${last}`;\n      } else if (other.length === 2) {\n        msg += `one of ${other[0]} or ${other[1]}`;\n      } else {\n        if (StringPrototypeToLowerCase(other[0]) !== other[0])\n          msg += 'an ';\n        msg += `${other[0]}`;\n      }\n    }\n\n    if (actual == null) {\n      msg += `. Received ${actual}`;\n    } else if (typeof actual === 'function' && actual.name) {\n      msg += `. Received function ${actual.name}`;\n    } else if (typeof actual === 'object') {\n      if (actual.constructor && actual.constructor.name) {\n        msg += `. Received an instance of ${actual.constructor.name}`;\n      } else {\n        const inspected = lazyInternalUtilInspect()\n          .inspect(actual\x2C { depth: -1 });\n        msg += `. Received ${inspected}`;\n      }\n    } else {\n      let inspected = lazyInternalUtilInspect()\n        .inspect(actual\x2C { colors: false });\n      if (inspected.length > 25)\n        inspected = `${StringPrototypeSlice(inspected\x2C 0\x2C 25)}...`;\n      msg += `. Received type ${typeof actual} (${inspected})`;\n    }\n    return msg;\n  }\x2C TypeError);\nE('ERR_INVALID_ARG_VALUE'\x2C (name\x2C value\x2C reason = 'is invalid') => {\n  let inspected = lazyInternalUtilInspect().inspect(value);\n  if (inspected.length > 128) {\n    inspected = `${StringPrototypeSlice(inspected\x2C 0\x2C 128)}...`;\n  }\n  const type = StringPrototypeIncludes(name\x2C '.') ? 'property' : 'argument';\n  return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n}\x2C TypeError\x2C RangeError);\nE('ERR_INVALID_ASYNC_ID'\x2C 'Invalid %s value: %s'\x2C RangeError);\nE('ERR_INVALID_BUFFER_SIZE'\x2C\n  'Buffer size must be a multiple of %s'\x2C RangeError);\nE('ERR_INVALID_CALLBACK'\x2C\n  'Callback must be a function. Received %O'\x2C TypeError);\nE('ERR_INVALID_CHAR'\x2C\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (name\x2C field = undefined) => {\n    let msg = `Invalid character in ${name}`;\n    if (field !== undefined) {\n      msg += ` ["${field}"]`;\n    }\n    return msg;\n  }\x2C TypeError);\nE('ERR_INVALID_CURSOR_POS'\x2C\n  'Cannot set cursor row without setting its column'\x2C TypeError);\nE('ERR_INVALID_FD'\x2C\n  '"fd" must be a positive integer: %s'\x2C RangeError);\nE('ERR_INVALID_FD_TYPE'\x2C 'Unsupported fd type: %s'\x2C TypeError);\nE('ERR_INVALID_FILE_URL_HOST'\x2C\n  'File URL host must be "localhost" or empty on %s'\x2C TypeError);\nE('ERR_INVALID_FILE_URL_PATH'\x2C 'File URL path %s'\x2C TypeError);\nE('ERR_INVALID_HANDLE_TYPE'\x2C 'This handle type cannot be sent'\x2C TypeError);\nE('ERR_INVALID_HTTP_TOKEN'\x2C '%s must be a valid HTTP token ["%s"]'\x2C TypeError);\nE('ERR_INVALID_IP_ADDRESS'\x2C 'Invalid IP address: %s'\x2C TypeError);\nE('ERR_INVALID_MODULE_SPECIFIER'\x2C (request\x2C reason\x2C base = undefined) => {\n  return `Invalid module "${request}" ${reason}${base ?\n    ` imported from ${base}` : ''}`;\n}\x2C TypeError);\nE('ERR_INVALID_PACKAGE_CONFIG'\x2C (path\x2C base\x2C message) => {\n  return `Invalid package config ${path}${base ? ` while importing ${base}` :\n    ''}${message ? `. ${message}` : ''}`;\n}\x2C Error);\nE('ERR_INVALID_PACKAGE_TARGET'\x2C\n  (pkgPath\x2C key\x2C target\x2C isImport = false\x2C base = undefined) => {\n    const relError = typeof target === 'string' && !isImport &&\n      target.length && !StringPrototypeStartsWith(target\x2C './');\n    if (key === '.') {\n      assert(isImport === false);\n      return `Invalid "exports" main target ${JSONStringify(target)} defined ` +\n        `in the package config ${pkgPath}package.json${base ?\n          ` imported from ${base}` : ''}${relError ?\n          '; targets must start with "./"' : ''}`;\n    }\n    return `Invalid "${isImport ? 'imports' : 'exports'}" target ${\n      JSONStringify(target)} defined for '${key}' in the package config ${\n      pkgPath}package.json${base ? ` imported from ${base}` : ''}${relError ?\n      '; targets must start with "./"' : ''}`;\n  }\x2C Error);\nE('ERR_INVALID_PROTOCOL'\x2C\n  'Protocol "%s" not supported. Expected "%s"'\x2C\n  TypeError);\nE('ERR_INVALID_REPL_EVAL_CONFIG'\x2C\n  'Cannot specify both "breakEvalOnSigint" and "eval" for REPL'\x2C TypeError);\nE('ERR_INVALID_REPL_INPUT'\x2C '%s'\x2C TypeError);\nE('ERR_INVALID_RETURN_PROPERTY'\x2C (input\x2C name\x2C prop\x2C value) => {\n  return `Expected a valid ${input} to be returned for the "${prop}" from the` +\n         ` "${name}" function but got ${value}.`;\n}\x2C TypeError);\nE('ERR_INVALID_RETURN_PROPERTY_VALUE'\x2C (input\x2C name\x2C prop\x2C value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned for the "${prop}" from the` +\n         ` "${name}" function but got ${type}.`;\n}\x2C TypeError);\nE('ERR_INVALID_RETURN_VALUE'\x2C (input\x2C name\x2C value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned from the "${name}"` +\n         ` function but got ${type}.`;\n}\x2C TypeError\x2C RangeError);\nE('ERR_INVALID_STATE'\x2C 'Invalid state: %s'\x2C Error\x2C TypeError\x2C RangeError);\nE('ERR_INVALID_SYNC_FORK_INPUT'\x2C\n  'Asynchronous forks do not support ' +\n    'Buffer\x2C TypedArray\x2C DataView or string input: %s'\x2C\n  TypeError);\nE('ERR_INVALID_THIS'\x2C 'Value of "this" must be of type %s'\x2C TypeError);\nE('ERR_INVALID_TUPLE'\x2C '%s must be an iterable %s tuple'\x2C TypeError);\nE('ERR_INVALID_URI'\x2C 'URI malformed'\x2C URIError);\nE('ERR_INVALID_URL'\x2C function(input) {\n  this.input = input;\n  // Don't include URL in message.\n  // (See https://github.com/nodejs/node/pull/38614)\n  return 'Invalid URL';\n}\x2C TypeError);\nE('ERR_INVALID_URL_SCHEME'\x2C\n  (expected) => {\n    if (typeof expected === 'string')\n      expected = [expected];\n    assert(expected.length <= 2);\n    const res = expected.length === 2 ?\n      `one of scheme ${expected[0]} or ${expected[1]}` :\n      `of scheme ${expected[0]}`;\n    return `The URL must be ${res}`;\n  }\x2C TypeError);\nE('ERR_IPC_CHANNEL_CLOSED'\x2C 'Channel closed'\x2C Error);\nE('ERR_IPC_DISCONNECTED'\x2C 'IPC channel is already disconnected'\x2C Error);\nE('ERR_IPC_ONE_PIPE'\x2C 'Child process can have only one IPC pipe'\x2C Error);\nE('ERR_IPC_SYNC_FORK'\x2C 'IPC cannot be used with synchronous forks'\x2C Error);\nE('ERR_MANIFEST_ASSERT_INTEGRITY'\x2C\n  (moduleURL\x2C realIntegrities) => {\n    let msg = `The content of "${\n      moduleURL\n    }" does not match the expected integrity.`;\n    if (realIntegrities.size) {\n      const sri = ArrayPrototypeJoin(\n        ArrayFrom(realIntegrities.entries()\x2C\n                  ({ 0: alg\x2C 1: dgs }) => `${alg}-${dgs}`)\x2C\n        ' '\n      );\n      msg += ` Integrities found are: ${sri}`;\n    } else {\n      msg += ' The resource was not found in the policy.';\n    }\n    return msg;\n  }\x2C Error);\nE('ERR_MANIFEST_DEPENDENCY_MISSING'\x2C\n  'Manifest resource %s does not list %s as a dependency specifier for ' +\n  'conditions: %s'\x2C\n  Error);\nE('ERR_MANIFEST_INTEGRITY_MISMATCH'\x2C\n  'Manifest resource %s has multiple entries but integrity lists do not match'\x2C\n  SyntaxError);\nE('ERR_MANIFEST_INVALID_RESOURCE_FIELD'\x2C\n  'Manifest resource %s has invalid property value for %s'\x2C\n  TypeError);\nE('ERR_MANIFEST_INVALID_SPECIFIER'\x2C\n  'Manifest resource %s has invalid dependency mapping %s'\x2C\n  TypeError);\nE('ERR_MANIFEST_TDZ'\x2C 'Manifest initialization has not yet run'\x2C Error);\nE('ERR_MANIFEST_UNKNOWN_ONERROR'\x2C\n  'Manifest specified unknown error behavior "%s".'\x2C\n  SyntaxError);\nE('ERR_METHOD_NOT_IMPLEMENTED'\x2C 'The %s method is not implemented'\x2C Error);\nE('ERR_MISSING_ARGS'\x2C\n  (...args) => {\n    assert(args.length > 0\x2C 'At least one arg needs to be specified');\n    let msg = 'The ';\n    const len = args.length;\n    const wrap = (a) => `"${a}"`;\n    args = ArrayPrototypeMap(\n      args\x2C\n      (a) => (ArrayIsArray(a) ?\n        ArrayPrototypeJoin(ArrayPrototypeMap(a\x2C wrap)\x2C ' or ') :\n        wrap(a))\n    );\n    switch (len) {\n      case 1:\n        msg += `${args[0]} argument`;\n        break;\n      case 2:\n        msg += `${args[0]} and ${args[1]} arguments`;\n        break;\n      default:\n        msg += ArrayPrototypeJoin(ArrayPrototypeSlice(args\x2C 0\x2C len - 1)\x2C '\x2C ');\n        msg += `\x2C and ${args[len - 1]} arguments`;\n        break;\n    }\n    return `${msg} must be specified`;\n  }\x2C TypeError);\nE('ERR_MISSING_OPTION'\x2C '%s is required'\x2C TypeError);\nE('ERR_MODULE_NOT_FOUND'\x2C (path\x2C base\x2C type = 'package') => {\n  return `Cannot find ${type} '${path}' imported from ${base}`;\n}\x2C Error);\nE('ERR_MULTIPLE_CALLBACK'\x2C 'Callback called multiple times'\x2C Error);\nE('ERR_NAPI_CONS_FUNCTION'\x2C 'Constructor must be a function'\x2C TypeError);\nE('ERR_NAPI_INVALID_DATAVIEW_ARGS'\x2C\n  'byte_offset + byte_length should be less than or equal to the size in ' +\n    'bytes of the array passed in'\x2C\n  RangeError);\nE('ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT'\x2C\n  'start offset of %s should be a multiple of %s'\x2C RangeError);\nE('ERR_NAPI_INVALID_TYPEDARRAY_LENGTH'\x2C\n  'Invalid typed array length'\x2C RangeError);\nE('ERR_NETWORK_IMPORT_BAD_RESPONSE'\x2C\n  "import '%s' received a bad response: %s"\x2C Error);\nE('ERR_NETWORK_IMPORT_DISALLOWED'\x2C\n  "import of '%s' by %s is not supported: %s"\x2C Error);\nE('ERR_NO_CRYPTO'\x2C\n  'Node.js is not compiled with OpenSSL crypto support'\x2C Error);\nE('ERR_NO_ICU'\x2C\n  '%s is not supported on Node.js compiled without ICU'\x2C TypeError);\nE('ERR_OPERATION_FAILED'\x2C 'Operation failed: %s'\x2C Error\x2C TypeError);\nE('ERR_OUT_OF_RANGE'\x2C\n  (str\x2C range\x2C input\x2C replaceDefaultBoolean = false) => {\n    assert(range\x2C 'Missing "range" argument');\n    let msg = replaceDefaultBoolean ? str :\n      `The value of "${str}" is out of range.`;\n    let received;\n    if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input));\n    } else if (typeof input === 'bigint') {\n      received = String(input);\n      if (input > 2n ** 32n || input < -(2n ** 32n)) {\n        received = addNumericalSeparator(received);\n      }\n      received += 'n';\n    } else {\n      received = lazyInternalUtilInspect().inspect(input);\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n  }\x2C RangeError);\nE('ERR_PACKAGE_IMPORT_NOT_DEFINED'\x2C (specifier\x2C packagePath\x2C base) => {\n  return `Package import specifier "${specifier}" is not defined${packagePath ?\n    ` in package ${packagePath}package.json` : ''} imported from ${base}`;\n}\x2C TypeError);\nE('ERR_PACKAGE_PATH_NOT_EXPORTED'\x2C (pkgPath\x2C subpath\x2C base = undefined) => {\n  if (subpath === '.')\n    return `No "exports" main defined in ${pkgPath}package.json${base ?\n      ` imported from ${base}` : ''}`;\n  return `Package subpath '${subpath}' is not defined by "exports" in ${\n    pkgPath}package.json${base ? ` imported from ${base}` : ''}`;\n}\x2C Error);\nE('ERR_PERFORMANCE_INVALID_TIMESTAMP'\x2C\n  '%d is not a valid timestamp'\x2C TypeError);\nE('ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS'\x2C '%s'\x2C TypeError);\nE('ERR_REQUIRE_ESM'\x2C\n  function(filename\x2C hasEsmSyntax\x2C parentPath = null\x2C packageJsonPath = null) {\n    hideInternalStackFrames(this);\n    let msg = `require() of ES Module ${filename}${parentPath ? ` from ${\n      parentPath}` : ''} not supported.`;\n    if (!packageJsonPath) {\n      if (StringPrototypeEndsWith(filename\x2C '.mjs'))\n        msg += `\\nInstead change the require of ${filename} to a dynamic ` +\n            'import() which is available in all CommonJS modules.';\n      return msg;\n    }\n    const path = require('path');\n    const basename = parentPath && path.basename(filename) ===\n      path.basename(parentPath) ? filename : path.basename(filename);\n    if (hasEsmSyntax) {\n      msg += `\\nInstead change the require of ${basename} in ${parentPath} to` +\n        ' a dynamic import() which is available in all CommonJS modules.';\n      return msg;\n    }\n    msg += `\\n${basename} is treated as an ES module file as it is a .js ` +\n      'file whose nearest parent package.json contains "type": "module" ' +\n      'which declares all .js files in that package scope as ES modules.' +\n      `\\nInstead rename ${basename} to end in .cjs\x2C change the requiring ` +\n      'code to use dynamic import() which is available in all CommonJS ' +\n      'modules\x2C or change "type": "module" to "type": "commonjs" in ' +\n      `${packageJsonPath} to treat all .js files as CommonJS (using .mjs for ` +\n      'all ES modules instead).\\n';\n    return msg;\n  }\x2C Error);\nE('ERR_SCRIPT_EXECUTION_INTERRUPTED'\x2C\n  'Script execution was interrupted by `SIGINT`'\x2C Error);\nE('ERR_SERVER_ALREADY_LISTEN'\x2C\n  'Listen method has been called more than once without closing.'\x2C Error);\nE('ERR_SERVER_NOT_RUNNING'\x2C 'Server is not running.'\x2C Error);\nE('ERR_SOCKET_ALREADY_BOUND'\x2C 'Socket is already bound'\x2C Error);\nE('ERR_SOCKET_BAD_BUFFER_SIZE'\x2C\n  'Buffer size must be a positive integer'\x2C TypeError);\nE('ERR_SOCKET_BAD_PORT'\x2C (name\x2C port\x2C allowZero = true) => {\n  assert(typeof allowZero === 'boolean'\x2C\n         "The 'allowZero' argument must be of type boolean.");\n  const operator = allowZero ? '>=' : '>';\n  return `${name} should be ${operator} 0 and < 65536. Received ${port}.`;\n}\x2C RangeError);\nE('ERR_SOCKET_BAD_TYPE'\x2C\n  'Bad socket type specified. Valid types are: udp4\x2C udp6'\x2C TypeError);\nE('ERR_SOCKET_BUFFER_SIZE'\x2C\n  'Could not get or set buffer size'\x2C\n  SystemError);\nE('ERR_SOCKET_CLOSED'\x2C 'Socket is closed'\x2C Error);\nE('ERR_SOCKET_DGRAM_IS_CONNECTED'\x2C 'Already connected'\x2C Error);\nE('ERR_SOCKET_DGRAM_NOT_CONNECTED'\x2C 'Not connected'\x2C Error);\nE('ERR_SOCKET_DGRAM_NOT_RUNNING'\x2C 'Not running'\x2C Error);\nE('ERR_SRI_PARSE'\x2C\n  'Subresource Integrity string %j had an unexpected %j at position %d'\x2C\n  SyntaxError);\nE('ERR_STREAM_ALREADY_FINISHED'\x2C\n  'Cannot call %s after a stream was finished'\x2C\n  Error);\nE('ERR_STREAM_CANNOT_PIPE'\x2C 'Cannot pipe\x2C not readable'\x2C Error);\nE('ERR_STREAM_DESTROYED'\x2C 'Cannot call %s after a stream was destroyed'\x2C Error);\nE('ERR_STREAM_NULL_VALUES'\x2C 'May not write null values to stream'\x2C TypeError);\nE('ERR_STREAM_PREMATURE_CLOSE'\x2C 'Premature close'\x2C Error);\nE('ERR_STREAM_PUSH_AFTER_EOF'\x2C 'stream.push() after EOF'\x2C Error);\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT'\x2C\n  'stream.unshift() after end event'\x2C Error);\nE('ERR_STREAM_WRAP'\x2C 'Stream has StringDecoder set or is in objectMode'\x2C Error);\nE('ERR_STREAM_WRITE_AFTER_END'\x2C 'write after end'\x2C Error);\nE('ERR_SYNTHETIC'\x2C 'JavaScript Callstack'\x2C Error);\nE('ERR_SYSTEM_ERROR'\x2C 'A system error occurred'\x2C SystemError);\nE('ERR_TLS_CERT_ALTNAME_FORMAT'\x2C 'Invalid subject alternative name string'\x2C\n  SyntaxError);\nE('ERR_TLS_CERT_ALTNAME_INVALID'\x2C function(reason\x2C host\x2C cert) {\n  this.reason = reason;\n  this.host = host;\n  this.cert = cert;\n  return `Hostname/IP does not match certificate's altnames: ${reason}`;\n}\x2C Error);\nE('ERR_TLS_DH_PARAM_SIZE'\x2C 'DH parameter size %s is less than 2048'\x2C Error);\nE('ERR_TLS_HANDSHAKE_TIMEOUT'\x2C 'TLS handshake timeout'\x2C Error);\nE('ERR_TLS_INVALID_CONTEXT'\x2C '%s must be a SecureContext'\x2C TypeError);\nE('ERR_TLS_INVALID_PROTOCOL_VERSION'\x2C\n  '%j is not a valid %s TLS protocol version'\x2C TypeError);\nE('ERR_TLS_INVALID_STATE'\x2C 'TLS socket connection must be securely established'\x2C\n  Error);\nE('ERR_TLS_PROTOCOL_VERSION_CONFLICT'\x2C\n  'TLS protocol version %j conflicts with secureProtocol %j'\x2C TypeError);\nE('ERR_TLS_RENEGOTIATION_DISABLED'\x2C\n  'TLS session renegotiation disabled for this socket'\x2C Error);\n\n// This should probably be a `TypeError`.\nE('ERR_TLS_REQUIRED_SERVER_NAME'\x2C\n  '"servername" is required parameter for Server.addContext'\x2C Error);\nE('ERR_TLS_SESSION_ATTACK'\x2C 'TLS session renegotiation attack detected'\x2C Error);\nE('ERR_TLS_SNI_FROM_SERVER'\x2C\n  'Cannot issue SNI from a TLS server-side socket'\x2C Error);\nE('ERR_TRACE_EVENTS_CATEGORY_REQUIRED'\x2C\n  'At least one category is required'\x2C TypeError);\nE('ERR_TRACE_EVENTS_UNAVAILABLE'\x2C 'Trace events are unavailable'\x2C Error);\n\n// This should probably be a `RangeError`.\nE('ERR_TTY_INIT_FAILED'\x2C 'TTY initialization failed'\x2C SystemError);\nE('ERR_UNAVAILABLE_DURING_EXIT'\x2C 'Cannot call function in process exit ' +\n  'handler'\x2C Error);\nE('ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET'\x2C\n  '`process.setupUncaughtExceptionCapture()` was called while a capture ' +\n    'callback was already active'\x2C\n  Error);\nE('ERR_UNESCAPED_CHARACTERS'\x2C '%s contains unescaped characters'\x2C TypeError);\nE('ERR_UNHANDLED_ERROR'\x2C\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (err = undefined) => {\n    const msg = 'Unhandled error.';\n    if (err === undefined) return msg;\n    return `${msg} (${err})`;\n  }\x2C Error);\nE('ERR_UNKNOWN_BUILTIN_MODULE'\x2C 'No such built-in module: %s'\x2C Error);\nE('ERR_UNKNOWN_CREDENTIAL'\x2C '%s identifier does not exist: %s'\x2C Error);\nE('ERR_UNKNOWN_ENCODING'\x2C 'Unknown encoding: %s'\x2C TypeError);\nE('ERR_UNKNOWN_FILE_EXTENSION'\x2C\n  'Unknown file extension "%s" for %s'\x2C\n  TypeError);\nE('ERR_UNKNOWN_MODULE_FORMAT'\x2C 'Unknown module format: %s for URL %s'\x2C\n  RangeError);\nE('ERR_UNKNOWN_SIGNAL'\x2C 'Unknown signal: %s'\x2C TypeError);\nE('ERR_UNSUPPORTED_DIR_IMPORT'\x2C "Directory import '%s' is not supported " +\n'resolving ES modules imported from %s'\x2C Error);\nE('ERR_UNSUPPORTED_ESM_URL_SCHEME'\x2C (url\x2C supported) => {\n  let msg = `Only URLs with a scheme in: ${ArrayPrototypeJoin(supported\x2C '\x2C ')} are supported by the default ESM loader`;\n  if (isWindows && url.protocol.length === 2) {\n    msg +=\n      '. On Windows\x2C absolute paths must be valid file:// URLs';\n  }\n  msg += `. Received protocol '${url.protocol}'`;\n  return msg;\n}\x2C Error);\n\n// This should probably be a `TypeError`.\nE('ERR_VALID_PERFORMANCE_ENTRY_TYPE'\x2C\n  'At least one valid performance entry type is required'\x2C Error);\nE('ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING'\x2C\n  'A dynamic import callback was not specified.'\x2C TypeError);\nE('ERR_VM_MODULE_ALREADY_LINKED'\x2C 'Module has already been linked'\x2C Error);\nE('ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA'\x2C\n  'Cached data cannot be created for a module which has been evaluated'\x2C Error);\nE('ERR_VM_MODULE_DIFFERENT_CONTEXT'\x2C\n  'Linked modules must use the same context'\x2C Error);\nE('ERR_VM_MODULE_LINKING_ERRORED'\x2C\n  'Linking has already failed for the provided module'\x2C Error);\nE('ERR_VM_MODULE_NOT_MODULE'\x2C\n  'Provided module is not an instance of Module'\x2C Error);\nE('ERR_VM_MODULE_STATUS'\x2C 'Module status %s'\x2C Error);\nE('ERR_WASI_ALREADY_STARTED'\x2C 'WASI instance has already started'\x2C Error);\nE('ERR_WORKER_INIT_FAILED'\x2C 'Worker initialization failure: %s'\x2C Error);\nE('ERR_WORKER_INVALID_EXEC_ARGV'\x2C (errors\x2C msg = 'invalid execArgv flags') =>\n  `Initiated Worker with ${msg}: ${ArrayPrototypeJoin(errors\x2C '\x2C ')}`\x2C\n  Error);\nE('ERR_WORKER_NOT_RUNNING'\x2C 'Worker instance not running'\x2C Error);\nE('ERR_WORKER_OUT_OF_MEMORY'\x2C\n  'Worker terminated due to reaching memory limit: %s'\x2C Error);\nE('ERR_WORKER_PATH'\x2C (filename) =>\n  'The worker script or module filename must be an absolute path or a ' +\n  'relative path starting with \\'./\\' or \\'../\\'.' +\n  (StringPrototypeStartsWith(filename\x2C 'file://') ?\n    ' Wrap file:// URLs with `new URL`.' : ''\n  ) +\n  (StringPrototypeStartsWith(filename\x2C 'data:text/javascript') ?\n    ' Wrap data: URLs with `new URL`.' : ''\n  ) +\n  ` Received "${filename}"`\x2C\n  TypeError);\nE('ERR_WORKER_UNSERIALIZABLE_ERROR'\x2C\n  'Serializing an uncaught exception failed'\x2C Error);\nE('ERR_WORKER_UNSUPPORTED_OPERATION'\x2C\n  '%s is not supported in workers'\x2C TypeError);\nE('ERR_ZLIB_INITIALIZATION_FAILED'\x2C 'Initialization failed'\x2C Error);\n
code-source-info,0x2cbd764bef16,11,10671,10895,C0O10796C5O10820C9O10815C13O10828C21O10849C28O10870C35O10828C40O10883C42O10893,,
tick,0x10035a500,81250,0,0x0,3,0x0,0x2cbd764bb5c8,0x105108d28,0x10510894c,0x2cbd764b0ca7,0x105108d28,0x10510894c,0x2cbd764a9e64,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89d6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x1bfd39474,81292,0,0x0,3,0x0,0x2cbd764bb5c8,0x105108d28,0x10510894c,0x2cbd764b0ca7,0x105108d28,0x10510894c,0x2cbd764a9e64,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89d6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,81584,0x29d5d5b86d36,5, node:_http_server:1:1,0x29d5d5b86690,~
script-source,160,node:_http_server,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  Error\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeTest\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n} = primordials;\n\nconst net = require('net');\nconst EE = require('events');\nconst assert = require('internal/assert');\nconst {\n  parsers\x2C\n  freeParser\x2C\n  continueExpression\x2C\n  chunkExpression\x2C\n  kIncomingMessage\x2C\n  kRequestTimeout\x2C\n  HTTPParser\x2C\n  isLenient\x2C\n  _checkInvalidHeaderChar: checkInvalidHeaderChar\x2C\n  prepareError\x2C\n} = require('_http_common');\nconst { OutgoingMessage } = require('_http_outgoing');\nconst {\n  kOutHeaders\x2C\n  kNeedDrain\x2C\n  emitStatistics\n} = require('internal/http');\nconst {\n  defaultTriggerAsyncIdScope\x2C\n  getOrSetAsyncId\n} = require('internal/async_hooks');\nconst { IncomingMessage } = require('_http_incoming');\nconst {\n  connResetException\x2C\n  codes\n} = require('internal/errors');\nconst {\n  ERR_HTTP_REQUEST_TIMEOUT\x2C\n  ERR_HTTP_HEADERS_SENT\x2C\n  ERR_HTTP_INVALID_STATUS_CODE\x2C\n  ERR_HTTP_SOCKET_ENCODING\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_CHAR\n} = codes;\nconst {\n  validateInteger\x2C\n  validateBoolean\n} = require('internal/validators');\nconst Buffer = require('buffer').Buffer;\nconst {\n  DTRACE_HTTP_SERVER_REQUEST\x2C\n  DTRACE_HTTP_SERVER_RESPONSE\n} = require('internal/dtrace');\nconst { setTimeout\x2C clearTimeout } = require('timers');\n\nlet debug = require('internal/util/debuglog').debuglog('http'\x2C (fn) => {\n  debug = fn;\n});\n\nconst dc = require('diagnostics_channel');\nconst onRequestStartChannel = dc.channel('http.server.request.start');\nconst onResponseFinishChannel = dc.channel('http.server.response.finish');\n\nconst kServerResponse = Symbol('ServerResponse');\nconst kServerResponseStatistics = Symbol('ServerResponseStatistics');\n\nconst {\n  hasObserver\x2C\n} = require('internal/perf/observe');\n\nconst STATUS_CODES = {\n  100: 'Continue'\x2C                   // RFC 7231 6.2.1\n  101: 'Switching Protocols'\x2C        // RFC 7231 6.2.2\n  102: 'Processing'\x2C                 // RFC 2518 10.1 (obsoleted by RFC 4918)\n  103: 'Early Hints'\x2C                // RFC 8297 2\n  200: 'OK'\x2C                         // RFC 7231 6.3.1\n  201: 'Created'\x2C                    // RFC 7231 6.3.2\n  202: 'Accepted'\x2C                   // RFC 7231 6.3.3\n  203: 'Non-Authoritative Information'\x2C // RFC 7231 6.3.4\n  204: 'No Content'\x2C                 // RFC 7231 6.3.5\n  205: 'Reset Content'\x2C              // RFC 7231 6.3.6\n  206: 'Partial Content'\x2C            // RFC 7233 4.1\n  207: 'Multi-Status'\x2C               // RFC 4918 11.1\n  208: 'Already Reported'\x2C           // RFC 5842 7.1\n  226: 'IM Used'\x2C                    // RFC 3229 10.4.1\n  300: 'Multiple Choices'\x2C           // RFC 7231 6.4.1\n  301: 'Moved Permanently'\x2C          // RFC 7231 6.4.2\n  302: 'Found'\x2C                      // RFC 7231 6.4.3\n  303: 'See Other'\x2C                  // RFC 7231 6.4.4\n  304: 'Not Modified'\x2C               // RFC 7232 4.1\n  305: 'Use Proxy'\x2C                  // RFC 7231 6.4.5\n  307: 'Temporary Redirect'\x2C         // RFC 7231 6.4.7\n  308: 'Permanent Redirect'\x2C         // RFC 7238 3\n  400: 'Bad Request'\x2C                // RFC 7231 6.5.1\n  401: 'Unauthorized'\x2C               // RFC 7235 3.1\n  402: 'Payment Required'\x2C           // RFC 7231 6.5.2\n  403: 'Forbidden'\x2C                  // RFC 7231 6.5.3\n  404: 'Not Found'\x2C                  // RFC 7231 6.5.4\n  405: 'Method Not Allowed'\x2C         // RFC 7231 6.5.5\n  406: 'Not Acceptable'\x2C             // RFC 7231 6.5.6\n  407: 'Proxy Authentication Required'\x2C // RFC 7235 3.2\n  408: 'Request Timeout'\x2C            // RFC 7231 6.5.7\n  409: 'Conflict'\x2C                   // RFC 7231 6.5.8\n  410: 'Gone'\x2C                       // RFC 7231 6.5.9\n  411: 'Length Required'\x2C            // RFC 7231 6.5.10\n  412: 'Precondition Failed'\x2C        // RFC 7232 4.2\n  413: 'Payload Too Large'\x2C          // RFC 7231 6.5.11\n  414: 'URI Too Long'\x2C               // RFC 7231 6.5.12\n  415: 'Unsupported Media Type'\x2C     // RFC 7231 6.5.13\n  416: 'Range Not Satisfiable'\x2C      // RFC 7233 4.4\n  417: 'Expectation Failed'\x2C         // RFC 7231 6.5.14\n  418: 'I\\'m a Teapot'\x2C              // RFC 7168 2.3.3\n  421: 'Misdirected Request'\x2C        // RFC 7540 9.1.2\n  422: 'Unprocessable Entity'\x2C       // RFC 4918 11.2\n  423: 'Locked'\x2C                     // RFC 4918 11.3\n  424: 'Failed Dependency'\x2C          // RFC 4918 11.4\n  425: 'Too Early'\x2C                  // RFC 8470 5.2\n  426: 'Upgrade Required'\x2C           // RFC 2817 and RFC 7231 6.5.15\n  428: 'Precondition Required'\x2C      // RFC 6585 3\n  429: 'Too Many Requests'\x2C          // RFC 6585 4\n  431: 'Request Header Fields Too Large'\x2C // RFC 6585 5\n  451: 'Unavailable For Legal Reasons'\x2C // RFC 7725 3\n  500: 'Internal Server Error'\x2C      // RFC 7231 6.6.1\n  501: 'Not Implemented'\x2C            // RFC 7231 6.6.2\n  502: 'Bad Gateway'\x2C                // RFC 7231 6.6.3\n  503: 'Service Unavailable'\x2C        // RFC 7231 6.6.4\n  504: 'Gateway Timeout'\x2C            // RFC 7231 6.6.5\n  505: 'HTTP Version Not Supported'\x2C // RFC 7231 6.6.6\n  506: 'Variant Also Negotiates'\x2C    // RFC 2295 8.1\n  507: 'Insufficient Storage'\x2C       // RFC 4918 11.5\n  508: 'Loop Detected'\x2C              // RFC 5842 7.2\n  509: 'Bandwidth Limit Exceeded'\x2C\n  510: 'Not Extended'\x2C               // RFC 2774 7\n  511: 'Network Authentication Required' // RFC 6585 6\n};\n\nconst kOnMessageBegin = HTTPParser.kOnMessageBegin | 0;\nconst kOnExecute = HTTPParser.kOnExecute | 0;\nconst kOnTimeout = HTTPParser.kOnTimeout | 0;\nconst kLenientAll = HTTPParser.kLenientAll | 0;\nconst kLenientNone = HTTPParser.kLenientNone | 0;\n\nclass HTTPServerAsyncResource {\n  constructor(type\x2C socket) {\n    this.type = type;\n    this.socket = socket;\n  }\n}\n\nfunction ServerResponse(req) {\n  OutgoingMessage.call(this);\n\n  if (req.method === 'HEAD') this._hasBody = false;\n\n  this.req = req;\n  this.sendDate = true;\n  this._sent100 = false;\n  this._expect_continue = false;\n\n  if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {\n    this.useChunkedEncodingByDefault = RegExpPrototypeTest(chunkExpression\x2C\n                                                           req.headers.te);\n    this.shouldKeepAlive = false;\n  }\n\n  if (hasObserver('http')) {\n    this[kServerResponseStatistics] = {\n      startTime: process.hrtime()\n    };\n  }\n}\nObjectSetPrototypeOf(ServerResponse.prototype\x2C OutgoingMessage.prototype);\nObjectSetPrototypeOf(ServerResponse\x2C OutgoingMessage);\n\nServerResponse.prototype._finish = function _finish() {\n  DTRACE_HTTP_SERVER_RESPONSE(this.socket);\n  emitStatistics(this[kServerResponseStatistics]);\n  OutgoingMessage.prototype._finish.call(this);\n};\n\n\nServerResponse.prototype.statusCode = 200;\nServerResponse.prototype.statusMessage = undefined;\n\nfunction onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called\x2C directly or indirectly\x2C by a 'close'\n  // listener\x2C onServerResponseClose is still in that copy of the listeners\n  // array. That is\x2C in the example below\x2C b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event'\x2C a);\n  //   obj.on('event'\x2C b);\n  //   function a() { obj.removeListener('event'\x2C b) }\n  //   function b() { throw "BAM!" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo\x2C we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately\x2C that requires only a single if check. :-)\n  if (this._httpMessage) {\n    emitCloseNT(this._httpMessage);\n  }\n}\n\nServerResponse.prototype.assignSocket = function assignSocket(socket) {\n  assert(!socket._httpMessage);\n  socket._httpMessage = this;\n  socket.on('close'\x2C onServerResponseClose);\n  this.socket = socket;\n  this.emit('socket'\x2C socket);\n  this._flush();\n};\n\nServerResponse.prototype.detachSocket = function detachSocket(socket) {\n  assert(socket._httpMessage === this);\n  socket.removeListener('close'\x2C onServerResponseClose);\n  socket._httpMessage = null;\n  this.socket = null;\n};\n\nServerResponse.prototype.writeContinue = function writeContinue(cb) {\n  this._writeRaw('HTTP/1.1 100 Continue\\r\\n\\r\\n'\x2C 'ascii'\x2C cb);\n  this._sent100 = true;\n};\n\nServerResponse.prototype.writeProcessing = function writeProcessing(cb) {\n  this._writeRaw('HTTP/1.1 102 Processing\\r\\n\\r\\n'\x2C 'ascii'\x2C cb);\n};\n\nServerResponse.prototype._implicitHeader = function _implicitHeader() {\n  this.writeHead(this.statusCode);\n};\n\nServerResponse.prototype.writeHead = writeHead;\nfunction writeHead(statusCode\x2C reason\x2C obj) {\n  const originalStatusCode = statusCode;\n\n  statusCode |= 0;\n  if (statusCode < 100 || statusCode > 999) {\n    throw new ERR_HTTP_INVALID_STATUS_CODE(originalStatusCode);\n  }\n\n\n  if (typeof reason === 'string') {\n    // writeHead(statusCode\x2C reasonPhrase[\x2C headers])\n    this.statusMessage = reason;\n  } else {\n    // writeHead(statusCode[\x2C headers])\n    if (!this.statusMessage)\n      this.statusMessage = STATUS_CODES[statusCode] || 'unknown';\n    obj = reason;\n  }\n  this.statusCode = statusCode;\n\n  let headers;\n  if (this[kOutHeaders]) {\n    // Slow-case: when progressive API and header fields are passed.\n    let k;\n    if (ArrayIsArray(obj)) {\n      if (obj.length % 2 !== 0) {\n        throw new ERR_INVALID_ARG_VALUE('headers'\x2C obj);\n      }\n\n      for (let n = 0; n < obj.length; n += 2) {\n        k = obj[n + 0];\n        if (k) this.setHeader(k\x2C obj[n + 1]);\n      }\n    } else if (obj) {\n      const keys = ObjectKeys(obj);\n      // Retain for(;;) loop for performance reasons\n      // Refs: https://github.com/nodejs/node/pull/30958\n      for (let i = 0; i < keys.length; i++) {\n        k = keys[i];\n        if (k) this.setHeader(k\x2C obj[k]);\n      }\n    }\n    if (k === undefined && this._header) {\n      throw new ERR_HTTP_HEADERS_SENT('render');\n    }\n    // Only progressive api is used\n    headers = this[kOutHeaders];\n  } else {\n    // Only writeHead() called\n    headers = obj;\n  }\n\n  if (checkInvalidHeaderChar(this.statusMessage))\n    throw new ERR_INVALID_CHAR('statusMessage');\n\n  const statusLine = `HTTP/1.1 ${statusCode} ${this.statusMessage}\\r\\n`;\n\n  if (statusCode === 204 || statusCode === 304 ||\n      (statusCode >= 100 && statusCode <= 199)) {\n    // RFC 2616\x2C 10.2.5:\n    // The 204 response MUST NOT include a message-body\x2C and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616\x2C 10.3.5:\n    // The 304 response MUST NOT contain a message-body\x2C and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616\x2C 10.1 Informational 1xx:\n    // This class of status code indicates a provisional response\x2C\n    // consisting only of the Status-Line and optional headers\x2C and is\n    // terminated by an empty line.\n    this._hasBody = false;\n  }\n\n  // Don't keep alive connections where the client expects 100 Continue\n  // but we sent a final status; they may put extra bytes on the wire.\n  if (this._expect_continue && !this._sent100) {\n    this.shouldKeepAlive = false;\n  }\n\n  this._storeHeader(statusLine\x2C headers);\n\n  return this;\n}\n\n// Docs-only deprecated: DEP0063\nServerResponse.prototype.writeHeader = ServerResponse.prototype.writeHead;\n\nfunction storeHTTPOptions(options) {\n  this[kIncomingMessage] = options.IncomingMessage || IncomingMessage;\n  this[kServerResponse] = options.ServerResponse || ServerResponse;\n\n  const maxHeaderSize = options.maxHeaderSize;\n  if (maxHeaderSize !== undefined)\n    validateInteger(maxHeaderSize\x2C 'maxHeaderSize'\x2C 0);\n  this.maxHeaderSize = maxHeaderSize;\n\n  const insecureHTTPParser = options.insecureHTTPParser;\n  if (insecureHTTPParser !== undefined)\n    validateBoolean(insecureHTTPParser\x2C 'options.insecureHTTPParser');\n  this.insecureHTTPParser = insecureHTTPParser;\n}\n\nfunction Server(options\x2C requestListener) {\n  if (!(this instanceof Server)) return new Server(options\x2C requestListener);\n\n  if (typeof options === 'function') {\n    requestListener = options;\n    options = {};\n  } else if (options == null || typeof options === 'object') {\n    options = { ...options };\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C 'object'\x2C options);\n  }\n\n  storeHTTPOptions.call(this\x2C options);\n  net.Server.call(\n    this\x2C\n    { allowHalfOpen: true\x2C noDelay: options.noDelay\x2C\n      keepAlive: options.keepAlive\x2C\n      keepAliveInitialDelay: options.keepAliveInitialDelay });\n\n  if (requestListener) {\n    this.on('request'\x2C requestListener);\n  }\n\n  // Similar option to this. Too lazy to write my own docs.\n  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n  this.httpAllowHalfOpen = false;\n\n  this.on('connection'\x2C connectionListener);\n\n  this.timeout = 0;\n  this.keepAliveTimeout = 5000;\n  this.maxHeadersCount = null;\n  this.maxRequestsPerSocket = 0;\n  this.headersTimeout = 60 * 1000; // 60 seconds\n  this.requestTimeout = 0;\n}\nObjectSetPrototypeOf(Server.prototype\x2C net.Server.prototype);\nObjectSetPrototypeOf(Server\x2C net.Server);\n\n\nServer.prototype.setTimeout = function setTimeout(msecs\x2C callback) {\n  this.timeout = msecs;\n  if (callback)\n    this.on('timeout'\x2C callback);\n  return this;\n};\n\nServer.prototype[EE.captureRejectionSymbol] = function(err\x2C event\x2C ...args) {\n  switch (event) {\n    case 'request': {\n      const { 1: res } = args;\n      if (!res.headersSent && !res.writableEnded) {\n        // Don't leak headers.\n        const names = res.getHeaderNames();\n        for (let i = 0; i < names.length; i++) {\n          res.removeHeader(names[i]);\n        }\n        res.statusCode = 500;\n        res.end(STATUS_CODES[500]);\n      } else {\n        res.destroy();\n      }\n      break;\n    }\n    default:\n      net.Server.prototype[SymbolFor('nodejs.rejection')]\n        .apply(this\x2C arguments);\n  }\n};\n\nfunction connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket)\x2C connectionListenerInternal\x2C this\x2C socket\n  );\n}\n\nfunction connectionListenerInternal(server\x2C socket) {\n  debug('SERVER new http connection');\n\n  // Ensure that the server property of the socket is correctly set.\n  // See https://github.com/nodejs/node/issues/13435\n  socket.server = server;\n\n  // If the user has added a listener to the server\x2C\n  // request\x2C or response\x2C then it's their responsibility.\n  // otherwise\x2C destroy on timeout by default\n  if (server.timeout && typeof socket.setTimeout === 'function')\n    socket.setTimeout(server.timeout);\n  socket.on('timeout'\x2C socketOnTimeout);\n\n  const parser = parsers.alloc();\n\n  const lenient = server.insecureHTTPParser === undefined ?\n    isLenient() : server.insecureHTTPParser;\n\n  // TODO(addaleax): This doesn't play well with the\n  // `async_hooks.currentResource()` proposal\x2C see\n  // https://github.com/nodejs/node/pull/21313\n  parser.initialize(\n    HTTPParser.REQUEST\x2C\n    new HTTPServerAsyncResource('HTTPINCOMINGMESSAGE'\x2C socket)\x2C\n    server.maxHeaderSize || 0\x2C\n    lenient ? kLenientAll : kLenientNone\x2C\n    server.headersTimeout || 0\x2C\n  );\n  parser.socket = socket;\n  socket.parser = parser;\n\n  // Propagate headers limit from server instance to parser\n  if (typeof server.maxHeadersCount === 'number') {\n    parser.maxHeaderPairs = server.maxHeadersCount << 1;\n  }\n\n  const state = {\n    onData: null\x2C\n    onEnd: null\x2C\n    onClose: null\x2C\n    onDrain: null\x2C\n    outgoing: []\x2C\n    incoming: []\x2C\n    // `outgoingData` is an approximate amount of bytes queued through all\n    // inactive responses. If more data than the high watermark is queued - we\n    // need to pause TCP socket/HTTP parser\x2C and wait until the data will be\n    // sent to the client.\n    outgoingData: 0\x2C\n    requestsCount: 0\x2C\n    keepAliveTimeoutSet: false\n  };\n  state.onData = socketOnData.bind(undefined\x2C\n                                   server\x2C socket\x2C parser\x2C state);\n  state.onEnd = socketOnEnd.bind(undefined\x2C\n                                 server\x2C socket\x2C parser\x2C state);\n  state.onClose = socketOnClose.bind(undefined\x2C\n                                     socket\x2C state);\n  state.onDrain = socketOnDrain.bind(undefined\x2C\n                                     socket\x2C state);\n  socket.on('data'\x2C state.onData);\n  socket.on('error'\x2C socketOnError);\n  socket.on('end'\x2C state.onEnd);\n  socket.on('close'\x2C state.onClose);\n  socket.on('drain'\x2C state.onDrain);\n  parser.onIncoming = parserOnIncoming.bind(undefined\x2C\n                                            server\x2C socket\x2C state);\n\n  // We are consuming socket\x2C so it won't get any actual data\n  socket.on('resume'\x2C onSocketResume);\n  socket.on('pause'\x2C onSocketPause);\n\n  // Overrides to unconsume on `data`\x2C `readable` listeners\n  socket.on = generateSocketListenerWrapper('on');\n  socket.addListener = generateSocketListenerWrapper('addListener');\n  socket.prependListener = generateSocketListenerWrapper('prependListener');\n  socket.setEncoding = socketSetEncoding;\n\n  // We only consume the socket if it has never been consumed before.\n  if (socket._handle && socket._handle.isStreamBase &&\n      !socket._handle._consumed) {\n    parser._consumed = true;\n    socket._handle._consumed = true;\n    parser.consume(socket._handle);\n  }\n  parser[kOnExecute] =\n    onParserExecute.bind(undefined\x2C\n                         server\x2C socket\x2C parser\x2C state);\n\n  parser[kOnTimeout] =\n    onParserTimeout.bind(undefined\x2C\n                         server\x2C socket);\n\n  // When receiving new requests on the same socket (pipelining or keep alive)\n  // make sure the requestTimeout is active.\n  parser[kOnMessageBegin] =\n    setRequestTimeout.bind(undefined\x2C\n                           server\x2C socket);\n\n  // This protects from DOS attack where an attacker establish the connection\n  // without sending any data on applications where server.timeout is left to\n  // the default value of zero.\n  setRequestTimeout(server\x2C socket);\n\n  socket._paused = false;\n}\n\nfunction socketSetEncoding() {\n  throw new ERR_HTTP_SOCKET_ENCODING();\n}\n\nfunction updateOutgoingData(socket\x2C state\x2C delta) {\n  state.outgoingData += delta;\n  socketOnDrain(socket\x2C state);\n}\n\nfunction socketOnDrain(socket\x2C state) {\n  const needPause = state.outgoingData > socket.writableHighWaterMark;\n\n  // If we previously paused\x2C then start reading again.\n  if (socket._paused && !needPause) {\n    socket._paused = false;\n    if (socket.parser)\n      socket.parser.resume();\n    socket.resume();\n  }\n\n  const msg = socket._httpMessage;\n  if (msg && !msg.finished && msg[kNeedDrain]) {\n    msg[kNeedDrain] = false;\n    msg.emit('drain');\n  }\n}\n\nfunction socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout'\x2C this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout'\x2C this);\n  const serverTimeout = this.server.emit('timeout'\x2C this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n}\n\nfunction socketOnClose(socket\x2C state) {\n  debug('server socket close');\n  freeParser(socket.parser\x2C null\x2C socket);\n  abortIncoming(state.incoming);\n}\n\nfunction abortIncoming(incoming) {\n  while (incoming.length) {\n    const req = incoming.shift();\n    req.destroy(connResetException('aborted'));\n  }\n  // Abort socket._httpMessage ?\n}\n\nfunction socketOnEnd(server\x2C socket\x2C parser\x2C state) {\n  const ret = parser.finish();\n\n  if (ret instanceof Error) {\n    debug('parse error');\n    // socketOnError has additional logic and will call socket.destroy(err).\n    socketOnError.call(socket\x2C ret);\n  } else if (!server.httpAllowHalfOpen) {\n    socket.end();\n  } else if (state.outgoing.length) {\n    state.outgoing[state.outgoing.length - 1]._last = true;\n  } else if (socket._httpMessage) {\n    socket._httpMessage._last = true;\n  } else {\n    socket.end();\n  }\n}\n\nfunction socketOnData(server\x2C socket\x2C parser\x2C state\x2C d) {\n  assert(!socket._paused);\n  debug('SERVER socketOnData %d'\x2C d.length);\n\n  const ret = parser.execute(d);\n  onParserExecuteCommon(server\x2C socket\x2C parser\x2C state\x2C ret\x2C d);\n}\n\nfunction onRequestTimeout(socket) {\n  socket[kRequestTimeout] = undefined;\n  // socketOnError has additional logic and will call socket.destroy(err).\n  socketOnError.call(socket\x2C new ERR_HTTP_REQUEST_TIMEOUT());\n}\n\nfunction onParserExecute(server\x2C socket\x2C parser\x2C state\x2C ret) {\n  // When underlying `net.Socket` instance is consumed - no\n  // `data` events are emitted\x2C and thus `socket.setTimeout` fires the\n  // callback even if the data is constantly flowing into the socket.\n  // See\x2C https://github.com/nodejs/node/commit/ec2822adaad76b126b5cccdeaa1addf2376c9aa6\n  socket._unrefTimer();\n  debug('SERVER socketOnParserExecute %d'\x2C ret);\n  onParserExecuteCommon(server\x2C socket\x2C parser\x2C state\x2C ret\x2C undefined);\n}\n\nfunction onParserTimeout(server\x2C socket) {\n  const serverTimeout = server.emit('timeout'\x2C socket);\n\n  if (!serverTimeout)\n    socket.destroy();\n}\n\nconst noop = () => {};\nconst badRequestResponse = Buffer.from(\n  `HTTP/1.1 400 ${STATUS_CODES[400]}\\r\\n` +\n  'Connection: close\\r\\n\\r\\n'\x2C 'ascii'\n);\nconst requestTimeoutResponse = Buffer.from(\n  `HTTP/1.1 408 ${STATUS_CODES[408]}\\r\\n` +\n  'Connection: close\\r\\n\\r\\n'\x2C 'ascii'\n);\nconst requestHeaderFieldsTooLargeResponse = Buffer.from(\n  `HTTP/1.1 431 ${STATUS_CODES[431]}\\r\\n` +\n  'Connection: close\\r\\n\\r\\n'\x2C 'ascii'\n);\nfunction socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error'\x2C socketOnError);\n  this.on('error'\x2C noop);\n\n  if (!this.server.emit('clientError'\x2C e\x2C this)) {\n    if (this.writable && this.bytesWritten === 0) {\n      let response;\n\n      switch (e.code) {\n        case 'HPE_HEADER_OVERFLOW':\n          response = requestHeaderFieldsTooLargeResponse;\n          break;\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\n          response = requestTimeoutResponse;\n          break;\n        default:\n          response = badRequestResponse;\n          break;\n      }\n\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n}\n\nfunction onParserExecuteCommon(server\x2C socket\x2C parser\x2C state\x2C ret\x2C d) {\n  resetSocketTimeout(server\x2C socket\x2C state);\n\n  if (ret instanceof Error) {\n    prepareError(ret\x2C parser\x2C d);\n    debug('parse error'\x2C ret);\n    socketOnError.call(socket\x2C ret);\n  } else if (parser.incoming && parser.incoming.upgrade) {\n    // Upgrade or CONNECT\n    const req = parser.incoming;\n    debug('SERVER upgrade or connect'\x2C req.method);\n\n    if (!d)\n      d = parser.getCurrentBuffer();\n\n    socket.removeListener('data'\x2C state.onData);\n    socket.removeListener('end'\x2C state.onEnd);\n    socket.removeListener('close'\x2C state.onClose);\n    socket.removeListener('drain'\x2C state.onDrain);\n    socket.removeListener('error'\x2C socketOnError);\n    socket.removeListener('timeout'\x2C socketOnTimeout);\n    unconsume(parser\x2C socket);\n    parser.finish();\n    freeParser(parser\x2C req\x2C socket);\n    parser = null;\n\n    const eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\n    if (eventName === 'upgrade' || server.listenerCount(eventName) > 0) {\n      debug('SERVER have listener for %s'\x2C eventName);\n      const bodyHead = d.slice(ret\x2C d.length);\n\n      socket.readableFlowing = null;\n\n      // Clear the requestTimeout after upgrading the connection.\n      clearRequestTimeout(req);\n\n      server.emit(eventName\x2C req\x2C socket\x2C bodyHead);\n    } else {\n      // Got CONNECT method\x2C but have no handler.\n      socket.destroy();\n    }\n  } else if (parser.incoming && parser.incoming.method === 'PRI') {\n    debug('SERVER got PRI request');\n    socket.destroy();\n  } else {\n    // When receiving new requests on the same socket (pipelining or keep alive)\n    // make sure the requestTimeout is active.\n    parser[kOnMessageBegin] =\n      setRequestTimeout.bind(undefined\x2C server\x2C socket);\n  }\n\n  if (socket._paused && socket.parser) {\n    // onIncoming paused the socket\x2C we should pause the parser as well\n    debug('pause parser');\n    socket.parser.pause();\n  }\n}\n\nfunction clearIncoming(req) {\n  req = req || this;\n  const parser = req.socket && req.socket.parser;\n  // Reset the .incoming property so that the request object can be gc'ed.\n  if (parser && parser.incoming === req) {\n    if (req.readableEnded) {\n      parser.incoming = null;\n    } else {\n      req.on('end'\x2C clearIncoming);\n    }\n  }\n}\n\nfunction setRequestTimeout(server\x2C socket) {\n  // Set the request timeout handler.\n  if (\n    !socket[kRequestTimeout] &&\n    server.requestTimeout && server.requestTimeout > 0\n  ) {\n    debug('requestTimeout timer set');\n    socket[kRequestTimeout] =\n      setTimeout(onRequestTimeout\x2C server.requestTimeout\x2C socket).unref();\n  }\n}\n\nfunction clearRequestTimeout(req) {\n  if (!req) {\n    req = this;\n  }\n\n  if (!req[kRequestTimeout]) {\n    return;\n  }\n\n  debug('requestTimeout timer cleared');\n  clearTimeout(req[kRequestTimeout]);\n  req[kRequestTimeout] = undefined;\n}\n\nfunction resOnFinish(req\x2C res\x2C socket\x2C state\x2C server) {\n  if (onResponseFinishChannel.hasSubscribers) {\n    onResponseFinishChannel.publish({\n      request: req\x2C\n      response: res\x2C\n      socket\x2C\n      server\n    });\n  }\n\n  // Usually the first incoming element should be our request.  it may\n  // be that in the case abortIncoming() was called that the incoming\n  // array will be empty.\n  assert(state.incoming.length === 0 || state.incoming[0] === req);\n\n  state.incoming.shift();\n\n  // If the user never called req.read()\x2C and didn't pipe() or\n  // .resume() or .on('data')\x2C then we call req._dump() so that the\n  // bytes will be pulled off the wire.\n  if (!req._consuming && !req._readableState.resumeScheduled)\n    req._dump();\n\n  // Make sure the requestTimeout is cleared before finishing.\n  // This might occur if the application has sent a response\n  // without consuming the request body\x2C which would have already\n  // cleared the timer.\n  // clearRequestTimeout can be executed even if the timer is not active\x2C\n  // so this is safe.\n  clearRequestTimeout(req);\n\n  res.detachSocket(socket);\n  clearIncoming(req);\n  process.nextTick(emitCloseNT\x2C res);\n\n  if (res._last) {\n    if (typeof socket.destroySoon === 'function') {\n      socket.destroySoon();\n    } else {\n      socket.end();\n    }\n  } else if (state.outgoing.length === 0) {\n    if (server.keepAliveTimeout && typeof socket.setTimeout === 'function') {\n      socket.setTimeout(server.keepAliveTimeout);\n      state.keepAliveTimeoutSet = true;\n    }\n  } else {\n    // Start sending the next message\n    const m = state.outgoing.shift();\n    if (m) {\n      m.assignSocket(socket);\n    }\n  }\n}\n\nfunction emitCloseNT(self) {\n  if (!self._closed) {\n    self.destroyed = true;\n    self._closed = true;\n    self.emit('close');\n  }\n}\n\n// The following callback is issued after the headers have been read on a\n// new message. In this callback we setup the response object and pass it\n// to the user.\nfunction parserOnIncoming(server\x2C socket\x2C state\x2C req\x2C keepAlive) {\n  resetSocketTimeout(server\x2C socket\x2C state);\n\n  if (req.upgrade) {\n    req.upgrade = req.method === 'CONNECT' ||\n                  server.listenerCount('upgrade') > 0;\n    if (req.upgrade)\n      return 2;\n  }\n\n  state.incoming.push(req);\n\n  // If the writable end isn't consuming\x2C then stop reading\n  // so that we don't become overwhelmed by a flood of\n  // pipelined requests that may never be resolved.\n  if (!socket._paused) {\n    const ws = socket._writableState;\n    if (ws.needDrain || state.outgoingData >= socket.writableHighWaterMark) {\n      socket._paused = true;\n      // We also need to pause the parser\x2C but don't do that until after\n      // the call to execute\x2C because we may still be processing the last\n      // chunk.\n      socket.pause();\n    }\n  }\n\n  const res = new server[kServerResponse](req);\n  res._keepAliveTimeout = server.keepAliveTimeout;\n  res._onPendingData = updateOutgoingData.bind(undefined\x2C\n                                               socket\x2C state);\n\n  res.shouldKeepAlive = keepAlive;\n  DTRACE_HTTP_SERVER_REQUEST(req\x2C socket);\n\n  if (onRequestStartChannel.hasSubscribers) {\n    onRequestStartChannel.publish({\n      request: req\x2C\n      response: res\x2C\n      socket\x2C\n      server\n    });\n  }\n\n  if (socket._httpMessage) {\n    // There are already pending outgoing res\x2C append.\n    state.outgoing.push(res);\n  } else {\n    res.assignSocket(socket);\n  }\n\n  // When we're finished writing the response\x2C check if this is the last\n  // response\x2C if so destroy the socket.\n  res.on('finish'\x2C\n         resOnFinish.bind(undefined\x2C\n                          req\x2C res\x2C socket\x2C state\x2C server));\n\n  let handled = false;\n\n  if (req.httpVersionMajor === 1 && req.httpVersionMinor === 1) {\n    const isRequestsLimitSet = (\n      typeof server.maxRequestsPerSocket === 'number' &&\n      server.maxRequestsPerSocket > 0\n    );\n\n    if (isRequestsLimitSet) {\n      state.requestsCount++;\n      res.maxRequestsOnConnectionReached = (\n        server.maxRequestsPerSocket <= state.requestsCount);\n    }\n\n    if (isRequestsLimitSet &&\n      (server.maxRequestsPerSocket < state.requestsCount)) {\n      handled = true;\n\n      res.writeHead(503);\n      res.end();\n    } else if (req.headers.expect !== undefined) {\n      handled = true;\n\n      if (RegExpPrototypeTest(continueExpression\x2C req.headers.expect)) {\n        res._expect_continue = true;\n\n        if (server.listenerCount('checkContinue') > 0) {\n          server.emit('checkContinue'\x2C req\x2C res);\n        } else {\n          res.writeContinue();\n          server.emit('request'\x2C req\x2C res);\n        }\n      } else if (server.listenerCount('checkExpectation') > 0) {\n        server.emit('checkExpectation'\x2C req\x2C res);\n      } else {\n        res.writeHead(417);\n        res.end();\n      }\n    }\n  }\n\n  if (!handled) {\n    req.on('end'\x2C clearRequestTimeout);\n    server.emit('request'\x2C req\x2C res);\n  }\n\n  return 0;  // No special treatment.\n}\n\nfunction resetSocketTimeout(server\x2C socket\x2C state) {\n  if (!state.keepAliveTimeoutSet)\n    return;\n\n  socket.setTimeout(server.timeout || 0);\n  state.keepAliveTimeoutSet = false;\n}\n\nfunction onSocketResume() {\n  // It may seem that the socket is resumed\x2C but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously\x2C and may be called from\n  // `incoming.readStart()`. Stop the socket again here\x2C just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n}\n\nfunction onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}\n\nfunction unconsume(parser\x2C socket) {\n  if (socket._handle) {\n    if (parser._consumed)\n      parser.unconsume();\n    parser._consumed = false;\n    socket.removeListener('pause'\x2C onSocketPause);\n    socket.removeListener('resume'\x2C onSocketResume);\n  }\n}\n\nfunction generateSocketListenerWrapper(originalFnName) {\n  return function socketListenerWrap(ev\x2C fn) {\n    const res = net.Socket.prototype[originalFnName].call(this\x2C\n                                                          ev\x2C fn);\n    if (!this.parser) {\n      this.on = net.Socket.prototype.on;\n      this.addListener = net.Socket.prototype.addListener;\n      this.prependListener = net.Socket.prototype.prependListener;\n      return res;\n    }\n\n    if (ev === 'data' || ev === 'readable')\n      unconsume(this.parser\x2C this);\n\n    return res;\n  };\n}\n\nmodule.exports = {\n  STATUS_CODES\x2C\n  Server\x2C\n  ServerResponse\x2C\n  storeHTTPOptions\x2C\n  _connectionListener: connectionListener\x2C\n  kServerResponse\n};\n
code-source-info,0x29d5d5b86d36,160,0,32732,C0O0C4O32732,,
code-creation,Function,10,82792,0x29d5d5b88556,1356, node:_http_server:1:1,0x29d5d5b86cb0,~
code-source-info,0x29d5d5b88556,160,0,32732,C0O0C359O1159C365O1175C371O1184C377O1198C382O1222C388O1245C393O1255C399O1296C402O1296C406O1296C408O1323C411O1323C416O1357C419O1357C423O1357C425O1596C428O1596C433O1395C439O1406C445O1420C451O1442C457O1461C463O1481C469O1500C475O1514C481O1552C487O1578C493O1649C496O1649C501O1629C507O1734C510O1734C515O1686C521O1701C527O1715C533O1820C536O1820C541O1770C547O1800C553O1881C556O1881C561O1861C567O1950C570O1950C575O1918C581O1940C586O1988C592O2016C598O2041C604O2073C610O2101C616O2125C622O2150C628O2227C631O2227C636O2188C642O2207C648O2274C651O2274C656O2291C661O2372C664O2372C669O2310C675O2340C681O2437C684O2437C689O2408C695O2420C701O2469C704O2469C709O2502C722O2503C728O2469C730O2560C733O2560C738O2625C746O2625C751O2622C753O2698C761O2698C766O2695C768O2763C771O2763C775O2763C777O2823C780O2823C784O2823C786O2887C789O2887C794O2870C800O2943C804O2943C806O6422C809O6433C813O6449C816O6422C818O6473C821O6484C825O6495C828O6473C830O6519C833O6530C837O6541C840O6519C842O6566C845O6577C849O6589C852O6566C854O6615C857O6626C861O6639C864O6615C887O6645C889O7347C892O7383C900O7410C905O7347C910O7422C916O7422C921O7478C924O7493C933O7511C937O7682C940O7697C949O7718C953O7725C956O7740C962O7764C966O8766C969O8781C978O8804C982O9021C985O9036C994O9059C998O9246C1001O9261C1010O9285C1014O9408C1017O9423C1026O9449C1030O9552C1033O9567C1042O9593C1046O9663C1049O9678C1056O9698C1060O12341C1063O12356C1071O12395C1076O12405C1080O12378C1084O14165C1087O14193C1095O14208C1100O14215C1105O14165C1110O14227C1116O14260C1121O14227C1126O14271C1129O14278C1138O14299C1142O14433C1145O14440C1150O14453C1159O14477C1163O22076C1167O22076C1169O22120C1184O22156C1200O22168C1207O22120C1213O22113C1215O22250C1230O22286C1246O22298C1253O22250C1259O22243C1261O22393C1276O22429C1292O22441C1299O22393C1305O22386C1307O32585C1314O32606C1320O32622C1326O32632C1332O32650C1338O32691C1344O32713C1350O32600C1355O32731,,
tick,0x1bfd70f34,82875,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x2cbd764a9eaf,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89d6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,82959,0x29d5d5b8b756,5, node:diagnostics_channel:1:1,0x29d5d5b8b508,~
script-source,161,node:diagnostics_channel,'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  ObjectCreate\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  SymbolHasInstance\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n  }\n} = require('internal/errors');\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst { triggerUncaughtException } = internalBinding('errors');\n\nconst { WeakReference } = internalBinding('util');\n\n// TODO(qard): should there be a C++ channel interface?\nclass ActiveChannel {\n  subscribe(subscription) {\n    validateFunction(subscription\x2C 'subscription');\n    ArrayPrototypePush(this._subscribers\x2C subscription);\n  }\n\n  unsubscribe(subscription) {\n    const index = ArrayPrototypeIndexOf(this._subscribers\x2C subscription);\n    if (index === -1) return false;\n\n    ArrayPrototypeSplice(this._subscribers\x2C index\x2C 1);\n\n    // When there are no more active subscribers\x2C restore to fast prototype.\n    if (!this._subscribers.length) {\n      // eslint-disable-next-line no-use-before-define\n      ObjectSetPrototypeOf(this\x2C Channel.prototype);\n    }\n\n    return true;\n  }\n\n  get hasSubscribers() {\n    return true;\n  }\n\n  publish(data) {\n    for (let i = 0; i < this._subscribers.length; i++) {\n      try {\n        const onMessage = this._subscribers[i];\n        onMessage(data\x2C this.name);\n      } catch (err) {\n        process.nextTick(() => {\n          triggerUncaughtException(err\x2C false);\n        });\n      }\n    }\n  }\n}\n\nclass Channel {\n  constructor(name) {\n    this._subscribers = undefined;\n    this.name = name;\n  }\n\n  static [SymbolHasInstance](instance) {\n    const prototype = ObjectGetPrototypeOf(instance);\n    return prototype === Channel.prototype ||\n           prototype === ActiveChannel.prototype;\n  }\n\n  subscribe(subscription) {\n    ObjectSetPrototypeOf(this\x2C ActiveChannel.prototype);\n    this._subscribers = [];\n    this.subscribe(subscription);\n  }\n\n  unsubscribe() {\n    return false;\n  }\n\n  get hasSubscribers() {\n    return false;\n  }\n\n  publish() {}\n}\n\nconst channels = ObjectCreate(null);\n\nfunction channel(name) {\n  let channel;\n  const ref = channels[name];\n  if (ref) channel = ref.get();\n  if (channel) return channel;\n\n  if (typeof name !== 'string' && typeof name !== 'symbol') {\n    throw new ERR_INVALID_ARG_TYPE('channel'\x2C ['string'\x2C 'symbol']\x2C name);\n  }\n\n  channel = new Channel(name);\n  channels[name] = new WeakReference(channel);\n  return channel;\n}\n\nfunction hasSubscribers(name) {\n  let channel;\n  const ref = channels[name];\n  if (ref) channel = ref.get();\n  if (!channel) {\n    return false;\n  }\n\n  return channel.hasSubscribers;\n}\n\nmodule.exports = {\n  channel\x2C\n  hasSubscribers\x2C\n  Channel\n};\n
code-source-info,0x29d5d5b8b756,161,0,2697,C0O0C4O2697,,
code-creation,Function,10,83084,0x29d5d5b8c2c6,313, node:diagnostics_channel:1:1,0x29d5d5b8b6d0,~
code-source-info,0x29d5d5b8c2c6,161,0,2697,C0O0C55O25C61O50C67O72C73O96C78O112C84O136C90O160C95O250C98O250C103O250C108O220C114O310C117O310C122O288C128O380C131O380C136O351C142O434C145O434C150O416C197O516C215O1592C272O1482C274O2054C276O2054C280O2054C282O2636C289O2657C295O2668C301O2686C307O2651C312O2696,,
code-creation,LazyCompile,10,83167,0x29d5d5b8cb9e,105,channel node:diagnostics_channel:97:17,0x29d5d5b8b788,~
code-source-info,0x29d5d5b8cb9e,161,2091,2448,C0O2106C2O2129C9O2137C13O2147C15O2170C20O2170C25O2179C29O2192C31O2207C32O2211C44O2275C62O2281C67O2275C68O2353C75O2363C81O2384C88O2405C93O2401C98O2399C102O2431C104O2446,,
code-creation,LazyCompile,10,83167,0x29d5d5b8d146,13,Channel node:diagnostics_channel:67:14,0x29d5d5b8b9e0,~
code-source-info,0x29d5d5b8d146,161,1511,1580,C0O1524C1O1542C5O1559C7O1569C12O1579,,
code-creation,LazyCompile,10,83209,0x29d5d5b8d4a6,5,byteLength node:buffer:628:17,0x232faba32f68,~
code-source-info,0x29d5d5b8d4a6,24,18010,18035,C0O18029C4O18035,,
code-creation,LazyCompile,10,83250,0x29d5d5b8d57e,23,write node:buffer:629:12,0x232faba33050,~
code-source-info,0x29d5d5b8d57e,24,18048,18113,C0O18082C17O18082C22O18113,,
code-creation,LazyCompile,10,83292,0x29d5d5b8da3e,43,get node:http:132:6,0x2cbd764a9a20,~
code-source-info,0x29d5d5b8da3e,152,3767,3973,C0O3776C6O3844C12O3844C17O3825C22O3879C25O3895C32O3893C38O3948C42O3969,,
code-creation,LazyCompile,10,83334,0x29d5d5b8e026,10,get node:http:145:6,0x2cbd764a9a70,~
code-source-info,0x29d5d5b8e026,152,4080,4122,C0O4089C5O4106C9O4118,,
tick,0x100d7f930,83375,0,0x0,0,0x26b72db362ce,0x2cbd764a89de,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,83417,0x29d5d5b8e52e,5, node:https:1:1,0x29d5d5b8e288,~
script-source,162,node:https,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  FunctionPrototypeCall\x2C\n  JSONStringify\x2C\n  ObjectAssign\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectConstruct\x2C\n} = primordials;\n\nrequire('internal/util').assertCrypto();\n\nconst tls = require('tls');\nconst { Agent: HttpAgent } = require('_http_agent');\nconst {\n  Server: HttpServer\x2C\n  storeHTTPOptions\x2C\n  _connectionListener\x2C\n} = require('_http_server');\nconst { ClientRequest } = require('_http_client');\nlet debug = require('internal/util/debuglog').debuglog('https'\x2C (fn) => {\n  debug = fn;\n});\nconst { URL\x2C urlToHttpOptions\x2C searchParamsSymbol } = require('internal/url');\n\nfunction Server(opts\x2C requestListener) {\n  if (!(this instanceof Server)) return new Server(opts\x2C requestListener);\n\n  if (typeof opts === 'function') {\n    requestListener = opts;\n    opts = undefined;\n  }\n  opts = { ...opts };\n\n  if (!opts.ALPNProtocols) {\n    // http/1.0 is not defined as Protocol IDs in IANA\n    // https://www.iana.org/assignments/tls-extensiontype-values\n    //       /tls-extensiontype-values.xhtml#alpn-protocol-ids\n    opts.ALPNProtocols = ['http/1.1'];\n  }\n\n  FunctionPrototypeCall(storeHTTPOptions\x2C this\x2C opts);\n  FunctionPrototypeCall(tls.Server\x2C this\x2C opts\x2C _connectionListener);\n\n  this.httpAllowHalfOpen = false;\n\n  if (requestListener) {\n    this.addListener('request'\x2C requestListener);\n  }\n\n  this.addListener('tlsClientError'\x2C function addListener(err\x2C conn) {\n    if (!this.emit('clientError'\x2C err\x2C conn))\n      conn.destroy(err);\n  });\n\n  this.timeout = 0;\n  this.keepAliveTimeout = 5000;\n  this.maxHeadersCount = null;\n  this.headersTimeout = 60 * 1000; // 60 seconds\n  this.requestTimeout = 0;\n}\nObjectSetPrototypeOf(Server.prototype\x2C tls.Server.prototype);\nObjectSetPrototypeOf(Server\x2C tls.Server);\n\nServer.prototype.setTimeout = HttpServer.prototype.setTimeout;\n\n/**\n * Creates a new `https.Server` instance.\n * @param {{\n *   IncomingMessage?: IncomingMessage;\n *   ServerResponse?: ServerResponse;\n *   insecureHTTPParser?: boolean;\n *   maxHeaderSize?: number;\n *   }} [opts]\n * @param {Function} [requestListener]\n * @returns {Server}\n */\nfunction createServer(opts\x2C requestListener) {\n  return new Server(opts\x2C requestListener);\n}\n\n\n// HTTPS agents.\n\nfunction createConnection(port\x2C host\x2C options) {\n  if (port !== null && typeof port === 'object') {\n    options = port;\n  } else if (host !== null && typeof host === 'object') {\n    options = { ...host };\n  } else if (options === null || typeof options !== 'object') {\n    options = {};\n  } else {\n    options = { ...options };\n  }\n\n  if (typeof port === 'number') {\n    options.port = port;\n  }\n\n  if (typeof host === 'string') {\n    options.host = host;\n  }\n\n  debug('createConnection'\x2C options);\n\n  if (options._agentKey) {\n    const session = this._getSession(options._agentKey);\n    if (session) {\n      debug('reuse session for %j'\x2C options._agentKey);\n      options = {\n        session\x2C\n        ...options\n      };\n    }\n  }\n\n  const socket = tls.connect(options);\n\n  if (options._agentKey) {\n    // Cache new session for reuse\n    socket.on('session'\x2C (session) => {\n      this._cacheSession(options._agentKey\x2C session);\n    });\n\n    // Evict session on error\n    socket.once('close'\x2C (err) => {\n      if (err)\n        this._evictSession(options._agentKey);\n    });\n  }\n\n  return socket;\n}\n\n/**\n * Creates a new `HttpAgent` instance.\n * @param {{\n *   keepAlive?: boolean;\n *   keepAliveMsecs?: number;\n *   maxSockets?: number;\n *   maxTotalSockets?: number;\n *   maxFreeSockets?: number;\n *   scheduling?: string;\n *   timeout?: number;\n *   maxCachedSessions?: number;\n *   servername?: string;\n *   }} [options]\n * @returns {Agent}\n */\nfunction Agent(options) {\n  if (!(this instanceof Agent))\n    return new Agent(options);\n\n  FunctionPrototypeCall(HttpAgent\x2C this\x2C options);\n  this.defaultPort = 443;\n  this.protocol = 'https:';\n  this.maxCachedSessions = this.options.maxCachedSessions;\n  if (this.maxCachedSessions === undefined)\n    this.maxCachedSessions = 100;\n\n  this._sessionCache = {\n    map: {}\x2C\n    list: []\n  };\n}\nObjectSetPrototypeOf(Agent.prototype\x2C HttpAgent.prototype);\nObjectSetPrototypeOf(Agent\x2C HttpAgent);\nAgent.prototype.createConnection = createConnection;\n\n/**\n * Gets a unique name for a set of options.\n * @param {{\n *   host: string;\n *   port: number;\n *   localAddress: string;\n *   family: number;\n *   }} [options]\n * @returns {string}\n */\nAgent.prototype.getName = function getName(options = {}) {\n  let name = FunctionPrototypeCall(HttpAgent.prototype.getName\x2C this\x2C options);\n\n  name += ':';\n  if (options.ca)\n    name += options.ca;\n\n  name += ':';\n  if (options.cert)\n    name += options.cert;\n\n  name += ':';\n  if (options.clientCertEngine)\n    name += options.clientCertEngine;\n\n  name += ':';\n  if (options.ciphers)\n    name += options.ciphers;\n\n  name += ':';\n  if (options.key)\n    name += options.key;\n\n  name += ':';\n  if (options.pfx)\n    name += options.pfx;\n\n  name += ':';\n  if (options.rejectUnauthorized !== undefined)\n    name += options.rejectUnauthorized;\n\n  name += ':';\n  if (options.servername && options.servername !== options.host)\n    name += options.servername;\n\n  name += ':';\n  if (options.minVersion)\n    name += options.minVersion;\n\n  name += ':';\n  if (options.maxVersion)\n    name += options.maxVersion;\n\n  name += ':';\n  if (options.secureProtocol)\n    name += options.secureProtocol;\n\n  name += ':';\n  if (options.crl)\n    name += options.crl;\n\n  name += ':';\n  if (options.honorCipherOrder !== undefined)\n    name += options.honorCipherOrder;\n\n  name += ':';\n  if (options.ecdhCurve)\n    name += options.ecdhCurve;\n\n  name += ':';\n  if (options.dhparam)\n    name += options.dhparam;\n\n  name += ':';\n  if (options.secureOptions !== undefined)\n    name += options.secureOptions;\n\n  name += ':';\n  if (options.sessionIdContext)\n    name += options.sessionIdContext;\n\n  name += ':';\n  if (options.sigalgs)\n    name += JSONStringify(options.sigalgs);\n\n  name += ':';\n  if (options.privateKeyIdentifier)\n    name += options.privateKeyIdentifier;\n\n  name += ':';\n  if (options.privateKeyEngine)\n    name += options.privateKeyEngine;\n\n  return name;\n};\n\nAgent.prototype._getSession = function _getSession(key) {\n  return this._sessionCache.map[key];\n};\n\nAgent.prototype._cacheSession = function _cacheSession(key\x2C session) {\n  // Cache is disabled\n  if (this.maxCachedSessions === 0)\n    return;\n\n  // Fast case - update existing entry\n  if (this._sessionCache.map[key]) {\n    this._sessionCache.map[key] = session;\n    return;\n  }\n\n  // Put new entry\n  if (this._sessionCache.list.length >= this.maxCachedSessions) {\n    const oldKey = ArrayPrototypeShift(this._sessionCache.list);\n    debug('evicting %j'\x2C oldKey);\n    delete this._sessionCache.map[oldKey];\n  }\n\n  ArrayPrototypePush(this._sessionCache.list\x2C key);\n  this._sessionCache.map[key] = session;\n};\n\nAgent.prototype._evictSession = function _evictSession(key) {\n  const index = ArrayPrototypeIndexOf(this._sessionCache.list\x2C key);\n  if (index === -1)\n    return;\n\n  ArrayPrototypeSplice(this._sessionCache.list\x2C index\x2C 1);\n  delete this._sessionCache.map[key];\n};\n\nconst globalAgent = new Agent();\n\n/**\n * Makes a request to a secure web server.\n * @param {...any} args\n * @returns {ClientRequest}\n */\nfunction request(...args) {\n  let options = {};\n\n  if (typeof args[0] === 'string') {\n    const urlStr = ArrayPrototypeShift(args);\n    options = urlToHttpOptions(new URL(urlStr));\n  } else if (args[0] && args[0][searchParamsSymbol] &&\n             args[0][searchParamsSymbol][searchParamsSymbol]) {\n    // url.URL instance\n    options = urlToHttpOptions(ArrayPrototypeShift(args));\n  }\n\n  if (args[0] && typeof args[0] !== 'function') {\n    ObjectAssign(options\x2C ArrayPrototypeShift(args));\n  }\n\n  options._defaultAgent = module.exports.globalAgent;\n  ArrayPrototypeUnshift(args\x2C options);\n\n  return ReflectConstruct(ClientRequest\x2C args);\n}\n\n/**\n * Makes a GET request to a secure web server.\n * @param {string | URL} input\n * @param {{\n *   agent?: Agent | boolean;\n *   auth?: string;\n *   createConnection?: Function;\n *   defaultPort?: number;\n *   family?: number;\n *   headers?: Object;\n *   hints?: number;\n *   host?: string;\n *   hostname?: string;\n *   insecureHTTPParser?: boolean;\n *   localAddress?: string;\n *   localPort?: number;\n *   lookup?: Function;\n *   maxHeaderSize?: number;\n *   method?: string;\n *   path?: string;\n *   port?: number;\n *   protocol?: string;\n *   setHost?: boolean;\n *   socketPath?: string;\n *   timeout?: number;\n *   signal?: AbortSignal;\n *   } | string | URL} [options]\n * @param {Function} [cb]\n * @returns {ClientRequest}\n */\nfunction get(input\x2C options\x2C cb) {\n  const req = request(input\x2C options\x2C cb);\n  req.end();\n  return req;\n}\n\nmodule.exports = {\n  Agent\x2C\n  globalAgent\x2C\n  Server\x2C\n  createServer\x2C\n  get\x2C\n  request\n};\n
code-source-info,0x29d5d5b8e52e,162,0,10053,C0O0C4O10053,,
code-creation,Function,10,83792,0x29d5d5b8eb5e,523, node:https:1:1,0x29d5d5b8e4a8,~
code-source-info,0x29d5d5b8eb5e,162,0,10053,C0O0C96O1159C102O1184C108O1206C114O1229C120O1253C126O1278C132O1303C138O1320C144O1336C149O1360C155O1396C158O1396C163O1420C168O1421C172O1450C175O1450C179O1450C181O1495C184O1495C189O1481C195O1596C198O1596C203O1537C208O1551C214O1571C220O1647C223O1647C228O1629C234O1684C237O1684C242O1717C255O1718C261O1684C263O1818C266O1818C271O1772C277O1777C283O1795C289O2881C292O2909C300O2924C305O2931C310O2881C315O2943C321O2976C326O2943C331O2986C334O2993C339O3027C344O3037C348O3014C352O5282C355O5309C363O5330C368O5282C373O5342C379O5342C384O5382C387O5388C394O5415C398O5626C401O5632C410O5650C414O7369C417O7375C426O7397C430O7469C433O7475C442O7499C446O8077C449O8083C458O8107C462O8362C465O8362C471O9964C481O9985C487O9994C493O10009C499O10019C505O10035C511O10042C517O9979C522O10052,,
code-creation,LazyCompile,10,83875,0x29d5d5b8fd6e,19,assertCrypto node:internal/util:152:22,0x232faba01e08,~
code-source-info,0x29d5d5b8fd6e,16,3948,4001,C0O3955C6O3973C11O3979C16O3973C18O4000,,
code-creation,Eval,10,84000,0x29d5d5b90c9e,5, node:tls:1:1,0x29d5d5b908a8,~
script-source,163,node:tls,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSome\x2C\n  JSONParse\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeTest\x2C\n  StringFromCharCode\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeSubstring\x2C\n} = primordials;\n\nconst {\n  ERR_TLS_CERT_ALTNAME_FORMAT\x2C\n  ERR_TLS_CERT_ALTNAME_INVALID\x2C\n  ERR_OUT_OF_RANGE\n} = require('internal/errors').codes;\nconst internalUtil = require('internal/util');\ninternalUtil.assertCrypto();\nconst { isArrayBufferView } = require('internal/util/types');\n\nconst net = require('net');\nconst { getOptionValue } = require('internal/options');\nconst { getRootCertificates\x2C getSSLCiphers } = internalBinding('crypto');\nconst { Buffer } = require('buffer');\nconst { URL } = require('internal/url');  // Only used for Security Revert\nconst { canonicalizeIP } = internalBinding('cares_wrap');\nconst _tls_common = require('_tls_common');\nconst _tls_wrap = require('_tls_wrap');\nconst { createSecurePair } = require('internal/tls/secure-pair');\nconst { parseCertString } = require('internal/tls/parse-cert-string');\n\n// Allow {CLIENT_RENEG_LIMIT} client-initiated session renegotiations\n// every {CLIENT_RENEG_WINDOW} seconds. An error event is emitted if more\n// renegotiations are seen. The settings are applied to all remote client\n// connections.\nexports.CLIENT_RENEG_LIMIT = 3;\nexports.CLIENT_RENEG_WINDOW = 600;\n\nexports.DEFAULT_CIPHERS = getOptionValue('--tls-cipher-list');\n\nexports.DEFAULT_ECDH_CURVE = 'auto';\n\nif (getOptionValue('--tls-min-v1.0'))\n  exports.DEFAULT_MIN_VERSION = 'TLSv1';\nelse if (getOptionValue('--tls-min-v1.1'))\n  exports.DEFAULT_MIN_VERSION = 'TLSv1.1';\nelse if (getOptionValue('--tls-min-v1.2'))\n  exports.DEFAULT_MIN_VERSION = 'TLSv1.2';\nelse if (getOptionValue('--tls-min-v1.3'))\n  exports.DEFAULT_MIN_VERSION = 'TLSv1.3';\nelse\n  exports.DEFAULT_MIN_VERSION = 'TLSv1.2';\n\nif (getOptionValue('--tls-max-v1.3'))\n  exports.DEFAULT_MAX_VERSION = 'TLSv1.3';\nelse if (getOptionValue('--tls-max-v1.2'))\n  exports.DEFAULT_MAX_VERSION = 'TLSv1.2';\nelse\n  exports.DEFAULT_MAX_VERSION = 'TLSv1.3'; // Will depend on node version.\n\n\nexports.getCiphers = internalUtil.cachedResult(\n  () => internalUtil.filterDuplicateStrings(getSSLCiphers()\x2C true)\n);\n\nlet rootCertificates;\n\nfunction cacheRootCertificates() {\n  rootCertificates = ObjectFreeze(getRootCertificates());\n}\n\nObjectDefineProperty(exports\x2C 'rootCertificates'\x2C {\n  configurable: false\x2C\n  enumerable: true\x2C\n  get: () => {\n    // Out-of-line caching to promote inlining the getter.\n    if (!rootCertificates) cacheRootCertificates();\n    return rootCertificates;\n  }\x2C\n});\n\n// Convert protocols array into valid OpenSSL protocols list\n// ("\\x06spdy/2\\x08http/1.1\\x08http/1.0")\nfunction convertProtocols(protocols) {\n  const lens = new Array(protocols.length);\n  const buff = Buffer.allocUnsafe(ArrayPrototypeReduce(protocols\x2C (p\x2C c\x2C i) => {\n    const len = Buffer.byteLength(c);\n    if (len > 255) {\n      throw new ERR_OUT_OF_RANGE('The byte length of the protocol at index ' +\n        `${i} exceeds the maximum length.`\x2C '<= 255'\x2C len\x2C true);\n    }\n    lens[i] = len;\n    return p + 1 + len;\n  }\x2C 0));\n\n  let offset = 0;\n  for (let i = 0\x2C c = protocols.length; i < c; i++) {\n    buff[offset++] = lens[i];\n    buff.write(protocols[i]\x2C offset);\n    offset += lens[i];\n  }\n\n  return buff;\n}\n\nexports.convertALPNProtocols = function convertALPNProtocols(protocols\x2C out) {\n  // If protocols is Array - translate it into buffer\n  if (ArrayIsArray(protocols)) {\n    out.ALPNProtocols = convertProtocols(protocols);\n  } else if (isArrayBufferView(protocols)) {\n    // Copy new buffer not to be modified by user.\n    out.ALPNProtocols = Buffer.from(protocols);\n  }\n};\n\nfunction unfqdn(host) {\n  return StringPrototypeReplace(host\x2C /[.]$/\x2C '');\n}\n\n// String#toLowerCase() is locale-sensitive so we use\n// a conservative version that only lowercases A-Z.\nfunction toLowerCase(c) {\n  return StringFromCharCode(32 + StringPrototypeCharCodeAt(c\x2C 0));\n}\n\nfunction splitHost(host) {\n  return StringPrototypeSplit(\n    StringPrototypeReplace(unfqdn(host)\x2C /[A-Z]/g\x2C toLowerCase)\x2C\n    '.'\n  );\n}\n\nfunction check(hostParts\x2C pattern\x2C wildcards) {\n  // Empty strings\x2C null\x2C undefined\x2C etc. never match.\n  if (!pattern)\n    return false;\n\n  const patternParts = splitHost(pattern);\n\n  if (hostParts.length !== patternParts.length)\n    return false;\n\n  // Pattern has empty components\x2C e.g. "bad..example.com".\n  if (ArrayPrototypeIncludes(patternParts\x2C ''))\n    return false;\n\n  // RFC 6125 allows IDNA U-labels (Unicode) in names but we have no\n  // good way to detect their encoding or normalize them so we simply\n  // reject them.  Control characters and blanks are rejected as well\n  // because nothing good can come from accepting them.\n  const isBad = (s) => RegExpPrototypeTest(/[^\\u0021-\\u007F]/u\x2C s);\n  if (ArrayPrototypeSome(patternParts\x2C isBad))\n    return false;\n\n  // Check host parts from right to left first.\n  for (let i = hostParts.length - 1; i > 0; i -= 1) {\n    if (hostParts[i] !== patternParts[i])\n      return false;\n  }\n\n  const hostSubdomain = hostParts[0];\n  const patternSubdomain = patternParts[0];\n  const patternSubdomainParts = StringPrototypeSplit(patternSubdomain\x2C '*');\n\n  // Short-circuit when the subdomain does not contain a wildcard.\n  // RFC 6125 does not allow wildcard substitution for components\n  // containing IDNA A-labels (Punycode) so match those verbatim.\n  if (patternSubdomainParts.length === 1 ||\n      StringPrototypeIncludes(patternSubdomain\x2C 'xn--'))\n    return hostSubdomain === patternSubdomain;\n\n  if (!wildcards)\n    return false;\n\n  // More than one wildcard is always wrong.\n  if (patternSubdomainParts.length > 2)\n    return false;\n\n  // *.tld wildcards are not allowed.\n  if (patternParts.length <= 2)\n    return false;\n\n  const { 0: prefix\x2C 1: suffix } = patternSubdomainParts;\n\n  if (prefix.length + suffix.length > hostSubdomain.length)\n    return false;\n\n  if (!StringPrototypeStartsWith(hostSubdomain\x2C prefix))\n    return false;\n\n  if (!StringPrototypeEndsWith(hostSubdomain\x2C suffix))\n    return false;\n\n  return true;\n}\n\n// This pattern is used to determine the length of escaped sequences within\n// the subject alt names string. It allows any valid JSON string literal.\n// This MUST match the JSON specification (ECMA-404 / RFC8259) exactly.\nconst jsonStringPattern =\n  // eslint-disable-next-line no-control-regex\n  /^"(?:[^"\\\\\\u0000-\\u001f]|\\\\(?:["\\\\/bfnrt]|u[0-9a-fA-F]{4}))*"/;\n\nfunction splitEscapedAltNames(altNames) {\n  const result = [];\n  let currentToken = '';\n  let offset = 0;\n  while (offset !== altNames.length) {\n    const nextSep = StringPrototypeIndexOf(altNames\x2C '\x2C '\x2C offset);\n    const nextQuote = StringPrototypeIndexOf(altNames\x2C '"'\x2C offset);\n    if (nextQuote !== -1 && (nextSep === -1 || nextQuote < nextSep)) {\n      // There is a quote character and there is no separator before the quote.\n      currentToken += StringPrototypeSubstring(altNames\x2C offset\x2C nextQuote);\n      const match = RegExpPrototypeExec(\n        jsonStringPattern\x2C StringPrototypeSubstring(altNames\x2C nextQuote));\n      if (!match) {\n        throw new ERR_TLS_CERT_ALTNAME_FORMAT();\n      }\n      currentToken += JSONParse(match[0]);\n      offset = nextQuote + match[0].length;\n    } else if (nextSep !== -1) {\n      // There is a separator and no quote before it.\n      currentToken += StringPrototypeSubstring(altNames\x2C offset\x2C nextSep);\n      ArrayPrototypePush(result\x2C currentToken);\n      currentToken = '';\n      offset = nextSep + 2;\n    } else {\n      currentToken += StringPrototypeSubstring(altNames\x2C offset);\n      offset = altNames.length;\n    }\n  }\n  ArrayPrototypePush(result\x2C currentToken);\n  return result;\n}\n\nexports.checkServerIdentity = function checkServerIdentity(hostname\x2C cert) {\n  const subject = cert.subject;\n  const altNames = cert.subjectaltname;\n  const dnsNames = [];\n  const uriNames = [];\n  const ips = [];\n\n  hostname = '' + hostname;\n\n  if (altNames) {\n    const splitAltNames = StringPrototypeIncludes(altNames\x2C '"') ?\n      splitEscapedAltNames(altNames) :\n      StringPrototypeSplit(altNames\x2C '\x2C ');\n    ArrayPrototypeForEach(splitAltNames\x2C (name) => {\n      if (StringPrototypeStartsWith(name\x2C 'DNS:')) {\n        ArrayPrototypePush(dnsNames\x2C StringPrototypeSlice(name\x2C 4));\n      } else if (process.REVERT_CVE_2021_44531 &&\n                 StringPrototypeStartsWith(name\x2C 'URI:')) {\n        const uri = new URL(StringPrototypeSlice(name\x2C 4));\n\n        // TODO(bnoordhuis) Also use scheme.\n        ArrayPrototypePush(uriNames\x2C uri.hostname);\n      } else if (StringPrototypeStartsWith(name\x2C 'IP Address:')) {\n        ArrayPrototypePush(ips\x2C canonicalizeIP(StringPrototypeSlice(name\x2C 11)));\n      }\n    });\n  }\n\n  let valid = false;\n  let reason = 'Unknown reason';\n\n  const hasAltNames =\n    dnsNames.length > 0 || ips.length > 0 || uriNames.length > 0;\n\n  hostname = unfqdn(hostname);  // Remove trailing dot for error messages.\n\n  if (net.isIP(hostname)) {\n    valid = ArrayPrototypeIncludes(ips\x2C canonicalizeIP(hostname));\n    if (!valid)\n      reason = `IP: ${hostname} is not in the cert's list: ` +\n               ArrayPrototypeJoin(ips\x2C '\x2C ');\n    // TODO(bnoordhuis) Also check URI SANs that are IP addresses.\n  } else if ((process.REVERT_CVE_2021_44531 && (hasAltNames || subject)) ||\n             (dnsNames.length > 0 || subject?.CN)) {\n    const hostParts = splitHost(hostname);\n    const wildcard = (pattern) => check(hostParts\x2C pattern\x2C true);\n\n    if ((process.REVERT_CVE_2021_44531 && hasAltNames) ||\n        (dnsNames.length > 0)) {\n      const noWildcard = (pattern) => check(hostParts\x2C pattern\x2C false);\n      valid = ArrayPrototypeSome(dnsNames\x2C wildcard) ||\n              ArrayPrototypeSome(uriNames\x2C noWildcard);\n      if (!valid)\n        reason =\n          `Host: ${hostname}. is not in the cert's altnames: ${altNames}`;\n    } else {\n      // Match against Common Name only if no supported identifiers exist.\n      const cn = subject.CN;\n\n      if (ArrayIsArray(cn))\n        valid = ArrayPrototypeSome(cn\x2C wildcard);\n      else if (cn)\n        valid = wildcard(cn);\n\n      if (!valid)\n        reason = `Host: ${hostname}. is not cert's CN: ${cn}`;\n    }\n  } else {\n    reason = 'Cert does not contain a DNS name';\n  }\n\n  if (!valid) {\n    return new ERR_TLS_CERT_ALTNAME_INVALID(reason\x2C hostname\x2C cert);\n  }\n};\n\nexports.createSecureContext = _tls_common.createSecureContext;\nexports.SecureContext = _tls_common.SecureContext;\nexports.TLSSocket = _tls_wrap.TLSSocket;\nexports.Server = _tls_wrap.Server;\nexports.createServer = _tls_wrap.createServer;\nexports.connect = _tls_wrap.connect;\n\nexports.parseCertString = internalUtil.deprecate(\n  parseCertString\x2C\n  'tls.parseCertString() is deprecated. ' +\n  'Please use querystring.parse() instead.'\x2C\n  'DEP0076');\n\nexports.createSecurePair = internalUtil.deprecate(\n  createSecurePair\x2C\n  'tls.createSecurePair() is deprecated. Please use ' +\n  'tls.TLSSocket instead.'\x2C 'DEP0064');\n
code-source-info,0x29d5d5b90c9e,163,0,12414,C0O0C4O12414,,
code-creation,Function,10,84500,0x29d5d5b9142e,815, node:tls:1:1,0x29d5d5b90c18,~
code-source-info,0x29d5d5b9142e,163,0,12414,C0O0C156O1159C162O1168C168O1184C174O1209C180O1235C186O1257C192O1279C198O1303C204O1325C210O1338C215O1362C221O1378C227O1401C233O1424C239O1446C245O1475C251O1502C257O1529C263O1555C269O1581C275O1605C281O1629C287O1658C293O1796C296O1796C301O1822C306O1712C312O1743C318O1775C324O1851C327O1851C331O1851C333O1877C336O1890C341O1890C345O1936C348O1936C353O1914C359O1981C362O1981C366O1981C368O2024C371O2024C376O2005C381O2100C384O2100C389O2061C395O2082C401O2146C404O2146C409O2135C415O2181C418O2181C423O2173C429O2267C432O2267C437O2248C443O2318C446O2318C451O2360C454O2360C459O2411C462O2411C467O2390C472O2476C475O2476C480O2456C485O2754C487O2781C491O2786C495O2814C499O2822C502O2848C506O2846C510O2886C512O2913C516O2924C519O2928C525O2964C527O2992C533O3008C536O3012C542O3048C544O3076C550O3094C553O3098C559O3134C561O3162C567O3180C570O3184C576O3220C578O3248C584O3268C586O3296C590O3310C593O3314C599O3350C601O3378C607O3396C610O3400C616O3436C618O3464C624O3484C626O3512C630O3559C633O3593C643O3593C648O3578C652O3682C653O3682C655O3797C658O3818C663O3899C674O3797C679O4774C683O4803C687O7849C691O7849C693O9153C697O9181C701O11841C705O11827C709O11898C713O11884C717O11943C721O11931C725O11981C729O11969C733O12022C737O12010C741O12064C745O12052C749O12074C752O12113C762O12185C772O12113C777O12098C781O12247C784O12287C794O12372C804O12287C809O12272C814O12413,,
tick,0x10091c160,84625,1,0x1003b104c,5,0x0,0x10510a008,0x29d5d5b915ae,0x105108d28,0x10510894c,0x29d5d5b8ec0d,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89de,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,84792,0x29d5d5ba225e,5, node:_tls_common:1:1,0x29d5d5ba1fe8,~
script-source,164,node:_tls_common,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst tls = require('tls');\n\nconst {\n  ArrayPrototypePush\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  StringPrototypeReplace\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_TLS_INVALID_PROTOCOL_VERSION\x2C\n    ERR_TLS_PROTOCOL_VERSION_CONFLICT\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  crypto: {\n    SSL_OP_CIPHER_SERVER_PREFERENCE\x2C\n    TLS1_VERSION\x2C\n    TLS1_1_VERSION\x2C\n    TLS1_2_VERSION\x2C\n    TLS1_3_VERSION\x2C\n  }\x2C\n} = internalBinding('constants');\n\nconst {\n  validateInteger\x2C\n} = require('internal/validators');\n\nconst {\n  configSecureContext\x2C\n} = require('internal/tls/secure-context');\n\nconst {\n  parseCertString\x2C\n} = require('internal/tls/parse-cert-string');\n\nfunction toV(which\x2C v\x2C def) {\n  if (v == null) v = def;\n  if (v === 'TLSv1') return TLS1_VERSION;\n  if (v === 'TLSv1.1') return TLS1_1_VERSION;\n  if (v === 'TLSv1.2') return TLS1_2_VERSION;\n  if (v === 'TLSv1.3') return TLS1_3_VERSION;\n  throw new ERR_TLS_INVALID_PROTOCOL_VERSION(v\x2C which);\n}\n\nconst {\n  SecureContext: NativeSecureContext\x2C\n} = internalBinding('crypto');\n\nfunction SecureContext(secureProtocol\x2C secureOptions\x2C minVersion\x2C maxVersion) {\n  if (!(this instanceof SecureContext)) {\n    return new SecureContext(secureProtocol\x2C secureOptions\x2C minVersion\x2C\n                             maxVersion);\n  }\n\n  if (secureProtocol) {\n    if (minVersion != null)\n      throw new ERR_TLS_PROTOCOL_VERSION_CONFLICT(minVersion\x2C secureProtocol);\n    if (maxVersion != null)\n      throw new ERR_TLS_PROTOCOL_VERSION_CONFLICT(maxVersion\x2C secureProtocol);\n  }\n\n  this.context = new NativeSecureContext();\n  this.context.init(secureProtocol\x2C\n                    toV('minimum'\x2C minVersion\x2C tls.DEFAULT_MIN_VERSION)\x2C\n                    toV('maximum'\x2C maxVersion\x2C tls.DEFAULT_MAX_VERSION));\n\n  if (secureOptions) {\n    validateInteger(secureOptions\x2C 'secureOptions');\n    this.context.setOptions(secureOptions);\n  }\n}\n\nfunction createSecureContext(options) {\n  if (!options) options = {};\n\n  const {\n    honorCipherOrder\x2C\n    minVersion\x2C\n    maxVersion\x2C\n    secureProtocol\x2C\n  } = options;\n\n  let { secureOptions } = options;\n\n  if (honorCipherOrder)\n    secureOptions |= SSL_OP_CIPHER_SERVER_PREFERENCE;\n\n  const c = new SecureContext(secureProtocol\x2C secureOptions\x2C\n                              minVersion\x2C maxVersion);\n\n  configSecureContext(c.context\x2C options);\n\n  return c;\n}\n\n// Translate some fields from the handle's C-friendly format into more idiomatic\n// javascript object representations before passing them back to the user.  Can\n// be used on any cert object\x2C but changing the name would be semver-major.\nfunction translatePeerCertificate(c) {\n  if (!c)\n    return null;\n\n  // TODO(tniessen): can we remove parseCertString without breaking anything?\n  if (typeof c.issuer === 'string') c.issuer = parseCertString(c.issuer);\n  if (c.issuerCertificate != null && c.issuerCertificate !== c) {\n    c.issuerCertificate = translatePeerCertificate(c.issuerCertificate);\n  }\n  // TODO(tniessen): can we remove parseCertString without breaking anything?\n  if (typeof c.subject === 'string') c.subject = parseCertString(c.subject);\n  if (c.infoAccess != null) {\n    const info = c.infoAccess;\n    c.infoAccess = ObjectCreate(null);\n\n    // XXX: More key validation?\n    StringPrototypeReplace(info\x2C /([^\\n:]*):([^\\n]*)(?:\\n|$)/g\x2C\n                           (all\x2C key\x2C val) => {\n                             if (val.charCodeAt(0) === 0x22) {\n                               // The translatePeerCertificate function is only\n                               // used on internally created legacy certificate\n                               // objects\x2C and any value that contains a quote\n                               // will always be a valid JSON string literal\x2C\n                               // so this should never throw.\n                               val = JSONParse(val);\n                             }\n                             if (key in c.infoAccess)\n                               ArrayPrototypePush(c.infoAccess[key]\x2C val);\n                             else\n                               c.infoAccess[key] = [val];\n                           });\n  }\n  return c;\n}\n\nmodule.exports = {\n  SecureContext\x2C\n  createSecureContext\x2C\n  translatePeerCertificate\x2C\n};\n
code-source-info,0x29d5d5ba225e,164,0,5366,C0O0C4O5366,,
code-creation,Function,10,85000,0x29d5d5ba255e,264, node:_tls_common:1:1,0x29d5d5ba21d8,~
code-source-info,0x29d5d5ba255e,164,0,5366,C0O0C76O1161C79O1161C83O1161C85O1188C91O1210C97O1223C103O1239C109O1386C112O1386C117O1386C122O1304C128O1342C134O1559C137O1559C142O1559C147O1439C153O1476C159O1494C165O1514C171O1534C177O1621C180O1621C185O1600C191O1689C194O1689C199O1664C205O1761C208O1761C213O1740C219O2150C222O2150C227O2125C233O5276C240O5297C246O5314C252O5337C258O5291C263O5365,,
code-creation,Eval,10,85125,0x29d5d5ba3436,5, node:internal/tls/secure-context:1:1,0x29d5d5ba3160,~
script-source,165,node:internal/tls/secure-context,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  isArrayBufferView\x2C\n} = require('internal/util/types');\n\nconst {\n  validateInt32\x2C\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst {\n  toBuf\x2C\n} = require('internal/crypto/util');\n\nconst {\n  crypto: {\n    TLS1_2_VERSION\x2C\n    TLS1_3_VERSION\x2C\n  }\x2C\n} = internalBinding('constants');\n\nfunction getDefaultEcdhCurve() {\n  // We do it this way because DEFAULT_ECDH_CURVE can be\n  // changed by users\x2C so we need to grab the current\n  // value\x2C but we want the evaluation to be lazy.\n  return require('tls').DEFAULT_ECDH_CURVE || 'auto';\n}\n\nfunction getDefaultCiphers() {\n  // We do it this way because DEFAULT_CIPHERS can be\n  // changed by users\x2C so we need to grab the current\n  // value\x2C but we want the evaluation to be lazy.\n  return require('tls').DEFAULT_CIPHERS;\n}\n\nfunction addCACerts(context\x2C certs\x2C name) {\n  ArrayPrototypeForEach(certs\x2C (cert) => {\n    validateKeyOrCertOption(name\x2C cert);\n    context.addCACert(cert);\n  });\n}\n\nfunction setCerts(context\x2C certs\x2C name) {\n  ArrayPrototypeForEach(certs\x2C (cert) => {\n    validateKeyOrCertOption(name\x2C cert);\n    context.setCert(cert);\n  });\n}\n\nfunction validateKeyOrCertOption(name\x2C value) {\n  if (typeof value !== 'string' && !isArrayBufferView(value)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      name\x2C\n      [\n        'string'\x2C\n        'Buffer'\x2C\n        'TypedArray'\x2C\n        'DataView'\x2C\n      ]\x2C\n      value\n    );\n  }\n}\n\nfunction setKey(context\x2C key\x2C passphrase\x2C name) {\n  validateKeyOrCertOption(`${name}.key`\x2C key);\n  if (passphrase !== undefined && passphrase !== null)\n    validateString(passphrase\x2C `${name}.passphrase`);\n  context.setKey(key\x2C passphrase);\n}\n\nfunction processCiphers(ciphers\x2C name) {\n  ciphers = StringPrototypeSplit(ciphers || getDefaultCiphers()\x2C ':');\n\n  const cipherList =\n    ArrayPrototypeJoin(\n      ArrayPrototypeFilter(\n        ciphers\x2C\n        (cipher) => {\n          return cipher.length > 0 &&\n            !StringPrototypeStartsWith(cipher\x2C 'TLS_');\n        })\x2C ':');\n\n  const cipherSuites =\n    ArrayPrototypeJoin(\n      ArrayPrototypeFilter(\n        ciphers\x2C\n        (cipher) => {\n          return cipher.length > 0 &&\n            StringPrototypeStartsWith(cipher\x2C 'TLS_');\n        })\x2C ':');\n\n  // Specifying empty cipher suites for both TLS1.2 and TLS1.3 is invalid\x2C its\n  // not possible to handshake with no suites.\n  if (cipherSuites === '' && cipherList === '')\n    throw new ERR_INVALID_ARG_VALUE(name\x2C ciphers);\n\n  return { cipherList\x2C cipherSuites };\n}\n\nfunction configSecureContext(context\x2C options = {}\x2C name = 'options') {\n  validateObject(options\x2C name);\n\n  const {\n    ca\x2C\n    cert\x2C\n    ciphers = getDefaultCiphers()\x2C\n    clientCertEngine\x2C\n    crl\x2C\n    dhparam\x2C\n    ecdhCurve = getDefaultEcdhCurve()\x2C\n    key\x2C\n    passphrase\x2C\n    pfx\x2C\n    privateKeyIdentifier\x2C\n    privateKeyEngine\x2C\n    sessionIdContext\x2C\n    sessionTimeout\x2C\n    sigalgs\x2C\n    ticketKeys\x2C\n  } = options;\n\n  // Add CA before the cert to be able to load cert's issuer in C++ code.\n  // NOTE(@jasnell): ca\x2C cert\x2C and key are permitted to be falsy\x2C so do not\n  // change the checks to !== undefined checks.\n  if (ca) {\n    addCACerts(context\x2C ArrayIsArray(ca) ? ca : [ca]\x2C `${name}.ca`);\n  } else {\n    context.addRootCerts();\n  }\n\n  if (cert) {\n    setCerts(context\x2C ArrayIsArray(cert) ? cert : [cert]\x2C `${name}.cert`);\n  }\n\n  // Set the key after the cert.\n  // `ssl_set_pkey` returns `0` when the key does not match the cert\x2C but\n  // `ssl_set_cert` returns `1` and nullifies the key in the SSL structure\n  // which leads to the crash later on.\n  if (key) {\n    if (ArrayIsArray(key)) {\n      for (let i = 0; i < key.length; ++i) {\n        const val = key[i];\n        const pem = (\n          val?.pem !== undefined ? val.pem : val);\n        const pass = (\n          val?.passphrase !== undefined ? val.passphrase : passphrase);\n        setKey(context\x2C pem\x2C pass\x2C name);\n      }\n    } else {\n      setKey(context\x2C key\x2C passphrase\x2C name);\n    }\n  }\n\n  if (sigalgs !== undefined && sigalgs !== null) {\n    validateString(sigalgs\x2C `${name}.sigalgs`);\n\n    if (sigalgs === '')\n      throw new ERR_INVALID_ARG_VALUE(`${name}.sigalgs`\x2C sigalgs);\n\n    context.setSigalgs(sigalgs);\n  }\n\n  if (privateKeyIdentifier !== undefined && privateKeyIdentifier !== null) {\n    if (privateKeyEngine === undefined || privateKeyEngine === null) {\n      // Engine is required when privateKeyIdentifier is present\n      throw new ERR_INVALID_ARG_VALUE(`${name}.privateKeyEngine`\x2C\n                                      privateKeyEngine);\n    }\n    if (key) {\n      // Both data key and engine key can't be set at the same time\n      throw new ERR_INVALID_ARG_VALUE(`${name}.privateKeyIdentifier`\x2C\n                                      privateKeyIdentifier);\n    }\n\n    if (typeof privateKeyIdentifier === 'string' &&\n        typeof privateKeyEngine === 'string') {\n      if (context.setEngineKey)\n        context.setEngineKey(privateKeyIdentifier\x2C privateKeyEngine);\n      else\n        throw new ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED();\n    } else if (typeof privateKeyIdentifier !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(`${name}.privateKeyIdentifier`\x2C\n                                     ['string'\x2C 'null'\x2C 'undefined']\x2C\n                                     privateKeyIdentifier);\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(`${name}.privateKeyEngine`\x2C\n                                     ['string'\x2C 'null'\x2C 'undefined']\x2C\n                                     privateKeyEngine);\n    }\n  }\n\n  if (ciphers !== undefined && ciphers !== null)\n    validateString(ciphers\x2C `${name}.ciphers`);\n\n  // Work around an OpenSSL API quirk. cipherList is for TLSv1.2 and below\x2C\n  // cipherSuites is for TLSv1.3 (and presumably any later versions). TLSv1.3\n  // cipher suites all have a standard name format beginning with TLS_\x2C so split\n  // the ciphers and pass them to the appropriate API.\n  const {\n    cipherList\x2C\n    cipherSuites\x2C\n  } = processCiphers(ciphers\x2C `${name}.ciphers`);\n\n  context.setCipherSuites(cipherSuites);\n  context.setCiphers(cipherList);\n\n  if (cipherSuites === '' &&\n      context.getMaxProto() > TLS1_2_VERSION &&\n      context.getMinProto() < TLS1_3_VERSION) {\n    context.setMaxProto(TLS1_2_VERSION);\n  }\n\n  if (cipherList === '' &&\n      context.getMinProto() < TLS1_3_VERSION &&\n      context.getMaxProto() > TLS1_2_VERSION) {\n    context.setMinProto(TLS1_3_VERSION);\n  }\n\n  validateString(ecdhCurve\x2C `${name}.ecdhCurve`);\n  context.setECDHCurve(ecdhCurve);\n\n  if (dhparam !== undefined && dhparam !== null) {\n    validateKeyOrCertOption(`${name}.dhparam`\x2C dhparam);\n    const warning = context.setDHParam(dhparam);\n    if (warning)\n      process.emitWarning(warning\x2C 'SecurityWarning');\n  }\n\n  if (crl !== undefined && crl !== null) {\n    if (ArrayIsArray(crl)) {\n      for (const val of crl) {\n        validateKeyOrCertOption(`${name}.crl`\x2C val);\n        context.addCRL(val);\n      }\n    } else {\n      validateKeyOrCertOption(`${name}.crl`\x2C crl);\n      context.addCRL(crl);\n    }\n  }\n\n  if (sessionIdContext !== undefined && sessionIdContext !== null) {\n    validateString(sessionIdContext\x2C `${name}.sessionIdContext`);\n    context.setSessionIdContext(sessionIdContext);\n  }\n\n  if (pfx !== undefined && pfx !== null) {\n    if (ArrayIsArray(pfx)) {\n      ArrayPrototypeForEach(pfx\x2C (val) => {\n        const raw = val.buf ? val.buf : val;\n        const pass = val.passphrase || passphrase;\n        if (pass !== undefined && pass !== null) {\n          context.loadPKCS12(toBuf(raw)\x2C toBuf(pass));\n        } else {\n          context.loadPKCS12(toBuf(raw));\n        }\n      });\n    } else if (passphrase) {\n      context.loadPKCS12(toBuf(pfx)\x2C toBuf(passphrase));\n    } else {\n      context.loadPKCS12(toBuf(pfx));\n    }\n  }\n\n  if (typeof clientCertEngine === 'string') {\n    if (typeof context.setClientCertEngine !== 'function')\n      throw new ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED();\n    else\n      context.setClientCertEngine(clientCertEngine);\n  } else if (clientCertEngine !== undefined && clientCertEngine !== null) {\n    throw new ERR_INVALID_ARG_TYPE(`${name}.clientCertEngine`\x2C\n                                   ['string'\x2C 'null'\x2C 'undefined']\x2C\n                                   clientCertEngine);\n  }\n\n  if (ticketKeys !== undefined && ticketKeys !== null) {\n    if (!isArrayBufferView(ticketKeys)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        `${name}.ticketKeys`\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        ticketKeys);\n    }\n    if (ticketKeys.byteLength !== 48) {\n      throw new ERR_INVALID_ARG_VALUE(\n        `${name}.ticketKeys`\x2C\n        ticketKeys.byteLength\x2C\n        'must be exactly 48 bytes');\n    }\n    context.setTicketKeys(ticketKeys);\n  }\n\n  if (sessionTimeout !== undefined && sessionTimeout !== null) {\n    validateInt32(sessionTimeout\x2C `${name}.sessionTimeout`);\n    context.setSessionTimeout(sessionTimeout);\n  }\n}\n\nmodule.exports = {\n  configSecureContext\x2C\n};\n
code-source-info,0x29d5d5ba3436,165,0,9261,C0O0C4O9261,,
code-creation,Function,10,85500,0x29d5d5ba386e,285, node:internal/tls/secure-context:1:1,0x29d5d5ba33b0,~
code-source-info,0x29d5d5ba386e,165,0,9261,C0O0C108O25C114O41C120O65C126O90C132O112C138O136C144O306C150O306C155O306C160O204C166O248C172O274C178O368C184O368C189O345C195O466C201O466C206O411C212O428C218O446C224O520C230O520C235O509C241O623C244O623C249O623C254O578C260O598C266O9216C273O9237C279O9231C284O9260,,
code-creation,Eval,10,85667,0x29d5d5ba561e,5, node:internal/crypto/util:1:1,0x29d5d5ba5288,~
script-source,166,node:internal/crypto/util,'use strict';\n\nconst {\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypePush\x2C\n  BigInt\x2C\n  FunctionPrototypeBind\x2C\n  Number\x2C\n  ObjectKeys\x2C\n  Promise\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  getCiphers: _getCiphers\x2C\n  getCurves: _getCurves\x2C\n  getHashes: _getHashes\x2C\n  setEngine: _setEngine\x2C\n  secureHeapUsed: _secureHeapUsed\x2C\n} = internalBinding('crypto');\n\nconst { getOptionValue } = require('internal/options');\n\nconst {\n  crypto: {\n    ENGINE_METHOD_ALL\n  }\n} = internalBinding('constants');\n\nconst normalizeHashName = require('internal/crypto/hashnames');\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_CRYPTO_ENGINE_UNKNOWN\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  validateArray\x2C\n  validateNumber\x2C\n  validateString\n} = require('internal/validators');\n\nconst { Buffer } = require('buffer');\n\nconst {\n  cachedResult\x2C\n  filterDuplicateStrings\x2C\n  lazyDOMException\x2C\n} = require('internal/util');\n\nconst {\n  isArrayBufferView\x2C\n  isAnyArrayBuffer\x2C\n} = require('internal/util/types');\n\nconst kHandle = Symbol('kHandle');\nconst kKeyObject = Symbol('kKeyObject');\n\nconst lazyRequireCache = {};\n\nfunction lazyRequire(name) {\n  let ret = lazyRequireCache[name];\n  if (ret === undefined)\n    ret = lazyRequireCache[name] = require(name);\n  return ret;\n}\n\nvar defaultEncoding = 'buffer';\n\nfunction setDefaultEncoding(val) {\n  defaultEncoding = val;\n}\n\nfunction getDefaultEncoding() {\n  return defaultEncoding;\n}\n\n// This is here because many functions accepted binary strings without\n// any explicit encoding in older versions of node\x2C and we don't want\n// to break them unnecessarily.\nfunction toBuf(val\x2C encoding) {\n  if (typeof val === 'string') {\n    if (encoding === 'buffer')\n      encoding = 'utf8';\n    return Buffer.from(val\x2C encoding);\n  }\n  return val;\n}\n\nconst getCiphers = cachedResult(() => filterDuplicateStrings(_getCiphers()));\nconst getHashes = cachedResult(() => filterDuplicateStrings(_getHashes()));\nconst getCurves = cachedResult(() => filterDuplicateStrings(_getCurves()));\n\nfunction setEngine(id\x2C flags) {\n  validateString(id\x2C 'id');\n  if (flags)\n    validateNumber(flags\x2C 'flags');\n  flags = flags >>> 0;\n\n  // Use provided engine for everything by default\n  if (flags === 0)\n    flags = ENGINE_METHOD_ALL;\n\n  if (!_setEngine(id\x2C flags))\n    throw new ERR_CRYPTO_ENGINE_UNKNOWN(id);\n}\n\nconst getArrayBufferOrView = hideStackFrames((buffer\x2C name\x2C encoding) => {\n  if (isAnyArrayBuffer(buffer))\n    return buffer;\n  if (typeof buffer === 'string') {\n    if (encoding === 'buffer')\n      encoding = 'utf8';\n    return Buffer.from(buffer\x2C encoding);\n  }\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      name\x2C\n      [\n        'string'\x2C\n        'ArrayBuffer'\x2C\n        'Buffer'\x2C\n        'TypedArray'\x2C\n        'DataView'\x2C\n      ]\x2C\n      buffer\n    );\n  }\n  return buffer;\n});\n\n// The maximum buffer size that we'll support in the WebCrypto impl\nconst kMaxBufferLength = (2 ** 31) - 1;\n\n// The EC named curves that we currently support via the Web Crypto API.\nconst kNamedCurveAliases = {\n  'P-256': 'prime256v1'\x2C\n  'P-384': 'secp384r1'\x2C\n  'P-521': 'secp521r1'\x2C\n  'NODE-ED25519': 'ed25519'\x2C\n  'NODE-ED448': 'ed448'\x2C\n  'NODE-X25519': 'x25519'\x2C\n  'NODE-X448': 'x448'\x2C\n};\n\nconst kAesKeyLengths = [128\x2C 192\x2C 256];\n\n// These are the only algorithms we currently support\n// via the Web Crypto API\nconst kAlgorithms = {\n  'rsassa-pkcs1-v1_5': 'RSASSA-PKCS1-v1_5'\x2C\n  'rsa-pss': 'RSA-PSS'\x2C\n  'rsa-oaep': 'RSA-OAEP'\x2C\n  'ecdsa': 'ECDSA'\x2C\n  'ecdh': 'ECDH'\x2C\n  'aes-ctr': 'AES-CTR'\x2C\n  'aes-cbc': 'AES-CBC'\x2C\n  'aes-gcm': 'AES-GCM'\x2C\n  'aes-kw': 'AES-KW'\x2C\n  'hmac': 'HMAC'\x2C\n  'sha-1': 'SHA-1'\x2C\n  'sha-256': 'SHA-256'\x2C\n  'sha-384': 'SHA-384'\x2C\n  'sha-512': 'SHA-512'\x2C\n  'hkdf': 'HKDF'\x2C\n  'pbkdf2': 'PBKDF2'\x2C\n  // Following here are Node.js specific extensions. All\n  // should be prefixed with 'node-'\n  'node-dsa': 'NODE-DSA'\x2C\n  'node-dh': 'NODE-DH'\x2C\n  'node-scrypt': 'NODE-SCRYPT'\x2C\n  'node-ed25519': 'NODE-ED25519'\x2C\n  'node-ed448': 'NODE-ED448'\x2C\n};\nconst kAlgorithmsKeys = ObjectKeys(kAlgorithms);\n\n// These are the only export and import formats we currently\n// support via the Web Crypto API\nconst kExportFormats = [\n  'raw'\x2C\n  'pkcs8'\x2C\n  'spki'\x2C\n  'jwk'\x2C\n  'node.keyObject'];\n\n// These are the only hash algorithms we currently support via\n// the Web Crypto API.\nconst kHashTypes = [\n  'SHA-1'\x2C\n  'SHA-256'\x2C\n  'SHA-384'\x2C\n  'SHA-512'\x2C\n];\n\nfunction validateMaxBufferLength(data\x2C name) {\n  if (data.byteLength > kMaxBufferLength) {\n    throw lazyDOMException(\n      `${name} must be less than ${kMaxBufferLength + 1} bits`\x2C\n      'OperationError');\n  }\n}\n\nfunction normalizeAlgorithm(algorithm\x2C label = 'algorithm') {\n  if (algorithm != null) {\n    if (typeof algorithm === 'string')\n      algorithm = { name: algorithm };\n\n    if (typeof algorithm === 'object') {\n      const { name } = algorithm;\n      let hash;\n      if (typeof name !== 'string' ||\n          !ArrayPrototypeIncludes(\n            kAlgorithmsKeys\x2C\n            StringPrototypeToLowerCase(name))) {\n        throw lazyDOMException('Unrecognized name.'\x2C 'NotSupportedError');\n      }\n      if (algorithm.hash !== undefined) {\n        hash = normalizeAlgorithm(algorithm.hash\x2C 'algorithm.hash');\n        if (!ArrayPrototypeIncludes(kHashTypes\x2C hash.name))\n          throw lazyDOMException('Unrecognized name.'\x2C 'NotSupportedError');\n      }\n      return {\n        ...algorithm\x2C\n        name: kAlgorithms[StringPrototypeToLowerCase(name)]\x2C\n        hash\x2C\n      };\n    }\n  }\n  throw lazyDOMException('Unrecognized name.'\x2C 'NotSupportedError');\n}\n\nfunction hasAnyNotIn(set\x2C checks) {\n  for (const s of set)\n    if (!ArrayPrototypeIncludes(checks\x2C s))\n      return true;\n  return false;\n}\n\nfunction validateBitLength(length\x2C name\x2C required = false) {\n  if (length !== undefined || required) {\n    validateNumber(length\x2C name);\n    if (length < 0)\n      throw new ERR_OUT_OF_RANGE(name\x2C '> 0');\n    if (length % 8) {\n      throw new ERR_INVALID_ARG_VALUE(\n        name\x2C\n        length\x2C\n        'must be a multiple of 8');\n    }\n  }\n}\n\nfunction validateByteLength(buf\x2C name\x2C target) {\n  if (buf.byteLength !== target) {\n    throw lazyDOMException(\n      `${name} must contain exactly ${target} bytes`\x2C\n      'OperationError');\n  }\n}\n\nconst validateByteSource = hideStackFrames((val\x2C name) => {\n  val = toBuf(val);\n\n  if (isAnyArrayBuffer(val) || isArrayBufferView(val))\n    return;\n\n  throw new ERR_INVALID_ARG_TYPE(\n    name\x2C\n    [\n      'string'\x2C\n      'ArrayBuffer'\x2C\n      'TypedArray'\x2C\n      'DataView'\x2C\n      'Buffer'\x2C\n    ]\x2C\n    val);\n});\n\nfunction onDone(resolve\x2C reject\x2C err\x2C result) {\n  if (err) return reject(err);\n  resolve(result);\n}\n\nfunction jobPromise(job) {\n  return new Promise((resolve\x2C reject) => {\n    job.ondone = FunctionPrototypeBind(onDone\x2C job\x2C resolve\x2C reject);\n    job.run();\n  });\n}\n\n// In WebCrypto\x2C the publicExponent option in RSA is represented as a\n// WebIDL "BigInteger"... that is\x2C a Uint8Array that allows an arbitrary\n// number of leading zero bits. Our conventional APIs for reading\n// an unsigned int from a Buffer are not adequate. The implementation\n// here is adapted from the chromium implementation here:\n// https://github.com/chromium/chromium/blob/HEAD/third_party/blink/public/platform/web_crypto_algorithm_params.h\x2C but ported to JavaScript\n// Returns undefined if the conversion was unsuccessful.\nfunction bigIntArrayToUnsignedInt(input) {\n  let result = 0;\n\n  for (let n = 0; n < input.length; ++n) {\n    const n_reversed = input.length - n - 1;\n    if (n_reversed >= 4 && input[n])\n      return;  // Too large\n    result |= input[n] << 8 * n_reversed;\n  }\n\n  return result;\n}\n\nfunction bigIntArrayToUnsignedBigInt(input) {\n  let result = 0n;\n\n  for (let n = 0; n < input.length; ++n) {\n    const n_reversed = input.length - n - 1;\n    result |= BigInt(input[n]) << 8n * BigInt(n_reversed);\n  }\n\n  return result;\n}\n\nfunction getStringOption(options\x2C key) {\n  let value;\n  if (options && (value = options[key]) != null)\n    validateString(value\x2C `options.${key}`);\n  return value;\n}\n\nfunction getUsagesUnion(usageSet\x2C ...usages) {\n  const newset = [];\n  for (let n = 0; n < usages.length; n++) {\n    if (usageSet.has(usages[n]))\n      ArrayPrototypePush(newset\x2C usages[n]);\n  }\n  return newset;\n}\n\nfunction getHashLength(name) {\n  switch (name) {\n    case 'SHA-1': return 160;\n    case 'SHA-256': return 256;\n    case 'SHA-384': return 384;\n    case 'SHA-512': return 512;\n  }\n}\n\nconst kKeyOps = {\n  sign: 1\x2C\n  verify: 2\x2C\n  encrypt: 3\x2C\n  decrypt: 4\x2C\n  wrapKey: 5\x2C\n  unwrapKey: 6\x2C\n  deriveKey: 7\x2C\n  deriveBits: 8\x2C\n};\n\nfunction validateKeyOps(keyOps\x2C usagesSet) {\n  if (keyOps === undefined) return;\n  validateArray(keyOps\x2C 'keyData.key_ops');\n  let flags = 0;\n  for (let n = 0; n < keyOps.length; n++) {\n    const op = keyOps[n];\n    const op_flag = kKeyOps[op];\n    // Skipping unknown key ops\n    if (op_flag === undefined)\n      continue;\n    // Have we seen it already? if so\x2C error\n    if (flags & (1 << op_flag))\n      throw lazyDOMException('Duplicate key operation'\x2C 'DataError');\n    flags |= (1 << op_flag);\n\n    // TODO(@jasnell): RFC7517 section 4.3 strong recommends validating\n    // key usage combinations. Specifically\x2C it says that unrelated key\n    // ops SHOULD NOT be used together. We're not yet validating that here.\n  }\n\n  if (usagesSet !== undefined) {\n    for (const use of usagesSet) {\n      if (!ArrayPrototypeIncludes(keyOps\x2C use)) {\n        throw lazyDOMException(\n          'Key operations and usage mismatch'\x2C\n          'DataError');\n      }\n    }\n  }\n}\n\nfunction secureHeapUsed() {\n  const val = _secureHeapUsed();\n  if (val === undefined)\n    return { total: 0\x2C used: 0\x2C utilization: 0\x2C min: 0 };\n  const used = Number(_secureHeapUsed());\n  const total = Number(getOptionValue('--secure-heap'));\n  const min = Number(getOptionValue('--secure-heap-min'));\n  const utilization = used / total;\n  return { total\x2C used\x2C utilization\x2C min };\n}\n\nmodule.exports = {\n  getArrayBufferOrView\x2C\n  getCiphers\x2C\n  getCurves\x2C\n  getDefaultEncoding\x2C\n  getHashes\x2C\n  kHandle\x2C\n  kKeyObject\x2C\n  setDefaultEncoding\x2C\n  setEngine\x2C\n  toBuf\x2C\n\n  kHashTypes\x2C\n  kNamedCurveAliases\x2C\n  kAesKeyLengths\x2C\n  kExportFormats\x2C\n  normalizeAlgorithm\x2C\n  normalizeHashName\x2C\n  hasAnyNotIn\x2C\n  validateBitLength\x2C\n  validateByteLength\x2C\n  validateByteSource\x2C\n  validateKeyOps\x2C\n  jobPromise\x2C\n  lazyRequire\x2C\n  validateMaxBufferLength\x2C\n  bigIntArrayToUnsignedBigInt\x2C\n  bigIntArrayToUnsignedInt\x2C\n  getStringOption\x2C\n  getUsagesUnion\x2C\n  getHashLength\x2C\n  secureHeapUsed\x2C\n};\n
code-source-info,0x29d5d5ba561e,166,0,10573,C0O0C4O10573,,
code-creation,Function,10,86084,0x29d5d5ba667e,848, node:internal/crypto/util:1:1,0x29d5d5ba5598,~
code-source-info,0x29d5d5ba667e,166,0,10573,C0O0C215O25C221O51C227O73C233O83C239O108C245O118C250O132C256O143C262O173C267O348C271O348C277O221C283O247C289O272C295O297C301O327C307O403C315O403C321O384C327O483C331O483C337O483C343O457C349O540C357O540C362O731C370O731C376O589C387O621C393O652C399O678C405O705C411O824C419O824C425O770C431O787C437O805C443O876C451O876C457O865C463O970C471O970C477O906C482O922C488O948C494O1050C502O1050C508O1007C514O1028C520O1099C524O1099C529O1137C533O1137C538O1185C539O1185C541O1369C543O1369C545O1877C551O1877C556O1954C562O1954C567O2030C573O2030C578O2431C584O2431C589O3007C595O3007C597O3123C602O3329C608O3447C612O3447C614O4092C618O4092C622O4092C624O4236C630O4404C634O4404C636O6337C642O6337C648O8521C652O8521C654O9995C662O10016C668O10040C674O10054C680O10067C686O10089C692O10102C698O10113C704O10127C710O10149C716O10162C722O10172C728O10186C734O10208C740O10226C746O10244C752O10266C758O10287C764O10302C770O10323C776O10345C782O10367C788O10385C794O10399C800O10414C806O10441C812O10472C818O10500C824O10519C830O10537C836O10554C842O10010C847O10572,,
tick,0x1bfcd791c,86167,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x29d5d5ba3954,0x105108d28,0x10510894c,0x29d5d5ba2620,0x105108d28,0x10510894c,0x29d5d5b915ec,0x105108d28,0x10510894c,0x29d5d5b8ec0d,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89de,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,86250,0x29d5d5ba8356,5, node:internal/crypto/hashnames:1:1,0x29d5d5ba81e0,~
script-source,167,node:internal/crypto/hashnames,'use strict';\n\nconst {\n  ObjectKeys\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst kHashContextNode = 1;\nconst kHashContextWebCrypto = 2;\nconst kHashContextJwkRsa = 3;\nconst kHashContextJwkRsaPss = 4;\nconst kHashContextJwkRsaOaep = 5;\nconst kHashContextJwkHmac = 6;\nconst kHashContextJwkDsa = 7;\n\n// WebCrypto and JWK use a bunch of different names for the\n// standard set of SHA-* digest algorithms... which is ... fun.\n// Here we provide a utility for mapping between them in order\n// make it easier in the code.\n\nconst kHashNames = {\n  sha1: {\n    [kHashContextNode]: 'sha1'\x2C\n    [kHashContextWebCrypto]: 'SHA-1'\x2C\n    [kHashContextJwkRsa]: 'RS1'\x2C\n    [kHashContextJwkRsaPss]: 'PS1'\x2C\n    [kHashContextJwkRsaOaep]: 'RSA-OAEP'\x2C\n    [kHashContextJwkHmac]: 'HS1'\x2C\n    [kHashContextJwkDsa]: 'NODE-DSA-SHA-1'\x2C\n  }\x2C\n  sha256: {\n    [kHashContextNode]: 'sha256'\x2C\n    [kHashContextWebCrypto]: 'SHA-256'\x2C\n    [kHashContextJwkRsa]: 'RS256'\x2C\n    [kHashContextJwkRsaPss]: 'PS256'\x2C\n    [kHashContextJwkRsaOaep]: 'RSA-OAEP-256'\x2C\n    [kHashContextJwkHmac]: 'HS256'\x2C\n    [kHashContextJwkDsa]: 'NODE-DSA-SHA-256'\x2C\n  }\x2C\n  sha384: {\n    [kHashContextNode]: 'sha384'\x2C\n    [kHashContextWebCrypto]: 'SHA-384'\x2C\n    [kHashContextJwkRsa]: 'RS384'\x2C\n    [kHashContextJwkRsaPss]: 'PS384'\x2C\n    [kHashContextJwkRsaOaep]: 'RSA-OAEP-384'\x2C\n    [kHashContextJwkHmac]: 'HS384'\x2C\n    [kHashContextJwkDsa]: 'NODE-DSA-SHA-384'\x2C\n  }\x2C\n  sha512: {\n    [kHashContextNode]: 'sha512'\x2C\n    [kHashContextWebCrypto]: 'SHA-512'\x2C\n    [kHashContextJwkRsa]: 'RS512'\x2C\n    [kHashContextJwkRsaPss]: 'PS512'\x2C\n    [kHashContextJwkRsaOaep]: 'RSA-OAEP-512'\x2C\n    [kHashContextJwkHmac]: 'HS512'\x2C\n    [kHashContextJwkDsa]: 'NODE-DSA-SHA-512'\x2C\n  }\n};\n\n{\n  // Index the aliases\n  const keys = ObjectKeys(kHashNames);\n  for (let n = 0; n < keys.length; n++) {\n    const contexts = ObjectKeys(kHashNames[keys[n]]);\n    for (let i = 0; i < contexts.length; i++) {\n      const alias =\n        StringPrototypeToLowerCase(kHashNames[keys[n]][contexts[i]]);\n      if (kHashNames[alias] === undefined)\n        kHashNames[alias] = kHashNames[keys[n]];\n    }\n  }\n}\n\nfunction normalizeHashName(name\x2C context = kHashContextNode) {\n  if (typeof name !== 'string')\n    return name;\n  name = StringPrototypeToLowerCase(name);\n  const alias = kHashNames[name] && kHashNames[name][context];\n  return alias || name;\n}\n\nnormalizeHashName.kContextNode = kHashContextNode;\nnormalizeHashName.kContextWebCrypto = kHashContextWebCrypto;\nnormalizeHashName.kContextJwkRsa = kHashContextJwkRsa;\nnormalizeHashName.kContextJwkRsaPss = kHashContextJwkRsaPss;\nnormalizeHashName.kContextJwkRsaOaep = kHashContextJwkRsaOaep;\nnormalizeHashName.kContextJwkHmac = kHashContextJwkHmac;\nnormalizeHashName.kContextJwkDsa = kHashContextJwkDsa;\n\nmodule.exports = normalizeHashName;\n
code-source-info,0x29d5d5ba8356,167,0,2786,C0O0C4O2786,,
code-creation,Function,10,86375,0x29d5d5ba864e,584, node:internal/crypto/hashnames:1:1,0x29d5d5ba82d0,~
code-source-info,0x29d5d5ba864e,167,0,2786,C0O0C19O25C24O39C30O110C32O110C34O143C37O173C40O206C43O240C46O271C49O301C52O543C57O553C64O560C68O579C75O592C79O616C86O630C90O651C97O663C101O687C108O699C112O724C119O741C123O763C130O775C134O796C145O829C152O836C156O855C163O870C167O894C174O910C178O931C185O945C189O969C196O983C200O1008C207O1029C211O1051C218O1065C222O1086C233O1121C240O1128C244O1147C251O1162C255O1186C262O1202C266O1223C273O1237C277O1261C284O1275C288O1300C295O1321C299O1343C306O1357C310O1378C321O1413C328O1420C332O1439C339O1454C343O1478C350O1494C354O1515C361O1529C365O1553C372O1567C376O1592C383O1613C387O1635C394O1649C398O1670C411O543C413O1738C416O1738C421O1777C423O1789C427O1782C432O1825C437O1851C440O1846C444O1825C449O1875C451O1891C455O1880C460O1934C468O1976C471O1971C477O1989C480O1980C484O1934C489O2002C494O2016C499O2047C508O2082C511O2077C514O2065C518O1900C523O1862C526O1798C531O1764C534O2346C536O2377C540O2397C542O2433C546O2458C548O2491C552O2513C554O2549C558O2574C560O2611C564O2637C566O2671C570O2694C572O2727C576O2750C578O2765C583O2785,,
code-creation,LazyCompile,10,86459,0x29d5d5ba921e,20,cachedResult node:internal/util:241:22,0x232faba02008,~
code-source-info,0x29d5d5ba921e,16,6718,6853,C0O6718C12O6731C13O6731C15O6741C19O6851,,
code-creation,Eval,10,86542,0x29d5d5ba9766,5, node:internal/tls/parse-cert-string:1:1,0x29d5d5ba95b0,~
script-source,168,node:internal/tls/parse-cert-string,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePush\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  ObjectCreate\x2C\n} = primordials;\n\n// Example:\n// C=US\\nST=CA\\nL=SF\\nO=Joyent\\nOU=Node.js\\nCN=ca1\\nemailAddress=ry@clouds.org\nfunction parseCertString(s) {\n  const out = ObjectCreate(null);\n  ArrayPrototypeForEach(StringPrototypeSplit(s\x2C '\\n')\x2C (part) => {\n    const sepIndex = StringPrototypeIndexOf(part\x2C '=');\n    if (sepIndex > 0) {\n      const key = StringPrototypeSlice(part\x2C 0\x2C sepIndex);\n      const value = StringPrototypeSlice(part\x2C sepIndex + 1);\n      if (key in out) {\n        if (!ArrayIsArray(out[key])) {\n          out[key] = [out[key]];\n        }\n        ArrayPrototypePush(out[key]\x2C value);\n      } else {\n        out[key] = value;\n      }\n    }\n  });\n  return out;\n}\n\nexports.parseCertString = parseCertString;\n
code-source-info,0x29d5d5ba9766,168,0,889,C0O0C4O889,,
code-creation,Function,10,86584,0x29d5d5ba987e,81, node:internal/tls/parse-cert-string:1:1,0x29d5d5ba96e0,~
code-source-info,0x29d5d5ba987e,168,0,889,C0O0C31O25C37O41C43O66C49O88C55O114C61O138C67O162C73O846C75O870C80O888,,
code-creation,Eval,10,87042,0x29d5d5bab4ee,5, node:_tls_wrap:1:1,0x29d5d5baad58,~
script-source,169,node:_tls_wrap,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototype\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  RegExp\x2C\n  RegExpPrototypeTest\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n} = primordials;\n\nconst {\n  assertCrypto\x2C\n  deprecate\n} = require('internal/util');\n\nassertCrypto();\n\nconst { setImmediate } = require('timers');\nconst assert = require('internal/assert');\nconst crypto = require('crypto');\nconst EE = require('events');\nconst net = require('net');\nconst tls = require('tls');\nconst common = require('_tls_common');\nconst JSStreamSocket = require('internal/js_stream_socket');\nconst { Buffer } = require('buffer');\nlet debug = require('internal/util/debuglog').debuglog('tls'\x2C (fn) => {\n  debug = fn;\n});\nconst { TCP\x2C constants: TCPConstants } = internalBinding('tcp_wrap');\nconst tls_wrap = internalBinding('tls_wrap');\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\nconst { owner_symbol } = require('internal/async_hooks').symbols;\nconst { isArrayBufferView } = require('internal/util/types');\nconst { SecureContext: NativeSecureContext } = internalBinding('crypto');\nconst { connResetException\x2C codes } = require('internal/errors');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_MULTIPLE_CALLBACK\x2C\n  ERR_SOCKET_CLOSED\x2C\n  ERR_TLS_DH_PARAM_SIZE\x2C\n  ERR_TLS_HANDSHAKE_TIMEOUT\x2C\n  ERR_TLS_INVALID_CONTEXT\x2C\n  ERR_TLS_RENEGOTIATION_DISABLED\x2C\n  ERR_TLS_REQUIRED_SERVER_NAME\x2C\n  ERR_TLS_SESSION_ATTACK\x2C\n  ERR_TLS_SNI_FROM_SERVER\x2C\n  ERR_TLS_INVALID_STATE\n} = codes;\nconst { onpskexchange: kOnPskExchange } = internalBinding('symbols');\nconst {\n  getOptionValue\x2C\n  getAllowUnauthorized\x2C\n} = require('internal/options');\nconst {\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateCallback\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateNumber\x2C\n  validateObject\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst {\n  InternalX509Certificate\n} = require('internal/crypto/x509');\nconst traceTls = getOptionValue('--trace-tls');\nconst tlsKeylog = getOptionValue('--tls-keylog');\nconst { appendFile } = require('fs');\nconst kConnectOptions = Symbol('connect-options');\nconst kDisableRenegotiation = Symbol('disable-renegotiation');\nconst kErrorEmitted = Symbol('error-emitted');\nconst kHandshakeTimeout = Symbol('handshake-timeout');\nconst kRes = Symbol('res');\nconst kSNICallback = Symbol('snicallback');\nconst kEnableTrace = Symbol('enableTrace');\nconst kPskCallback = Symbol('pskcallback');\nconst kPskIdentityHint = Symbol('pskidentityhint');\nconst kPendingSession = Symbol('pendingSession');\nconst kIsVerified = Symbol('verified');\n\nconst noop = FunctionPrototype;\n\nlet ipServernameWarned = false;\nlet tlsTracingWarned = false;\n\n// Server side times how long a handshake is taking to protect against slow\n// handshakes being used for DoS.\nfunction onhandshakestart(now) {\n  debug('server onhandshakestart');\n\n  const { lastHandshakeTime } = this;\n  assert(now >= lastHandshakeTime\x2C\n         `now (${now}) < lastHandshakeTime (${lastHandshakeTime})`);\n\n  this.lastHandshakeTime = now;\n\n  // If this is the first handshake we can skip the rest of the checks.\n  if (lastHandshakeTime === 0)\n    return;\n\n  if ((now - lastHandshakeTime) >= tls.CLIENT_RENEG_WINDOW * 1000)\n    this.handshakes = 1;\n  else\n    this.handshakes++;\n\n  const owner = this[owner_symbol];\n\n  assert(owner._tlsOptions.isServer);\n\n  if (this.handshakes > tls.CLIENT_RENEG_LIMIT) {\n    owner._emitTLSError(new ERR_TLS_SESSION_ATTACK());\n    return;\n  }\n\n  if (owner[kDisableRenegotiation])\n    owner._emitTLSError(new ERR_TLS_RENEGOTIATION_DISABLED());\n}\n\nfunction onhandshakedone() {\n  debug('server onhandshakedone');\n\n  const owner = this[owner_symbol];\n  assert(owner._tlsOptions.isServer);\n\n  // `newSession` callback wasn't called yet\n  if (owner._newSessionPending) {\n    owner._securePending = true;\n    return;\n  }\n\n  owner._finishInit();\n}\n\n\nfunction loadSession(hello) {\n  debug('server onclienthello'\x2C\n        'sessionid.len'\x2C hello.sessionId.length\x2C\n        'ticket?'\x2C hello.tlsTicket\n  );\n  const owner = this[owner_symbol];\n\n  let once = false;\n  function onSession(err\x2C session) {\n    debug('server resumeSession callback(err %j\x2C sess? %s)'\x2C err\x2C !!session);\n    if (once)\n      return owner.destroy(new ERR_MULTIPLE_CALLBACK());\n    once = true;\n\n    if (err)\n      return owner.destroy(err);\n\n    if (owner._handle === null)\n      return owner.destroy(new ERR_SOCKET_CLOSED());\n\n    owner._handle.loadSession(session);\n    // Session is loaded. End the parser to allow handshaking to continue.\n    owner._handle.endParser();\n  }\n\n  if (hello.sessionId.length <= 0 ||\n      hello.tlsTicket ||\n      (owner.server &&\n      !owner.server.emit('resumeSession'\x2C hello.sessionId\x2C onSession))) {\n    // Sessions without identifiers can't be resumed.\n    // Sessions with tickets can be resumed directly from the ticket\x2C no server\n    // session storage is necessary.\n    // Without a call to a resumeSession listener\x2C a session will never be\n    // loaded\x2C so end the parser to allow handshaking to continue.\n    owner._handle.endParser();\n  }\n}\n\n\nfunction loadSNI(info) {\n  const owner = this[owner_symbol];\n  const servername = info.servername;\n  if (!servername || !owner._SNICallback)\n    return requestOCSP(owner\x2C info);\n\n  let once = false;\n  owner._SNICallback(servername\x2C (err\x2C context) => {\n    if (once)\n      return owner.destroy(new ERR_MULTIPLE_CALLBACK());\n    once = true;\n\n    if (err)\n      return owner.destroy(err);\n\n    if (owner._handle === null)\n      return owner.destroy(new ERR_SOCKET_CLOSED());\n\n    // TODO(indutny): eventually disallow raw `SecureContext`\n    if (context)\n      owner._handle.sni_context = context.context || context;\n\n    requestOCSP(owner\x2C info);\n  });\n}\n\n\nfunction requestOCSP(socket\x2C info) {\n  if (!info.OCSPRequest || !socket.server)\n    return requestOCSPDone(socket);\n\n  let ctx = socket._handle.sni_context;\n\n  if (!ctx) {\n    ctx = socket.server._sharedCreds;\n\n    // TLS socket is using a `net.Server` instead of a tls.TLSServer.\n    // Some TLS properties like `server._sharedCreds` will not be present\n    if (!ctx)\n      return requestOCSPDone(socket);\n  }\n\n  // TODO(indutny): eventually disallow raw `SecureContext`\n  if (ctx.context)\n    ctx = ctx.context;\n\n  if (socket.server.listenerCount('OCSPRequest') === 0) {\n    return requestOCSPDone(socket);\n  }\n\n  let once = false;\n  const onOCSP = (err\x2C response) => {\n    debug('server OCSPRequest done'\x2C 'handle?'\x2C !!socket._handle\x2C 'once?'\x2C once\x2C\n          'response?'\x2C !!response\x2C 'err?'\x2C err);\n    if (once)\n      return socket.destroy(new ERR_MULTIPLE_CALLBACK());\n    once = true;\n\n    if (err)\n      return socket.destroy(err);\n\n    if (socket._handle === null)\n      return socket.destroy(new ERR_SOCKET_CLOSED());\n\n    if (response)\n      socket._handle.setOCSPResponse(response);\n    requestOCSPDone(socket);\n  };\n\n  debug('server oncertcb emit OCSPRequest');\n  socket.server.emit('OCSPRequest'\x2C\n                     ctx.getCertificate()\x2C\n                     ctx.getIssuer()\x2C\n                     onOCSP);\n}\n\nfunction requestOCSPDone(socket) {\n  debug('server certcb done');\n  try {\n    socket._handle.certCbDone();\n  } catch (e) {\n    debug('server certcb done errored'\x2C e);\n    socket.destroy(e);\n  }\n}\n\nfunction onnewsessionclient(sessionId\x2C session) {\n  debug('client emit session');\n  const owner = this[owner_symbol];\n  if (owner[kIsVerified]) {\n    owner.emit('session'\x2C session);\n  } else {\n    owner[kPendingSession] = session;\n  }\n}\n\nfunction onnewsession(sessionId\x2C session) {\n  debug('onnewsession');\n  const owner = this[owner_symbol];\n\n  // TODO(@sam-github) no server to emit the event on\x2C but handshake won't\n  // continue unless newSessionDone() is called\x2C should it be\x2C or is that\n  // situation unreachable\x2C or only occurring during shutdown?\n  if (!owner.server)\n    return;\n\n  let once = false;\n  const done = () => {\n    debug('onnewsession done');\n    if (once)\n      return;\n    once = true;\n\n    if (owner._handle === null)\n      return owner.destroy(new ERR_SOCKET_CLOSED());\n\n    this.newSessionDone();\n\n    owner._newSessionPending = false;\n    if (owner._securePending)\n      owner._finishInit();\n    owner._securePending = false;\n  };\n\n  owner._newSessionPending = true;\n  if (!owner.server.emit('newSession'\x2C sessionId\x2C session\x2C done))\n    done();\n}\n\nfunction onPskServerCallback(identity\x2C maxPskLen) {\n  const owner = this[owner_symbol];\n  const ret = owner[kPskCallback](owner\x2C identity);\n  if (ret == null)\n    return undefined;\n\n  let psk;\n  if (isArrayBufferView(ret)) {\n    psk = ret;\n  } else {\n    if (typeof ret !== 'object') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'ret'\x2C\n        ['Object'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        ret\n      );\n    }\n    psk = ret.psk;\n    validateBuffer(psk\x2C 'psk');\n  }\n\n  if (psk.length > maxPskLen) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'psk'\x2C\n      psk\x2C\n      `Pre-shared key exceeds ${maxPskLen} bytes`\n    );\n  }\n\n  return psk;\n}\n\nfunction onPskClientCallback(hint\x2C maxPskLen\x2C maxIdentityLen) {\n  const owner = this[owner_symbol];\n  const ret = owner[kPskCallback](hint);\n  if (ret == null)\n    return undefined;\n\n  validateObject(ret\x2C 'ret');\n\n  validateBuffer(ret.psk\x2C 'psk');\n  if (ret.psk.length > maxPskLen) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'psk'\x2C\n      ret.psk\x2C\n      `Pre-shared key exceeds ${maxPskLen} bytes`\n    );\n  }\n\n  validateString(ret.identity\x2C 'identity');\n  if (Buffer.byteLength(ret.identity) > maxIdentityLen) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'identity'\x2C\n      ret.identity\x2C\n      `PSK identity exceeds ${maxIdentityLen} bytes`\n    );\n  }\n\n  return { psk: ret.psk\x2C identity: ret.identity };\n}\n\nfunction onkeylog(line) {\n  debug('onkeylog');\n  this[owner_symbol].emit('keylog'\x2C line);\n}\n\nfunction onocspresponse(resp) {\n  debug('client onocspresponse');\n  this[owner_symbol].emit('OCSPResponse'\x2C resp);\n}\n\nfunction onerror(err) {\n  const owner = this[owner_symbol];\n  debug('%s onerror %s had? %j'\x2C\n        (typeof owner._tlsOptions === 'object' && owner._tlsOptions !== null) ?\n          owner._tlsOptions.isServer ? 'server' : 'client' :\n          'unknown'\x2C\n        err\x2C owner._hadError);\n\n  if (owner._hadError)\n    return;\n\n  owner._hadError = true;\n\n  // Destroy socket if error happened before handshake's finish\n  if (!owner._secureEstablished) {\n    // When handshake fails control is not yet released\x2C\n    // so self._tlsError will return null instead of actual error\n    owner.destroy(err);\n  } else if (owner._tlsOptions?.isServer &&\n             owner._rejectUnauthorized &&\n             RegExpPrototypeTest(/peer did not return a certificate/\x2C\n                                 err.message)) {\n    // Ignore server's authorization errors\n    owner.destroy();\n  } else {\n    // Emit error\n    owner._emitTLSError(err);\n  }\n}\n\n// Used by both client and server TLSSockets to start data flowing from _handle\x2C\n// read(0) causes a StreamBase::ReadStart\x2C via Socket._read.\nfunction initRead(tlsSocket\x2C socket) {\n  debug('%s initRead'\x2C\n        tlsSocket._tlsOptions.isServer ? 'server' : 'client'\x2C\n        'handle?'\x2C !!tlsSocket._handle\x2C\n        'buffered?'\x2C !!socket && socket.readableLength\n  );\n  // If we were destroyed already don't bother reading\n  if (!tlsSocket._handle)\n    return;\n\n  // Socket already has some buffered data - emulate receiving it\n  if (socket && socket.readableLength) {\n    let buf;\n    while ((buf = socket.read()) !== null)\n      tlsSocket._handle.receive(buf);\n  }\n\n  tlsSocket.read(0);\n}\n\n/**\n * Provides a wrap of socket stream to do encrypted communication.\n */\n\nfunction TLSSocket(socket\x2C opts) {\n  const tlsOptions = { ...opts };\n  let enableTrace = tlsOptions.enableTrace;\n\n  if (enableTrace == null) {\n    enableTrace = traceTls;\n\n    if (enableTrace && !tlsTracingWarned) {\n      tlsTracingWarned = true;\n      process.emitWarning('Enabling --trace-tls can expose sensitive data in ' +\n                          'the resulting log.');\n    }\n  } else {\n    validateBoolean(enableTrace\x2C 'options.enableTrace');\n  }\n\n  if (tlsOptions.ALPNProtocols)\n    tls.convertALPNProtocols(tlsOptions.ALPNProtocols\x2C tlsOptions);\n\n  this._tlsOptions = tlsOptions;\n  this._secureEstablished = false;\n  this._securePending = false;\n  this._newSessionPending = false;\n  this._controlReleased = false;\n  this.secureConnecting = true;\n  this._SNICallback = null;\n  this.servername = null;\n  this.alpnProtocol = null;\n  this.authorized = false;\n  this.authorizationError = null;\n  this[kRes] = null;\n  this[kIsVerified] = false;\n  this[kPendingSession] = null;\n\n  let wrap;\n  if ((socket instanceof net.Socket && socket._handle) || !socket) {\n    // 1. connected socket\n    // 2. no socket\x2C one will be created with net.Socket().connect\n    wrap = socket;\n  } else {\n    // 3. socket has no handle so it is js not c++\n    // 4. unconnected sockets are wrapped\n    // TLS expects to interact from C++ with a net.Socket that has a C++ stream\n    // handle\x2C but a JS stream doesn't have one. Wrap it up to make it look like\n    // a socket.\n    wrap = new JSStreamSocket(socket);\n  }\n\n  // Just a documented property to make secure sockets\n  // distinguishable from regular ones.\n  this.encrypted = true;\n\n  ReflectApply(net.Socket\x2C this\x2C [{\n    handle: this._wrapHandle(wrap)\x2C\n    allowHalfOpen: socket ? socket.allowHalfOpen : tlsOptions.allowHalfOpen\x2C\n    pauseOnCreate: tlsOptions.pauseOnConnect\x2C\n    manualStart: true\x2C\n    highWaterMark: tlsOptions.highWaterMark\x2C\n    onread: !socket ? tlsOptions.onread : null\x2C\n    signal: tlsOptions.signal\x2C\n  }]);\n\n  // Proxy for API compatibility\n  this.ssl = this._handle;  // C++ TLSWrap object\n\n  this.on('error'\x2C this._tlsError);\n\n  this._init(socket\x2C wrap);\n\n  if (enableTrace && this._handle)\n    this._handle.enableTrace();\n\n  // Read on next tick so the caller has a chance to setup listeners\n  process.nextTick(initRead\x2C this\x2C socket);\n}\nObjectSetPrototypeOf(TLSSocket.prototype\x2C net.Socket.prototype);\nObjectSetPrototypeOf(TLSSocket\x2C net.Socket);\nexports.TLSSocket = TLSSocket;\n\nconst proxiedMethods = [\n  'ref'\x2C 'unref'\x2C 'open'\x2C 'bind'\x2C 'listen'\x2C 'connect'\x2C 'bind6'\x2C\n  'connect6'\x2C 'getsockname'\x2C 'getpeername'\x2C 'setNoDelay'\x2C 'setKeepAlive'\x2C\n  'setSimultaneousAccepts'\x2C 'setBlocking'\x2C\n\n  // PipeWrap\n  'setPendingInstances'\x2C\n];\n\n// Proxy HandleWrap\x2C PipeWrap and TCPWrap methods\nfunction makeMethodProxy(name) {\n  return function methodProxy(...args) {\n    if (this._parent[name])\n      return ReflectApply(this._parent[name]\x2C this._parent\x2C args);\n  };\n}\nfor (const proxiedMethod of proxiedMethods) {\n  tls_wrap.TLSWrap.prototype[proxiedMethod] =\n    makeMethodProxy(proxiedMethod);\n}\n\ntls_wrap.TLSWrap.prototype.close = function close(cb) {\n  let ssl;\n  if (this[owner_symbol]) {\n    ssl = this[owner_symbol].ssl;\n    this[owner_symbol].ssl = null;\n  }\n\n  // Invoke `destroySSL` on close to clean up possibly pending write requests\n  // that may self-reference TLSWrap\x2C leading to leak\n  const done = () => {\n    if (ssl) {\n      ssl.destroySSL();\n      if (ssl._secureContext.singleUse) {\n        ssl._secureContext.context.close();\n        ssl._secureContext.context = null;\n      }\n    }\n    if (cb)\n      cb();\n  };\n\n  if (this._parentWrap && this._parentWrap._handle === this._parent) {\n    this._parentWrap.once('close'\x2C done);\n    return this._parentWrap.destroy();\n  }\n  return this._parent.close(done);\n};\n\nTLSSocket.prototype.disableRenegotiation = function disableRenegotiation() {\n  this[kDisableRenegotiation] = true;\n};\n\nTLSSocket.prototype._wrapHandle = function(wrap) {\n  let handle;\n\n  if (wrap)\n    handle = wrap._handle;\n\n  const options = this._tlsOptions;\n  if (!handle) {\n    handle = options.pipe ?\n      new Pipe(PipeConstants.SOCKET) :\n      new TCP(TCPConstants.SOCKET);\n    handle[owner_symbol] = this;\n  }\n\n  // Wrap socket's handle\n  const context = options.secureContext ||\n                  options.credentials ||\n                  tls.createSecureContext(options);\n  assert(handle.isStreamBase\x2C 'handle must be a StreamBase');\n  if (!(context.context instanceof NativeSecureContext)) {\n    throw new ERR_TLS_INVALID_CONTEXT('context');\n  }\n  const res = tls_wrap.wrap(handle\x2C context.context\x2C !!options.isServer);\n  res._parent = handle;  // C++ "wrap" object: TCPWrap\x2C JSStream\x2C ...\n  res._parentWrap = wrap;  // JS object: net.Socket\x2C JSStreamSocket\x2C ...\n  res._secureContext = context;\n  res.reading = handle.reading;\n  this[kRes] = res;\n  defineHandleReading(this\x2C handle);\n\n  this.on('close'\x2C onSocketCloseDestroySSL);\n\n  return res;\n};\n\n// This eliminates a cyclic reference to TLSWrap\n// Ref: https://github.com/nodejs/node/commit/f7620fb96d339f704932f9bb9a0dceb9952df2d4\nfunction defineHandleReading(socket\x2C handle) {\n  ObjectDefineProperty(handle\x2C 'reading'\x2C {\n    get: () => {\n      return socket[kRes].reading;\n    }\x2C\n    set: (value) => {\n      socket[kRes].reading = value;\n    }\n  });\n}\n\nfunction onSocketCloseDestroySSL() {\n  // Make sure we are not doing it on OpenSSL's stack\n  setImmediate(destroySSL\x2C this);\n  this[kRes] = null;\n}\n\nfunction destroySSL(self) {\n  self._destroySSL();\n}\n\nTLSSocket.prototype._destroySSL = function _destroySSL() {\n  if (!this.ssl) return;\n  this.ssl.destroySSL();\n  if (this.ssl._secureContext.singleUse) {\n    this.ssl._secureContext.context.close();\n    this.ssl._secureContext.context = null;\n  }\n  this.ssl = null;\n  this[kPendingSession] = null;\n  this[kIsVerified] = false;\n};\n\n// Constructor guts\x2C arbitrarily factored out.\nlet warnOnTlsKeylog = true;\nlet warnOnTlsKeylogError = true;\nTLSSocket.prototype._init = function(socket\x2C wrap) {\n  const options = this._tlsOptions;\n  const ssl = this._handle;\n  this.server = options.server;\n\n  debug('%s _init'\x2C\n        options.isServer ? 'server' : 'client'\x2C\n        'handle?'\x2C !!ssl\n  );\n\n  // Clients (!isServer) always request a cert\x2C servers request a client cert\n  // only on explicit configuration.\n  const requestCert = !!options.requestCert || !options.isServer;\n  const rejectUnauthorized = !!options.rejectUnauthorized;\n\n  this._requestCert = requestCert;\n  this._rejectUnauthorized = rejectUnauthorized;\n  if (requestCert || rejectUnauthorized)\n    ssl.setVerifyMode(requestCert\x2C rejectUnauthorized);\n\n  // Only call .onkeylog if there is a keylog listener.\n  ssl.onkeylog = onkeylog;\n  this.on('newListener'\x2C keylogNewListener);\n\n  function keylogNewListener(event) {\n    if (event !== 'keylog')\n      return;\n\n    // Guard against enableKeylogCallback after destroy\n    if (!this._handle) return;\n    this._handle.enableKeylogCallback();\n\n    // Remove this listener since it's no longer needed.\n    this.removeListener('newListener'\x2C keylogNewListener);\n  }\n\n  if (options.isServer) {\n    ssl.onhandshakestart = onhandshakestart;\n    ssl.onhandshakedone = onhandshakedone;\n    ssl.onclienthello = loadSession;\n    ssl.oncertcb = loadSNI;\n    ssl.onnewsession = onnewsession;\n    ssl.lastHandshakeTime = 0;\n    ssl.handshakes = 0;\n\n    if (this.server) {\n      if (this.server.listenerCount('resumeSession') > 0 ||\n          this.server.listenerCount('newSession') > 0) {\n        // Also starts the client hello parser as a side effect.\n        ssl.enableSessionCallbacks();\n      }\n      if (this.server.listenerCount('OCSPRequest') > 0)\n        ssl.enableCertCb();\n    }\n  } else {\n    ssl.onhandshakestart = noop;\n    ssl.onhandshakedone = () => {\n      debug('client onhandshakedone');\n      this._finishInit();\n    };\n    ssl.onocspresponse = onocspresponse;\n\n    if (options.session)\n      ssl.setSession(options.session);\n\n    ssl.onnewsession = onnewsessionclient;\n\n    // Only call .onnewsession if there is a session listener.\n    this.on('newListener'\x2C newListener);\n\n    function newListener(event) {\n      if (event !== 'session')\n        return;\n\n      // Guard against enableSessionCallbacks after destroy\n      if (!this._handle) return;\n      this._handle.enableSessionCallbacks();\n\n      // Remove this listener since it's no longer needed.\n      this.removeListener('newListener'\x2C newListener);\n    }\n  }\n\n  if (tlsKeylog) {\n    if (warnOnTlsKeylog) {\n      warnOnTlsKeylog = false;\n      process.emitWarning('Using --tls-keylog makes TLS connections insecure ' +\n        'by writing secret key material to file ' + tlsKeylog);\n    }\n    this.on('keylog'\x2C (line) => {\n      appendFile(tlsKeylog\x2C line\x2C { mode: 0o600 }\x2C (err) => {\n        if (err && warnOnTlsKeylogError) {\n          warnOnTlsKeylogError = false;\n          process.emitWarning('Failed to write TLS keylog (this warning ' +\n            'will not be repeated): ' + err);\n        }\n      });\n    });\n  }\n\n  ssl.onerror = onerror;\n\n  // If custom SNICallback was given\x2C or if\n  // there're SNI contexts to perform match against -\n  // set `.onsniselect` callback.\n  if (options.isServer &&\n      options.SNICallback &&\n      (options.SNICallback !== SNICallback ||\n       (options.server && options.server._contexts.length))) {\n    assert(typeof options.SNICallback === 'function');\n    this._SNICallback = options.SNICallback;\n    ssl.enableCertCb();\n  }\n\n  if (options.ALPNProtocols) {\n    // Keep reference in secureContext not to be GC-ed\n    ssl._secureContext.alpnBuffer = options.ALPNProtocols;\n    ssl.setALPNProtocols(ssl._secureContext.alpnBuffer);\n  }\n\n  if (options.pskCallback && ssl.enablePskCallback) {\n    validateFunction(options.pskCallback\x2C 'pskCallback');\n\n    ssl[kOnPskExchange] = options.isServer ?\n      onPskServerCallback : onPskClientCallback;\n\n    this[kPskCallback] = options.pskCallback;\n    ssl.enablePskCallback();\n\n    if (options.pskIdentityHint) {\n      validateString(options.pskIdentityHint\x2C 'options.pskIdentityHint');\n      ssl.setPskIdentityHint(options.pskIdentityHint);\n    }\n  }\n\n\n  if (options.handshakeTimeout > 0)\n    this.setTimeout(options.handshakeTimeout\x2C this._handleTimeout);\n\n  if (socket instanceof net.Socket) {\n    this._parent = socket;\n\n    // To prevent assertion in afterConnect() and properly kick off readStart\n    this.connecting = socket.connecting || !socket._handle;\n    socket.once('connect'\x2C () => {\n      this.connecting = false;\n      this.emit('connect');\n    });\n  }\n\n  // Assume `tls.connect()`\n  if (wrap) {\n    wrap.on('error'\x2C (err) => this._emitTLSError(err));\n  } else {\n    assert(!socket);\n    this.connecting = true;\n  }\n};\n\nTLSSocket.prototype.renegotiate = function(options\x2C callback) {\n  validateObject(options\x2C 'options');\n  if (callback !== undefined) {\n    validateCallback(callback);\n  }\n\n  debug('%s renegotiate()'\x2C\n        this._tlsOptions.isServer ? 'server' : 'client'\x2C\n        'destroyed?'\x2C this.destroyed\n  );\n\n  if (this.destroyed)\n    return;\n\n  let requestCert = !!this._requestCert;\n  let rejectUnauthorized = !!this._rejectUnauthorized;\n\n  if (options.requestCert !== undefined)\n    requestCert = !!options.requestCert;\n  if (options.rejectUnauthorized !== undefined)\n    rejectUnauthorized = !!options.rejectUnauthorized;\n\n  if (requestCert !== this._requestCert ||\n      rejectUnauthorized !== this._rejectUnauthorized) {\n    this._handle.setVerifyMode(requestCert\x2C rejectUnauthorized);\n    this._requestCert = requestCert;\n    this._rejectUnauthorized = rejectUnauthorized;\n  }\n  // Ensure that we'll cycle through internal openssl's state\n  this.write('');\n\n  try {\n    this._handle.renegotiate();\n  } catch (err) {\n    if (callback) {\n      process.nextTick(callback\x2C err);\n    }\n    return false;\n  }\n\n  // Ensure that we'll cycle through internal openssl's state\n  this.write('');\n\n  if (callback) {\n    this.once('secure'\x2C () => callback(null));\n  }\n\n  return true;\n};\n\nTLSSocket.prototype.exportKeyingMaterial = function(length\x2C label\x2C context) {\n  validateUint32(length\x2C 'length'\x2C true);\n  validateString(label\x2C 'label');\n  if (context !== undefined)\n    validateBuffer(context\x2C 'context');\n\n  if (!this._secureEstablished)\n    throw new ERR_TLS_INVALID_STATE();\n\n  return this._handle.exportKeyingMaterial(length\x2C label\x2C context);\n};\n\nTLSSocket.prototype.setMaxSendFragment = function setMaxSendFragment(size) {\n  validateInt32(size\x2C 'size');\n  return this._handle.setMaxSendFragment(size) === 1;\n};\n\nTLSSocket.prototype._handleTimeout = function() {\n  this._emitTLSError(new ERR_TLS_HANDSHAKE_TIMEOUT());\n};\n\nTLSSocket.prototype._emitTLSError = function(err) {\n  const e = this._tlsError(err);\n  if (e)\n    this.emit('error'\x2C e);\n};\n\nTLSSocket.prototype._tlsError = function(err) {\n  this.emit('_tlsError'\x2C err);\n  if (this._controlReleased)\n    return err;\n  return null;\n};\n\nTLSSocket.prototype._releaseControl = function() {\n  if (this._controlReleased)\n    return false;\n  this._controlReleased = true;\n  this.removeListener('error'\x2C this._tlsError);\n  return true;\n};\n\nTLSSocket.prototype._finishInit = function() {\n  // Guard against getting onhandshakedone() after .destroy().\n  // * 1.2: If destroy() during onocspresponse()\x2C then write of next handshake\n  // record fails\x2C the handshake done info callbacks does not occur\x2C and the\n  // socket closes.\n  // * 1.3: The OCSP response comes in the same record that finishes handshake\x2C\n  // so even after .destroy()\x2C the handshake done info callback occurs\n  // immediately after onocspresponse(). Ignore it.\n  if (!this._handle)\n    return;\n\n  this.alpnProtocol = this._handle.getALPNNegotiatedProtocol();\n  // The servername could be set by TLSWrap::SelectSNIContextCallback().\n  if (this.servername === null) {\n    this.servername = this._handle.getServername();\n  }\n\n  debug('%s _finishInit'\x2C\n        this._tlsOptions.isServer ? 'server' : 'client'\x2C\n        'handle?'\x2C !!this._handle\x2C\n        'alpn'\x2C this.alpnProtocol\x2C\n        'servername'\x2C this.servername);\n\n  this._secureEstablished = true;\n  if (this._tlsOptions.handshakeTimeout > 0)\n    this.setTimeout(0\x2C this._handleTimeout);\n  this.emit('secure');\n};\n\nTLSSocket.prototype._start = function() {\n  debug('%s _start'\x2C\n        this._tlsOptions.isServer ? 'server' : 'client'\x2C\n        'handle?'\x2C !!this._handle\x2C\n        'connecting?'\x2C this.connecting\x2C\n        'requestOCSP?'\x2C !!this._tlsOptions.requestOCSP\x2C\n  );\n  if (this.connecting) {\n    this.once('connect'\x2C this._start);\n    return;\n  }\n\n  // Socket was destroyed before the connection was established\n  if (!this._handle)\n    return;\n\n  if (this._tlsOptions.requestOCSP)\n    this._handle.requestOCSP();\n  this._handle.start();\n};\n\nTLSSocket.prototype.setServername = function(name) {\n  validateString(name\x2C 'name');\n\n  if (this._tlsOptions.isServer) {\n    throw new ERR_TLS_SNI_FROM_SERVER();\n  }\n\n  this._handle.setServername(name);\n};\n\nTLSSocket.prototype.setSession = function(session) {\n  if (typeof session === 'string')\n    session = Buffer.from(session\x2C 'latin1');\n  this._handle.setSession(session);\n};\n\nTLSSocket.prototype.getPeerCertificate = function(detailed) {\n  if (this._handle) {\n    return common.translatePeerCertificate(\n      this._handle.getPeerCertificate(detailed)) || {};\n  }\n\n  return null;\n};\n\nTLSSocket.prototype.getCertificate = function() {\n  if (this._handle) {\n    // It's not a peer cert\x2C but the formatting is identical.\n    return common.translatePeerCertificate(\n      this._handle.getCertificate()) || {};\n  }\n\n  return null;\n};\n\nTLSSocket.prototype.getPeerX509Certificate = function(detailed) {\n  const cert = this._handle?.getPeerX509Certificate();\n  return cert ? new InternalX509Certificate(cert) : undefined;\n};\n\nTLSSocket.prototype.getX509Certificate = function() {\n  const cert = this._handle?.getX509Certificate();\n  return cert ? new InternalX509Certificate(cert) : undefined;\n};\n\n// Proxy TLSSocket handle methods\nfunction makeSocketMethodProxy(name) {\n  return function socketMethodProxy(...args) {\n    if (this._handle)\n      return ReflectApply(this._handle[name]\x2C this._handle\x2C args);\n    return null;\n  };\n}\n\nArrayPrototypeForEach([\n  'getCipher'\x2C\n  'getSharedSigalgs'\x2C\n  'getEphemeralKeyInfo'\x2C\n  'getFinished'\x2C\n  'getPeerFinished'\x2C\n  'getProtocol'\x2C\n  'getSession'\x2C\n  'getTLSTicket'\x2C\n  'isSessionReused'\x2C\n  'enableTrace'\x2C\n]\x2C (method) => {\n  TLSSocket.prototype[method] = makeSocketMethodProxy(method);\n});\n\n// TODO: support anonymous (nocert)\n\n\nfunction onServerSocketSecure() {\n  if (this._requestCert) {\n    const verifyError = this._handle.verifyError();\n    if (verifyError) {\n      this.authorizationError = verifyError.code;\n\n      if (this._rejectUnauthorized)\n        this.destroy();\n    } else {\n      this.authorized = true;\n    }\n  }\n\n  if (!this.destroyed && this._releaseControl()) {\n    debug('server emit secureConnection');\n    this.secureConnecting = false;\n    this._tlsOptions.server.emit('secureConnection'\x2C this);\n  }\n}\n\nfunction onSocketTLSError(err) {\n  if (!this._controlReleased && !this[kErrorEmitted]) {\n    this[kErrorEmitted] = true;\n    debug('server emit tlsClientError:'\x2C err);\n    this._tlsOptions.server.emit('tlsClientError'\x2C err\x2C this);\n  }\n}\n\nfunction onSocketKeylog(line) {\n  this._tlsOptions.server.emit('keylog'\x2C line\x2C this);\n}\n\nfunction onSocketClose(err) {\n  // Closed because of error - no need to emit it twice\n  if (err)\n    return;\n\n  // Emit ECONNRESET\n  if (!this._controlReleased && !this[kErrorEmitted]) {\n    this[kErrorEmitted] = true;\n    const connReset = connResetException('socket hang up');\n    this._tlsOptions.server.emit('tlsClientError'\x2C connReset\x2C this);\n  }\n}\n\nfunction tlsConnectionListener(rawSocket) {\n  debug('net.Server.on(connection): new TLSSocket');\n  const socket = new TLSSocket(rawSocket\x2C {\n    secureContext: this._sharedCreds\x2C\n    isServer: true\x2C\n    server: this\x2C\n    requestCert: this.requestCert\x2C\n    rejectUnauthorized: this.rejectUnauthorized\x2C\n    handshakeTimeout: this[kHandshakeTimeout]\x2C\n    ALPNProtocols: this.ALPNProtocols\x2C\n    SNICallback: this[kSNICallback] || SNICallback\x2C\n    enableTrace: this[kEnableTrace]\x2C\n    pauseOnConnect: this.pauseOnConnect\x2C\n    pskCallback: this[kPskCallback]\x2C\n    pskIdentityHint: this[kPskIdentityHint]\x2C\n  });\n\n  socket.on('secure'\x2C onServerSocketSecure);\n\n  if (this.listenerCount('keylog') > 0)\n    socket.on('keylog'\x2C onSocketKeylog);\n\n  socket[kErrorEmitted] = false;\n  socket.on('close'\x2C onSocketClose);\n  socket.on('_tlsError'\x2C onSocketTLSError);\n}\n\n// AUTHENTICATION MODES\n//\n// There are several levels of authentication that TLS/SSL supports.\n// Read more about this in "man SSL_set_verify".\n//\n// 1. The server sends a certificate to the client but does not request a\n// cert from the client. This is common for most HTTPS servers. The browser\n// can verify the identity of the server\x2C but the server does not know who\n// the client is. Authenticating the client is usually done over HTTP using\n// login boxes and cookies and stuff.\n//\n// 2. The server sends a cert to the client and requests that the client\n// also send it a cert. The client knows who the server is and the server is\n// requesting the client also identify themselves. There are several\n// outcomes:\n//\n//   A) verifyError returns null meaning the client's certificate is signed\n//   by one of the server's CAs. The server now knows the client's identity\n//   and the client is authorized.\n//\n//   B) For some reason the client's certificate is not acceptable -\n//   verifyError returns a string indicating the problem. The server can\n//   either (i) reject the client or (ii) allow the client to connect as an\n//   unauthorized connection.\n//\n// The mode is controlled by two boolean variables.\n//\n// requestCert\n//   If true the server requests a certificate from client connections. For\n//   the common HTTPS case\x2C users will want this to be false\x2C which is what\n//   it defaults to.\n//\n// rejectUnauthorized\n//   If true clients whose certificates are invalid for any reason will not\n//   be allowed to make connections. If false\x2C they will simply be marked as\n//   unauthorized but secure communication will continue. By default this is\n//   true.\n//\n//\n//\n// Options:\n// - requestCert. Send verify request. Default to false.\n// - rejectUnauthorized. Boolean\x2C default to true.\n// - key. string.\n// - cert: string.\n// - clientCertEngine: string.\n// - ca: string or array of strings.\n// - sessionTimeout: integer.\n//\n// emit 'secureConnection'\n//   function (tlsSocket) { }\n//\n//   "UNABLE_TO_GET_ISSUER_CERT"\x2C "UNABLE_TO_GET_CRL"\x2C\n//   "UNABLE_TO_DECRYPT_CERT_SIGNATURE"\x2C "UNABLE_TO_DECRYPT_CRL_SIGNATURE"\x2C\n//   "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY"\x2C "CERT_SIGNATURE_FAILURE"\x2C\n//   "CRL_SIGNATURE_FAILURE"\x2C "CERT_NOT_YET_VALID" "CERT_HAS_EXPIRED"\x2C\n//   "CRL_NOT_YET_VALID"\x2C "CRL_HAS_EXPIRED" "ERROR_IN_CERT_NOT_BEFORE_FIELD"\x2C\n//   "ERROR_IN_CERT_NOT_AFTER_FIELD"\x2C "ERROR_IN_CRL_LAST_UPDATE_FIELD"\x2C\n//   "ERROR_IN_CRL_NEXT_UPDATE_FIELD"\x2C "OUT_OF_MEM"\x2C\n//   "DEPTH_ZERO_SELF_SIGNED_CERT"\x2C "SELF_SIGNED_CERT_IN_CHAIN"\x2C\n//   "UNABLE_TO_GET_ISSUER_CERT_LOCALLY"\x2C "UNABLE_TO_VERIFY_LEAF_SIGNATURE"\x2C\n//   "CERT_CHAIN_TOO_LONG"\x2C "CERT_REVOKED" "INVALID_CA"\x2C\n//   "PATH_LENGTH_EXCEEDED"\x2C "INVALID_PURPOSE" "CERT_UNTRUSTED"\x2C\n//   "CERT_REJECTED"\n//\nfunction Server(options\x2C listener) {\n  if (!(this instanceof Server))\n    return new Server(options\x2C listener);\n\n  if (typeof options === 'function') {\n    listener = options;\n    options = {};\n  } else if (options == null || typeof options === 'object') {\n    options = options || {};\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C 'Object'\x2C options);\n  }\n\n  this._contexts = [];\n  this.requestCert = options.requestCert === true;\n  this.rejectUnauthorized = options.rejectUnauthorized !== false;\n\n  if (options.sessionTimeout)\n    this.sessionTimeout = options.sessionTimeout;\n\n  if (options.ticketKeys)\n    this.ticketKeys = options.ticketKeys;\n\n  if (options.ALPNProtocols)\n    tls.convertALPNProtocols(options.ALPNProtocols\x2C this);\n\n  this.setSecureContext(options);\n\n  this[kHandshakeTimeout] = options.handshakeTimeout || (120 * 1000);\n  this[kSNICallback] = options.SNICallback;\n  this[kPskCallback] = options.pskCallback;\n  this[kPskIdentityHint] = options.pskIdentityHint;\n\n  validateNumber(this[kHandshakeTimeout]\x2C 'options.handshakeTimeout');\n\n  if (this[kSNICallback] && typeof this[kSNICallback] !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'options.SNICallback'\x2C 'function'\x2C options.SNICallback);\n  }\n\n  if (this[kPskCallback] && typeof this[kPskCallback] !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'options.pskCallback'\x2C 'function'\x2C options.pskCallback);\n  }\n  if (this[kPskIdentityHint] && typeof this[kPskIdentityHint] !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'options.pskIdentityHint'\x2C\n      'string'\x2C\n      options.pskIdentityHint\n    );\n  }\n\n  // constructor call\n  ReflectApply(net.Server\x2C this\x2C [options\x2C tlsConnectionListener]);\n\n  if (listener) {\n    this.on('secureConnection'\x2C listener);\n  }\n\n  this[kEnableTrace] = options.enableTrace;\n}\n\nObjectSetPrototypeOf(Server.prototype\x2C net.Server.prototype);\nObjectSetPrototypeOf(Server\x2C net.Server);\nexports.Server = Server;\nexports.createServer = function createServer(options\x2C listener) {\n  return new Server(options\x2C listener);\n};\n\n\nServer.prototype.setSecureContext = function(options) {\n  validateObject(options\x2C 'options');\n\n  if (options.pfx)\n    this.pfx = options.pfx;\n  else\n    this.pfx = undefined;\n\n  if (options.key)\n    this.key = options.key;\n  else\n    this.key = undefined;\n\n  if (options.passphrase)\n    this.passphrase = options.passphrase;\n  else\n    this.passphrase = undefined;\n\n  if (options.cert)\n    this.cert = options.cert;\n  else\n    this.cert = undefined;\n\n  if (options.clientCertEngine)\n    this.clientCertEngine = options.clientCertEngine;\n  else\n    this.clientCertEngine = undefined;\n\n  if (options.ca)\n    this.ca = options.ca;\n  else\n    this.ca = undefined;\n\n  if (options.minVersion)\n    this.minVersion = options.minVersion;\n  else\n    this.minVersion = undefined;\n\n  if (options.maxVersion)\n    this.maxVersion = options.maxVersion;\n  else\n    this.maxVersion = undefined;\n\n  if (options.secureProtocol)\n    this.secureProtocol = options.secureProtocol;\n  else\n    this.secureProtocol = undefined;\n\n  if (options.crl)\n    this.crl = options.crl;\n  else\n    this.crl = undefined;\n\n  this.sigalgs = options.sigalgs;\n\n  if (options.ciphers)\n    this.ciphers = options.ciphers;\n  else\n    this.ciphers = undefined;\n\n  this.ecdhCurve = options.ecdhCurve;\n\n  if (options.dhparam)\n    this.dhparam = options.dhparam;\n  else\n    this.dhparam = undefined;\n\n  if (options.honorCipherOrder !== undefined)\n    this.honorCipherOrder = !!options.honorCipherOrder;\n  else\n    this.honorCipherOrder = true;\n\n  const secureOptions = options.secureOptions || 0;\n\n  if (secureOptions)\n    this.secureOptions = secureOptions;\n  else\n    this.secureOptions = undefined;\n\n  if (options.sessionIdContext) {\n    this.sessionIdContext = options.sessionIdContext;\n  } else {\n    this.sessionIdContext = StringPrototypeSlice(\n      crypto.createHash('sha1')\n        .update(ArrayPrototypeJoin(process.argv\x2C ' '))\n        .digest('hex')\x2C 0\x2C 32);\n  }\n\n  if (options.sessionTimeout)\n    this.sessionTimeout = options.sessionTimeout;\n\n  if (options.ticketKeys)\n    this.ticketKeys = options.ticketKeys;\n\n  this.privateKeyIdentifier = options.privateKeyIdentifier;\n  this.privateKeyEngine = options.privateKeyEngine;\n\n  this._sharedCreds = tls.createSecureContext({\n    pfx: this.pfx\x2C\n    key: this.key\x2C\n    passphrase: this.passphrase\x2C\n    cert: this.cert\x2C\n    clientCertEngine: this.clientCertEngine\x2C\n    ca: this.ca\x2C\n    ciphers: this.ciphers\x2C\n    sigalgs: this.sigalgs\x2C\n    ecdhCurve: this.ecdhCurve\x2C\n    dhparam: this.dhparam\x2C\n    minVersion: this.minVersion\x2C\n    maxVersion: this.maxVersion\x2C\n    secureProtocol: this.secureProtocol\x2C\n    secureOptions: this.secureOptions\x2C\n    honorCipherOrder: this.honorCipherOrder\x2C\n    crl: this.crl\x2C\n    sessionIdContext: this.sessionIdContext\x2C\n    ticketKeys: this.ticketKeys\x2C\n    sessionTimeout: this.sessionTimeout\x2C\n    privateKeyIdentifier: this.privateKeyIdentifier\x2C\n    privateKeyEngine: this.privateKeyEngine\x2C\n  });\n};\n\n\nServer.prototype._getServerData = function() {\n  return {\n    ticketKeys: this.getTicketKeys().toString('hex')\n  };\n};\n\n\nServer.prototype._setServerData = function(data) {\n  this.setTicketKeys(Buffer.from(data.ticketKeys\x2C 'hex'));\n};\n\n\nServer.prototype.getTicketKeys = function getTicketKeys() {\n  return this._sharedCreds.context.getTicketKeys();\n};\n\n\nServer.prototype.setTicketKeys = function setTicketKeys(keys) {\n  validateBuffer(keys);\n  assert(keys.byteLength === 48\x2C\n         'Session ticket keys must be a 48-byte buffer');\n  this._sharedCreds.context.setTicketKeys(keys);\n};\n\n\nServer.prototype.setOptions = deprecate(function(options) {\n  this.requestCert = options.requestCert === true;\n  this.rejectUnauthorized = options.rejectUnauthorized !== false;\n\n  if (options.pfx) this.pfx = options.pfx;\n  if (options.key) this.key = options.key;\n  if (options.passphrase) this.passphrase = options.passphrase;\n  if (options.cert) this.cert = options.cert;\n  if (options.clientCertEngine)\n    this.clientCertEngine = options.clientCertEngine;\n  if (options.ca) this.ca = options.ca;\n  if (options.minVersion) this.minVersion = options.minVersion;\n  if (options.maxVersion) this.maxVersion = options.maxVersion;\n  if (options.secureProtocol) this.secureProtocol = options.secureProtocol;\n  if (options.crl) this.crl = options.crl;\n  if (options.ciphers) this.ciphers = options.ciphers;\n  if (options.ecdhCurve !== undefined)\n    this.ecdhCurve = options.ecdhCurve;\n  if (options.dhparam) this.dhparam = options.dhparam;\n  if (options.sessionTimeout) this.sessionTimeout = options.sessionTimeout;\n  if (options.ticketKeys) this.ticketKeys = options.ticketKeys;\n  const secureOptions = options.secureOptions || 0;\n  if (options.honorCipherOrder !== undefined)\n    this.honorCipherOrder = !!options.honorCipherOrder;\n  else\n    this.honorCipherOrder = true;\n  if (secureOptions) this.secureOptions = secureOptions;\n  if (options.ALPNProtocols)\n    tls.convertALPNProtocols(options.ALPNProtocols\x2C this);\n  if (options.sessionIdContext) {\n    this.sessionIdContext = options.sessionIdContext;\n  } else {\n    this.sessionIdContext = StringPrototypeSlice(\n      crypto.createHash('sha1')\n        .update(ArrayPrototypeJoin(process.argv\x2C ' '))\n        .digest('hex')\x2C 0\x2C 32);\n  }\n  if (options.pskCallback) this[kPskCallback] = options.pskCallback;\n  if (options.pskIdentityHint) this[kPskIdentityHint] = options.pskIdentityHint;\n  if (options.sigalgs) this.sigalgs = options.sigalgs;\n  if (options.privateKeyIdentifier !== undefined)\n    this.privateKeyIdentifier = options.privateKeyIdentifier;\n  if (options.privateKeyEngine !== undefined)\n    this.privateKeyEngine = options.privateKeyEngine;\n}\x2C 'Server.prototype.setOptions() is deprecated'\x2C 'DEP0122');\n\n// SNI Contexts High-Level API\nServer.prototype.addContext = function(servername\x2C context) {\n  if (!servername) {\n    throw new ERR_TLS_REQUIRED_SERVER_NAME();\n  }\n\n  const re = new RegExp('^' + StringPrototypeReplace(\n    StringPrototypeReplace(servername\x2C /([.^$+?\\-\\\\[\\]{}])/g\x2C '\\\\$1')\x2C\n    /\\*/g\x2C '[^.]*'\n  ) + '$');\n  ArrayPrototypePush(this._contexts\x2C\n                     [re\x2C tls.createSecureContext(context).context]);\n};\n\nServer.prototype[EE.captureRejectionSymbol] = function(\n  err\x2C event\x2C sock) {\n\n  switch (event) {\n    case 'secureConnection':\n      sock.destroy(err);\n      break;\n    default:\n      ReflectApply(net.Server.prototype[SymbolFor('nodejs.rejection')]\x2C this\x2C\n                   [err\x2C event\x2C sock]);\n  }\n};\n\nfunction SNICallback(servername\x2C callback) {\n  const contexts = this.server._contexts;\n\n  for (let i = contexts.length - 1; i >= 0; --i) {\n    const elem = contexts[i];\n    if (RegExpPrototypeTest(elem[0]\x2C servername)) {\n      callback(null\x2C elem[1]);\n      return;\n    }\n  }\n\n  callback(null\x2C undefined);\n}\n\n\n// Target API:\n//\n//  let s = tls.connect({port: 8000\x2C host: "google.com"}\x2C function() {\n//    if (!s.authorized) {\n//      s.destroy();\n//      return;\n//    }\n//\n//    // s.socket;\n//\n//    s.end("hello world\\n");\n//  });\n//\n//\nfunction normalizeConnectArgs(listArgs) {\n  const args = net._normalizeArgs(listArgs);\n  const options = args[0];\n  const cb = args[1];\n\n  // If args[0] was options\x2C then normalize dealt with it.\n  // If args[0] is port\x2C or args[0]\x2C args[1] is host\x2C port\x2C we need to\n  // find the options and merge them in\x2C normalize's options has only\n  // the host/port/path args that it knows about\x2C not the tls options.\n  // This means that options.host overrides a host arg.\n  if (listArgs[1] !== null && typeof listArgs[1] === 'object') {\n    ObjectAssign(options\x2C listArgs[1]);\n  } else if (listArgs[2] !== null && typeof listArgs[2] === 'object') {\n    ObjectAssign(options\x2C listArgs[2]);\n  }\n\n  return cb ? [options\x2C cb] : [options];\n}\n\nfunction onConnectSecure() {\n  const options = this[kConnectOptions];\n\n  // Check the size of DHE parameter above minimum requirement\n  // specified in options.\n  const ekeyinfo = this.getEphemeralKeyInfo();\n  if (ekeyinfo.type === 'DH' && ekeyinfo.size < options.minDHSize) {\n    const err = new ERR_TLS_DH_PARAM_SIZE(ekeyinfo.size);\n    debug('client emit:'\x2C err);\n    this.emit('error'\x2C err);\n    this.destroy();\n    return;\n  }\n\n  let verifyError = this._handle.verifyError();\n\n  // Verify that server's identity matches it's certificate's names\n  // Unless server has resumed our existing session\n  if (!verifyError && !this.isSessionReused()) {\n    const hostname = options.servername ||\n                   options.host ||\n                   (options.socket && options.socket._host) ||\n                   'localhost';\n    const cert = this.getPeerCertificate(true);\n    verifyError = options.checkServerIdentity(hostname\x2C cert);\n  }\n\n  if (verifyError) {\n    this.authorized = false;\n    this.authorizationError = verifyError.code || verifyError.message;\n\n    // rejectUnauthorized property can be explicitly defined as `undefined`\n    // causing the assignment to default value (`true`) fail. Before assigning\n    // it to the tlssock connection options\x2C explicitly check if it is false\n    // and update rejectUnauthorized property. The property gets used by\n    // TLSSocket connection handler to allow or reject connection if\n    // unauthorized.\n    // This check is potentially redundant\x2C however it is better to keep it\n    // in case the option object gets modified somewhere.\n    if (options.rejectUnauthorized !== false) {\n      this.destroy(verifyError);\n      return;\n    }\n    debug('client emit secureConnect. rejectUnauthorized: %s\x2C ' +\n          'authorizationError: %s'\x2C options.rejectUnauthorized\x2C\n          this.authorizationError);\n    this.secureConnecting = false;\n    this.emit('secureConnect');\n  } else {\n    this.authorized = true;\n    debug('client emit secureConnect. authorized:'\x2C this.authorized);\n    this.secureConnecting = false;\n    this.emit('secureConnect');\n  }\n\n  this[kIsVerified] = true;\n  const session = this[kPendingSession];\n  this[kPendingSession] = null;\n  if (session)\n    this.emit('session'\x2C session);\n\n  this.removeListener('end'\x2C onConnectEnd);\n}\n\nfunction onConnectEnd() {\n  // NOTE: This logic is shared with _http_client.js\n  if (!this._hadError) {\n    const options = this[kConnectOptions];\n    this._hadError = true;\n    const error = connResetException('Client network socket disconnected ' +\n                                     'before secure TLS connection was ' +\n                                     'established');\n    error.path = options.path;\n    error.host = options.host;\n    error.port = options.port;\n    error.localAddress = options.localAddress;\n    this.destroy(error);\n  }\n}\n\n// Arguments: [port\x2C] [host\x2C] [options\x2C] [cb]\nexports.connect = function connect(...args) {\n  args = normalizeConnectArgs(args);\n  let options = args[0];\n  const cb = args[1];\n  const allowUnauthorized = getAllowUnauthorized();\n\n  options = {\n    rejectUnauthorized: !allowUnauthorized\x2C\n    ciphers: tls.DEFAULT_CIPHERS\x2C\n    checkServerIdentity: tls.checkServerIdentity\x2C\n    minDHSize: 1024\x2C\n    ...options\n  };\n\n  if (!options.keepAlive)\n    options.singleUse = true;\n\n  assert(typeof options.checkServerIdentity === 'function');\n  assert(typeof options.minDHSize === 'number'\x2C\n         'options.minDHSize is not a number: ' + options.minDHSize);\n  assert(options.minDHSize > 0\x2C\n         'options.minDHSize is not a positive number: ' +\n         options.minDHSize);\n\n  const context = options.secureContext || tls.createSecureContext(options);\n\n  const tlssock = new TLSSocket(options.socket\x2C {\n    allowHalfOpen: options.allowHalfOpen\x2C\n    pipe: !!options.path\x2C\n    secureContext: context\x2C\n    isServer: false\x2C\n    requestCert: true\x2C\n    rejectUnauthorized: options.rejectUnauthorized !== false\x2C\n    session: options.session\x2C\n    ALPNProtocols: options.ALPNProtocols\x2C\n    requestOCSP: options.requestOCSP\x2C\n    enableTrace: options.enableTrace\x2C\n    pskCallback: options.pskCallback\x2C\n    highWaterMark: options.highWaterMark\x2C\n    onread: options.onread\x2C\n    signal: options.signal\x2C\n  });\n\n  // rejectUnauthorized property can be explicitly defined as `undefined`\n  // causing the assignment to default value (`true`) fail. Before assigning\n  // it to the tlssock connection options\x2C explicitly check if it is false\n  // and update rejectUnauthorized property. The property gets used by TLSSocket\n  // connection handler to allow or reject connection if unauthorized\n  options.rejectUnauthorized = options.rejectUnauthorized !== false;\n\n  tlssock[kConnectOptions] = options;\n\n  if (cb)\n    tlssock.once('secureConnect'\x2C cb);\n\n  if (!options.socket) {\n    // If user provided the socket\x2C it's their responsibility to manage its\n    // connectivity. If we created one internally\x2C we connect it.\n    if (options.timeout) {\n      tlssock.setTimeout(options.timeout);\n    }\n\n    tlssock.connect(options\x2C tlssock._start);\n  }\n\n  tlssock._releaseControl();\n\n  if (options.session)\n    tlssock.setSession(options.session);\n\n  if (options.servername) {\n    if (!ipServernameWarned && net.isIP(options.servername)) {\n      process.emitWarning(\n        'Setting the TLS ServerName to an IP address is not permitted by ' +\n        'RFC 6066. This will be ignored in a future version.'\x2C\n        'DeprecationWarning'\x2C\n        'DEP0123'\n      );\n      ipServernameWarned = true;\n    }\n    tlssock.setServername(options.servername);\n  }\n\n  if (options.socket)\n    tlssock._start();\n\n  tlssock.on('secure'\x2C onConnectSecure);\n  tlssock.prependListener('end'\x2C onConnectEnd);\n\n  return tlssock;\n};\n
code-source-info,0x29d5d5bab4ee,169,0,49636,C0O0C4O49636,,
code-creation,Function,10,88875,0x29d5d5bad5fe,2023, node:_tls_wrap:1:1,0x29d5d5bab468,~
code-source-info,0x29d5d5bad5fe,169,0,49636,C0O0C401O1159C406O1184C412O1206C418O1228C423O1249C429O1265C435O1289C440O1313C446O1329C452O1339C458O1362C464O1388C470O1412C475O1422C481O1491C485O1491C490O1461C495O1477C500O1518C503O1560C507O1560C512O1543C518O1594C522O1594C526O1594C528O1637C532O1637C536O1637C538O1667C542O1667C547O1698C551O1698C555O1698C557O1726C561O1726C565O1726C567O1757C571O1757C575O1757C577O1804C581O1804C585O1804C587O1861C591O1861C596O1850C602O1892C606O1892C612O1925C627O1926C633O1892C635O2011C639O2011C644O1978C650O1994C656O2057C660O2057C664O2057C666O2129C670O2129C675O2094C681O2111C687O2184C691O2184C696O2215C701O2167C707O2255C711O2255C716O2233C722O2334C726O2334C731O2310C737O2399C741O2399C746O2369C752O2389C757O2437C763O2461C769O2486C775O2511C781O2532C787O2557C793O2586C799O2613C805O2647C811O2679C817O2705C823O2732C829O2807C833O2807C838O2788C844O2889C848O2889C853O2845C858O2863C864O3096C868O3096C873O2928C879O2947C885O2965C891O2985C897O3005C903O3022C909O3040C915O3058C921O3076C927O3166C931O3166C936O3138C942O3216C946O3216C950O3216C952O3265C956O3265C960O3265C962O3320C966O3320C971O3305C977O3359C981O3359C985O3359C987O3416C991O3416C995O3416C997O3471C1001O3471C1005O3471C1007O3522C1011O3522C1015O3522C1017O3564C1021O3564C1025O3564C1027O3600C1031O3600C1035O3600C1037O3644C1041O3644C1045O3644C1047O3688C1051O3688C1055O3688C1057O3736C1061O3736C1065O3736C1067O3787C1071O3787C1075O3787C1077O3833C1081O3833C1085O3833C1087O3867C1089O3867C1091O3912C1092O3912C1094O3942C1095O3942C1097O15173C1101O15204C1111O15219C1117O15226C1123O15173C1128O15238C1136O15274C1142O15238C1147O15283C1149O15301C1153O15338C1158O15819C1185O15802C1216O15802C1219O15839C1223O15848C1229O15856C1235O15887C1239O15881C1246O15791C1317O15922C1320O15931C1325O15939C1334O15955C1338O16653C1341O16663C1350O16694C1354O16772C1357O16782C1366O16804C1370O18373C1373O18383C1382O18405C1386O18771C1387O18771C1389O18804C1390O18804C1392O18810C1395O18820C1404O18836C1408O23569C1411O23579C1420O23601C1424O24840C1427O24850C1436O24881C1440O25208C1443O25218C1452O25247C1456O25374C1459O25384C1468O25409C1472O25483C1475O25493C1484O25517C1488O25608C1491O25618C1500O25638C1504O25751C1507O25761C1516O25787C1520O25948C1523O25958C1532O25980C1536O27044C1539O27054C1548O27071C1552O27575C1555O27585C1564O27609C1568O27782C1571O27792C1580O27813C1584O27956C1587O27966C1596O27995C1604O28164C1607O28174C1616O28199C1624O28410C1627O28420C1636O28453C1644O28598C1647O28608C1656O28637C1664O29004C1679O29004C1689O35960C1693O35988C1707O36003C1717O36010C1727O35960C1737O36022C1745O36055C1755O36022C1765O36064C1767O36079C1775O36089C1779O36110C1787O36200C1790O36207C1803O36234C1811O39143C1814O39150C1827O39175C1835O39264C1838O39271C1851O39296C1859O39379C1862O39386C1875O39410C1883O39496C1886O39503C1899O39527C1907O39729C1910O39736C1919O39759C1933O39759C1943O39757C1951O41928C1954O41935C1967O41956C1975O42329C1978O42336C1987O42349C2001O42373C2009O46805C2013O46821C2022O49635,,
tick,0x10041de00,89000,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x29d5d5b915f4,0x105108d28,0x10510894c,0x29d5d5b8ec0d,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89de,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x1bfd39474,89000,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x29d5d5b915f4,0x105108d28,0x10510894c,0x29d5d5b8ec0d,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89de,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,89167,0x29d5d5bb2cb6,5, node:crypto:1:1,0x29d5d5bb2a70,~
script-source,170,node:crypto,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Note: In 0.8 and before\x2C crypto functions all defaulted to using\n// binary-encoded strings rather than buffers.\n\n'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n} = primordials;\n\nconst {\n  assertCrypto\x2C\n  deprecate\n} = require('internal/util');\nassertCrypto();\n\nconst {\n  ERR_CRYPTO_FIPS_FORCED\x2C\n} = require('internal/errors').codes;\nconst constants = internalBinding('constants').crypto;\nconst { getOptionValue } = require('internal/options');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\nconst fipsForced = getOptionValue('--force-fips');\nconst {\n  getFipsCrypto\x2C\n  setFipsCrypto\x2C\n  timingSafeEqual\x2C\n} = internalBinding('crypto');\nconst {\n  checkPrime\x2C\n  checkPrimeSync\x2C\n  generatePrime\x2C\n  generatePrimeSync\x2C\n  randomBytes\x2C\n  randomFill\x2C\n  randomFillSync\x2C\n  randomInt\x2C\n  randomUUID\x2C\n} = require('internal/crypto/random');\nconst {\n  pbkdf2\x2C\n  pbkdf2Sync\n} = require('internal/crypto/pbkdf2');\nconst {\n  scrypt\x2C\n  scryptSync\n} = require('internal/crypto/scrypt');\nconst {\n  hkdf\x2C\n  hkdfSync\n} = require('internal/crypto/hkdf');\nconst {\n  generateKeyPair\x2C\n  generateKeyPairSync\x2C\n  generateKey\x2C\n  generateKeySync\x2C\n} = require('internal/crypto/keygen');\nconst {\n  createSecretKey\x2C\n  createPublicKey\x2C\n  createPrivateKey\x2C\n  KeyObject\x2C\n} = require('internal/crypto/keys');\nconst {\n  DiffieHellman\x2C\n  DiffieHellmanGroup\x2C\n  ECDH\x2C\n  diffieHellman\n} = require('internal/crypto/diffiehellman');\nconst {\n  Cipher\x2C\n  Cipheriv\x2C\n  Decipher\x2C\n  Decipheriv\x2C\n  privateDecrypt\x2C\n  privateEncrypt\x2C\n  publicDecrypt\x2C\n  publicEncrypt\x2C\n  getCipherInfo\x2C\n} = require('internal/crypto/cipher');\nconst {\n  Sign\x2C\n  signOneShot\x2C\n  Verify\x2C\n  verifyOneShot\n} = require('internal/crypto/sig');\nconst {\n  Hash\x2C\n  Hmac\n} = require('internal/crypto/hash');\nconst {\n  X509Certificate\n} = require('internal/crypto/x509');\nconst {\n  getCiphers\x2C\n  getCurves\x2C\n  getDefaultEncoding\x2C\n  getHashes\x2C\n  setDefaultEncoding\x2C\n  setEngine\x2C\n  secureHeapUsed\x2C\n} = require('internal/crypto/util');\nconst Certificate = require('internal/crypto/certificate');\n\nlet webcrypto;\nfunction lazyWebCrypto() {\n  webcrypto ??= require('internal/crypto/webcrypto');\n  return webcrypto;\n}\n\n// These helper functions are needed because the constructors can\n// use new\x2C in which case V8 cannot inline the recursive constructor call\nfunction createHash(algorithm\x2C options) {\n  return new Hash(algorithm\x2C options);\n}\n\nfunction createCipher(cipher\x2C password\x2C options) {\n  return new Cipher(cipher\x2C password\x2C options);\n}\n\nfunction createCipheriv(cipher\x2C key\x2C iv\x2C options) {\n  return new Cipheriv(cipher\x2C key\x2C iv\x2C options);\n}\n\nfunction createDecipher(cipher\x2C password\x2C options) {\n  return new Decipher(cipher\x2C password\x2C options);\n}\n\nfunction createDecipheriv(cipher\x2C key\x2C iv\x2C options) {\n  return new Decipheriv(cipher\x2C key\x2C iv\x2C options);\n}\n\nfunction createDiffieHellman(sizeOrKey\x2C keyEncoding\x2C generator\x2C genEncoding) {\n  return new DiffieHellman(sizeOrKey\x2C keyEncoding\x2C generator\x2C genEncoding);\n}\n\nfunction createDiffieHellmanGroup(name) {\n  return new DiffieHellmanGroup(name);\n}\n\nfunction createECDH(curve) {\n  return new ECDH(curve);\n}\n\nfunction createHmac(hmac\x2C key\x2C options) {\n  return new Hmac(hmac\x2C key\x2C options);\n}\n\nfunction createSign(algorithm\x2C options) {\n  return new Sign(algorithm\x2C options);\n}\n\nfunction createVerify(algorithm\x2C options) {\n  return new Verify(algorithm\x2C options);\n}\n\nmodule.exports = {\n  // Methods\n  checkPrime\x2C\n  checkPrimeSync\x2C\n  createCipheriv\x2C\n  createDecipheriv\x2C\n  createDiffieHellman\x2C\n  createDiffieHellmanGroup\x2C\n  createECDH\x2C\n  createHash\x2C\n  createHmac\x2C\n  createPrivateKey\x2C\n  createPublicKey\x2C\n  createSecretKey\x2C\n  createSign\x2C\n  createVerify\x2C\n  diffieHellman\x2C\n  generatePrime\x2C\n  generatePrimeSync\x2C\n  getCiphers\x2C\n  getCipherInfo\x2C\n  getCurves\x2C\n  getDiffieHellman: createDiffieHellmanGroup\x2C\n  getHashes\x2C\n  hkdf\x2C\n  hkdfSync\x2C\n  pbkdf2\x2C\n  pbkdf2Sync\x2C\n  generateKeyPair\x2C\n  generateKeyPairSync\x2C\n  generateKey\x2C\n  generateKeySync\x2C\n  privateDecrypt\x2C\n  privateEncrypt\x2C\n  publicDecrypt\x2C\n  publicEncrypt\x2C\n  randomBytes\x2C\n  randomFill\x2C\n  randomFillSync\x2C\n  randomInt\x2C\n  randomUUID\x2C\n  scrypt\x2C\n  scryptSync\x2C\n  sign: signOneShot\x2C\n  setEngine\x2C\n  timingSafeEqual\x2C\n  getFips: fipsForced ? getFipsForced : getFipsCrypto\x2C\n  setFips: fipsForced ? setFipsForced : setFipsCrypto\x2C\n  verify: verifyOneShot\x2C\n\n  // Classes\n  Certificate\x2C\n  Cipher\x2C\n  Cipheriv\x2C\n  Decipher\x2C\n  Decipheriv\x2C\n  DiffieHellman\x2C\n  DiffieHellmanGroup\x2C\n  ECDH\x2C\n  Hash\x2C\n  Hmac\x2C\n  KeyObject\x2C\n  Sign\x2C\n  Verify\x2C\n  X509Certificate\x2C\n  secureHeapUsed\x2C\n};\n\nfunction setFipsForced(val) {\n  if (val) return;\n  throw new ERR_CRYPTO_FIPS_FORCED();\n}\n\nfunction getFipsForced() {\n  return 1;\n}\n\nfunction getRandomValues(array) {\n  return lazyWebCrypto().crypto.getRandomValues(array);\n}\n\nObjectDefineProperty(constants\x2C 'defaultCipherList'\x2C {\n  value: getOptionValue('--tls-cipher-list')\n});\n\nObjectDefineProperties(module.exports\x2C {\n  createCipher: {\n    enumerable: false\x2C\n    value: deprecate(createCipher\x2C\n                     'crypto.createCipher is deprecated.'\x2C 'DEP0106')\n  }\x2C\n  createDecipher: {\n    enumerable: false\x2C\n    value: deprecate(createDecipher\x2C\n                     'crypto.createDecipher is deprecated.'\x2C 'DEP0106')\n  }\x2C\n  // crypto.fips is deprecated. DEP0093. Use crypto.getFips()/crypto.setFips()\n  fips: {\n    get: fipsForced ? getFipsForced : getFipsCrypto\x2C\n    set: fipsForced ? setFipsForced : setFipsCrypto\n  }\x2C\n  DEFAULT_ENCODING: {\n    enumerable: false\x2C\n    configurable: true\x2C\n    get: deprecate(getDefaultEncoding\x2C\n                   'crypto.DEFAULT_ENCODING is deprecated.'\x2C 'DEP0091')\x2C\n    set: deprecate(setDefaultEncoding\x2C\n                   'crypto.DEFAULT_ENCODING is deprecated.'\x2C 'DEP0091')\n  }\x2C\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n\n  webcrypto: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    get() { return lazyWebCrypto().crypto; }\x2C\n    set: undefined\x2C\n  }\x2C\n\n  subtle: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    get() { return lazyWebCrypto().crypto.subtle; }\x2C\n    set: undefined\x2C\n  }\x2C\n\n  getRandomValues: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    get: () => getRandomValues\x2C\n    set: undefined\x2C\n  }\x2C\n\n  // Aliases for randomBytes are deprecated.\n  // The ecosystem needs those to exist for backwards compatibility.\n  prng: {\n    enumerable: false\x2C\n    configurable: true\x2C\n    writable: true\x2C\n    value: pendingDeprecation ?\n      deprecate(randomBytes\x2C 'crypto.prng is deprecated.'\x2C 'DEP0115') :\n      randomBytes\n  }\x2C\n  pseudoRandomBytes: {\n    enumerable: false\x2C\n    configurable: true\x2C\n    writable: true\x2C\n    value: pendingDeprecation ?\n      deprecate(randomBytes\x2C\n                'crypto.pseudoRandomBytes is deprecated.'\x2C 'DEP0115') :\n      randomBytes\n  }\x2C\n  rng: {\n    enumerable: false\x2C\n    configurable: true\x2C\n    writable: true\x2C\n    value: pendingDeprecation ?\n      deprecate(randomBytes\x2C 'crypto.rng is deprecated.'\x2C 'DEP0115') :\n      randomBytes\n  }\n});\n
code-source-info,0x29d5d5bb2cb6,170,0,8067,C0O0C4O8067,,
code-creation,Function,10,89500,0x29d5d5bb404e,1854, node:crypto:1:1,0x29d5d5bb2c30,~
code-source-info,0x29d5d5bb404e,170,0,8067,C0O0C138O1275C143O1299C148O1381C156O1381C162O1351C167O1367C172O1407C175O1462C183O1462C189O1488C195O1434C201O1514C205O1514C211O1542C216O1578C224O1578C230O1559C235O1634C239O1634C244O1694C248O1694C253O1791C257O1791C263O1736C268O1753C273O1770C278O1974C286O1974C292O1828C297O1842C302O1860C307O1877C312O1898C317O1913C323O1927C329O1945C335O1958C341O2044C349O2044C355O2019C361O2029C367O2114C375O2114C381O2089C387O2099C393O2180C401O2180C407O2159C413O2167C419O2301C427O2301C433O2223C439O2242C445O2265C451O2280C457O2419C465O2419C471O2346C477O2365C483O2384C489O2404C495O2527C503O2527C509O2462C515O2479C521O2501C527O2509C533O2716C541O2716C547O2579C553O2589C559O2601C565O2613C571O2627C577O2645C583O2663C589O2680C595O2697C601O2812C609O2812C615O2761C621O2769C627O2784C633O2794C639O2871C647O2871C653O2854C659O2862C665O2934C673O2934C679O2914C685O3094C693O3094C699O2977C705O2991C711O3004C717O3026C723O3039C729O3061C735O3074C741O3147C749O3147C755O3192C756O3192C758O4507C766O4541C772O4555C778O4573C784O4591C790O4611C796O4634C802O4662C808O4676C814O4690C820O4704C826O4724C832O4743C838O4762C844O4776C850O4792C856O4809C862O4826C868O4847C874O4861C880O4878C886O4909C892O4937C898O4950C904O4958C910O4970C916O4980C922O4994C928O5013C934O5036C940O5051C946O5070C952O5088C958O5106C964O5123C970O5140C976O5155C982O5169C988O5187C994O5200C1000O5214C1006O5224C1012O5244C1018O5259C1024O5272C1033O5300C1041O5329C1047O5355C1055O5384C1061O5409C1071O5440C1081O5455C1091O5465C1101O5477C1111O5489C1121O5503C1131O5520C1141O5542C1151O5550C1161O5558C1171O5566C1181O5579C1191O5587C1201O5597C1211O5616C1221O4522C1229O5861C1233O5882C1246O5925C1265O5861C1275O5996C1294O6023C1314O6059C1342O6176C1362O6212C1390O6402C1404O6413C1412O6442C1422O6466C1430O6495C1448O6534C1468O6592C1497O6704C1525O6824C1536O6884C1554O6913C1563O6966C1576O7017C1594O7044C1603O7097C1616O7155C1634O7191C1643O7249C1656O7281C1674O7420C1685O7500C1698O7527C1712O7599C1730O7637C1741O7717C1754O7744C1768O7845C1786O7869C1797O7949C1810O7976C1824O8047C1842O5966C1853O8066,,
tick,0x100571be8,89709,1,0x10041f4d8,2,0x0,0x105108c5c,0x10510894c,0x29d5d5bb416c,0x105108d28,0x10510894c,0x29d5d5bad812,0x105108d28,0x10510894c,0x29d5d5b915f4,0x105108d28,0x10510894c,0x29d5d5b8ec0d,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89de,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,89834,0x29d5d5bb6306,5, node:internal/crypto/random:1:1,0x29d5d5bb5df0,~
script-source,171,node:internal/crypto/random,'use strict';\n\nconst {\n  Array\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSplice\x2C\n  BigInt\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  MathMin\x2C\n  NumberIsNaN\x2C\n  NumberIsSafeInteger\x2C\n  NumberPrototypeToString\x2C\n  StringPrototypePadStart\x2C\n} = primordials;\n\nconst {\n  RandomBytesJob\x2C\n  RandomPrimeJob\x2C\n  CheckPrimeJob\x2C\n  kCryptoJobAsync\x2C\n  kCryptoJobSync\x2C\n  secureBuffer\x2C\n} = internalBinding('crypto');\n\nconst {\n  lazyDOMException\x2C\n} = require('internal/util');\n\nconst { Buffer\x2C kMaxLength } = require('buffer');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_OPERATION_FAILED\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  validateNumber\x2C\n  validateBoolean\x2C\n  validateCallback\x2C\n  validateObject\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst {\n  isArrayBufferView\x2C\n  isAnyArrayBuffer\x2C\n  isTypedArray\x2C\n  isFloat32Array\x2C\n  isFloat64Array\x2C\n} = require('internal/util/types');\n\nconst { FastBuffer } = require('internal/buffer');\n\nconst kMaxInt32 = 2 ** 31 - 1;\nconst kMaxPossibleLength = MathMin(kMaxLength\x2C kMaxInt32);\n\nfunction assertOffset(offset\x2C elementSize\x2C length) {\n  validateNumber(offset\x2C 'offset');\n  offset *= elementSize;\n\n  const maxLength = MathMin(length\x2C kMaxPossibleLength);\n  if (NumberIsNaN(offset) || offset > maxLength || offset < 0) {\n    throw new ERR_OUT_OF_RANGE('offset'\x2C `>= 0 && <= ${maxLength}`\x2C offset);\n  }\n\n  return offset >>> 0;  // Convert to uint32.\n}\n\nfunction assertSize(size\x2C elementSize\x2C offset\x2C length) {\n  validateNumber(size\x2C 'size');\n  size *= elementSize;\n\n  if (NumberIsNaN(size) || size > kMaxPossibleLength || size < 0) {\n    throw new ERR_OUT_OF_RANGE('size'\x2C\n                               `>= 0 && <= ${kMaxPossibleLength}`\x2C size);\n  }\n\n  if (size + offset > length) {\n    throw new ERR_OUT_OF_RANGE('size + offset'\x2C `<= ${length}`\x2C size + offset);\n  }\n\n  return size >>> 0;  // Convert to uint32.\n}\n\nfunction randomBytes(size\x2C callback) {\n  size = assertSize(size\x2C 1\x2C 0\x2C Infinity);\n  if (callback !== undefined) {\n    validateCallback(callback);\n  }\n\n  const buf = new FastBuffer(size);\n\n  if (callback === undefined) {\n    randomFillSync(buf.buffer\x2C 0\x2C size);\n    return buf;\n  }\n\n  // Keep the callback as a regular function so this is propagated.\n  randomFill(buf.buffer\x2C 0\x2C size\x2C function(error) {\n    if (error) return FunctionPrototypeCall(callback\x2C this\x2C error);\n    FunctionPrototypeCall(callback\x2C this\x2C null\x2C buf);\n  });\n}\n\nfunction randomFillSync(buf\x2C offset = 0\x2C size) {\n  if (!isAnyArrayBuffer(buf) && !isArrayBufferView(buf)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'buf'\x2C\n      ['ArrayBuffer'\x2C 'ArrayBufferView']\x2C\n      buf);\n  }\n\n  const elementSize = buf.BYTES_PER_ELEMENT || 1;\n\n  offset = assertOffset(offset\x2C elementSize\x2C buf.byteLength);\n\n  if (size === undefined) {\n    size = buf.byteLength - offset;\n  } else {\n    size = assertSize(size\x2C elementSize\x2C offset\x2C buf.byteLength);\n  }\n\n  if (size === 0)\n    return buf;\n\n  const job = new RandomBytesJob(\n    kCryptoJobSync\x2C\n    buf\x2C\n    offset\x2C\n    size);\n\n  const err = job.run()[0];\n  if (err)\n    throw err;\n\n  return buf;\n}\n\nfunction randomFill(buf\x2C offset\x2C size\x2C callback) {\n  if (!isAnyArrayBuffer(buf) && !isArrayBufferView(buf)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'buf'\x2C\n      ['ArrayBuffer'\x2C 'ArrayBufferView']\x2C\n      buf);\n  }\n\n  const elementSize = buf.BYTES_PER_ELEMENT || 1;\n\n  if (typeof offset === 'function') {\n    callback = offset;\n    offset = 0;\n    // Size is a length here\x2C assertSize() call turns it into a number of bytes\n    size = buf.length;\n  } else if (typeof size === 'function') {\n    callback = size;\n    size = buf.length - offset;\n  } else {\n    validateCallback(callback);\n  }\n\n  offset = assertOffset(offset\x2C elementSize\x2C buf.byteLength);\n\n  if (size === undefined) {\n    size = buf.byteLength - offset;\n  } else {\n    size = assertSize(size\x2C elementSize\x2C offset\x2C buf.byteLength);\n  }\n\n  if (size === 0) {\n    callback(null\x2C buf);\n    return;\n  }\n\n  const job = new RandomBytesJob(\n    kCryptoJobAsync\x2C\n    buf\x2C\n    offset\x2C\n    size);\n  job.ondone = FunctionPrototypeBind(onJobDone\x2C job\x2C buf\x2C callback);\n  job.run();\n}\n\n// Largest integer we can read from a buffer.\n// e.g.: Buffer.from("ff".repeat(6)\x2C "hex").readUIntBE(0\x2C 6);\nconst RAND_MAX = 0xFFFF_FFFF_FFFF;\n\n// Cache random data to use in randomInt. The cache size must be evenly\n// divisible by 6 because each attempt to obtain a random int uses 6 bytes.\nconst randomCache = new FastBuffer(6 * 1024);\nlet randomCacheOffset = randomCache.length;\nlet asyncCacheFillInProgress = false;\nconst asyncCachePendingTasks = [];\n\n// Generates an integer in [min\x2C max) range where min is inclusive and max is\n// exclusive.\nfunction randomInt(min\x2C max\x2C callback) {\n  // Detect optional min syntax\n  // randomInt(max)\n  // randomInt(max\x2C callback)\n  const minNotSpecified = typeof max === 'undefined' ||\n    typeof max === 'function';\n\n  if (minNotSpecified) {\n    callback = max;\n    max = min;\n    min = 0;\n  }\n\n  const isSync = typeof callback === 'undefined';\n  if (!isSync) {\n    validateCallback(callback);\n  }\n  if (!NumberIsSafeInteger(min)) {\n    throw new ERR_INVALID_ARG_TYPE('min'\x2C 'a safe integer'\x2C min);\n  }\n  if (!NumberIsSafeInteger(max)) {\n    throw new ERR_INVALID_ARG_TYPE('max'\x2C 'a safe integer'\x2C max);\n  }\n  if (max <= min) {\n    throw new ERR_OUT_OF_RANGE(\n      'max'\x2C `greater than the value of "min" (${min})`\x2C max\n    );\n  }\n\n  // First we generate a random int between [0..range)\n  const range = max - min;\n\n  if (!(range <= RAND_MAX)) {\n    throw new ERR_OUT_OF_RANGE(`max${minNotSpecified ? '' : ' - min'}`\x2C\n                               `<= ${RAND_MAX}`\x2C range);\n  }\n\n  // For (x % range) to produce an unbiased value greater than or equal to 0 and\n  // less than range\x2C x must be drawn randomly from the set of integers greater\n  // than or equal to 0 and less than randLimit.\n  const randLimit = RAND_MAX - (RAND_MAX % range);\n\n  // If we don't have a callback\x2C or if there is still data in the cache\x2C we can\n  // do this synchronously\x2C which is super fast.\n  while (isSync || (randomCacheOffset < randomCache.length)) {\n    if (randomCacheOffset === randomCache.length) {\n      // This might block the thread for a bit\x2C but we are in sync mode.\n      randomFillSync(randomCache);\n      randomCacheOffset = 0;\n    }\n\n    const x = randomCache.readUIntBE(randomCacheOffset\x2C 6);\n    randomCacheOffset += 6;\n\n    if (x < randLimit) {\n      const n = (x % range) + min;\n      if (isSync) return n;\n      process.nextTick(callback\x2C undefined\x2C n);\n      return;\n    }\n  }\n\n  // At this point\x2C we are in async mode with no data in the cache. We cannot\n  // simply refill the cache\x2C because another async call to randomInt might\n  // already be doing that. Instead\x2C queue this call for when the cache has\n  // been refilled.\n  ArrayPrototypePush(asyncCachePendingTasks\x2C { min\x2C max\x2C callback });\n  asyncRefillRandomIntCache();\n}\n\nfunction asyncRefillRandomIntCache() {\n  if (asyncCacheFillInProgress)\n    return;\n\n  asyncCacheFillInProgress = true;\n  randomFill(randomCache\x2C (err) => {\n    asyncCacheFillInProgress = false;\n\n    const tasks = asyncCachePendingTasks;\n    const errorReceiver = err && ArrayPrototypeShift(tasks);\n    if (!err)\n      randomCacheOffset = 0;\n\n    // Restart all pending tasks. If an error occurred\x2C we only notify a single\n    // callback (errorReceiver) about it. This way\x2C every async call to\n    // randomInt has a chance of being successful\x2C and it avoids complex\n    // exception handling here.\n    ArrayPrototypeForEach(ArrayPrototypeSplice(tasks\x2C 0)\x2C (task) => {\n      randomInt(task.min\x2C task.max\x2C task.callback);\n    });\n\n    // This is the only call that might throw\x2C and is therefore done at the end.\n    if (errorReceiver)\n      errorReceiver.callback(err);\n  });\n}\n\n\nfunction onJobDone(buf\x2C callback\x2C error) {\n  if (error) return FunctionPrototypeCall(callback\x2C this\x2C error);\n  FunctionPrototypeCall(callback\x2C this\x2C null\x2C buf);\n}\n\n// Really just the Web Crypto API alternative\n// to require('crypto').randomFillSync() with an\n// additional limitation that the input buffer is\n// not allowed to exceed 65536 bytes\x2C and can only\n// be an integer-type TypedArray.\nfunction getRandomValues(data) {\n  if (!isTypedArray(data) ||\n      isFloat32Array(data) ||\n      isFloat64Array(data)) {\n    // Ordinarily this would be an ERR_INVALID_ARG_TYPE. However\x2C\n    // the Web Crypto API and web platform tests expect this to\n    // be a DOMException with type TypeMismatchError.\n    throw lazyDOMException(\n      'The data argument must be an integer-type TypedArray'\x2C\n      'TypeMismatchError');\n  }\n  if (data.byteLength > 65536) {\n    throw lazyDOMException(\n      'The requested length exceeds 65\x2C536 bytes'\x2C\n      'QuotaExceededError');\n  }\n  randomFillSync(data\x2C 0);\n  return data;\n}\n\n// Implements an RFC 4122 version 4 random UUID.\n// To improve performance\x2C random data is generated in batches\n// large enough to cover kBatchSize UUID's at a time. The uuidData\n// buffer is reused. Each call to randomUUID() consumes 16 bytes\n// from the buffer.\n\nconst kBatchSize = 128;\nlet uuidData;\nlet uuidNotBuffered;\nlet uuidBatch = 0;\n\nlet hexBytesCache;\nfunction getHexBytes() {\n  if (hexBytesCache === undefined) {\n    hexBytesCache = new Array(256);\n    for (let i = 0; i < hexBytesCache.length; i++) {\n      const hex = NumberPrototypeToString(i\x2C 16);\n      hexBytesCache[i] = StringPrototypePadStart(hex\x2C 2\x2C '0');\n    }\n  }\n  return hexBytesCache;\n}\n\nfunction serializeUUID(buf\x2C offset = 0) {\n  const kHexBytes = getHexBytes();\n  // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n  return kHexBytes[buf[offset]] +\n    kHexBytes[buf[offset + 1]] +\n    kHexBytes[buf[offset + 2]] +\n    kHexBytes[buf[offset + 3]] +\n    '-' +\n    kHexBytes[buf[offset + 4]] +\n    kHexBytes[buf[offset + 5]] +\n    '-' +\n    kHexBytes[(buf[offset + 6] & 0x0f) | 0x40] +\n    kHexBytes[buf[offset + 7]] +\n    '-' +\n    kHexBytes[(buf[offset + 8] & 0x3f) | 0x80] +\n    kHexBytes[buf[offset + 9]] +\n    '-' +\n    kHexBytes[buf[offset + 10]] +\n    kHexBytes[buf[offset + 11]] +\n    kHexBytes[buf[offset + 12]] +\n    kHexBytes[buf[offset + 13]] +\n    kHexBytes[buf[offset + 14]] +\n    kHexBytes[buf[offset + 15]];\n}\n\nfunction getBufferedUUID() {\n  uuidData ??= secureBuffer(16 * kBatchSize);\n  if (uuidData === undefined)\n    throw new ERR_OPERATION_FAILED('Out of memory');\n\n  if (uuidBatch === 0) randomFillSync(uuidData);\n  uuidBatch = (uuidBatch + 1) % kBatchSize;\n  return serializeUUID(uuidData\x2C uuidBatch * 16);\n}\n\nfunction getUnbufferedUUID() {\n  uuidNotBuffered ??= secureBuffer(16);\n  if (uuidNotBuffered === undefined)\n    throw new ERR_OPERATION_FAILED('Out of memory');\n  randomFillSync(uuidNotBuffered);\n  return serializeUUID(uuidNotBuffered);\n}\n\nfunction randomUUID(options) {\n  if (options !== undefined)\n    validateObject(options\x2C 'options');\n  const {\n    disableEntropyCache = false\x2C\n  } = options || {};\n\n  validateBoolean(disableEntropyCache\x2C 'options.disableEntropyCache');\n\n  return disableEntropyCache ? getUnbufferedUUID() : getBufferedUUID();\n}\n\nfunction createRandomPrimeJob(type\x2C size\x2C options) {\n  validateObject(options\x2C 'options');\n\n  const {\n    safe = false\x2C\n    bigint = false\x2C\n  } = options;\n  let {\n    add\x2C\n    rem\x2C\n  } = options;\n\n  validateBoolean(safe\x2C 'options.safe');\n  validateBoolean(bigint\x2C 'options.bigint');\n\n  if (add !== undefined) {\n    if (typeof add === 'bigint') {\n      add = unsignedBigIntToBuffer(add\x2C 'options.add');\n    } else if (!isAnyArrayBuffer(add) && !isArrayBufferView(add)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.add'\x2C\n        [\n          'ArrayBuffer'\x2C\n          'TypedArray'\x2C\n          'Buffer'\x2C\n          'DataView'\x2C\n          'bigint'\x2C\n        ]\x2C\n        add);\n    }\n  }\n\n  if (rem !== undefined) {\n    if (typeof rem === 'bigint') {\n      rem = unsignedBigIntToBuffer(rem\x2C 'options.rem');\n    } else if (!isAnyArrayBuffer(rem) && !isArrayBufferView(rem)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.rem'\x2C\n        [\n          'ArrayBuffer'\x2C\n          'TypedArray'\x2C\n          'Buffer'\x2C\n          'DataView'\x2C\n          'bigint'\x2C\n        ]\x2C\n        rem);\n    }\n  }\n\n  const job = new RandomPrimeJob(type\x2C size\x2C safe\x2C add\x2C rem);\n  job.result = bigint ? arrayBufferToUnsignedBigInt : (p) => p;\n  return job;\n}\n\nfunction generatePrime(size\x2C options\x2C callback) {\n  validateUint32(size\x2C 'size'\x2C true);\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  validateCallback(callback);\n\n  const job = createRandomPrimeJob(kCryptoJobAsync\x2C size\x2C options);\n  job.ondone = (err\x2C prime) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    callback(\n      undefined\x2C\n      job.result(prime));\n  };\n  job.run();\n}\n\nfunction generatePrimeSync(size\x2C options = {}) {\n  validateUint32(size\x2C 'size'\x2C true);\n\n  const job = createRandomPrimeJob(kCryptoJobSync\x2C size\x2C options);\n  const { 0: err\x2C 1: prime } = job.run();\n  if (err)\n    throw err;\n  return job.result(prime);\n}\n\nfunction arrayBufferToUnsignedBigInt(arrayBuffer) {\n  return BigInt(`0x${Buffer.from(arrayBuffer).toString('hex')}`);\n}\n\nfunction unsignedBigIntToBuffer(bigint\x2C name) {\n  if (bigint < 0) {\n    throw new ERR_OUT_OF_RANGE(name\x2C '>= 0'\x2C bigint);\n  }\n\n  const hex = bigint.toString(16);\n  const padded = hex.padStart(hex.length + (hex.length % 2)\x2C 0);\n  return Buffer.from(padded\x2C 'hex');\n}\n\nfunction checkPrime(candidate\x2C options = {}\x2C callback) {\n  if (typeof candidate === 'bigint')\n    candidate = unsignedBigIntToBuffer(candidate\x2C 'candidate');\n  if (!isAnyArrayBuffer(candidate) && !isArrayBufferView(candidate)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'candidate'\x2C\n      [\n        'ArrayBuffer'\x2C\n        'TypedArray'\x2C\n        'Buffer'\x2C\n        'DataView'\x2C\n        'bigint'\x2C\n      ]\x2C\n      candidate\n    );\n  }\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  validateCallback(callback);\n  validateObject(options\x2C 'options');\n  const {\n    checks = 0\x2C\n  } = options;\n\n  validateUint32(checks\x2C 'options.checks');\n\n  const job = new CheckPrimeJob(kCryptoJobAsync\x2C candidate\x2C checks);\n  job.ondone = callback;\n  job.run();\n}\n\nfunction checkPrimeSync(candidate\x2C options = {}) {\n  if (typeof candidate === 'bigint')\n    candidate = unsignedBigIntToBuffer(candidate\x2C 'candidate');\n  if (!isAnyArrayBuffer(candidate) && !isArrayBufferView(candidate)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'candidate'\x2C\n      [\n        'ArrayBuffer'\x2C\n        'TypedArray'\x2C\n        'Buffer'\x2C\n        'DataView'\x2C\n        'bigint'\x2C\n      ]\x2C\n      candidate\n    );\n  }\n  validateObject(options\x2C 'options');\n  const {\n    checks = 0\x2C\n  } = options;\n\n  validateUint32(checks\x2C 'options.checks');\n\n  const job = new CheckPrimeJob(kCryptoJobSync\x2C candidate\x2C checks);\n  const { 0: err\x2C 1: result } = job.run();\n  if (err)\n    throw err;\n\n  return result;\n}\n\nmodule.exports = {\n  checkPrime\x2C\n  checkPrimeSync\x2C\n  randomBytes\x2C\n  randomFill\x2C\n  randomFillSync\x2C\n  randomInt\x2C\n  getRandomValues\x2C\n  randomUUID\x2C\n  generatePrime\x2C\n  generatePrimeSync\x2C\n};\n
code-source-info,0x29d5d5bb6306,171,0,15086,C0O0C4O15086,,
code-creation,Function,10,90417,0x29d5d5bb6d7e,687, node:internal/crypto/random:1:1,0x29d5d5bb6280,~
code-source-info,0x29d5d5bb6d7e,171,0,15086,C0O0C266O25C272O34C278O59C284O81C290O104C296O128C302O138C308O163C314O188C320O199C326O214C332O237C338O264C344O425C347O425C352O317C358O335C364O353C370O370C376O389C382O407C388O485C391O485C396O463C402O543C405O543C410O520C416O528C421O664C424O664C429O664C434O586C440O612C446O634C452O798C455O798C460O703C466O721C472O740C478O760C484O778C490O936C493O936C498O841C504O862C510O882C516O898C522O916C528O992C531O992C536O977C542O1039C549O1079C552O1079C557O1079C559O4307C561O4307C563O4494C573O4494C578O4494C580O4544C583O4556C587O4544C589O4595C590O4595C592O4633C594O4633C596O9134C600O9134C602O9143C603O9143C605O9157C606O9157C608O9190C609O9190C611O9198C612O9198C614O14901C621O14922C627O14936C633O14954C639O14969C645O14983C651O15001C657O15014C663O15033C669O15047C675O15064C681O14916C686O15085,,
code-creation,Eval,10,90542,0x29d5d5bb8ad6,5, node:internal/crypto/pbkdf2:1:1,0x29d5d5bb8870,~
script-source,172,node:internal/crypto/pbkdf2,'use strict';\n\nconst {\n  FunctionPrototypeCall\x2C\n  Promise\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\n\nconst {\n  PBKDF2Job\x2C\n  kCryptoJobAsync\x2C\n  kCryptoJobSync\x2C\n} = internalBinding('crypto');\n\nconst {\n  validateCallback\x2C\n  validateInteger\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst { ERR_MISSING_OPTION } = require('internal/errors').codes;\n\nconst {\n  getArrayBufferOrView\x2C\n  getDefaultEncoding\x2C\n  normalizeHashName\x2C\n  kKeyObject\x2C\n} = require('internal/crypto/util');\n\nconst {\n  lazyDOMException\x2C\n} = require('internal/util');\n\nfunction pbkdf2(password\x2C salt\x2C iterations\x2C keylen\x2C digest\x2C callback) {\n  if (typeof digest === 'function') {\n    callback = digest;\n    digest = undefined;\n  }\n\n  ({ password\x2C salt\x2C iterations\x2C keylen\x2C digest } =\n    check(password\x2C salt\x2C iterations\x2C keylen\x2C digest));\n\n  validateCallback(callback);\n\n  const job = new PBKDF2Job(\n    kCryptoJobAsync\x2C\n    password\x2C\n    salt\x2C\n    iterations\x2C\n    keylen\x2C\n    digest);\n\n  const encoding = getDefaultEncoding();\n  job.ondone = (err\x2C result) => {\n    if (err !== undefined)\n      return FunctionPrototypeCall(callback\x2C job\x2C err);\n    const buf = Buffer.from(result);\n    if (encoding === 'buffer')\n      return FunctionPrototypeCall(callback\x2C job\x2C null\x2C buf);\n    FunctionPrototypeCall(callback\x2C job\x2C null\x2C buf.toString(encoding));\n  };\n\n  job.run();\n}\n\nfunction pbkdf2Sync(password\x2C salt\x2C iterations\x2C keylen\x2C digest) {\n  ({ password\x2C salt\x2C iterations\x2C keylen\x2C digest } =\n    check(password\x2C salt\x2C iterations\x2C keylen\x2C digest));\n\n  const job = new PBKDF2Job(\n    kCryptoJobSync\x2C\n    password\x2C\n    salt\x2C\n    iterations\x2C\n    keylen\x2C\n    digest);\n\n  const { 0: err\x2C 1: result } = job.run();\n  if (err !== undefined)\n    throw err;\n\n  const buf = Buffer.from(result);\n  const encoding = getDefaultEncoding();\n  return encoding === 'buffer' ? buf : buf.toString(encoding);\n}\n\nfunction check(password\x2C salt\x2C iterations\x2C keylen\x2C digest) {\n  validateString(digest\x2C 'digest');\n\n  password = getArrayBufferOrView(password\x2C 'password');\n  salt = getArrayBufferOrView(salt\x2C 'salt');\n  validateUint32(iterations\x2C 'iterations'\x2C true);\n  validateUint32(keylen\x2C 'keylen');\n\n  return { password\x2C salt\x2C iterations\x2C keylen\x2C digest };\n}\n\nasync function pbkdf2DeriveBits(algorithm\x2C baseKey\x2C length) {\n  validateUint32(length\x2C 'length');\n  const { iterations } = algorithm;\n  let { hash } = algorithm;\n  const salt = getArrayBufferOrView(algorithm.salt\x2C 'algorithm.salt');\n  if (hash === undefined)\n    throw new ERR_MISSING_OPTION('algorithm.hash');\n  validateInteger(iterations\x2C 'algorithm.iterations'\x2C 1);\n\n  hash = normalizeHashName(hash.name);\n\n  const raw = baseKey[kKeyObject].export();\n\n  let byteLength = 64;  // the default\n  if (length !== undefined) {\n    if (length === 0)\n      throw lazyDOMException('length cannot be zero'\x2C 'OperationError');\n    if (length % 8) {\n      throw lazyDOMException(\n        'length must be a multiple of 8'\x2C\n        'OperationError');\n    }\n    byteLength = length / 8;\n  }\n\n  return new Promise((resolve\x2C reject) => {\n    pbkdf2(raw\x2C salt\x2C iterations\x2C byteLength\x2C hash\x2C (err\x2C result) => {\n      if (err) return reject(err);\n      resolve(result.buffer);\n    });\n  });\n}\n\nmodule.exports = {\n  pbkdf2\x2C\n  pbkdf2Sync\x2C\n  pbkdf2DeriveBits\x2C\n};\n
code-source-info,0x29d5d5bb8ad6,172,0,3284,C0O0C4O3284,,
code-creation,Function,10,90667,0x29d5d5bb8dde,255, node:internal/crypto/pbkdf2:1:1,0x29d5d5bb8a50,~
code-source-info,0x29d5d5bb8dde,172,0,3284,C0O0C75O25C81O50C87O96C90O96C95O85C101O178C104O178C109O126C115O139C121O158C127O293C130O293C135O216C141O236C147O255C153O273C159O357C162O357C167O383C172O334C178O485C181O485C186O402C192O426C198O448C204O469C210O551C213O551C218O529C224O3218C231O3239C237O3249C243O3263C249O3233C254O3283,,
code-creation,Eval,10,90792,0x29d5d5bb98a6,5, node:internal/crypto/scrypt:1:1,0x29d5d5bb9630,~
script-source,173,node:internal/crypto/scrypt,'use strict';\n\nconst {\n  FunctionPrototypeCall\x2C\n  Promise\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\n\nconst {\n  ScryptJob\x2C\n  kCryptoJobAsync\x2C\n  kCryptoJobSync\x2C\n} = internalBinding('crypto');\n\nconst {\n  validateCallback\x2C\n  validateInteger\x2C\n  validateInt32\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst {\n  codes: {\n    ERR_CRYPTO_SCRYPT_INVALID_PARAMETER\x2C\n    ERR_CRYPTO_SCRYPT_NOT_SUPPORTED\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  getArrayBufferOrView\x2C\n  getDefaultEncoding\x2C\n  kKeyObject\x2C\n} = require('internal/crypto/util');\n\nconst {\n  lazyDOMException\x2C\n} = require('internal/util');\n\nconst defaults = {\n  N: 16384\x2C\n  r: 8\x2C\n  p: 1\x2C\n  maxmem: 32 << 20\x2C  // 32 MB\x2C matches SCRYPT_MAX_MEM.\n};\n\nfunction scrypt(password\x2C salt\x2C keylen\x2C options\x2C callback = defaults) {\n  if (callback === defaults) {\n    callback = options;\n    options = defaults;\n  }\n\n  options = check(password\x2C salt\x2C keylen\x2C options);\n  const { N\x2C r\x2C p\x2C maxmem } = options;\n  ({ password\x2C salt\x2C keylen } = options);\n\n  validateCallback(callback);\n\n  const job = new ScryptJob(\n    kCryptoJobAsync\x2C password\x2C salt\x2C N\x2C r\x2C p\x2C maxmem\x2C keylen);\n\n  const encoding = getDefaultEncoding();\n  job.ondone = (error\x2C result) => {\n    if (error !== undefined)\n      return FunctionPrototypeCall(callback\x2C job\x2C error);\n    const buf = Buffer.from(result);\n    if (encoding === 'buffer')\n      return FunctionPrototypeCall(callback\x2C job\x2C null\x2C buf);\n    FunctionPrototypeCall(callback\x2C job\x2C null\x2C buf.toString(encoding));\n  };\n\n  job.run();\n}\n\nfunction scryptSync(password\x2C salt\x2C keylen\x2C options = defaults) {\n  options = check(password\x2C salt\x2C keylen\x2C options);\n  const { N\x2C r\x2C p\x2C maxmem } = options;\n  ({ password\x2C salt\x2C keylen } = options);\n  const job = new ScryptJob(\n    kCryptoJobSync\x2C password\x2C salt\x2C N\x2C r\x2C p\x2C maxmem\x2C keylen);\n  const { 0: err\x2C 1: result } = job.run();\n\n  if (err !== undefined)\n    throw err;\n\n  const buf = Buffer.from(result);\n  const encoding = getDefaultEncoding();\n  return encoding === 'buffer' ? buf : buf.toString(encoding);\n}\n\nfunction check(password\x2C salt\x2C keylen\x2C options) {\n  if (ScryptJob === undefined)\n    throw new ERR_CRYPTO_SCRYPT_NOT_SUPPORTED();\n\n  password = getArrayBufferOrView(password\x2C 'password');\n  salt = getArrayBufferOrView(salt\x2C 'salt');\n  validateInt32(keylen\x2C 'keylen'\x2C 0);\n\n  let { N\x2C r\x2C p\x2C maxmem } = defaults;\n  if (options && options !== defaults) {\n    const has_N = options.N !== undefined;\n    if (has_N) {\n      N = options.N;\n      validateUint32(N\x2C 'N');\n    }\n    if (options.cost !== undefined) {\n      if (has_N) throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();\n      N = options.cost;\n      validateUint32(N\x2C 'cost');\n    }\n    const has_r = (options.r !== undefined);\n    if (has_r) {\n      r = options.r;\n      validateUint32(r\x2C 'r');\n    }\n    if (options.blockSize !== undefined) {\n      if (has_r) throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();\n      r = options.blockSize;\n      validateUint32(r\x2C 'blockSize');\n    }\n    const has_p = options.p !== undefined;\n    if (has_p) {\n      p = options.p;\n      validateUint32(p\x2C 'p');\n    }\n    if (options.parallelization !== undefined) {\n      if (has_p) throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();\n      p = options.parallelization;\n      validateUint32(p\x2C 'parallelization');\n    }\n    if (options.maxmem !== undefined) {\n      maxmem = options.maxmem;\n      validateInteger(maxmem\x2C 'maxmem'\x2C 0);\n    }\n    if (N === 0) N = defaults.N;\n    if (r === 0) r = defaults.r;\n    if (p === 0) p = defaults.p;\n    if (maxmem === 0) maxmem = defaults.maxmem;\n  }\n\n  return { password\x2C salt\x2C keylen\x2C N\x2C r\x2C p\x2C maxmem };\n}\n\nasync function scryptDeriveBits(algorithm\x2C baseKey\x2C length) {\n  validateUint32(length\x2C 'length');\n  const {\n    N = 16384\x2C\n    r = 8\x2C\n    p = 1\x2C\n    maxmem = 32 * 1024 * 1024\x2C\n    encoding\x2C\n  } = algorithm;\n  validateUint32(N\x2C 'algorithm.N');\n  validateUint32(r\x2C 'algorithm.r');\n  validateUint32(p\x2C 'algorithm.p');\n  validateUint32(maxmem\x2C 'algorithm.maxmem');\n  const salt = getArrayBufferOrView(algorithm.salt\x2C 'algorithm.salt'\x2C encoding);\n\n  const raw = baseKey[kKeyObject].export();\n\n  let byteLength = 64;  // the default\n  if (length !== undefined) {\n    if (length === 0)\n      throw lazyDOMException('length cannot be zero'\x2C 'OperationError');\n    if (length % 8) {\n      throw lazyDOMException(\n        'length must be a multiple of 8'\x2C\n        'OperationError');\n    }\n    byteLength = length / 8;\n  }\n\n  return new Promise((resolve\x2C reject) => {\n    scrypt(raw\x2C salt\x2C byteLength\x2C { N\x2C r\x2C p\x2C maxmem }\x2C (err\x2C result) => {\n      if (err) return reject(err);\n      resolve(result.buffer);\n    });\n  });\n}\n\nmodule.exports = {\n  scrypt\x2C\n  scryptSync\x2C\n  scryptDeriveBits\x2C\n};\n
code-source-info,0x29d5d5bb98a6,173,0,4711,C0O0C4O4711,,
code-creation,Function,10,91000,0x29d5d5bb9c0e,264, node:internal/crypto/scrypt:1:1,0x29d5d5bb9820,~
code-source-info,0x29d5d5bb9c0e,173,0,4711,C0O0C78O25C84O50C90O96C93O96C98O85C104O178C107O178C112O126C118O139C124O158C130O292C133O292C138O216C144O236C150O255C156O272C162O430C165O430C170O430C175O348C181O389C187O531C190O531C195O469C201O493C207O515C213O597C216O597C221O575C227O641C231O641C233O4645C240O4666C246O4676C252O4690C258O4660C263O4710,,
tick,0x10035a618,91000,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x29d5d5bb41c5,0x105108d28,0x10510894c,0x29d5d5bad812,0x105108d28,0x10510894c,0x29d5d5b915f4,0x105108d28,0x10510894c,0x29d5d5b8ec0d,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89de,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,91084,0x29d5d5bbab3e,5, node:internal/crypto/hkdf:1:1,0x29d5d5bba848,~
script-source,174,node:internal/crypto/hkdf,'use strict';\n\nconst {\n  FunctionPrototypeCall\x2C\n  Promise\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  HKDFJob\x2C\n  kCryptoJobAsync\x2C\n  kCryptoJobSync\x2C\n} = internalBinding('crypto');\n\nconst {\n  validateCallback\x2C\n  validateInteger\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst { kMaxLength } = require('buffer');\n\nconst {\n  getArrayBufferOrView\x2C\n  normalizeHashName\x2C\n  toBuf\x2C\n  validateByteSource\x2C\n  kKeyObject\x2C\n} = require('internal/crypto/util');\n\nconst {\n  createSecretKey\x2C\n  isKeyObject\x2C\n} = require('internal/crypto/keys');\n\nconst {\n  lazyDOMException\x2C\n} = require('internal/util');\n\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_MISSING_OPTION\x2C\n  }\x2C\n  hideStackFrames\x2C\n} = require('internal/errors');\n\nconst validateParameters = hideStackFrames((hash\x2C key\x2C salt\x2C info\x2C length) => {\n  key = prepareKey(key);\n  salt = toBuf(salt);\n  info = toBuf(info);\n\n  validateString(hash\x2C 'digest');\n  validateByteSource(salt\x2C 'salt');\n  validateByteSource(info\x2C 'info');\n\n  validateInteger(length\x2C 'length'\x2C 0\x2C kMaxLength);\n\n  if (info.byteLength > 1024) {\n    throw ERR_OUT_OF_RANGE(\n      'info'\x2C\n      'must not contain more than 1024 bytes'\x2C\n      info.byteLength);\n  }\n\n  return {\n    hash\x2C\n    key\x2C\n    salt\x2C\n    info\x2C\n    length\x2C\n  };\n});\n\nfunction prepareKey(key) {\n  if (isKeyObject(key))\n    return key;\n\n  // TODO(@jasnell): createSecretKey should allow using an ArrayBuffer\n  if (isAnyArrayBuffer(key))\n    return createSecretKey(new Uint8Array(key));\n\n  key = toBuf(key);\n\n  if (!isArrayBufferView(key)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'ikm'\x2C\n      [\n        'string'\x2C\n        'SecretKeyObject'\x2C\n        'ArrayBuffer'\x2C\n        'TypedArray'\x2C\n        'DataView'\x2C\n        'Buffer'\x2C\n      ]\x2C\n      key);\n  }\n\n  return createSecretKey(key);\n}\n\nfunction hkdf(hash\x2C key\x2C salt\x2C info\x2C length\x2C callback) {\n  ({\n    hash\x2C\n    key\x2C\n    salt\x2C\n    info\x2C\n    length\x2C\n  } = validateParameters(hash\x2C key\x2C salt\x2C info\x2C length));\n\n  validateCallback(callback);\n\n  const job = new HKDFJob(kCryptoJobAsync\x2C hash\x2C key\x2C salt\x2C info\x2C length);\n\n  job.ondone = (error\x2C bits) => {\n    if (error) return FunctionPrototypeCall(callback\x2C job\x2C error);\n    FunctionPrototypeCall(callback\x2C job\x2C null\x2C bits);\n  };\n\n  job.run();\n}\n\nfunction hkdfSync(hash\x2C key\x2C salt\x2C info\x2C length) {\n  ({\n    hash\x2C\n    key\x2C\n    salt\x2C\n    info\x2C\n    length\x2C\n  } = validateParameters(hash\x2C key\x2C salt\x2C info\x2C length));\n\n  const job = new HKDFJob(kCryptoJobSync\x2C hash\x2C key\x2C salt\x2C info\x2C length);\n  const { 0: err\x2C 1: bits } = job.run();\n  if (err !== undefined)\n    throw err;\n\n  return bits;\n}\n\nasync function hkdfDeriveBits(algorithm\x2C baseKey\x2C length) {\n  validateUint32(length\x2C 'length');\n  const { hash } = algorithm;\n  const salt = getArrayBufferOrView(algorithm.salt\x2C 'algorithm.salt');\n  const info = getArrayBufferOrView(algorithm.info\x2C 'algorithm.info');\n  if (hash === undefined)\n    throw new ERR_MISSING_OPTION('algorithm.hash');\n\n  let byteLength = 512 / 8;\n  if (length !== undefined) {\n    if (length === 0)\n      throw lazyDOMException('length cannot be zero'\x2C 'OperationError');\n    if (length % 8) {\n      throw lazyDOMException(\n        'length must be a multiple of 8'\x2C\n        'OperationError');\n    }\n    byteLength = length / 8;\n  }\n\n  return new Promise((resolve\x2C reject) => {\n    hkdf(\n      normalizeHashName(hash.name)\x2C\n      baseKey[kKeyObject]\x2C\n      salt\x2C\n      info\x2C\n      byteLength\x2C\n      (err\x2C bits) => {\n        if (err) return reject(err);\n        resolve(bits);\n      });\n  });\n}\n\nmodule.exports = {\n  hkdf\x2C\n  hkdfSync\x2C\n  hkdfDeriveBits\x2C\n};\n
code-source-info,0x29d5d5bbab3e,174,0,3678,C0O0C4O3678,,
code-creation,Function,10,91250,0x29d5d5bbaef6,362, node:internal/crypto/hkdf:1:1,0x29d5d5bbaab8,~
code-source-info,0x29d5d5bbaef6,174,0,3678,C0O0C102O25C108O50C114O61C120O151C123O151C128O101C134O112C140O131C146O266C149O266C154O189C160O209C166O228C172O246C178O322C181O322C186O307C192O444C195O444C200O352C206O376C212O397C218O406C224O428C230O524C233O524C238O488C244O507C250O590C253O590C258O568C264O670C267O670C272O627C278O647C284O822C287O822C292O822C297O726C303O752C309O774C315O801C320O878C325O878C329O878C331O3618C338O3639C344O3647C350O3659C356O3633C361O3677,,
code-creation,Eval,10,91542,0x29d5d5bbc626,5, node:internal/crypto/keys:1:1,0x29d5d5bbc100,~
script-source,175,node:internal/crypto/keys,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayPrototypeSlice\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  KeyObjectHandle\x2C\n  createNativeKeyObjectClass\x2C\n  kKeyTypeSecret\x2C\n  kKeyTypePublic\x2C\n  kKeyTypePrivate\x2C\n  kKeyFormatPEM\x2C\n  kKeyFormatDER\x2C\n  kKeyFormatJWK\x2C\n  kKeyEncodingPKCS1\x2C\n  kKeyEncodingPKCS8\x2C\n  kKeyEncodingSPKI\x2C\n  kKeyEncodingSEC1\x2C\n} = internalBinding('crypto');\n\nconst {\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst {\n  codes: {\n    ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS\x2C\n    ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE\x2C\n    ERR_CRYPTO_INVALID_JWK\x2C\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  kHandle\x2C\n  kKeyObject\x2C\n  getArrayBufferOrView\x2C\n  bigIntArrayToUnsignedBigInt\x2C\n} = require('internal/crypto/util');\n\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\n\nconst {\n  JSTransferable\x2C\n  kClone\x2C\n  kDeserialize\x2C\n} = require('internal/worker/js_transferable');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst { inspect } = require('internal/util/inspect');\n\nconst { Buffer } = require('buffer');\n\nconst kAlgorithm = Symbol('kAlgorithm');\nconst kExtractable = Symbol('kExtractable');\nconst kKeyType = Symbol('kKeyType');\nconst kKeyUsages = Symbol('kKeyUsages');\n\n// Key input contexts.\nconst kConsumePublic = 0;\nconst kConsumePrivate = 1;\nconst kCreatePublic = 2;\nconst kCreatePrivate = 3;\n\nconst encodingNames = [];\nfor (const m of [[kKeyEncodingPKCS1\x2C 'pkcs1']\x2C [kKeyEncodingPKCS8\x2C 'pkcs8']\x2C\n                 [kKeyEncodingSPKI\x2C 'spki']\x2C [kKeyEncodingSEC1\x2C 'sec1']])\n  encodingNames[m[0]] = m[1];\n\n// Creating the KeyObject class is a little complicated due to inheritance\n// and that fact that KeyObjects should be transferrable between threads\x2C\n// which requires the KeyObject base class to be implemented in C++.\n// The creation requires a callback to make sure that the NativeKeyObject\n// base class cannot exist without the other KeyObject implementations.\nconst {\n  0: KeyObject\x2C\n  1: SecretKeyObject\x2C\n  2: PublicKeyObject\x2C\n  3: PrivateKeyObject\x2C\n} = createNativeKeyObjectClass((NativeKeyObject) => {\n  // Publicly visible KeyObject class.\n  class KeyObject extends NativeKeyObject {\n    constructor(type\x2C handle) {\n      if (type !== 'secret' && type !== 'public' && type !== 'private')\n        throw new ERR_INVALID_ARG_VALUE('type'\x2C type);\n      if (typeof handle !== 'object' || !(handle instanceof KeyObjectHandle))\n        throw new ERR_INVALID_ARG_TYPE('handle'\x2C 'object'\x2C handle);\n\n      super(handle);\n\n      this[kKeyType] = type;\n\n      ObjectDefineProperty(this\x2C kHandle\x2C {\n        value: handle\x2C\n        enumerable: false\x2C\n        configurable: false\x2C\n        writable: false\n      });\n    }\n\n    get type() {\n      return this[kKeyType];\n    }\n\n    static from(key) {\n      if (!isCryptoKey(key))\n        throw new ERR_INVALID_ARG_TYPE('key'\x2C 'CryptoKey'\x2C key);\n      return key[kKeyObject];\n    }\n\n    equals(otherKeyObject) {\n      if (!isKeyObject(otherKeyObject)) {\n        throw new ERR_INVALID_ARG_TYPE(\n          'otherKeyObject'\x2C 'KeyObject'\x2C otherKeyObject);\n      }\n\n      return otherKeyObject.type === this.type &&\n        this[kHandle].equals(otherKeyObject[kHandle]);\n    }\n  }\n\n  class SecretKeyObject extends KeyObject {\n    constructor(handle) {\n      super('secret'\x2C handle);\n    }\n\n    get symmetricKeySize() {\n      return this[kHandle].getSymmetricKeySize();\n    }\n\n    export(options) {\n      if (options !== undefined) {\n        validateObject(options\x2C 'options');\n        validateOneOf(\n          options.format\x2C 'options.format'\x2C [undefined\x2C 'buffer'\x2C 'jwk']);\n        if (options.format === 'jwk') {\n          return this[kHandle].exportJwk({}\x2C false);\n        }\n      }\n      return this[kHandle].export();\n    }\n  }\n\n  const kAsymmetricKeyType = Symbol('kAsymmetricKeyType');\n  const kAsymmetricKeyDetails = Symbol('kAsymmetricKeyDetails');\n\n  function normalizeKeyDetails(details = {}) {\n    if (details.publicExponent !== undefined) {\n      return {\n        ...details\x2C\n        publicExponent:\n          bigIntArrayToUnsignedBigInt(new Uint8Array(details.publicExponent))\n      };\n    }\n    return details;\n  }\n\n  class AsymmetricKeyObject extends KeyObject {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(type\x2C handle) {\n      super(type\x2C handle);\n    }\n\n    get asymmetricKeyType() {\n      return this[kAsymmetricKeyType] ||\n             (this[kAsymmetricKeyType] = this[kHandle].getAsymmetricKeyType());\n    }\n\n    get asymmetricKeyDetails() {\n      switch (this.asymmetricKeyType) {\n        case 'rsa':\n        case 'rsa-pss':\n        case 'dsa':\n        case 'ec':\n          return this[kAsymmetricKeyDetails] ||\n             (this[kAsymmetricKeyDetails] = normalizeKeyDetails(\n               this[kHandle].keyDetail({})\n             ));\n        default:\n          return {};\n      }\n    }\n  }\n\n  class PublicKeyObject extends AsymmetricKeyObject {\n    constructor(handle) {\n      super('public'\x2C handle);\n    }\n\n    export(options) {\n      if (options && options.format === 'jwk') {\n        return this[kHandle].exportJwk({}\x2C false);\n      }\n      const {\n        format\x2C\n        type\n      } = parsePublicKeyEncoding(options\x2C this.asymmetricKeyType);\n      return this[kHandle].export(format\x2C type);\n    }\n  }\n\n  class PrivateKeyObject extends AsymmetricKeyObject {\n    constructor(handle) {\n      super('private'\x2C handle);\n    }\n\n    export(options) {\n      if (options && options.format === 'jwk') {\n        if (options.passphrase !== undefined) {\n          throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n            'jwk'\x2C 'does not support encryption');\n        }\n        return this[kHandle].exportJwk({}\x2C false);\n      }\n      const {\n        format\x2C\n        type\x2C\n        cipher\x2C\n        passphrase\n      } = parsePrivateKeyEncoding(options\x2C this.asymmetricKeyType);\n      return this[kHandle].export(format\x2C type\x2C cipher\x2C passphrase);\n    }\n  }\n\n  return [KeyObject\x2C SecretKeyObject\x2C PublicKeyObject\x2C PrivateKeyObject];\n});\n\nfunction parseKeyFormat(formatStr\x2C defaultFormat\x2C optionName) {\n  if (formatStr === undefined && defaultFormat !== undefined)\n    return defaultFormat;\n  else if (formatStr === 'pem')\n    return kKeyFormatPEM;\n  else if (formatStr === 'der')\n    return kKeyFormatDER;\n  else if (formatStr === 'jwk')\n    return kKeyFormatJWK;\n  throw new ERR_INVALID_ARG_VALUE(optionName\x2C formatStr);\n}\n\nfunction parseKeyType(typeStr\x2C required\x2C keyType\x2C isPublic\x2C optionName) {\n  if (typeStr === undefined && !required) {\n    return undefined;\n  } else if (typeStr === 'pkcs1') {\n    if (keyType !== undefined && keyType !== 'rsa') {\n      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n        typeStr\x2C 'can only be used for RSA keys');\n    }\n    return kKeyEncodingPKCS1;\n  } else if (typeStr === 'spki' && isPublic !== false) {\n    return kKeyEncodingSPKI;\n  } else if (typeStr === 'pkcs8' && isPublic !== true) {\n    return kKeyEncodingPKCS8;\n  } else if (typeStr === 'sec1' && isPublic !== true) {\n    if (keyType !== undefined && keyType !== 'ec') {\n      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n        typeStr\x2C 'can only be used for EC keys');\n    }\n    return kKeyEncodingSEC1;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE(optionName\x2C typeStr);\n}\n\nfunction option(name\x2C objName) {\n  return objName === undefined ?\n    `options.${name}` : `options.${objName}.${name}`;\n}\n\nfunction parseKeyFormatAndType(enc\x2C keyType\x2C isPublic\x2C objName) {\n  const { format: formatStr\x2C type: typeStr } = enc;\n\n  const isInput = keyType === undefined;\n  const format = parseKeyFormat(formatStr\x2C\n                                isInput ? kKeyFormatPEM : undefined\x2C\n                                option('format'\x2C objName));\n\n  const isRequired = (!isInput ||\n                      format === kKeyFormatDER) &&\n                      format !== kKeyFormatJWK;\n  const type = parseKeyType(typeStr\x2C\n                            isRequired\x2C\n                            keyType\x2C\n                            isPublic\x2C\n                            option('type'\x2C objName));\n  return { format\x2C type };\n}\n\nfunction isStringOrBuffer(val) {\n  return typeof val === 'string' ||\n         isArrayBufferView(val) ||\n         isAnyArrayBuffer(val);\n}\n\nfunction parseKeyEncoding(enc\x2C keyType\x2C isPublic\x2C objName) {\n  validateObject(enc\x2C 'options');\n\n  const isInput = keyType === undefined;\n\n  const {\n    format\x2C\n    type\n  } = parseKeyFormatAndType(enc\x2C keyType\x2C isPublic\x2C objName);\n\n  let cipher\x2C passphrase\x2C encoding;\n  if (isPublic !== true) {\n    ({ cipher\x2C passphrase\x2C encoding } = enc);\n\n    if (!isInput) {\n      if (cipher != null) {\n        if (typeof cipher !== 'string')\n          throw new ERR_INVALID_ARG_VALUE(option('cipher'\x2C objName)\x2C cipher);\n        if (format === kKeyFormatDER &&\n            (type === kKeyEncodingPKCS1 ||\n             type === kKeyEncodingSEC1)) {\n          throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n            encodingNames[type]\x2C 'does not support encryption');\n        }\n      } else if (passphrase !== undefined) {\n        throw new ERR_INVALID_ARG_VALUE(option('cipher'\x2C objName)\x2C cipher);\n      }\n    }\n\n    if ((isInput && passphrase !== undefined &&\n         !isStringOrBuffer(passphrase)) ||\n        (!isInput && cipher != null && !isStringOrBuffer(passphrase))) {\n      throw new ERR_INVALID_ARG_VALUE(option('passphrase'\x2C objName)\x2C\n                                      passphrase);\n    }\n  }\n\n  if (passphrase !== undefined)\n    passphrase = getArrayBufferOrView(passphrase\x2C 'key.passphrase'\x2C encoding);\n\n  return { format\x2C type\x2C cipher\x2C passphrase };\n}\n\n// Parses the public key encoding based on an object. keyType must be undefined\n// when this is used to parse an input encoding and must be a valid key type if\n// used to parse an output encoding.\nfunction parsePublicKeyEncoding(enc\x2C keyType\x2C objName) {\n  return parseKeyEncoding(enc\x2C keyType\x2C keyType ? true : undefined\x2C objName);\n}\n\n// Parses the private key encoding based on an object. keyType must be undefined\n// when this is used to parse an input encoding and must be a valid key type if\n// used to parse an output encoding.\nfunction parsePrivateKeyEncoding(enc\x2C keyType\x2C objName) {\n  return parseKeyEncoding(enc\x2C keyType\x2C false\x2C objName);\n}\n\nfunction getKeyObjectHandle(key\x2C ctx) {\n  if (ctx === kCreatePrivate) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'key'\x2C\n      ['string'\x2C 'ArrayBuffer'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n      key\n    );\n  }\n\n  if (key.type !== 'private') {\n    if (ctx === kConsumePrivate || ctx === kCreatePublic)\n      throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type\x2C 'private');\n    if (key.type !== 'public') {\n      throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type\x2C\n                                                   'private or public');\n    }\n  }\n\n  return key[kHandle];\n}\n\nfunction getKeyTypes(allowKeyObject\x2C bufferOnly = false) {\n  const types = [\n    'ArrayBuffer'\x2C\n    'Buffer'\x2C\n    'TypedArray'\x2C\n    'DataView'\x2C\n    'string'\x2C // Only if bufferOnly == false\n    'KeyObject'\x2C // Only if allowKeyObject == true && bufferOnly == false\n    'CryptoKey'\x2C // Only if allowKeyObject == true && bufferOnly == false\n  ];\n  if (bufferOnly) {\n    return ArrayPrototypeSlice(types\x2C 0\x2C 4);\n  } else if (!allowKeyObject) {\n    return ArrayPrototypeSlice(types\x2C 0\x2C 5);\n  }\n  return types;\n}\n\nfunction getKeyObjectHandleFromJwk(key\x2C ctx) {\n  validateObject(key\x2C 'key');\n  validateOneOf(\n    key.kty\x2C 'key.kty'\x2C ['RSA'\x2C 'EC'\x2C 'OKP']);\n  const isPublic = ctx === kConsumePublic || ctx === kCreatePublic;\n\n  if (key.kty === 'OKP') {\n    validateString(key.crv\x2C 'key.crv');\n    validateOneOf(\n      key.crv\x2C 'key.crv'\x2C ['Ed25519'\x2C 'Ed448'\x2C 'X25519'\x2C 'X448']);\n    validateString(key.x\x2C 'key.x');\n\n    if (!isPublic)\n      validateString(key.d\x2C 'key.d');\n\n    let keyData;\n    if (isPublic)\n      keyData = Buffer.from(key.x\x2C 'base64');\n    else\n      keyData = Buffer.from(key.d\x2C 'base64');\n\n    switch (key.crv) {\n      case 'Ed25519':\n      case 'X25519':\n        if (keyData.byteLength !== 32) {\n          throw new ERR_CRYPTO_INVALID_JWK();\n        }\n        break;\n      case 'Ed448':\n        if (keyData.byteLength !== 57) {\n          throw new ERR_CRYPTO_INVALID_JWK();\n        }\n        break;\n      case 'X448':\n        if (keyData.byteLength !== 56) {\n          throw new ERR_CRYPTO_INVALID_JWK();\n        }\n        break;\n    }\n\n    const handle = new KeyObjectHandle();\n\n    const keyType = isPublic ? kKeyTypePublic : kKeyTypePrivate;\n    if (!handle.initEDRaw(`NODE-${key.crv.toUpperCase()}`\x2C keyData\x2C keyType)) {\n      throw new ERR_CRYPTO_INVALID_JWK();\n    }\n\n    return handle;\n  }\n\n  if (key.kty === 'EC') {\n    validateString(key.crv\x2C 'key.crv');\n    validateOneOf(\n      key.crv\x2C 'key.crv'\x2C ['P-256'\x2C 'secp256k1'\x2C 'P-384'\x2C 'P-521']);\n    validateString(key.x\x2C 'key.x');\n    validateString(key.y\x2C 'key.y');\n\n    const jwk = {\n      kty: key.kty\x2C\n      crv: key.crv\x2C\n      x: key.x\x2C\n      y: key.y\n    };\n\n    if (!isPublic) {\n      validateString(key.d\x2C 'key.d');\n      jwk.d = key.d;\n    }\n\n    const handle = new KeyObjectHandle();\n    const type = handle.initJwk(jwk\x2C jwk.crv);\n    if (type === undefined)\n      throw new ERR_CRYPTO_INVALID_JWK();\n\n    return handle;\n  }\n\n  // RSA\n  validateString(key.n\x2C 'key.n');\n  validateString(key.e\x2C 'key.e');\n\n  const jwk = {\n    kty: key.kty\x2C\n    n: key.n\x2C\n    e: key.e\n  };\n\n  if (!isPublic) {\n    validateString(key.d\x2C 'key.d');\n    validateString(key.p\x2C 'key.p');\n    validateString(key.q\x2C 'key.q');\n    validateString(key.dp\x2C 'key.dp');\n    validateString(key.dq\x2C 'key.dq');\n    validateString(key.qi\x2C 'key.qi');\n    jwk.d = key.d;\n    jwk.p = key.p;\n    jwk.q = key.q;\n    jwk.dp = key.dp;\n    jwk.dq = key.dq;\n    jwk.qi = key.qi;\n  }\n\n  const handle = new KeyObjectHandle();\n  const type = handle.initJwk(jwk);\n  if (type === undefined)\n    throw new ERR_CRYPTO_INVALID_JWK();\n\n  return handle;\n}\n\nfunction prepareAsymmetricKey(key\x2C ctx) {\n  if (isKeyObject(key)) {\n    // Best case: A key object\x2C as simple as that.\n    return { data: getKeyObjectHandle(key\x2C ctx) };\n  } else if (isCryptoKey(key)) {\n    return { data: getKeyObjectHandle(key[kKeyObject]\x2C ctx) };\n  } else if (isStringOrBuffer(key)) {\n    // Expect PEM by default\x2C mostly for backward compatibility.\n    return { format: kKeyFormatPEM\x2C data: getArrayBufferOrView(key\x2C 'key') };\n  } else if (typeof key === 'object') {\n    const { key: data\x2C encoding\x2C format } = key;\n    // The 'key' property can be a KeyObject as well to allow specifying\n    // additional options such as padding along with the key.\n    if (isKeyObject(data))\n      return { data: getKeyObjectHandle(data\x2C ctx) };\n    else if (isCryptoKey(data))\n      return { data: getKeyObjectHandle(data[kKeyObject]\x2C ctx) };\n    else if (isJwk(data) && format === 'jwk')\n      return { data: getKeyObjectHandleFromJwk(data\x2C ctx)\x2C format: 'jwk' };\n    // Either PEM or DER using PKCS#1 or SPKI.\n    if (!isStringOrBuffer(data)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'key.key'\x2C\n        getKeyTypes(ctx !== kCreatePrivate)\x2C\n        data);\n    }\n\n    const isPublic =\n      (ctx === kConsumePrivate || ctx === kCreatePrivate) ? false : undefined;\n    return {\n      data: getArrayBufferOrView(data\x2C 'key'\x2C encoding)\x2C\n      ...parseKeyEncoding(key\x2C undefined\x2C isPublic)\n    };\n  }\n  throw new ERR_INVALID_ARG_TYPE(\n    'key'\x2C\n    getKeyTypes(ctx !== kCreatePrivate)\x2C\n    key);\n}\n\nfunction preparePrivateKey(key) {\n  return prepareAsymmetricKey(key\x2C kConsumePrivate);\n}\n\nfunction preparePublicOrPrivateKey(key) {\n  return prepareAsymmetricKey(key\x2C kConsumePublic);\n}\n\nfunction prepareSecretKey(key\x2C encoding\x2C bufferOnly = false) {\n  if (!bufferOnly) {\n    if (isKeyObject(key)) {\n      if (key.type !== 'secret')\n        throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type\x2C 'secret');\n      return key[kHandle];\n    } else if (isCryptoKey(key)) {\n      if (key.type !== 'secret')\n        throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type\x2C 'secret');\n      return key[kKeyObject][kHandle];\n    }\n  }\n  if (typeof key !== 'string' &&\n      !isArrayBufferView(key) &&\n      !isAnyArrayBuffer(key)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'key'\x2C\n      getKeyTypes(!bufferOnly\x2C bufferOnly)\x2C\n      key);\n  }\n  return getArrayBufferOrView(key\x2C 'key'\x2C encoding);\n}\n\nfunction createSecretKey(key\x2C encoding) {\n  key = prepareSecretKey(key\x2C encoding\x2C true);\n  if (key.byteLength === 0)\n    throw new ERR_OUT_OF_RANGE('key.byteLength'\x2C '> 0'\x2C key.byteLength);\n  const handle = new KeyObjectHandle();\n  handle.init(kKeyTypeSecret\x2C key);\n  return new SecretKeyObject(handle);\n}\n\nfunction createPublicKey(key) {\n  const { format\x2C type\x2C data\x2C passphrase } =\n    prepareAsymmetricKey(key\x2C kCreatePublic);\n  let handle;\n  if (format === 'jwk') {\n    handle = data;\n  } else {\n    handle = new KeyObjectHandle();\n    handle.init(kKeyTypePublic\x2C data\x2C format\x2C type\x2C passphrase);\n  }\n  return new PublicKeyObject(handle);\n}\n\nfunction createPrivateKey(key) {\n  const { format\x2C type\x2C data\x2C passphrase } =\n    prepareAsymmetricKey(key\x2C kCreatePrivate);\n  let handle;\n  if (format === 'jwk') {\n    handle = data;\n  } else {\n    handle = new KeyObjectHandle();\n    handle.init(kKeyTypePrivate\x2C data\x2C format\x2C type\x2C passphrase);\n  }\n  return new PrivateKeyObject(handle);\n}\n\nfunction isKeyObject(obj) {\n  return obj != null && obj[kKeyType] !== undefined;\n}\n\n// Our implementation of CryptoKey is a simple wrapper around a KeyObject\n// that adapts it to the standard interface. This implementation also\n// extends the JSTransferable class\x2C allowing the CryptoKey to be cloned\n// to Workers.\n// TODO(@jasnell): Embedder environments like electron may have issues\n// here similar to other things like URL. A chromium provided CryptoKey\n// will not be recognized as a Node.js CryptoKey\x2C and vice versa. It\n// would be fantastic if we could find a way of making those interop.\nclass CryptoKey extends JSTransferable {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0)\n      return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `CryptoKey ${inspect({\n      type: this.type\x2C\n      extractable: this.extractable\x2C\n      algorithm: this.algorithm\x2C\n      usages: this.usages\n    }\x2C opts)}`;\n  }\n\n  get type() {\n    return this[kKeyObject].type;\n  }\n\n  get extractable() {\n    return this[kExtractable];\n  }\n\n  get algorithm() {\n    return this[kAlgorithm];\n  }\n\n  get usages() {\n    return ArrayFrom(this[kKeyUsages]);\n  }\n\n  [kClone]() {\n    const keyObject = this[kKeyObject];\n    const algorithm = this.algorithm;\n    const extractable = this.extractable;\n    const usages = this.usages;\n\n    return {\n      data: {\n        keyObject\x2C\n        algorithm\x2C\n        usages\x2C\n        extractable\x2C\n      }\x2C\n      deserializeInfo: 'internal/crypto/keys:InternalCryptoKey'\n    };\n  }\n\n  [kDeserialize]({ keyObject\x2C algorithm\x2C usages\x2C extractable }) {\n    this[kKeyObject] = keyObject;\n    this[kAlgorithm] = algorithm;\n    this[kKeyUsages] = usages;\n    this[kExtractable] = extractable;\n  }\n}\n\n// All internal code must use new InternalCryptoKey to create\n// CryptoKey instances. The CryptoKey class is exposed to end\n// user code but is not permitted to be constructed directly.\nclass InternalCryptoKey extends JSTransferable {\n  constructor(\n    keyObject\x2C\n    algorithm\x2C\n    keyUsages\x2C\n    extractable) {\n    super();\n    // Using symbol properties here currently instead of private\n    // properties because (for now) the performance penalty of\n    // private fields is still too high.\n    this[kKeyObject] = keyObject;\n    this[kAlgorithm] = algorithm;\n    this[kExtractable] = extractable;\n    this[kKeyUsages] = keyUsages;\n  }\n}\n\nInternalCryptoKey.prototype.constructor = CryptoKey;\nObjectSetPrototypeOf(InternalCryptoKey.prototype\x2C CryptoKey.prototype);\n\nfunction isCryptoKey(obj) {\n  return obj != null && obj[kKeyObject] !== undefined;\n}\n\nfunction isJwk(obj) {\n  return obj != null && obj.kty !== undefined;\n}\n\nmodule.exports = {\n  // Public API.\n  createSecretKey\x2C\n  createPublicKey\x2C\n  createPrivateKey\x2C\n  KeyObject\x2C\n  CryptoKey\x2C\n  InternalCryptoKey\x2C\n\n  // These are designed for internal use only and should not be exposed.\n  parsePublicKeyEncoding\x2C\n  parsePrivateKeyEncoding\x2C\n  parseKeyEncoding\x2C\n  preparePrivateKey\x2C\n  preparePublicOrPrivateKey\x2C\n  prepareSecretKey\x2C\n  SecretKeyObject\x2C\n  PublicKeyObject\x2C\n  PrivateKeyObject\x2C\n  isKeyObject\x2C\n  isCryptoKey\x2C\n  isJwk\x2C\n};\n
code-source-info,0x29d5d5bbc626,175,0,20682,C0O0C4O20682,,
code-creation,Function,10,92334,0x29d5d5bbdc1e,1232, node:internal/crypto/keys:1:1,0x29d5d5bbc5a0,~
code-source-info,0x29d5d5bbdc1e,175,0,20682,C0O0C264O25C270O38C276O61C282O85C287O109C293O119C299O398C303O398C309O159C315O178C320O208C326O226C332O244C338O263C344O280C350O297C356O314C362O335C368O356C374O376C380O491C384O491C390O436C396O454C402O471C408O764C412O764C418O764C424O547C430O588C436O628C442O656C448O685C454O711C460O738C466O885C470O885C476O803C482O814C488O828C494O852C500O972C504O972C510O929C516O949C522O1061C526O1061C532O1015C537O1033C542O1043C547O1151C551O1151C557O1137C562O1198C566O1198C572O1186C578O1252C582O1252C588O1241C594O1291C602O1291C606O1291C608O1334C616O1334C620O1334C622O1375C630O1375C634O1375C636O1414C644O1414C648O1414C650O1483C651O1483C653O1510C655O1510C657O1535C659O1535C661O1561C663O1561C665O1587C667O1587C669O1607C689O1609C714O1639C739O1686C764O1714C802O1602C833O1602C836O1744C841O1759C848O1767C851O1764C858O1591C929O2232C935O2232C941O2150C948O2166C957O2188C966O2210C975O18072C983O18156C1017O18735C1027O19090C1055O19515C1081O19958C1089O19980C1093O20032C1099O20053C1105O19993C1110O20224C1118O20262C1124O20281C1130O20300C1136O20320C1142O20333C1148O20346C1154O20441C1160O20467C1166O20494C1172O20514C1178O20535C1184O20564C1190O20584C1196O20603C1202O20622C1208O20642C1214O20657C1220O20672C1226O20239C1231O20681,,
tick,0x1bfd70e4c,92375,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x29d5d5bbafdf,0x105108d28,0x10510894c,0x29d5d5bb41df,0x105108d28,0x10510894c,0x29d5d5bad812,0x105108d28,0x10510894c,0x29d5d5b915f4,0x105108d28,0x10510894c,0x29d5d5b8ec0d,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89de,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
new,MemoryChunk,0x2811abd00000,262144
code-creation,LazyCompile,10,92542,0x2cbd764bfeee,252, node:internal/crypto/keys:97:32,0x29d5d5bbcce8,~
code-source-info,0x2cbd764bfeee,175,2259,6186,C0O2259C17O2347C55O3420C88O3969C98O3969C102O3969C104O4031C114O4031C118O4031C120O4373C153O5082C181O5501C209O6113C218O6121C227O6132C236O6149C245O6166C251O6184,,
code-creation,Eval,10,92709,0x2811abd0339e,5, node:internal/crypto/keygen:1:1,0x2811abd02f98,~
script-source,176,node:internal/crypto/keygen,'use strict';\n\nconst {\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperty\x2C\n  SafeArrayIterator\x2C\n} = primordials;\n\nconst {\n  DhKeyPairGenJob\x2C\n  DsaKeyPairGenJob\x2C\n  EcKeyPairGenJob\x2C\n  NidKeyPairGenJob\x2C\n  RsaKeyPairGenJob\x2C\n  SecretKeyGenJob\x2C\n  kCryptoJobAsync\x2C\n  kCryptoJobSync\x2C\n  kKeyVariantRSA_PSS\x2C\n  kKeyVariantRSA_SSA_PKCS1_v1_5\x2C\n  EVP_PKEY_ED25519\x2C\n  EVP_PKEY_ED448\x2C\n  EVP_PKEY_X25519\x2C\n  EVP_PKEY_X448\x2C\n  OPENSSL_EC_NAMED_CURVE\x2C\n  OPENSSL_EC_EXPLICIT_CURVE\x2C\n} = internalBinding('crypto');\n\nconst {\n  PublicKeyObject\x2C\n  PrivateKeyObject\x2C\n  SecretKeyObject\x2C\n  parsePublicKeyEncoding\x2C\n  parsePrivateKeyEncoding\x2C\n  isJwk\n} = require('internal/crypto/keys');\n\nconst {\n  kAesKeyLengths\x2C\n} = require('internal/crypto/util');\n\nconst { customPromisifyArgs } = require('internal/util');\n\nconst {\n  isInt32\x2C\n  isUint32\x2C\n  validateCallback\x2C\n  validateString\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n} = require('internal/validators');\n\nconst {\n  codes: {\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_MISSING_OPTION\x2C\n  }\n} = require('internal/errors');\n\nconst { isArrayBufferView } = require('internal/util/types');\n\nconst { getOptionValue } = require('internal/options');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\nfunction wrapKey(key\x2C ctor) {\n  if (typeof key === 'string' ||\n      isArrayBufferView(key) ||\n      isJwk(key))\n    return key;\n  return new ctor(key);\n}\n\nfunction generateKeyPair(type\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  validateCallback(callback);\n\n  const job = createJob(kCryptoJobAsync\x2C type\x2C options);\n\n  job.ondone = (error\x2C result) => {\n    if (error) return FunctionPrototypeCall(callback\x2C job\x2C error);\n    // If no encoding was chosen\x2C return key objects instead.\n    let { 0: pubkey\x2C 1: privkey } = result;\n    pubkey = wrapKey(pubkey\x2C PublicKeyObject);\n    privkey = wrapKey(privkey\x2C PrivateKeyObject);\n    FunctionPrototypeCall(callback\x2C job\x2C null\x2C pubkey\x2C privkey);\n  };\n\n  job.run();\n}\n\nObjectDefineProperty(generateKeyPair\x2C customPromisifyArgs\x2C {\n  value: ['publicKey'\x2C 'privateKey']\x2C\n  enumerable: false\n});\n\nfunction generateKeyPairSync(type\x2C options) {\n  return handleError(createJob(kCryptoJobSync\x2C type\x2C options).run());\n}\n\nfunction handleError(ret) {\n  if (ret == null)\n    return; // async\n\n  const { 0: err\x2C 1: keys } = ret;\n  if (err !== undefined)\n    throw err;\n\n  const { 0: publicKey\x2C 1: privateKey } = keys;\n\n  // If no encoding was chosen\x2C return key objects instead.\n  return {\n    publicKey: wrapKey(publicKey\x2C PublicKeyObject)\x2C\n    privateKey: wrapKey(privateKey\x2C PrivateKeyObject)\n  };\n}\n\nfunction parseKeyEncoding(keyType\x2C options = {}) {\n  const { publicKeyEncoding\x2C privateKeyEncoding } = options;\n\n  let publicFormat\x2C publicType;\n  if (publicKeyEncoding == null) {\n    publicFormat = publicType = undefined;\n  } else if (typeof publicKeyEncoding === 'object') {\n    ({\n      format: publicFormat\x2C\n      type: publicType\n    } = parsePublicKeyEncoding(publicKeyEncoding\x2C keyType\x2C\n                               'publicKeyEncoding'));\n  } else {\n    throw new ERR_INVALID_ARG_VALUE('options.publicKeyEncoding'\x2C\n                                    publicKeyEncoding);\n  }\n\n  let privateFormat\x2C privateType\x2C cipher\x2C passphrase;\n  if (privateKeyEncoding == null) {\n    privateFormat = privateType = undefined;\n  } else if (typeof privateKeyEncoding === 'object') {\n    ({\n      format: privateFormat\x2C\n      type: privateType\x2C\n      cipher\x2C\n      passphrase\n    } = parsePrivateKeyEncoding(privateKeyEncoding\x2C keyType\x2C\n                                'privateKeyEncoding'));\n  } else {\n    throw new ERR_INVALID_ARG_VALUE('options.privateKeyEncoding'\x2C\n                                    privateKeyEncoding);\n  }\n\n  return [\n    publicFormat\x2C\n    publicType\x2C\n    privateFormat\x2C\n    privateType\x2C\n    cipher\x2C\n    passphrase\x2C\n  ];\n}\n\nfunction createJob(mode\x2C type\x2C options) {\n  validateString(type\x2C 'type');\n\n  const encoding = new SafeArrayIterator(parseKeyEncoding(type\x2C options));\n\n  if (options !== undefined)\n    validateObject(options\x2C 'options');\n\n  switch (type) {\n    case 'rsa':\n    case 'rsa-pss':\n    {\n      validateObject(options\x2C 'options');\n      const { modulusLength } = options;\n      if (!isUint32(modulusLength))\n        throw new ERR_INVALID_ARG_VALUE('options.modulusLength'\x2C modulusLength);\n\n      let { publicExponent } = options;\n      if (publicExponent == null) {\n        publicExponent = 0x10001;\n      } else if (!isUint32(publicExponent)) {\n        throw new ERR_INVALID_ARG_VALUE(\n          'options.publicExponent'\x2C\n          publicExponent);\n      }\n\n      if (type === 'rsa') {\n        return new RsaKeyPairGenJob(\n          mode\x2C\n          kKeyVariantRSA_SSA_PKCS1_v1_5\x2C  // Used also for RSA-OAEP\n          modulusLength\x2C\n          publicExponent\x2C\n          ...encoding);\n      }\n\n      const {\n        hash\x2C mgf1Hash\x2C hashAlgorithm\x2C mgf1HashAlgorithm\x2C saltLength\n      } = options;\n      if (saltLength !== undefined && (!isInt32(saltLength) || saltLength < 0))\n        throw new ERR_INVALID_ARG_VALUE('options.saltLength'\x2C saltLength);\n      if (hashAlgorithm !== undefined && typeof hashAlgorithm !== 'string')\n        throw new ERR_INVALID_ARG_VALUE('options.hashAlgorithm'\x2C hashAlgorithm);\n      if (mgf1HashAlgorithm !== undefined &&\n          typeof mgf1HashAlgorithm !== 'string')\n        throw new ERR_INVALID_ARG_VALUE('options.mgf1HashAlgorithm'\x2C\n                                        mgf1HashAlgorithm);\n      if (hash !== undefined) {\n        pendingDeprecation && process.emitWarning(\n          '"options.hash" is deprecated\x2C ' +\n          'use "options.hashAlgorithm" instead.'\x2C\n          'DeprecationWarning'\x2C\n          'DEP0154');\n        if (typeof hash !== 'string' ||\n          (hashAlgorithm && hash !== hashAlgorithm)) {\n          throw new ERR_INVALID_ARG_VALUE('options.hash'\x2C hash);\n        }\n      }\n      if (mgf1Hash !== undefined) {\n        pendingDeprecation && process.emitWarning(\n          '"options.mgf1Hash" is deprecated\x2C ' +\n          'use "options.mgf1HashAlgorithm" instead.'\x2C\n          'DeprecationWarning'\x2C\n          'DEP0154');\n        if (typeof mgf1Hash !== 'string' ||\n          (mgf1HashAlgorithm && mgf1Hash !== mgf1HashAlgorithm)) {\n          throw new ERR_INVALID_ARG_VALUE('options.mgf1Hash'\x2C mgf1Hash);\n        }\n      }\n\n      return new RsaKeyPairGenJob(\n        mode\x2C\n        kKeyVariantRSA_PSS\x2C\n        modulusLength\x2C\n        publicExponent\x2C\n        hashAlgorithm || hash\x2C\n        mgf1HashAlgorithm || mgf1Hash\x2C\n        saltLength\x2C\n        ...encoding);\n    }\n    case 'dsa':\n    {\n      validateObject(options\x2C 'options');\n      const { modulusLength } = options;\n      if (!isUint32(modulusLength))\n        throw new ERR_INVALID_ARG_VALUE('options.modulusLength'\x2C modulusLength);\n\n      let { divisorLength } = options;\n      if (divisorLength == null) {\n        divisorLength = -1;\n      } else if (!isInt32(divisorLength) || divisorLength < 0) {\n        throw new ERR_INVALID_ARG_VALUE('options.divisorLength'\x2C divisorLength);\n      }\n\n      return new DsaKeyPairGenJob(\n        mode\x2C\n        modulusLength\x2C\n        divisorLength\x2C\n        ...encoding);\n    }\n    case 'ec':\n    {\n      validateObject(options\x2C 'options');\n      const { namedCurve } = options;\n      if (typeof namedCurve !== 'string')\n        throw new ERR_INVALID_ARG_VALUE('options.namedCurve'\x2C namedCurve);\n      let { paramEncoding } = options;\n      if (paramEncoding == null || paramEncoding === 'named')\n        paramEncoding = OPENSSL_EC_NAMED_CURVE;\n      else if (paramEncoding === 'explicit')\n        paramEncoding = OPENSSL_EC_EXPLICIT_CURVE;\n      else\n        throw new ERR_INVALID_ARG_VALUE('options.paramEncoding'\x2C paramEncoding);\n\n      return new EcKeyPairGenJob(\n        mode\x2C\n        namedCurve\x2C\n        paramEncoding\x2C\n        ...encoding);\n    }\n    case 'ed25519':\n    case 'ed448':\n    case 'x25519':\n    case 'x448':\n    {\n      let id;\n      switch (type) {\n        case 'ed25519':\n          id = EVP_PKEY_ED25519;\n          break;\n        case 'ed448':\n          id = EVP_PKEY_ED448;\n          break;\n        case 'x25519':\n          id = EVP_PKEY_X25519;\n          break;\n        case 'x448':\n          id = EVP_PKEY_X448;\n          break;\n      }\n      return new NidKeyPairGenJob(mode\x2C id\x2C ...encoding);\n    }\n    case 'dh':\n    {\n      validateObject(options\x2C 'options');\n      const { group\x2C primeLength\x2C prime\x2C generator } = options;\n      if (group != null) {\n        if (prime != null)\n          throw new ERR_INCOMPATIBLE_OPTION_PAIR('group'\x2C 'prime');\n        if (primeLength != null)\n          throw new ERR_INCOMPATIBLE_OPTION_PAIR('group'\x2C 'primeLength');\n        if (generator != null)\n          throw new ERR_INCOMPATIBLE_OPTION_PAIR('group'\x2C 'generator');\n        if (typeof group !== 'string')\n          throw new ERR_INVALID_ARG_VALUE('options.group'\x2C group);\n\n        return new DhKeyPairGenJob(mode\x2C group\x2C ...encoding);\n      }\n\n      if (prime != null) {\n        if (primeLength != null)\n          throw new ERR_INCOMPATIBLE_OPTION_PAIR('prime'\x2C 'primeLength');\n        if (!isArrayBufferView(prime))\n          throw new ERR_INVALID_ARG_VALUE('options.prime'\x2C prime);\n      } else if (primeLength != null) {\n        if (!isInt32(primeLength) || primeLength < 0)\n          throw new ERR_INVALID_ARG_VALUE('options.primeLength'\x2C primeLength);\n      } else {\n        throw new ERR_MISSING_OPTION(\n          'At least one of the group\x2C prime\x2C or primeLength options');\n      }\n\n      if (generator != null) {\n        if (!isInt32(generator) || generator < 0)\n          throw new ERR_INVALID_ARG_VALUE('options.generator'\x2C generator);\n      }\n      return new DhKeyPairGenJob(\n        mode\x2C\n        prime != null ? prime : primeLength\x2C\n        generator == null ? 2 : generator\x2C\n        ...encoding);\n    }\n    default:\n      // Fall through\n  }\n  throw new ERR_INVALID_ARG_VALUE('type'\x2C type\x2C 'must be a supported key type');\n}\n\n// Symmetric Key Generation\n\nfunction generateKeyJob(mode\x2C keyType\x2C options) {\n  validateString(keyType\x2C 'type');\n  validateObject(options\x2C 'options');\n  const { length } = options;\n  switch (keyType) {\n    case 'hmac':\n      validateInteger(length\x2C 'options.length'\x2C 1\x2C 2 ** 31 - 1);\n      break;\n    case 'aes':\n      validateOneOf(length\x2C 'options.length'\x2C kAesKeyLengths);\n      break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE(\n        'type'\x2C\n        keyType\x2C\n        'must be a supported key type');\n  }\n\n  return new SecretKeyGenJob(mode\x2C length);\n}\n\nfunction handleGenerateKeyError(ret) {\n  if (ret === undefined)\n    return; // async\n\n  const { 0: err\x2C 1: key } = ret;\n  if (err !== undefined)\n    throw err;\n\n  return wrapKey(key\x2C SecretKeyObject);\n}\n\nfunction generateKey(type\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  validateCallback(callback);\n\n  const job = generateKeyJob(kCryptoJobAsync\x2C type\x2C options);\n\n  job.ondone = (error\x2C key) => {\n    if (error) return FunctionPrototypeCall(callback\x2C job\x2C error);\n    FunctionPrototypeCall(callback\x2C job\x2C null\x2C wrapKey(key\x2C SecretKeyObject));\n  };\n\n  handleGenerateKeyError(job.run());\n}\n\nfunction generateKeySync(type\x2C options) {\n  return handleGenerateKeyError(\n    generateKeyJob(kCryptoJobSync\x2C type\x2C options).run());\n}\n\nmodule.exports = {\n  generateKeyPair\x2C\n  generateKeyPairSync\x2C\n  generateKey\x2C\n  generateKeySync\x2C\n};\n
code-source-info,0x2811abd0339e,176,0,11480,C0O0C4O11480,,
code-creation,Function,10,93125,0x2811abd03a16,538, node:internal/crypto/keygen:1:1,0x2811abd03318,~
code-source-info,0x2811abd03a16,176,0,11480,C0O0C176O25C182O50C187O74C193O461C196O461C201O121C207O140C213O160C219O179C225O199C231O219C237O238C243O257C249O275C255O297C261O330C267O350C273O368C279O387C285O404C291O430C297O620C300O620C305O499C311O518C317O538C323O557C329O583C335O610C341O684C344O684C349O664C355O750C358O750C363O726C368O904C371O904C376O787C382O798C388O810C394O830C400O848C406O867C412O885C418O1049C421O1049C426O1049C431O960C437O994C443O1021C449O1108C452O1108C457O1086C463O1168C466O1168C471O1149C476O1224C479O1224C483O1224C485O2086C496O2048C501O11382C508O11403C514O11422C520O11445C526O11460C532O11397C537O11479,,
code-creation,Eval,10,93375,0x2811abd055b6,5, node:internal/crypto/diffiehellman:1:1,0x2811abd050d0,~
script-source,177,node:internal/crypto/diffiehellman,'use strict';\n\nconst {\n  ArrayBufferPrototypeSlice\x2C\n  FunctionPrototypeCall\x2C\n  MathFloor\x2C\n  ObjectDefineProperty\x2C\n  Promise\x2C\n  SafeSet\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\n\nconst {\n  DHBitsJob\x2C\n  DHKeyExportJob\x2C\n  DiffieHellman: _DiffieHellman\x2C\n  DiffieHellmanGroup: _DiffieHellmanGroup\x2C\n  ECDH: _ECDH\x2C\n  ECDHBitsJob\x2C\n  ECDHConvertKey: _ECDHConvertKey\x2C\n  statelessDH\x2C\n  kCryptoJobAsync\x2C\n} = internalBinding('crypto');\n\nconst {\n  codes: {\n    ERR_CRYPTO_ECDH_INVALID_FORMAT\x2C\n    ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY\x2C\n    ERR_CRYPTO_INCOMPATIBLE_KEY\x2C\n    ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  validateCallback\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst {\n  isArrayBufferView\x2C\n  isAnyArrayBuffer\x2C\n} = require('internal/util/types');\n\nconst {\n  lazyDOMException\x2C\n} = require('internal/util');\n\nconst {\n  KeyObject\x2C\n  InternalCryptoKey\x2C\n  createPrivateKey\x2C\n  createPublicKey\x2C\n  isCryptoKey\x2C\n  isKeyObject\x2C\n} = require('internal/crypto/keys');\n\nconst {\n  generateKeyPair\x2C\n} = require('internal/crypto/keygen');\n\nconst {\n  getArrayBufferOrView\x2C\n  getDefaultEncoding\x2C\n  getUsagesUnion\x2C\n  hasAnyNotIn\x2C\n  jobPromise\x2C\n  toBuf\x2C\n  kHandle\x2C\n  kKeyObject\x2C\n} = require('internal/crypto/util');\n\nconst {\n  crypto: {\n    POINT_CONVERSION_COMPRESSED\x2C\n    POINT_CONVERSION_HYBRID\x2C\n    POINT_CONVERSION_UNCOMPRESSED\x2C\n  }\n} = internalBinding('constants');\n\nconst DH_GENERATOR = 2;\n\nfunction DiffieHellman(sizeOrKey\x2C keyEncoding\x2C generator\x2C genEncoding) {\n  if (!(this instanceof DiffieHellman))\n    return new DiffieHellman(sizeOrKey\x2C keyEncoding\x2C generator\x2C genEncoding);\n\n  if (typeof sizeOrKey !== 'number' &&\n      typeof sizeOrKey !== 'string' &&\n      !isArrayBufferView(sizeOrKey) &&\n      !isAnyArrayBuffer(sizeOrKey)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'sizeOrKey'\x2C\n      ['number'\x2C 'string'\x2C 'ArrayBuffer'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n      sizeOrKey\n    );\n  }\n\n  // Sizes < 0 don't make sense but they _are_ accepted (and subsequently\n  // rejected with ERR_OSSL_BN_BITS_TOO_SMALL) by OpenSSL. The glue code\n  // in node_crypto.cc accepts values that are IsInt32() for that reason\n  // and that's why we do that here too.\n  if (typeof sizeOrKey === 'number')\n    validateInt32(sizeOrKey\x2C 'sizeOrKey');\n\n  if (keyEncoding && !Buffer.isEncoding(keyEncoding) &&\n      keyEncoding !== 'buffer') {\n    genEncoding = generator;\n    generator = keyEncoding;\n    keyEncoding = false;\n  }\n\n  const encoding = getDefaultEncoding();\n  keyEncoding = keyEncoding || encoding;\n  genEncoding = genEncoding || encoding;\n\n  if (typeof sizeOrKey !== 'number')\n    sizeOrKey = toBuf(sizeOrKey\x2C keyEncoding);\n\n  if (!generator) {\n    generator = DH_GENERATOR;\n  } else if (typeof generator === 'number') {\n    validateInt32(generator\x2C 'generator');\n  } else if (typeof generator === 'string') {\n    generator = toBuf(generator\x2C genEncoding);\n  } else if (!isArrayBufferView(generator) && !isAnyArrayBuffer(generator)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'generator'\x2C\n      ['number'\x2C 'string'\x2C 'ArrayBuffer'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n      generator\n    );\n  }\n\n\n  this[kHandle] = new _DiffieHellman(sizeOrKey\x2C generator);\n  ObjectDefineProperty(this\x2C 'verifyError'\x2C {\n    enumerable: true\x2C\n    value: this[kHandle].verifyError\x2C\n    writable: false\n  });\n}\n\n\nfunction DiffieHellmanGroup(name) {\n  if (!(this instanceof DiffieHellmanGroup))\n    return new DiffieHellmanGroup(name);\n  this[kHandle] = new _DiffieHellmanGroup(name);\n  ObjectDefineProperty(this\x2C 'verifyError'\x2C {\n    enumerable: true\x2C\n    value: this[kHandle].verifyError\x2C\n    writable: false\n  });\n}\n\n\nDiffieHellmanGroup.prototype.generateKeys =\n    DiffieHellman.prototype.generateKeys =\n    dhGenerateKeys;\n\nfunction dhGenerateKeys(encoding) {\n  const keys = this[kHandle].generateKeys();\n  encoding = encoding || getDefaultEncoding();\n  return encode(keys\x2C encoding);\n}\n\n\nDiffieHellmanGroup.prototype.computeSecret =\n    DiffieHellman.prototype.computeSecret =\n    dhComputeSecret;\n\nfunction dhComputeSecret(key\x2C inEnc\x2C outEnc) {\n  const encoding = getDefaultEncoding();\n  inEnc = inEnc || encoding;\n  outEnc = outEnc || encoding;\n  key = getArrayBufferOrView(key\x2C 'key'\x2C inEnc);\n  const ret = this[kHandle].computeSecret(key);\n  if (typeof ret === 'string')\n    throw new ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY();\n  return encode(ret\x2C outEnc);\n}\n\n\nDiffieHellmanGroup.prototype.getPrime =\n    DiffieHellman.prototype.getPrime =\n    dhGetPrime;\n\nfunction dhGetPrime(encoding) {\n  const prime = this[kHandle].getPrime();\n  encoding = encoding || getDefaultEncoding();\n  return encode(prime\x2C encoding);\n}\n\n\nDiffieHellmanGroup.prototype.getGenerator =\n    DiffieHellman.prototype.getGenerator =\n    dhGetGenerator;\n\nfunction dhGetGenerator(encoding) {\n  const generator = this[kHandle].getGenerator();\n  encoding = encoding || getDefaultEncoding();\n  return encode(generator\x2C encoding);\n}\n\n\nDiffieHellmanGroup.prototype.getPublicKey =\n    DiffieHellman.prototype.getPublicKey =\n    dhGetPublicKey;\n\nfunction dhGetPublicKey(encoding) {\n  const key = this[kHandle].getPublicKey();\n  encoding = encoding || getDefaultEncoding();\n  return encode(key\x2C encoding);\n}\n\n\nDiffieHellmanGroup.prototype.getPrivateKey =\n    DiffieHellman.prototype.getPrivateKey =\n    dhGetPrivateKey;\n\nfunction dhGetPrivateKey(encoding) {\n  const key = this[kHandle].getPrivateKey();\n  encoding = encoding || getDefaultEncoding();\n  return encode(key\x2C encoding);\n}\n\n\nDiffieHellman.prototype.setPublicKey = function setPublicKey(key\x2C encoding) {\n  encoding = encoding || getDefaultEncoding();\n  key = getArrayBufferOrView(key\x2C 'key'\x2C encoding);\n  this[kHandle].setPublicKey(key);\n  return this;\n};\n\n\nDiffieHellman.prototype.setPrivateKey = function setPrivateKey(key\x2C encoding) {\n  encoding = encoding || getDefaultEncoding();\n  key = getArrayBufferOrView(key\x2C 'key'\x2C encoding);\n  this[kHandle].setPrivateKey(key);\n  return this;\n};\n\n\nfunction ECDH(curve) {\n  if (!(this instanceof ECDH))\n    return new ECDH(curve);\n\n  validateString(curve\x2C 'curve');\n  this[kHandle] = new _ECDH(curve);\n}\n\nECDH.prototype.computeSecret = DiffieHellman.prototype.computeSecret;\nECDH.prototype.setPrivateKey = DiffieHellman.prototype.setPrivateKey;\nECDH.prototype.setPublicKey = DiffieHellman.prototype.setPublicKey;\nECDH.prototype.getPrivateKey = DiffieHellman.prototype.getPrivateKey;\n\nECDH.prototype.generateKeys = function generateKeys(encoding\x2C format) {\n  this[kHandle].generateKeys();\n\n  return this.getPublicKey(encoding\x2C format);\n};\n\nECDH.prototype.getPublicKey = function getPublicKey(encoding\x2C format) {\n  const f = getFormat(format);\n  const key = this[kHandle].getPublicKey(f);\n  encoding = encoding || getDefaultEncoding();\n  return encode(key\x2C encoding);\n};\n\nECDH.convertKey = function convertKey(key\x2C curve\x2C inEnc\x2C outEnc\x2C format) {\n  validateString(curve\x2C 'curve');\n  const encoding = inEnc || getDefaultEncoding();\n  key = getArrayBufferOrView(key\x2C 'key'\x2C encoding);\n  outEnc = outEnc || encoding;\n  const f = getFormat(format);\n  const convertedKey = _ECDHConvertKey(key\x2C curve\x2C f);\n  return encode(convertedKey\x2C outEnc);\n};\n\nfunction encode(buffer\x2C encoding) {\n  if (encoding && encoding !== 'buffer')\n    buffer = buffer.toString(encoding);\n  return buffer;\n}\n\nfunction getFormat(format) {\n  if (format) {\n    if (format === 'compressed')\n      return POINT_CONVERSION_COMPRESSED;\n    if (format === 'hybrid')\n      return POINT_CONVERSION_HYBRID;\n    if (format !== 'uncompressed')\n      throw new ERR_CRYPTO_ECDH_INVALID_FORMAT(format);\n  }\n  return POINT_CONVERSION_UNCOMPRESSED;\n}\n\nconst dhEnabledKeyTypes = new SafeSet(['dh'\x2C 'ec'\x2C 'x448'\x2C 'x25519']);\n\nfunction diffieHellman(options) {\n  validateObject(options\x2C 'options');\n\n  const { privateKey\x2C publicKey } = options;\n  if (!(privateKey instanceof KeyObject))\n    throw new ERR_INVALID_ARG_VALUE('options.privateKey'\x2C privateKey);\n\n  if (!(publicKey instanceof KeyObject))\n    throw new ERR_INVALID_ARG_VALUE('options.publicKey'\x2C publicKey);\n\n  if (privateKey.type !== 'private')\n    throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(privateKey.type\x2C 'private');\n\n  if (publicKey.type !== 'public' && publicKey.type !== 'private') {\n    throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(publicKey.type\x2C\n                                                 'private or public');\n  }\n\n  const privateType = privateKey.asymmetricKeyType;\n  const publicType = publicKey.asymmetricKeyType;\n  if (privateType !== publicType || !dhEnabledKeyTypes.has(privateType)) {\n    throw new ERR_CRYPTO_INCOMPATIBLE_KEY('key types for Diffie-Hellman'\x2C\n                                          `${privateType} and ${publicType}`);\n  }\n\n  return statelessDH(privateKey[kHandle]\x2C publicKey[kHandle]);\n}\n\n// The deriveBitsECDH function is part of the Web Crypto API and serves both\n// deriveKeys and deriveBits functions.\nfunction deriveBitsECDH(name\x2C publicKey\x2C privateKey\x2C callback) {\n  validateString(name\x2C 'name');\n  validateObject(publicKey\x2C 'publicKey');\n  validateObject(privateKey\x2C 'privateKey');\n  validateCallback(callback);\n  const job = new ECDHBitsJob(kCryptoJobAsync\x2C name\x2C publicKey\x2C privateKey);\n  job.ondone = (error\x2C bits) => {\n    if (error) return FunctionPrototypeCall(callback\x2C job\x2C error);\n    FunctionPrototypeCall(callback\x2C job\x2C null\x2C bits);\n  };\n  job.run();\n}\n\n// The deriveBitsDH function is part of the Web Crypto API and serves both\n// deriveKeys and deriveBits functions.\nfunction deriveBitsDH(publicKey\x2C privateKey\x2C callback) {\n  validateObject(publicKey\x2C 'publicKey');\n  validateObject(privateKey\x2C 'privateKey');\n  validateCallback(callback);\n  const job = new DHBitsJob(kCryptoJobAsync\x2C publicKey\x2C privateKey);\n  job.ondone = (error\x2C bits) => {\n    if (error) return FunctionPrototypeCall(callback\x2C job\x2C error);\n    FunctionPrototypeCall(callback\x2C job\x2C null\x2C bits);\n  };\n  job.run();\n}\n\nfunction verifyAcceptableDhKeyUse(name\x2C type\x2C usages) {\n  let checkSet;\n  switch (type) {\n    case 'private':\n      checkSet = ['deriveBits'\x2C 'deriveKey'];\n      break;\n    case 'public':\n      checkSet = [];\n      break;\n  }\n  if (hasAnyNotIn(usages\x2C checkSet)) {\n    throw lazyDOMException(\n      `Unsupported key usage for an ${name} key`\x2C\n      'SyntaxError');\n  }\n}\n\nasync function dhGenerateKey(\n  algorithm\x2C\n  extractable\x2C\n  keyUsages) {\n  const usageSet = new SafeSet(keyUsages);\n\n  if (hasAnyNotIn(usageSet\x2C ['deriveKey'\x2C 'deriveBits'])) {\n    throw lazyDOMException(\n      'Unsupported key usage for a DH key'\x2C\n      'SyntaxError');\n  }\n\n  const {\n    name\x2C\n    primeLength\x2C\n    generator\x2C\n    group\n  } = algorithm;\n  let { prime } = algorithm;\n\n  if (prime !== undefined)\n    prime = getArrayBufferOrView(prime);\n\n  return new Promise((resolve\x2C reject) => {\n    generateKeyPair('dh'\x2C {\n      prime\x2C\n      primeLength\x2C\n      generator\x2C\n      group\x2C\n    }\x2C (err\x2C pubKey\x2C privKey) => {\n      if (err) {\n        return reject(lazyDOMException(\n          'The operation failed for an operation-specific reason'\x2C\n          'OperationError'));\n      }\n\n      const algorithm = { name\x2C prime\x2C primeLength\x2C generator\x2C group };\n\n      const publicKey = new InternalCryptoKey(pubKey\x2C algorithm\x2C []\x2C true);\n\n      const privateKey =\n        new InternalCryptoKey(\n          privKey\x2C\n          algorithm\x2C\n          getUsagesUnion(usageSet\x2C 'deriveBits'\x2C 'deriveKey')\x2C\n          extractable);\n\n      resolve({ publicKey\x2C privateKey });\n    });\n  });\n}\n\nasync function asyncDeriveBitsECDH(algorithm\x2C baseKey\x2C length) {\n  const { 'public': key } = algorithm;\n\n  // Null means that we're not asking for a specific number of bits\x2C just\n  // give us everything that is generated.\n  if (length !== null)\n    validateUint32(length\x2C 'length');\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE('algorithm.public'\x2C 'CryptoKey'\x2C key);\n\n  if (key.type !== 'public') {\n    throw lazyDOMException(\n      'algorithm.public must be a public key'\x2C 'InvalidAccessError');\n  }\n  if (baseKey.type !== 'private') {\n    throw lazyDOMException(\n      'baseKey must be a private key'\x2C 'InvalidAccessError');\n  }\n\n  if (key.algorithm.name !== 'ECDH') {\n    throw lazyDOMException('Keys must be ECDH keys'\x2C 'InvalidAccessError');\n  }\n\n  if (key.algorithm.name !== baseKey.algorithm.name) {\n    throw lazyDOMException(\n      'The public and private keys must be of the same type'\x2C\n      'InvalidAccessError');\n  }\n\n  if (key.algorithm.namedCurve !== baseKey.algorithm.namedCurve)\n    throw lazyDOMException('Named curve mismatch'\x2C 'InvalidAccessError');\n\n  const bits = await new Promise((resolve\x2C reject) => {\n    deriveBitsECDH(\n      baseKey.algorithm.namedCurve\x2C\n      key[kKeyObject][kHandle]\x2C\n      baseKey[kKeyObject][kHandle]\x2C (err\x2C bits) => {\n        if (err) return reject(err);\n        resolve(bits);\n      });\n  });\n\n  // If a length is not specified\x2C return the full derived secret\n  if (length === null)\n    return bits;\n\n  // If the length is not a multiple of 8\x2C it will be truncated\n  // down to the nearest multiple of 8.\n  length = MathFloor(length / 8);\n  const { byteLength } = bits;\n\n  // If the length is larger than the derived secret\x2C throw.\n  // Otherwise\x2C we either return the secret or a truncated\n  // slice.\n  if (byteLength < length)\n    throw lazyDOMException('derived bit length is too small'\x2C 'OperationError');\n\n  return length === byteLength ?\n    bits :\n    ArrayBufferPrototypeSlice(bits\x2C 0\x2C length);\n}\n\nasync function asyncDeriveBitsDH(algorithm\x2C baseKey\x2C length) {\n  const { 'public': key } = algorithm;\n  // Null has a specific meaning for DH\n  if (length !== null)\n    validateUint32(length\x2C 'length');\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE('algorithm.public'\x2C 'CryptoKey'\x2C key);\n\n  if (key.type !== 'public') {\n    throw lazyDOMException(\n      'algorithm.public must be a public key'\x2C 'InvalidAccessError');\n  }\n  if (baseKey.type !== 'private') {\n    throw lazyDOMException(\n      'baseKey must be a private key'\x2C 'InvalidAccessError');\n  }\n\n  if (key.algorithm.name !== 'NODE-DH')\n    throw lazyDOMException('Keys must be DH keys'\x2C 'InvalidAccessError');\n\n  if (key.algorithm.name !== baseKey.algorithm.name) {\n    throw lazyDOMException(\n      'The public and private keys must be of the same type'\x2C\n      'InvalidAccessError');\n  }\n\n  const bits = await new Promise((resolve\x2C reject) => {\n    deriveBitsDH(\n      key[kKeyObject][kHandle]\x2C\n      baseKey[kKeyObject][kHandle]\x2C (err\x2C bits) => {\n        if (err) return reject(err);\n        resolve(bits);\n      });\n  });\n\n  // If a length is not specified\x2C return the full derived secret\n  if (length === null)\n    return bits;\n\n  // If the length is not a multiple of 8\x2C it will be truncated\n  // down to the nearest multiple of 8.\n  length = MathFloor(length / 8);\n  const { byteLength } = bits;\n\n  // If the length is larger than the derived secret\x2C throw.\n  // Otherwise\x2C we either return the secret or a truncated\n  // slice.\n  if (byteLength < length)\n    throw lazyDOMException('derived bit length is too small'\x2C 'OperationError');\n\n  return length === byteLength ?\n    bits :\n    ArrayBufferPrototypeSlice(bits\x2C 0\x2C length);\n}\n\nfunction dhExportKey(key\x2C format) {\n  return jobPromise(new DHKeyExportJob(\n    kCryptoJobAsync\x2C\n    format\x2C\n    key[kKeyObject][kHandle]));\n}\n\nasync function dhImportKey(\n  format\x2C\n  keyData\x2C\n  algorithm\x2C\n  extractable\x2C\n  keyUsages) {\n  const usagesSet = new SafeSet(keyUsages);\n  let keyObject;\n  switch (format) {\n    case 'node.keyObject': {\n      if (!isKeyObject(keyData))\n        throw new ERR_INVALID_ARG_TYPE('keyData'\x2C 'KeyObject'\x2C keyData);\n      if (keyData.type === 'secret')\n        throw lazyDOMException('Invalid key type'\x2C 'InvalidAccessException');\n      verifyAcceptableDhKeyUse(algorithm.name\x2C keyData.type\x2C usagesSet);\n      keyObject = keyData;\n      break;\n    }\n    case 'spki': {\n      verifyAcceptableDhKeyUse(algorithm.name\x2C 'public'\x2C usagesSet);\n      keyObject = createPublicKey({\n        key: keyData\x2C\n        format: 'der'\x2C\n        type: 'spki'\n      });\n      break;\n    }\n    case 'pkcs8': {\n      verifyAcceptableDhKeyUse(algorithm.name\x2C 'private'\x2C usagesSet);\n      keyObject = createPrivateKey({\n        key: keyData\x2C\n        format: 'der'\x2C\n        type: 'pkcs8'\n      });\n      break;\n    }\n    default:\n      throw lazyDOMException(\n        `Unable to import DH key with format ${format}`\x2C\n        'NotSupportedError');\n  }\n\n  const {\n    prime\x2C\n    primeLength\x2C\n    generator\x2C\n    group\x2C\n  } = keyObject[kHandle].keyDetail({});\n\n  return new InternalCryptoKey(keyObject\x2C {\n    name: algorithm.name\x2C\n    prime\x2C\n    primeLength\x2C\n    generator\x2C\n    group\x2C\n  }\x2C keyUsages\x2C extractable);\n}\n\nmodule.exports = {\n  DiffieHellman\x2C\n  DiffieHellmanGroup\x2C\n  ECDH\x2C\n  diffieHellman\x2C\n  deriveBitsECDH\x2C\n  deriveBitsDH\x2C\n  dhGenerateKey\x2C\n  asyncDeriveBitsECDH\x2C\n  asyncDeriveBitsDH\x2C\n  dhExportKey\x2C\n  dhImportKey\x2C\n};\n
code-source-info,0x2811abd055b6,177,0,16942,C0O0C4O16942,,
code-creation,Function,10,94042,0x2811abd0625e,1080, node:internal/crypto/diffiehellman:1:1,0x2811abd05530,~
code-source-info,0x2811abd0625e,177,0,16942,C0O0C263O25C269O54C275O79C281O92C287O116C293O127C299O173C302O173C307O162C313O411C316O411C321O203C327O216C333O249C339O287C345O316C351O325C357O356C363O375C369O390C375O668C378O668C383O668C388O462C394O498C400O538C406O571C412O611C418O637C424O800C427O800C432O707C438O727C444O744C450O762C456O780C462O886C465O886C470O843C476O864C482O951C485O951C490O929C496O1093C499O1093C504O988C510O1001C516O1022C522O1042C528O1061C534O1076C540O1158C543O1158C548O1137C554O1333C557O1333C562O1204C568O1228C574O1250C580O1268C586O1283C592O1297C598O1306C604O1317C610O1492C613O1492C618O1492C623O1391C629O1424C635O1453C641O1544C643O1544C645O3762C648O3781C656O3824C663O3847C669O3804C673O4035C676O4054C684O4098C691O4122C697O4078C701O4508C704O4527C712O4566C719O4585C725O4546C729O4763C732O4782C740O4825C747O4848C753O4805C757O5046C760O5065C768O5108C775O5131C781O5088C785O5317C788O5336C796O5380C803O5404C809O5360C813O5593C816O5607C825O5630C829O5825C832O5839C841O5863C845O6216C848O6221C856O6261C861O6271C865O6245C869O6286C872O6291C880O6331C885O6341C889O6315C893O6356C896O6361C904O6400C909O6410C913O6384C917O6424C920O6429C928O6469C933O6479C937O6453C941O6495C944O6500C953O6523C957O6650C960O6655C969O6678C973O6881C980O6897C984O7740C994O7740C999O7740C1001O16731C1008O16752C1014O16769C1020O16791C1026O16799C1032O16816C1038O16834C1044O16850C1050O16867C1056O16890C1062O16911C1068O16926C1074O16746C1079O16941,,
tick,0x1bfc38210,94084,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x29d5d5bb4245,0x105108d28,0x10510894c,0x29d5d5bad812,0x105108d28,0x10510894c,0x29d5d5b915f4,0x105108d28,0x10510894c,0x29d5d5b8ec0d,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89de,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,94250,0x2811abd0891e,5, node:internal/crypto/cipher:1:1,0x2811abd085c8,~
script-source,178,node:internal/crypto/cipher,'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst {\n  CipherBase\x2C\n  privateDecrypt: _privateDecrypt\x2C\n  privateEncrypt: _privateEncrypt\x2C\n  publicDecrypt: _publicDecrypt\x2C\n  publicEncrypt: _publicEncrypt\x2C\n  getCipherInfo: _getCipherInfo\x2C\n} = internalBinding('crypto');\n\nconst {\n  crypto: {\n    RSA_PKCS1_OAEP_PADDING\x2C\n    RSA_PKCS1_PADDING\x2C\n  }\n} = internalBinding('constants');\n\nconst {\n  codes: {\n    ERR_CRYPTO_INVALID_STATE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  validateEncoding\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst {\n  preparePrivateKey\x2C\n  preparePublicOrPrivateKey\x2C\n  prepareSecretKey\x2C\n} = require('internal/crypto/keys');\n\nconst {\n  getDefaultEncoding\x2C\n  getArrayBufferOrView\x2C\n  getStringOption\x2C\n  kHandle\x2C\n} = require('internal/crypto/util');\n\nconst {\n  isArrayBufferView\x2C\n} = require('internal/util/types');\n\nconst assert = require('internal/assert');\n\nconst LazyTransform = require('internal/streams/lazy_transform');\n\nconst { normalizeEncoding } = require('internal/util');\n\nconst { StringDecoder } = require('string_decoder');\n\nfunction rsaFunctionFor(method\x2C defaultPadding\x2C keyType) {\n  return (options\x2C buffer) => {\n    const { format\x2C type\x2C data\x2C passphrase } =\n      keyType === 'private' ?\n        preparePrivateKey(options) :\n        preparePublicOrPrivateKey(options);\n    const padding = options.padding || defaultPadding;\n    const { oaepHash\x2C encoding } = options;\n    let { oaepLabel } = options;\n    if (oaepHash !== undefined)\n      validateString(oaepHash\x2C 'key.oaepHash');\n    if (oaepLabel !== undefined)\n      oaepLabel = getArrayBufferOrView(oaepLabel\x2C 'key.oaepLabel'\x2C encoding);\n    buffer = getArrayBufferOrView(buffer\x2C 'buffer'\x2C encoding);\n    return method(data\x2C format\x2C type\x2C passphrase\x2C buffer\x2C padding\x2C oaepHash\x2C\n                  oaepLabel);\n  };\n}\n\nconst publicEncrypt = rsaFunctionFor(_publicEncrypt\x2C RSA_PKCS1_OAEP_PADDING\x2C\n                                     'public');\nconst publicDecrypt = rsaFunctionFor(_publicDecrypt\x2C RSA_PKCS1_PADDING\x2C\n                                     'public');\nconst privateEncrypt = rsaFunctionFor(_privateEncrypt\x2C RSA_PKCS1_PADDING\x2C\n                                      'private');\nconst privateDecrypt = rsaFunctionFor(_privateDecrypt\x2C RSA_PKCS1_OAEP_PADDING\x2C\n                                      'private');\n\nfunction getDecoder(decoder\x2C encoding) {\n  encoding = normalizeEncoding(encoding);\n  decoder = decoder || new StringDecoder(encoding);\n  assert(decoder.encoding === encoding\x2C 'Cannot change encoding');\n  return decoder;\n}\n\nfunction getUIntOption(options\x2C key) {\n  let value;\n  if (options && (value = options[key]) != null) {\n    if (value >>> 0 !== value)\n      throw new ERR_INVALID_ARG_VALUE(`options.${key}`\x2C value);\n    return value;\n  }\n  return -1;\n}\n\nfunction createCipherBase(cipher\x2C credential\x2C options\x2C decipher\x2C iv) {\n  const authTagLength = getUIntOption(options\x2C 'authTagLength');\n  this[kHandle] = new CipherBase(decipher);\n  if (iv === undefined) {\n    this[kHandle].init(cipher\x2C credential\x2C authTagLength);\n  } else {\n    this[kHandle].initiv(cipher\x2C credential\x2C iv\x2C authTagLength);\n  }\n  this._decoder = null;\n\n  ReflectApply(LazyTransform\x2C this\x2C [options]);\n}\n\nfunction createCipher(cipher\x2C password\x2C options\x2C decipher) {\n  validateString(cipher\x2C 'cipher');\n  password = getArrayBufferOrView(password\x2C 'password');\n\n  ReflectApply(createCipherBase\x2C this\x2C [cipher\x2C password\x2C options\x2C decipher]);\n}\n\nfunction createCipherWithIV(cipher\x2C key\x2C options\x2C decipher\x2C iv) {\n  validateString(cipher\x2C 'cipher');\n  const encoding = getStringOption(options\x2C 'encoding');\n  key = prepareSecretKey(key\x2C encoding);\n  iv = iv === null ? null : getArrayBufferOrView(iv\x2C 'iv');\n  ReflectApply(createCipherBase\x2C this\x2C [cipher\x2C key\x2C options\x2C decipher\x2C iv]);\n}\n\n// The Cipher class is part of the legacy Node.js crypto API. It exposes\n// a stream-based encryption/decryption model. For backwards compatibility\n// the Cipher class is defined using the legacy function syntax rather than\n// ES6 classes.\n\nfunction Cipher(cipher\x2C password\x2C options) {\n  if (!(this instanceof Cipher))\n    return new Cipher(cipher\x2C password\x2C options);\n\n  ReflectApply(createCipher\x2C this\x2C [cipher\x2C password\x2C options\x2C true]);\n}\n\nObjectSetPrototypeOf(Cipher.prototype\x2C LazyTransform.prototype);\nObjectSetPrototypeOf(Cipher\x2C LazyTransform);\n\nCipher.prototype._transform = function _transform(chunk\x2C encoding\x2C callback) {\n  this.push(this[kHandle].update(chunk\x2C encoding));\n  callback();\n};\n\nCipher.prototype._flush = function _flush(callback) {\n  try {\n    this.push(this[kHandle].final());\n  } catch (e) {\n    callback(e);\n    return;\n  }\n  callback();\n};\n\nCipher.prototype.update = function update(data\x2C inputEncoding\x2C outputEncoding) {\n  const encoding = getDefaultEncoding();\n  inputEncoding = inputEncoding || encoding;\n  outputEncoding = outputEncoding || encoding;\n\n  if (typeof data === 'string') {\n    validateEncoding(data\x2C inputEncoding);\n  } else if (!isArrayBufferView(data)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'data'\x2C ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C data);\n  }\n\n  const ret = this[kHandle].update(data\x2C inputEncoding);\n\n  if (outputEncoding && outputEncoding !== 'buffer') {\n    this._decoder = getDecoder(this._decoder\x2C outputEncoding);\n    return this._decoder.write(ret);\n  }\n\n  return ret;\n};\n\n\nCipher.prototype.final = function final(outputEncoding) {\n  outputEncoding = outputEncoding || getDefaultEncoding();\n  const ret = this[kHandle].final();\n\n  if (outputEncoding && outputEncoding !== 'buffer') {\n    this._decoder = getDecoder(this._decoder\x2C outputEncoding);\n    return this._decoder.end(ret);\n  }\n\n  return ret;\n};\n\n\nCipher.prototype.setAutoPadding = function setAutoPadding(ap) {\n  if (!this[kHandle].setAutoPadding(!!ap))\n    throw new ERR_CRYPTO_INVALID_STATE('setAutoPadding');\n  return this;\n};\n\nCipher.prototype.getAuthTag = function getAuthTag() {\n  const ret = this[kHandle].getAuthTag();\n  if (ret === undefined)\n    throw new ERR_CRYPTO_INVALID_STATE('getAuthTag');\n  return ret;\n};\n\n\nfunction setAuthTag(tagbuf\x2C encoding) {\n  tagbuf = getArrayBufferOrView(tagbuf\x2C 'buffer'\x2C encoding);\n  if (!this[kHandle].setAuthTag(tagbuf))\n    throw new ERR_CRYPTO_INVALID_STATE('setAuthTag');\n  return this;\n}\n\nCipher.prototype.setAAD = function setAAD(aadbuf\x2C options) {\n  const encoding = getStringOption(options\x2C 'encoding');\n  const plaintextLength = getUIntOption(options\x2C 'plaintextLength');\n  aadbuf = getArrayBufferOrView(aadbuf\x2C 'aadbuf'\x2C encoding);\n  if (!this[kHandle].setAAD(aadbuf\x2C plaintextLength))\n    throw new ERR_CRYPTO_INVALID_STATE('setAAD');\n  return this;\n};\n\n// The Cipheriv class is part of the legacy Node.js crypto API. It exposes\n// a stream-based encryption/decryption model. For backwards compatibility\n// the Cipheriv class is defined using the legacy function syntax rather than\n// ES6 classes.\n\nfunction Cipheriv(cipher\x2C key\x2C iv\x2C options) {\n  if (!(this instanceof Cipheriv))\n    return new Cipheriv(cipher\x2C key\x2C iv\x2C options);\n\n  ReflectApply(createCipherWithIV\x2C this\x2C [cipher\x2C key\x2C options\x2C true\x2C iv]);\n}\n\nfunction addCipherPrototypeFunctions(constructor) {\n  constructor.prototype._transform = Cipher.prototype._transform;\n  constructor.prototype._flush = Cipher.prototype._flush;\n  constructor.prototype.update = Cipher.prototype.update;\n  constructor.prototype.final = Cipher.prototype.final;\n  constructor.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;\n  if (constructor === Cipheriv) {\n    constructor.prototype.getAuthTag = Cipher.prototype.getAuthTag;\n  } else {\n    constructor.prototype.setAuthTag = setAuthTag;\n  }\n  constructor.prototype.setAAD = Cipher.prototype.setAAD;\n}\n\nObjectSetPrototypeOf(Cipheriv.prototype\x2C LazyTransform.prototype);\nObjectSetPrototypeOf(Cipheriv\x2C LazyTransform);\naddCipherPrototypeFunctions(Cipheriv);\n\n// The Decipher class is part of the legacy Node.js crypto API. It exposes\n// a stream-based encryption/decryption model. For backwards compatibility\n// the Decipher class is defined using the legacy function syntax rather than\n// ES6 classes.\n\nfunction Decipher(cipher\x2C password\x2C options) {\n  if (!(this instanceof Decipher))\n    return new Decipher(cipher\x2C password\x2C options);\n\n  ReflectApply(createCipher\x2C this\x2C [cipher\x2C password\x2C options\x2C false]);\n}\n\nObjectSetPrototypeOf(Decipher.prototype\x2C LazyTransform.prototype);\nObjectSetPrototypeOf(Decipher\x2C LazyTransform);\naddCipherPrototypeFunctions(Decipher);\n\n// The Decipheriv class is part of the legacy Node.js crypto API. It exposes\n// a stream-based encryption/decryption model. For backwards compatibility\n// the Decipheriv class is defined using the legacy function syntax rather than\n// ES6 classes.\n\nfunction Decipheriv(cipher\x2C key\x2C iv\x2C options) {\n  if (!(this instanceof Decipheriv))\n    return new Decipheriv(cipher\x2C key\x2C iv\x2C options);\n\n  ReflectApply(createCipherWithIV\x2C this\x2C [cipher\x2C key\x2C options\x2C false\x2C iv]);\n}\n\nObjectSetPrototypeOf(Decipheriv.prototype\x2C LazyTransform.prototype);\nObjectSetPrototypeOf(Decipheriv\x2C LazyTransform);\naddCipherPrototypeFunctions(Decipheriv);\n\nfunction getCipherInfo(nameOrNid\x2C options) {\n  if (typeof nameOrNid !== 'string' && typeof nameOrNid !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'nameOrNid'\x2C\n      ['string'\x2C 'number']\x2C\n      nameOrNid);\n  }\n  if (typeof nameOrNid === 'number')\n    validateInt32(nameOrNid\x2C 'nameOrNid');\n  let keyLength\x2C ivLength;\n  if (options !== undefined) {\n    validateObject(options\x2C 'options');\n    ({ keyLength\x2C ivLength } = options);\n    if (keyLength !== undefined)\n      validateInt32(keyLength\x2C 'options.keyLength');\n    if (ivLength !== undefined)\n      validateInt32(ivLength\x2C 'options.ivLength');\n  }\n\n  const ret = _getCipherInfo({}\x2C nameOrNid\x2C keyLength\x2C ivLength);\n  if (ret !== undefined) {\n    if (ret.name) ret.name = StringPrototypeToLowerCase(ret.name);\n    if (ret.type) ret.type = StringPrototypeToLowerCase(ret.type);\n  }\n  return ret;\n}\n\nmodule.exports = {\n  Cipher\x2C\n  Cipheriv\x2C\n  Decipher\x2C\n  Decipheriv\x2C\n  privateDecrypt\x2C\n  privateEncrypt\x2C\n  publicDecrypt\x2C\n  publicEncrypt\x2C\n  getCipherInfo\x2C\n};\n
code-source-info,0x2811abd0891e,178,0,10241,C0O0C4O10241,,
code-creation,Function,10,94667,0x2811abd092e6,843, node:internal/crypto/cipher:1:1,0x2811abd08898,~
code-source-info,0x2811abd092e6,178,0,10241,C0O0C149O25C154O49C160O65C166O306C170O306C175O121C181O151C186O186C191O220C196O253C201O286C207O413C211O413C216O413C222O358C227O386C232O554C236O554C241O554C247O467C253O497C259O523C265O668C269O668C274O593C280O613C286O630C292O648C298O783C302O783C307O711C313O732C319O761C325O905C329O905C334O827C340O849C346O873C352O892C358O972C362O972C367O949C373O1020C377O1020C381O1020C383O1071C387O1071C391O1071C393O1146C397O1146C402O1124C408O1199C412O1199C417O1181C423O1999C433O1999C439O2124C449O2124C455O2245C465O2245C471O2369C481O2369C487O4378C491O4406C501O4431C507O4378C512O4443C520O4443C525O4489C528O4496C537O4517C541O4638C544O4645C553O4662C557O4805C560O4812C569O4829C573O5485C576O5492C585O5508C589O5817C592O5824C601O5849C605O6001C608O6008C617O6029C621O6409C624O6416C633O6433C637O7830C641O7860C651O7885C657O7830C662O7897C670O7897C675O7944C679O7944C683O8439C687O8469C697O8494C703O8439C708O8506C716O8506C721O8553C725O8553C729O9061C733O9093C743O9118C749O9061C754O9130C762O9130C767O9179C771O9179C775O10084C783O10105C789O10115C795O10127C801O10139C807O10153C813O10171C819O10189C825O10206C831O10223C837O10099C842O10240,,
tick,0x1bfcfc73c,94750,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x29d5d5bb426b,0x105108d28,0x10510894c,0x29d5d5bad812,0x105108d28,0x10510894c,0x29d5d5b915f4,0x105108d28,0x10510894c,0x29d5d5b8ec0d,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89de,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,94792,0x2811abd0a7c6,5, node:internal/streams/lazy_transform:1:1,0x2811abd0a650,~
script-source,179,node:internal/streams/lazy_transform,// LazyTransform is a special type of Transform stream that is lazily loaded.\n// This is used for performance with bi-API-ship: when two APIs are available\n// for the stream\x2C one conventional and one non-conventional.\n'use strict';\n\nconst {\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst stream = require('stream');\n\nconst {\n  getDefaultEncoding\n} = require('internal/crypto/util');\n\nmodule.exports = LazyTransform;\n\nfunction LazyTransform(options) {\n  this._options = options;\n}\nObjectSetPrototypeOf(LazyTransform.prototype\x2C stream.Transform.prototype);\nObjectSetPrototypeOf(LazyTransform\x2C stream.Transform);\n\nfunction makeGetter(name) {\n  return function() {\n    stream.Transform.call(this\x2C this._options);\n    this._writableState.decodeStrings = false;\n\n    if (!this._options || !this._options.defaultEncoding) {\n      this._writableState.defaultEncoding = getDefaultEncoding();\n    }\n\n    return this[name];\n  };\n}\n\nfunction makeSetter(name) {\n  return function(val) {\n    ObjectDefineProperty(this\x2C name\x2C {\n      value: val\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\n    });\n  };\n}\n\nObjectDefineProperties(LazyTransform.prototype\x2C {\n  _readableState: {\n    get: makeGetter('_readableState')\x2C\n    set: makeSetter('_readableState')\x2C\n    configurable: true\x2C\n    enumerable: true\n  }\x2C\n  _writableState: {\n    get: makeGetter('_writableState')\x2C\n    set: makeSetter('_writableState')\x2C\n    configurable: true\x2C\n    enumerable: true\n  }\n});\n
code-source-info,0x2811abd0a7c6,179,0,1518,C0O0C4O1518,,
code-creation,Function,10,94834,0x2811abd0ab06,193, node:internal/streams/lazy_transform:1:1,0x2811abd0a740,~
code-source-info,0x2811abd0ab06,179,0,1518,C0O0C29O243C34O269C40O293C45O348C48O348C52O348C54O401C57O401C62O378C68O435C70O450C74O566C82O584C87O594C92O531C97O606C100O649C105O606C110O1206C120O1237C128O1248C139O1287C153O1385C161O1396C172O1435C186O1169C192O1517,,
code-creation,LazyCompile,10,94875,0x2811abd0b03e,14,makeGetter node:internal/streams/lazy_transform:26:20,0x2811abd0a848,~
code-source-info,0x2811abd0b03e,179,681,970,C0O681C9O692C13O968,,
code-creation,LazyCompile,10,94917,0x2811abd0b3c6,14,makeSetter node:internal/streams/lazy_transform:39:20,0x2811abd0a8c0,~
code-source-info,0x2811abd0b3c6,179,991,1167,C0O991C9O1002C13O1165,,
code-creation,LazyCompile,10,94959,0x2811abd0b5ce,22,rsaFunctionFor node:internal/crypto/cipher:65:24,0x2811abd08950,~
code-source-info,0x2811abd0b5ce,178,1250,1975,C0O1250C17O1288C21O1973,,
code-creation,LazyCompile,10,94959,0x2811abd0c366,169,addCipherPrototypeFunctions node:internal/crypto/cipher:246:37,0x2811abd08c20,~
code-source-info,0x2811abd0c366,178,7273,7828,C0O7303C8O7333C13O7343C17O7324C21O7369C29O7395C34O7405C38O7386C42O7427C50O7453C55O7463C59O7444C63O7485C71O7510C76O7520C80O7501C84O7541C92O7575C97O7585C101O7566C105O7603C107O7619C112O7651C120O7681C125O7691C129O7672C135O7730C142O7751C146O7783C154O7809C159O7819C163O7800C168O7827,,
code-creation,Eval,10,95084,0x2811abd0cb46,5, node:internal/crypto/sig:1:1,0x2811abd0c810,~
script-source,180,node:internal/crypto/sig,'use strict';\n\nconst {\n  FunctionPrototypeCall\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_CRYPTO_SIGN_KEY_REQUIRED\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  validateCallback\x2C\n  validateEncoding\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst {\n  Sign: _Sign\x2C\n  SignJob\x2C\n  Verify: _Verify\x2C\n  kCryptoJobAsync\x2C\n  kCryptoJobSync\x2C\n  kSigEncDER\x2C\n  kSigEncP1363\x2C\n  kSignJobModeSign\x2C\n  kSignJobModeVerify\x2C\n} = internalBinding('crypto');\n\nconst {\n  getArrayBufferOrView\x2C\n  getDefaultEncoding\x2C\n  kHandle\x2C\n} = require('internal/crypto/util');\n\nconst {\n  preparePrivateKey\x2C\n  preparePublicOrPrivateKey\x2C\n} = require('internal/crypto/keys');\n\nconst { Writable } = require('stream');\n\nconst { Buffer } = require('buffer');\n\nconst {\n  isArrayBufferView\x2C\n} = require('internal/util/types');\n\nfunction Sign(algorithm\x2C options) {\n  if (!(this instanceof Sign))\n    return new Sign(algorithm\x2C options);\n  validateString(algorithm\x2C 'algorithm');\n  this[kHandle] = new _Sign();\n  this[kHandle].init(algorithm);\n\n  ReflectApply(Writable\x2C this\x2C [options]);\n}\n\nObjectSetPrototypeOf(Sign.prototype\x2C Writable.prototype);\nObjectSetPrototypeOf(Sign\x2C Writable);\n\nSign.prototype._write = function _write(chunk\x2C encoding\x2C callback) {\n  this.update(chunk\x2C encoding);\n  callback();\n};\n\nSign.prototype.update = function update(data\x2C encoding) {\n  encoding = encoding || getDefaultEncoding();\n\n  if (typeof data === 'string') {\n    validateEncoding(data\x2C encoding);\n  } else if (!isArrayBufferView(data)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'data'\x2C ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C data);\n  }\n\n  this[kHandle].update(data\x2C encoding);\n  return this;\n};\n\nfunction getPadding(options) {\n  return getIntOption('padding'\x2C options);\n}\n\nfunction getSaltLength(options) {\n  return getIntOption('saltLength'\x2C options);\n}\n\nfunction getDSASignatureEncoding(options) {\n  if (typeof options === 'object') {\n    const { dsaEncoding = 'der' } = options;\n    if (dsaEncoding === 'der')\n      return kSigEncDER;\n    else if (dsaEncoding === 'ieee-p1363')\n      return kSigEncP1363;\n    throw new ERR_INVALID_ARG_VALUE('options.dsaEncoding'\x2C dsaEncoding);\n  }\n\n  return kSigEncDER;\n}\n\nfunction getIntOption(name\x2C options) {\n  const value = options[name];\n  if (value !== undefined) {\n    if (value === value >> 0) {\n      return value;\n    }\n    throw new ERR_INVALID_ARG_VALUE(`options.${name}`\x2C value);\n  }\n  return undefined;\n}\n\nSign.prototype.sign = function sign(options\x2C encoding) {\n  if (!options)\n    throw new ERR_CRYPTO_SIGN_KEY_REQUIRED();\n\n  const { data\x2C format\x2C type\x2C passphrase } = preparePrivateKey(options\x2C true);\n\n  // Options specific to RSA\n  const rsaPadding = getPadding(options);\n  const pssSaltLength = getSaltLength(options);\n\n  // Options specific to (EC)DSA\n  const dsaSigEnc = getDSASignatureEncoding(options);\n\n  const ret = this[kHandle].sign(data\x2C format\x2C type\x2C passphrase\x2C rsaPadding\x2C\n                                 pssSaltLength\x2C dsaSigEnc);\n\n  encoding = encoding || getDefaultEncoding();\n  if (encoding && encoding !== 'buffer')\n    return ret.toString(encoding);\n\n  return ret;\n};\n\nfunction signOneShot(algorithm\x2C data\x2C key\x2C callback) {\n  if (algorithm != null)\n    validateString(algorithm\x2C 'algorithm');\n\n  if (callback !== undefined)\n    validateCallback(callback);\n\n  data = getArrayBufferOrView(data\x2C 'data');\n\n  if (!key)\n    throw new ERR_CRYPTO_SIGN_KEY_REQUIRED();\n\n  // Options specific to RSA\n  const rsaPadding = getPadding(key);\n  const pssSaltLength = getSaltLength(key);\n\n  // Options specific to (EC)DSA\n  const dsaSigEnc = getDSASignatureEncoding(key);\n\n  const {\n    data: keyData\x2C\n    format: keyFormat\x2C\n    type: keyType\x2C\n    passphrase: keyPassphrase\n  } = preparePrivateKey(key);\n\n  const job = new SignJob(\n    callback ? kCryptoJobAsync : kCryptoJobSync\x2C\n    kSignJobModeSign\x2C\n    keyData\x2C\n    keyFormat\x2C\n    keyType\x2C\n    keyPassphrase\x2C\n    data\x2C\n    algorithm\x2C\n    pssSaltLength\x2C\n    rsaPadding\x2C\n    dsaSigEnc);\n\n  if (!callback) {\n    const { 0: err\x2C 1: signature } = job.run();\n    if (err !== undefined)\n      throw err;\n\n    return Buffer.from(signature);\n  }\n\n  job.ondone = (error\x2C signature) => {\n    if (error) return FunctionPrototypeCall(callback\x2C job\x2C error);\n    FunctionPrototypeCall(callback\x2C job\x2C null\x2C Buffer.from(signature));\n  };\n  job.run();\n}\n\nfunction Verify(algorithm\x2C options) {\n  if (!(this instanceof Verify))\n    return new Verify(algorithm\x2C options);\n  validateString(algorithm\x2C 'algorithm');\n  this[kHandle] = new _Verify();\n  this[kHandle].init(algorithm);\n\n  ReflectApply(Writable\x2C this\x2C [options]);\n}\n\nObjectSetPrototypeOf(Verify.prototype\x2C Writable.prototype);\nObjectSetPrototypeOf(Verify\x2C Writable);\n\nVerify.prototype._write = Sign.prototype._write;\nVerify.prototype.update = Sign.prototype.update;\n\nVerify.prototype.verify = function verify(options\x2C signature\x2C sigEncoding) {\n  const {\n    data\x2C\n    format\x2C\n    type\x2C\n    passphrase\n  } = preparePublicOrPrivateKey(options\x2C true);\n\n  sigEncoding = sigEncoding || getDefaultEncoding();\n\n  // Options specific to RSA\n  const rsaPadding = getPadding(options);\n  const pssSaltLength = getSaltLength(options);\n\n  // Options specific to (EC)DSA\n  const dsaSigEnc = getDSASignatureEncoding(options);\n\n  signature = getArrayBufferOrView(signature\x2C 'signature'\x2C sigEncoding);\n\n  return this[kHandle].verify(data\x2C format\x2C type\x2C passphrase\x2C signature\x2C\n                              rsaPadding\x2C pssSaltLength\x2C dsaSigEnc);\n};\n\nfunction verifyOneShot(algorithm\x2C data\x2C key\x2C signature\x2C callback) {\n  if (algorithm != null)\n    validateString(algorithm\x2C 'algorithm');\n\n  if (callback !== undefined)\n    validateCallback(callback);\n\n  data = getArrayBufferOrView(data\x2C 'data');\n\n  if (!isArrayBufferView(data)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'data'\x2C\n      ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n      data\n    );\n  }\n\n  // Options specific to RSA\n  const rsaPadding = getPadding(key);\n  const pssSaltLength = getSaltLength(key);\n\n  // Options specific to (EC)DSA\n  const dsaSigEnc = getDSASignatureEncoding(key);\n\n  if (!isArrayBufferView(signature)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'signature'\x2C\n      ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n      signature\n    );\n  }\n\n  const {\n    data: keyData\x2C\n    format: keyFormat\x2C\n    type: keyType\x2C\n    passphrase: keyPassphrase\n  } = preparePublicOrPrivateKey(key);\n\n  const job = new SignJob(\n    callback ? kCryptoJobAsync : kCryptoJobSync\x2C\n    kSignJobModeVerify\x2C\n    keyData\x2C\n    keyFormat\x2C\n    keyType\x2C\n    keyPassphrase\x2C\n    data\x2C\n    algorithm\x2C\n    pssSaltLength\x2C\n    rsaPadding\x2C\n    dsaSigEnc\x2C\n    signature);\n\n  if (!callback) {\n    const { 0: err\x2C 1: result } = job.run();\n    if (err !== undefined)\n      throw err;\n\n    return result;\n  }\n\n  job.ondone = (error\x2C result) => {\n    if (error) return FunctionPrototypeCall(callback\x2C job\x2C error);\n    FunctionPrototypeCall(callback\x2C job\x2C null\x2C result);\n  };\n  job.run();\n}\n\nmodule.exports = {\n  Sign\x2C\n  signOneShot\x2C\n  Verify\x2C\n  verifyOneShot\x2C\n};\n
code-source-info,0x2811abd0cb46,180,0,7083,C0O0C4O7083,,
code-creation,Function,10,95375,0x2811abd0d19e,563, node:internal/crypto/sig:1:1,0x2811abd0cac0,~
code-source-info,0x2811abd0d19e,180,0,7083,C0O0C126O25C132O50C137O74C143O220C146O220C151O220C156O129C162O163C168O189C174O319C177O319C182O259C188O279C194O299C200O518C203O518C208O368C214O377C220O396C226O407C232O426C238O444C244O458C250O474C256O494C262O615C265O615C270O556C276O580C282O602C288O711C291O711C296O659C302O680C308O766C311O766C316O753C322O805C325O805C330O794C336O858C339O858C344O835C350O1152C353O1178C361O1198C366O1152C371O1210C377O1210C382O1249C385O1254C394O1271C398O1368C401O1373C410O1390C414O2517C417O2522C426O2537C430O4681C433O4709C441O4729C446O4681C451O4741C457O4741C462O4782C465O4789C473O4813C478O4823C482O4806C486O4831C489O4838C497O4862C502O4872C506O4855C510O4881C513O4888C522O4905C526O7011C533O7032C539O7040C545O7055C551O7065C557O7026C562O7082,,
code-creation,Eval,10,95500,0x2811abd0e5ee,5, node:internal/crypto/hash:1:1,0x2811abd0e2f8,~
script-source,181,node:internal/crypto/hash,'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  Hash: _Hash\x2C\n  HashJob\x2C\n  Hmac: _Hmac\x2C\n  kCryptoJobAsync\x2C\n} = internalBinding('crypto');\n\nconst {\n  getArrayBufferOrView\x2C\n  getDefaultEncoding\x2C\n  getStringOption\x2C\n  jobPromise\x2C\n  normalizeAlgorithm\x2C\n  normalizeHashName\x2C\n  validateMaxBufferLength\x2C\n  kHandle\x2C\n} = require('internal/crypto/util');\n\nconst {\n  prepareSecretKey\x2C\n} = require('internal/crypto/keys');\n\nconst {\n  Buffer\x2C\n} = require('buffer');\n\nconst {\n  codes: {\n    ERR_CRYPTO_HASH_FINALIZED\x2C\n    ERR_CRYPTO_HASH_UPDATE_FAILED\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  validateEncoding\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst {\n  isArrayBufferView\x2C\n} = require('internal/util/types');\n\nconst LazyTransform = require('internal/streams/lazy_transform');\n\nconst kState = Symbol('kState');\nconst kFinalized = Symbol('kFinalized');\n\nfunction Hash(algorithm\x2C options) {\n  if (!(this instanceof Hash))\n    return new Hash(algorithm\x2C options);\n  if (!(algorithm instanceof _Hash))\n    validateString(algorithm\x2C 'algorithm');\n  const xofLen = typeof options === 'object' && options !== null ?\n    options.outputLength : undefined;\n  if (xofLen !== undefined)\n    validateUint32(xofLen\x2C 'options.outputLength');\n  this[kHandle] = new _Hash(algorithm\x2C xofLen);\n  this[kState] = {\n    [kFinalized]: false\n  };\n  ReflectApply(LazyTransform\x2C this\x2C [options]);\n}\n\nObjectSetPrototypeOf(Hash.prototype\x2C LazyTransform.prototype);\nObjectSetPrototypeOf(Hash\x2C LazyTransform);\n\nHash.prototype.copy = function copy(options) {\n  const state = this[kState];\n  if (state[kFinalized])\n    throw new ERR_CRYPTO_HASH_FINALIZED();\n\n  return new Hash(this[kHandle]\x2C options);\n};\n\nHash.prototype._transform = function _transform(chunk\x2C encoding\x2C callback) {\n  this[kHandle].update(chunk\x2C encoding);\n  callback();\n};\n\nHash.prototype._flush = function _flush(callback) {\n  this.push(this[kHandle].digest());\n  callback();\n};\n\nHash.prototype.update = function update(data\x2C encoding) {\n  encoding = encoding || getDefaultEncoding();\n\n  const state = this[kState];\n  if (state[kFinalized])\n    throw new ERR_CRYPTO_HASH_FINALIZED();\n\n  if (typeof data === 'string') {\n    validateEncoding(data\x2C encoding);\n  } else if (!isArrayBufferView(data)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'data'\x2C ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C data);\n  }\n\n  if (!this[kHandle].update(data\x2C encoding))\n    throw new ERR_CRYPTO_HASH_UPDATE_FAILED();\n  return this;\n};\n\n\nHash.prototype.digest = function digest(outputEncoding) {\n  const state = this[kState];\n  if (state[kFinalized])\n    throw new ERR_CRYPTO_HASH_FINALIZED();\n  outputEncoding = outputEncoding || getDefaultEncoding();\n\n  // Explicit conversion for backward compatibility.\n  const ret = this[kHandle].digest(`${outputEncoding}`);\n  state[kFinalized] = true;\n  return ret;\n};\n\nfunction Hmac(hmac\x2C key\x2C options) {\n  if (!(this instanceof Hmac))\n    return new Hmac(hmac\x2C key\x2C options);\n  validateString(hmac\x2C 'hmac');\n  const encoding = getStringOption(options\x2C 'encoding');\n  key = prepareSecretKey(key\x2C encoding);\n  this[kHandle] = new _Hmac();\n  this[kHandle].init(hmac\x2C key);\n  this[kState] = {\n    [kFinalized]: false\n  };\n  ReflectApply(LazyTransform\x2C this\x2C [options]);\n}\n\nObjectSetPrototypeOf(Hmac.prototype\x2C LazyTransform.prototype);\nObjectSetPrototypeOf(Hmac\x2C LazyTransform);\n\nHmac.prototype.update = Hash.prototype.update;\n\nHmac.prototype.digest = function digest(outputEncoding) {\n  const state = this[kState];\n  outputEncoding = outputEncoding || getDefaultEncoding();\n\n  if (state[kFinalized]) {\n    const buf = Buffer.from('');\n    return outputEncoding === 'buffer' ? buf : buf.toString(outputEncoding);\n  }\n\n  // Explicit conversion for backward compatibility.\n  const ret = this[kHandle].digest(`${outputEncoding}`);\n  state[kFinalized] = true;\n  return ret;\n};\n\nHmac.prototype._flush = Hash.prototype._flush;\nHmac.prototype._transform = Hash.prototype._transform;\n\n// Implementation for WebCrypto subtle.digest()\n\nasync function asyncDigest(algorithm\x2C data) {\n  algorithm = normalizeAlgorithm(algorithm);\n  data = getArrayBufferOrView(data\x2C 'data');\n  validateMaxBufferLength(data\x2C 'data');\n\n  if (algorithm.length !== undefined)\n    validateUint32(algorithm.length\x2C 'algorithm.length');\n\n  return jobPromise(new HashJob(\n    kCryptoJobAsync\x2C\n    normalizeHashName(algorithm.name)\x2C\n    data\x2C\n    algorithm.length));\n}\n\nmodule.exports = {\n  Hash\x2C\n  Hmac\x2C\n  asyncDigest\x2C\n};\n
code-source-info,0x2811abd0e5ee,181,0,4550,C0O0C4O4550,,
code-creation,Function,10,95667,0x2811abd0eb2e,590, node:internal/crypto/hash:1:1,0x2811abd0e568,~
code-source-info,0x2811abd0eb2e,181,0,4550,C0O0C97O25C102O49C108O65C113O163C116O163C121O107C127O116C133O133C139O142C145O363C148O363C153O201C159O225C165O247C171O266C177O280C183O302C189O323C195O350C201O429C204O429C209O407C215O485C218O485C223O473C229O624C232O624C237O624C242O528C248O559C254O594C260O721C263O721C268O663C274O683C280O701C286O787C289O787C294O764C300O842C303O842C307O842C309O902C312O902C316O902C318O939C321O939C325O939C327O1483C330O1509C338O1534C343O1483C348O1546C354O1546C359O1590C362O1595C371O1610C375O1783C378O1788C387O1809C391O1919C394O1924C403O1941C407O2026C410O2031C419O2048C423O2566C426O2571C435O2588C439O3339C442O3365C450O3390C455O3339C460O3402C466O3402C471O3446C474O3451C482O3475C487O3485C491O3468C495O3494C498O3499C507O3516C511O3940C514O3945C522O3969C527O3979C531O3962C535O3987C538O3992C546O4020C551O4030C555O4013C559O4497C566O4518C572O4526C578O4534C584O4512C589O4549,,
code-creation,Eval,10,95875,0x2811abd0ff76,5, node:internal/crypto/x509:1:1,0x2811abd0fbb0,~
script-source,182,node:internal/crypto/x509,'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  SafeMap\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  parseX509\x2C\n  X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT\x2C\n  X509_CHECK_FLAG_NEVER_CHECK_SUBJECT\x2C\n  X509_CHECK_FLAG_NO_WILDCARDS\x2C\n  X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS\x2C\n  X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS\x2C\n  X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS\x2C\n} = internalBinding('crypto');\n\nconst {\n  PublicKeyObject\x2C\n  isKeyObject\x2C\n} = require('internal/crypto/keys');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst {\n  validateBoolean\x2C\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst { inspect } = require('internal/util/inspect');\n\nconst { Buffer } = require('buffer');\n\nconst {\n  isArrayBufferView\x2C\n} = require('internal/util/types');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  JSTransferable\x2C\n  kClone\x2C\n  kDeserialize\x2C\n} = require('internal/worker/js_transferable');\n\nconst {\n  kHandle\x2C\n} = require('internal/crypto/util');\n\nconst kInternalState = Symbol('kInternalState');\n\nfunction isX509Certificate(value) {\n  return value[kInternalState] !== undefined;\n}\n\nfunction getFlags(options = {}) {\n  validateObject(options\x2C 'options');\n  const {\n    // TODO(tniessen): change the default to 'default'\n    subject = 'always'\x2C  // Can be 'default'\x2C 'always'\x2C or 'never'\n    wildcards = true\x2C\n    partialWildcards = true\x2C\n    multiLabelWildcards = false\x2C\n    singleLabelSubdomains = false\x2C\n  } = { ...options };\n  let flags = 0;\n  validateString(subject\x2C 'options.subject');\n  validateBoolean(wildcards\x2C 'options.wildcards');\n  validateBoolean(partialWildcards\x2C 'options.partialWildcards');\n  validateBoolean(multiLabelWildcards\x2C 'options.multiLabelWildcards');\n  validateBoolean(singleLabelSubdomains\x2C 'options.singleLabelSubdomains');\n  switch (subject) {\n    case 'default': /* Matches OpenSSL's default\x2C no flags. */ break;\n    case 'always': flags |= X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT; break;\n    case 'never': flags |= X509_CHECK_FLAG_NEVER_CHECK_SUBJECT; break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE('options.subject'\x2C subject);\n  }\n  if (!wildcards) flags |= X509_CHECK_FLAG_NO_WILDCARDS;\n  if (!partialWildcards) flags |= X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS;\n  if (multiLabelWildcards) flags |= X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS;\n  if (singleLabelSubdomains) flags |= X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS;\n  return flags;\n}\n\nclass InternalX509Certificate extends JSTransferable {\n  [kInternalState] = new SafeMap();\n\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n  }\n}\n\nclass X509Certificate extends JSTransferable {\n  [kInternalState] = new SafeMap();\n\n  constructor(buffer) {\n    if (typeof buffer === 'string')\n      buffer = Buffer.from(buffer);\n    if (!isArrayBufferView(buffer)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'buffer'\x2C\n        ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        buffer);\n    }\n    super();\n    this[kHandle] = parseX509(buffer);\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0)\n      return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `X509Certificate ${inspect({\n      subject: this.subject\x2C\n      subjectAltName: this.subjectAltName\x2C\n      issuer: this.issuer\x2C\n      infoAccess: this.infoAccess\x2C\n      validFrom: this.validFrom\x2C\n      validTo: this.validTo\x2C\n      fingerprint: this.fingerprint\x2C\n      fingerprint256: this.fingerprint256\x2C\n      fingerprint512: this.fingerprint512\x2C\n      keyUsage: this.keyUsage\x2C\n      serialNumber: this.serialNumber\x2C\n    }\x2C opts)}`;\n  }\n\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/crypto/x509:InternalX509Certificate'\n    };\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n  }\n\n  get subject() {\n    let value = this[kInternalState].get('subject');\n    if (value === undefined) {\n      value = this[kHandle].subject();\n      this[kInternalState].set('subject'\x2C value);\n    }\n    return value;\n  }\n\n  get subjectAltName() {\n    let value = this[kInternalState].get('subjectAltName');\n    if (value === undefined) {\n      value = this[kHandle].subjectAltName();\n      this[kInternalState].set('subjectAltName'\x2C value);\n    }\n    return value;\n  }\n\n  get issuer() {\n    let value = this[kInternalState].get('issuer');\n    if (value === undefined) {\n      value = this[kHandle].issuer();\n      this[kInternalState].set('issuer'\x2C value);\n    }\n    return value;\n  }\n\n  get issuerCertificate() {\n    let value = this[kInternalState].get('issuerCertificate');\n    if (value === undefined) {\n      const cert = this[kHandle].getIssuerCert();\n      if (cert)\n        value = new InternalX509Certificate(this[kHandle].getIssuerCert());\n      this[kInternalState].set('issuerCertificate'\x2C value);\n    }\n    return value;\n  }\n\n  get infoAccess() {\n    let value = this[kInternalState].get('infoAccess');\n    if (value === undefined) {\n      value = this[kHandle].infoAccess();\n      this[kInternalState].set('infoAccess'\x2C value);\n    }\n    return value;\n  }\n\n  get validFrom() {\n    let value = this[kInternalState].get('validFrom');\n    if (value === undefined) {\n      value = this[kHandle].validFrom();\n      this[kInternalState].set('validFrom'\x2C value);\n    }\n    return value;\n  }\n\n  get validTo() {\n    let value = this[kInternalState].get('validTo');\n    if (value === undefined) {\n      value = this[kHandle].validTo();\n      this[kInternalState].set('validTo'\x2C value);\n    }\n    return value;\n  }\n\n  get fingerprint() {\n    let value = this[kInternalState].get('fingerprint');\n    if (value === undefined) {\n      value = this[kHandle].fingerprint();\n      this[kInternalState].set('fingerprint'\x2C value);\n    }\n    return value;\n  }\n\n  get fingerprint256() {\n    let value = this[kInternalState].get('fingerprint256');\n    if (value === undefined) {\n      value = this[kHandle].fingerprint256();\n      this[kInternalState].set('fingerprint256'\x2C value);\n    }\n    return value;\n  }\n\n  get fingerprint512() {\n    let value = this[kInternalState].get('fingerprint512');\n    if (value === undefined) {\n      value = this[kHandle].fingerprint512();\n      this[kInternalState].set('fingerprint512'\x2C value);\n    }\n    return value;\n  }\n\n  get keyUsage() {\n    let value = this[kInternalState].get('keyUsage');\n    if (value === undefined) {\n      value = this[kHandle].keyUsage();\n      this[kInternalState].set('keyUsage'\x2C value);\n    }\n    return value;\n  }\n\n  get serialNumber() {\n    let value = this[kInternalState].get('serialNumber');\n    if (value === undefined) {\n      value = this[kHandle].serialNumber();\n      this[kInternalState].set('serialNumber'\x2C value);\n    }\n    return value;\n  }\n\n  get raw() {\n    let value = this[kInternalState].get('raw');\n    if (value === undefined) {\n      value = this[kHandle].raw();\n      this[kInternalState].set('raw'\x2C value);\n    }\n    return value;\n  }\n\n  get publicKey() {\n    let value = this[kInternalState].get('publicKey');\n    if (value === undefined) {\n      value = new PublicKeyObject(this[kHandle].publicKey());\n      this[kInternalState].set('publicKey'\x2C value);\n    }\n    return value;\n  }\n\n  toString() {\n    let value = this[kInternalState].get('pem');\n    if (value === undefined) {\n      value = this[kHandle].pem();\n      this[kInternalState].set('pem'\x2C value);\n    }\n    return value;\n  }\n\n  // There's no standardized JSON encoding for X509 certs so we\n  // fallback to providing the PEM encoding as a string.\n  toJSON() { return this.toString(); }\n\n  get ca() {\n    let value = this[kInternalState].get('ca');\n    if (value === undefined) {\n      value = this[kHandle].checkCA();\n      this[kInternalState].set('ca'\x2C value);\n    }\n    return value;\n  }\n\n  checkHost(name\x2C options) {\n    validateString(name\x2C 'name');\n    return this[kHandle].checkHost(name\x2C getFlags(options));\n  }\n\n  checkEmail(email\x2C options) {\n    validateString(email\x2C 'email');\n    return this[kHandle].checkEmail(email\x2C getFlags(options));\n  }\n\n  checkIP(ip\x2C options) {\n    validateString(ip\x2C 'ip');\n    // The options argument is currently undocumented since none of the options\n    // have any effect on the behavior of this function. However\x2C we still parse\n    // the options argument in case OpenSSL adds flags in the future that do\n    // affect the behavior of X509_check_ip. This ensures that no invalid values\n    // are passed as the second argument in the meantime.\n    return this[kHandle].checkIP(ip\x2C getFlags(options));\n  }\n\n  checkIssued(otherCert) {\n    if (!isX509Certificate(otherCert))\n      throw new ERR_INVALID_ARG_TYPE('otherCert'\x2C 'X509Certificate'\x2C otherCert);\n    return this[kHandle].checkIssued(otherCert[kHandle]);\n  }\n\n  checkPrivateKey(pkey) {\n    if (!isKeyObject(pkey))\n      throw new ERR_INVALID_ARG_TYPE('pkey'\x2C 'KeyObject'\x2C pkey);\n    if (pkey.type !== 'private')\n      throw new ERR_INVALID_ARG_VALUE('pkey'\x2C pkey);\n    return this[kHandle].checkPrivateKey(pkey[kHandle]);\n  }\n\n  verify(pkey) {\n    if (!isKeyObject(pkey))\n      throw new ERR_INVALID_ARG_TYPE('pkey'\x2C 'KeyObject'\x2C pkey);\n    if (pkey.type !== 'public')\n      throw new ERR_INVALID_ARG_VALUE('pkey'\x2C pkey);\n    return this[kHandle].verify(pkey[kHandle]);\n  }\n\n  toLegacyObject() {\n    return this[kHandle].toLegacy();\n  }\n}\n\nInternalX509Certificate.prototype.constructor = X509Certificate;\nObjectSetPrototypeOf(\n  InternalX509Certificate.prototype\x2C\n  X509Certificate.prototype);\n\nmodule.exports = {\n  X509Certificate\x2C\n  InternalX509Certificate\x2C\n  isX509Certificate\x2C\n};\n
code-source-info,0x2811abd0ff76,182,0,9641,C0O0C4O9641,,
code-creation,Function,10,96250,0x2811abd11976,657, node:internal/crypto/x509:1:1,0x2811abd0fef0,~
code-source-info,0x2811abd11976,182,0,9641,C0O0C80O25C85O49C91O60C96O346C99O346C104O96C110O109C116O149C122O188C128O220C134O260C140O301C146O420C149O420C154O384C160O403C166O499C169O499C174O485C179O593C182O593C187O536C193O555C199O573C205O646C208O646C213O634C219O700C222O700C227O689C233O753C236O753C241O730C247O866C250O866C255O866C260O809C266O835C272O951C275O951C280O905C285O923C290O933C295O1019C298O1019C303O1006C309O1076C312O1076C316O1076C325O2517C333O2537C368O2479C377O2673C385O2693C395O3056C403O3683C412O3851C594O9397C597O9421C604O9443C608O9462C611O9510C616O9539C621O9462C626O9552C633O9573C639O9592C645O9619C651O9567C656O9640,,
code-creation,Function,10,96250,0x2811abd11d6e,26,<instance_members_initializer> node:internal/crypto/x509:105:3,0x2811abd10b80,~
code-source-info,0x2811abd11d6e,182,2692,2724,C3O2711C10O2711C25O2724,,
code-creation,Function,10,96292,0x2811abd11e0e,26,<instance_members_initializer> node:internal/crypto/x509:96:3,0x2811abd10098,~
code-source-info,0x2811abd11e0e,182,2536,2568,C3O2555C10O2555C25O2568,,
tick,0x1bfd39474,96292,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x29d5d5bb42ef,0x105108d28,0x10510894c,0x29d5d5bad812,0x105108d28,0x10510894c,0x29d5d5b915f4,0x105108d28,0x10510894c,0x29d5d5b8ec0d,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89de,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,96375,0x2811abd1327e,5, node:internal/crypto/certificate:1:1,0x2811abd130e8,~
script-source,183,node:internal/crypto/certificate,'use strict';\n\nconst {\n  certExportChallenge\x2C\n  certExportPublicKey\x2C\n  certVerifySpkac\x2C\n} = internalBinding('crypto');\n\nconst {\n  getArrayBufferOrView\x2C\n} = require('internal/crypto/util');\n\n// The functions contained in this file cover the SPKAC format\n// (also referred to as Netscape SPKI). A general description of\n// the format can be found at https://en.wikipedia.org/wiki/SPKAC\n\nfunction verifySpkac(spkac\x2C encoding) {\n  return certVerifySpkac(\n    getArrayBufferOrView(spkac\x2C 'spkac'\x2C encoding));\n}\n\nfunction exportPublicKey(spkac\x2C encoding) {\n  return certExportPublicKey(\n    getArrayBufferOrView(spkac\x2C 'spkac'\x2C encoding));\n}\n\nfunction exportChallenge(spkac\x2C encoding) {\n  return certExportChallenge(\n    getArrayBufferOrView(spkac\x2C 'spkac'\x2C encoding));\n}\n\n// The legacy implementation of this exposed the Certificate\n// object and required that users create an instance before\n// calling the member methods. This API pattern has been\n// deprecated\x2C however\x2C as the method implementations do not\n// rely on any object state.\n\n// For backwards compatibility reasons\x2C this cannot be converted into a\n// ES6 Class.\nfunction Certificate() {\n  if (!(this instanceof Certificate))\n    return new Certificate();\n}\n\nCertificate.prototype.verifySpkac = verifySpkac;\nCertificate.prototype.exportPublicKey = exportPublicKey;\nCertificate.prototype.exportChallenge = exportChallenge;\n\nCertificate.exportChallenge = exportChallenge;\nCertificate.exportPublicKey = exportPublicKey;\nCertificate.verifySpkac = verifySpkac;\n\nmodule.exports = Certificate;\n
code-source-info,0x2811abd1327e,183,0,1546,C0O0C4O1546,,
code-creation,Function,10,96417,0x2811abd134b6,155, node:internal/crypto/certificate:1:1,0x2811abd131f8,~
code-source-info,0x2811abd134b6,183,0,1546,C0O0C38O92C41O92C46O25C52O48C58O71C64O156C67O156C72O130C78O1218C81O1230C88O1252C92O1267C95O1279C102O1305C106O1324C109O1336C116O1362C120O1382C125O1410C129O1429C134O1457C138O1476C143O1500C147O1516C149O1531C154O1545,,
code-creation,Eval,10,96625,0x2811abd13f9e,5, node:internal/js_stream_socket:1:1,0x2811abd13d30,~
script-source,184,node:internal/js_stream_socket,'use strict';\n\nconst {\n  Symbol\x2C\n} = primordials;\n\nconst { setImmediate } = require('timers');\nconst assert = require('internal/assert');\nconst { Socket } = require('net');\nconst { JSStream } = internalBinding('js_stream');\nconst uv = internalBinding('uv');\nlet debug = require('internal/util/debuglog').debuglog(\n  'stream_socket'\x2C\n  (fn) => {\n    debug = fn;\n  }\n);\nconst { owner_symbol } = require('internal/async_hooks').symbols;\nconst { ERR_STREAM_WRAP } = require('internal/errors').codes;\n\nconst kCurrentWriteRequest = Symbol('kCurrentWriteRequest');\nconst kCurrentShutdownRequest = Symbol('kCurrentShutdownRequest');\nconst kPendingShutdownRequest = Symbol('kPendingShutdownRequest');\n\nfunction isClosing() { return this[owner_symbol].isClosing(); }\n\nfunction onreadstart() { return this[owner_symbol].readStart(); }\n\nfunction onreadstop() { return this[owner_symbol].readStop(); }\n\nfunction onshutdown(req) { return this[owner_symbol].doShutdown(req); }\n\nfunction onwrite(req\x2C bufs) { return this[owner_symbol].doWrite(req\x2C bufs); }\n\n/* This class serves as a wrapper for when the C++ side of Node wants access\n * to a standard JS stream. For example\x2C TLS or HTTP do not operate on network\n * resources conceptually\x2C although that is the common case and what we are\n * optimizing for; in theory\x2C they are completely composable and can work with\n * any stream resource they see.\n *\n * For the common case\x2C i.e. a TLS socket wrapping around a net.Socket\x2C we\n * can skip going through the JS layer and let TLS access the raw C++ handle\n * of a net.Socket. The flipside of this is that\x2C to maintain composability\x2C\n * we need a way to create "fake" net.Socket instances that call back into a\n * "real" JavaScript stream. JSStreamSocket is exactly this.\n */\nclass JSStreamSocket extends Socket {\n  constructor(stream) {\n    const handle = new JSStream();\n    handle.close = (cb) => {\n      debug('close');\n      this.doClose(cb);\n    };\n    // Inside of the following functions\x2C `this` refers to the handle\n    // and `this[owner_symbol]` refers to this JSStreamSocket instance.\n    handle.isClosing = isClosing;\n    handle.onreadstart = onreadstart;\n    handle.onreadstop = onreadstop;\n    handle.onshutdown = onshutdown;\n    handle.onwrite = onwrite;\n\n    stream.pause();\n    stream.on('error'\x2C (err) => this.emit('error'\x2C err));\n    const ondata = (chunk) => {\n      if (typeof chunk === 'string' ||\n          stream.readableObjectMode === true) {\n        // Make sure that no further `data` events will happen.\n        stream.pause();\n        stream.removeListener('data'\x2C ondata);\n\n        this.emit('error'\x2C new ERR_STREAM_WRAP());\n        return;\n      }\n\n      debug('data'\x2C chunk.length);\n      if (this._handle)\n        this._handle.readBuffer(chunk);\n    };\n    stream.on('data'\x2C ondata);\n    stream.once('end'\x2C () => {\n      debug('end');\n      if (this._handle)\n        this._handle.emitEOF();\n    });\n    // Some `Stream` don't pass `hasError` parameters when closed.\n    stream.once('close'\x2C () => {\n      // Errors emitted from `stream` have also been emitted to this instance\n      // so that we don't pass errors to `destroy()` again.\n      this.destroy();\n    });\n\n    super({ handle\x2C manualStart: true });\n    this.stream = stream;\n    this[kCurrentWriteRequest] = null;\n    this[kCurrentShutdownRequest] = null;\n    this[kPendingShutdownRequest] = null;\n    this.readable = stream.readable;\n    this.writable = stream.writable;\n\n    // Start reading.\n    this.read(0);\n  }\n\n  // Allow legacy requires in the test suite to keep working:\n  //   const { StreamWrap } = require('internal/js_stream_socket')\n  static get StreamWrap() {\n    return JSStreamSocket;\n  }\n\n  isClosing() {\n    return !this.readable || !this.writable;\n  }\n\n  readStart() {\n    this.stream.resume();\n    return 0;\n  }\n\n  readStop() {\n    this.stream.pause();\n    return 0;\n  }\n\n  doShutdown(req) {\n    // TODO(addaleax): It might be nice if we could get into a state where\n    // DoShutdown() is not called on streams while a write is still pending.\n    //\n    // Currently\x2C the only part of the code base where that happens is the\n    // TLS implementation\x2C which calls both DoWrite() and DoShutdown() on the\n    // underlying network stream inside of its own DoShutdown() method.\n    // Working around that on the native side is not quite trivial (yet?)\x2C\n    // so for now that is supported here.\n\n    if (this[kCurrentWriteRequest] !== null) {\n      this[kPendingShutdownRequest] = req;\n      return 0;\n    }\n    assert(this[kCurrentWriteRequest] === null);\n    assert(this[kCurrentShutdownRequest] === null);\n    this[kCurrentShutdownRequest] = req;\n\n    const handle = this._handle;\n\n    setImmediate(() => {\n      // Ensure that write is dispatched asynchronously.\n      this.stream.end(() => {\n        this.finishShutdown(handle\x2C 0);\n      });\n    });\n    return 0;\n  }\n\n  // handle === this._handle except when called from doClose().\n  finishShutdown(handle\x2C errCode) {\n    // The shutdown request might already have been cancelled.\n    if (this[kCurrentShutdownRequest] === null)\n      return;\n    const req = this[kCurrentShutdownRequest];\n    this[kCurrentShutdownRequest] = null;\n    handle.finishShutdown(req\x2C errCode);\n  }\n\n  doWrite(req\x2C bufs) {\n    assert(this[kCurrentWriteRequest] === null);\n    assert(this[kCurrentShutdownRequest] === null);\n\n    const handle = this._handle;\n    const self = this;\n\n    let pending = bufs.length;\n\n    this.stream.cork();\n    // Use `var` over `let` for performance optimization.\n    for (var i = 0; i < bufs.length; ++i)\n      this.stream.write(bufs[i]\x2C done);\n    this.stream.uncork();\n\n    // Only set the request here\x2C because the `write()` calls could throw.\n    this[kCurrentWriteRequest] = req;\n\n    function done(err) {\n      if (!err && --pending !== 0)\n        return;\n\n      // Ensure that this is called once in case of error\n      pending = 0;\n\n      let errCode = 0;\n      if (err) {\n        errCode = uv[`UV_${err.code}`] || uv.UV_EPIPE;\n      }\n\n      // Ensure that write was dispatched\n      setImmediate(() => {\n        self.finishWrite(handle\x2C errCode);\n      });\n    }\n\n    return 0;\n  }\n\n  // handle === this._handle except when called from doClose().\n  finishWrite(handle\x2C errCode) {\n    // The write request might already have been cancelled.\n    if (this[kCurrentWriteRequest] === null)\n      return;\n    const req = this[kCurrentWriteRequest];\n    this[kCurrentWriteRequest] = null;\n\n    handle.finishWrite(req\x2C errCode);\n    if (this[kPendingShutdownRequest]) {\n      const req = this[kPendingShutdownRequest];\n      this[kPendingShutdownRequest] = null;\n      this.doShutdown(req);\n    }\n  }\n\n  doClose(cb) {\n    const handle = this._handle;\n\n    // When sockets of the "net" module destroyed\x2C they will call\n    // `this._handle.close()` which will also emit EOF if not emitted before.\n    // This feature makes sockets on the other side emit "end" and "close"\n    // even though we haven't called `end()`. As `stream` are likely to be\n    // instances of `net.Socket`\x2C calling `stream.destroy()` manually will\n    // avoid issues that don't properly close wrapped connections.\n    this.stream.destroy();\n\n    setImmediate(() => {\n      // Should be already set by net.js\n      assert(this._handle === null);\n\n      this.finishWrite(handle\x2C uv.UV_ECANCELED);\n      this.finishShutdown(handle\x2C uv.UV_ECANCELED);\n\n      cb();\n    });\n  }\n}\n\nmodule.exports = JSStreamSocket;\n
code-source-info,0x2811abd13f9e,184,0,7449,C0O0C4O7449,,
code-creation,Function,10,96917,0x2811abd148ce,312, node:internal/js_stream_socket:1:1,0x2811abd13f18,~
code-source-info,0x2811abd148ce,184,0,7449,C0O0C65O25C70O76C73O76C78O59C84O110C87O110C91O110C93O157C96O157C101O146C106O194C109O194C114O181C120O235C123O235C127O235C129O270C132O270C137O303C150O304C156O270C158O393C161O393C166O424C171O376C177O462C180O462C185O488C190O442C196O526C199O526C203O526C205O590C208O590C212O590C214O657C217O657C221O657C230O1789C304O7416C306O7431C311O7448,,
code-creation,LazyCompile,10,97084,0x2811abd1a866,14,makeMethodProxy node:_tls_wrap:553:25,0x29d5d5bab9f8,~
code-source-info,0x2811abd1a866,169,15639,15790,C0O15639C9O15650C13O15788,,
code-creation,LazyCompile,10,97125,0x2811abd1e386,21, node:_tls_wrap:1035:4,0x29d5d5bac9b0,~
code-source-info,0x2811abd1e386,169,29220,29298,C0O29236C3O29246C11O29266C15O29264C20O29297,,
code-creation,LazyCompile,10,97125,0x2811abd1e4de,14,makeSocketMethodProxy node:_tls_wrap:1016:31,0x29d5d5babb60,~
code-source-info,0x2811abd1e4de,169,28834,29002,C0O28834C9O28845C13O29000,,
tick,0x100681d3c,97209,1,0x10041f4d8,5,0x0,0x105108c5c,0x10510894c,0x29d5d5b915fc,0x105108d28,0x10510894c,0x29d5d5b8ec0d,0x105108d28,0x26b72db365ba,0x26b72db2be93,0x26b72db1b016,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a89de,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,97209,0x2811abd1ec66,5, node:internal/tls/secure-pair:1:1,0x2811abd1ea90,~
script-source,185,node:internal/tls/secure-pair,'use strict';\n\nconst EventEmitter = require('events');\nconst { Duplex } = require('stream');\nconst _tls_wrap = require('_tls_wrap');\nconst _tls_common = require('_tls_common');\n\nconst {\n  Symbol\x2C\n  ReflectConstruct\x2C\n} = primordials;\n\nconst kCallback = Symbol('Callback');\nconst kOtherSide = Symbol('Other');\n\nclass DuplexSocket extends Duplex {\n  constructor() {\n    super();\n    this[kCallback] = null;\n    this[kOtherSide] = null;\n  }\n\n  _read() {\n    const callback = this[kCallback];\n    if (callback) {\n      this[kCallback] = null;\n      callback();\n    }\n  }\n\n  _write(chunk\x2C encoding\x2C callback) {\n    if (chunk.length === 0) {\n      process.nextTick(callback);\n    } else {\n      this[kOtherSide].push(chunk);\n      this[kOtherSide][kCallback] = callback;\n    }\n  }\n\n  _final(callback) {\n    this[kOtherSide].on('end'\x2C callback);\n    this[kOtherSide].push(null);\n  }\n}\n\nclass DuplexPair {\n  constructor() {\n    this.socket1 = new DuplexSocket();\n    this.socket2 = new DuplexSocket();\n    this.socket1[kOtherSide] = this.socket2;\n    this.socket2[kOtherSide] = this.socket1;\n  }\n}\n\nclass SecurePair extends EventEmitter {\n  constructor(secureContext = _tls_common.createSecureContext()\x2C\n              isServer = false\x2C\n              requestCert = !isServer\x2C\n              rejectUnauthorized = false\x2C\n              options = {}) {\n    super();\n    const { socket1\x2C socket2 } = new DuplexPair();\n\n    this.server = options.server;\n    this.credentials = secureContext;\n\n    this.encrypted = socket1;\n    this.cleartext = new _tls_wrap.TLSSocket(socket2\x2C {\n      secureContext\x2C\n      isServer\x2C\n      requestCert\x2C\n      rejectUnauthorized\x2C\n      ...options\n    });\n    this.cleartext.once('secure'\x2C () => this.emit('secure'));\n  }\n\n  destroy() {\n    this.cleartext.destroy();\n    this.encrypted.destroy();\n  }\n}\n\nexports.createSecurePair = function createSecurePair(...args) {\n  return ReflectConstruct(SecurePair\x2C args);\n};\n
code-source-info,0x2811abd1ec66,185,0,1929,C0O0C4O1929,,
code-creation,Function,10,97292,0x2811abd1f416,202, node:internal/tls/secure-pair:1:1,0x2811abd1ebe0,~
code-source-info,0x2811abd1f416,185,0,1929,C0O0C33O36C36O36C41O74C44O74C49O63C54O111C57O111C61O111C63O153C66O153C70O153C72O188C77O198C83O252C86O252C90O252C92O291C95O291C99O291C101O336C138O309C161O878C163O1115C190O1090C192O1817C196O1842C201O1928,,
code-creation,LazyCompile,10,97417,0x2811abd202be,88,Agent node:https:176:15,0x29d5d5b8e678,~
code-source-info,0x2811abd202be,162,4905,5281,C0O4919C2O4930C7O4953C12O4960C17O4979C18O4983C25O5005C34O4983C39O5034C43O5051C47O5060C49O5074C53O5118C58O5126C62O5111C66O5156C72O5193C74O5216C78O5226C82O5245C87O5280,,
code-creation,Function,11,97459,0x105110f40,160,addListener node:events:618:58,0x232faba26c28,^
code-source-info,0x105110f40,23,18237,18309,,,
code-creation,Function,11,97459,0x105111040,248,isURLInstance node:internal/url:1555:23,0x815de62d990,^
code-source-info,0x105111040,39,43511,43608,,,
code-creation,Function,11,97500,0x1051111a0,496, node:internal/fs/utils:687:40,0xd2efcc3f858,^
code-source-info,0x1051111a0,82,18690,18811,,,
code-creation,Function,11,97500,0x105111400,352,FastBuffer node:internal/buffer:958:14,0x232faba3ec18,^
code-source-info,0x105111400,25,26364,26453,,,
code-creation,Function,11,97500,0x1051115c0,672,alignPool node:buffer:159:19,0x232faba31a20,^
code-source-info,0x1051115c0,24,4032,4136,,,
code-creation,Function,11,97542,0x1051118c0,200,makeMethodProxy node:_tls_wrap:553:25,0x29d5d5bab9f8,^
code-source-info,0x1051118c0,169,15639,15790,,,
code-creation,Function,11,97542,0x105111a00,200,makeSocketMethodProxy node:_tls_wrap:1016:31,0x29d5d5babb60,^
code-source-info,0x105111a00,169,28834,29002,,,
code-creation,Function,11,97542,0x105111b40,176, node:_tls_wrap:1035:4,0x29d5d5bac9b0,^
code-source-info,0x105111b40,169,29220,29298,,,
code-creation,Function,11,97542,0x105111c60,200,checkListener node:events:258:23,0x232faba264e8,^
code-source-info,0x105111c60,23,7627,7683,,,
code-creation,RegExp,3,97667,0x105111da0,2008,^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$
code-creation,Eval,10,97834,0x2811abd22126,5, /Users/vignesh/Projects/HTTP2/lib/config.js:1:1,0x2811abd21fe0,~
script-source,186,/Users/vignesh/Projects/HTTP2/lib/config.js,/*\n * Create and export configuration variables\n *\n */\n\n// Container for all environments\nvar environments = {};\n\n// Staging (default) environment\nenvironments.staging = {\n  'httpPort' : 3000\x2C\n  'httpsPort' : 3001\x2C\n  'envName' : 'staging'\x2C\n  'hashingSecret' : 'thisIsASecret'\x2C\n  'maxChecks' : 5\x2C\n  'twilio' : {\n    'accountSid' : 'ACb32d411ad7fe886aac54c665d25e5c5d'\x2C\n    'authToken' : '9455e3eb3109edc12e3d8c92768f7a67'\x2C\n    'fromPhone' : '+15005550006'\n  }\x2C\n  'templateGlobals' : {\n    'appName' : 'UptimeChecker'\x2C\n    'companyName' : 'NotARealCompany\x2C Inc.'\x2C\n    'yearCreated' : '2018'\x2C\n    'baseUrl' : 'http://localhost:3000/'\n  }\n};\n\n// Testing environment\nenvironments.testing = {\n  'httpPort' : 4000\x2C\n  'httpsPort' : 4001\x2C\n  'envName' : 'testing'\x2C\n  'hashingSecret' : 'thisIsASecret'\x2C\n  'maxChecks' : 5\x2C\n  'twilio' : {\n    'accountSid' : 'ACb32d411ad7fe886aac54c665d25e5c5d'\x2C\n    'authToken' : '9455e3eb3109edc12e3d8c92768f7a67'\x2C\n    'fromPhone' : '+15005550006'\n  }\x2C\n  'templateGlobals' : {\n    'appName' : 'UptimeChecker'\x2C\n    'companyName' : 'NotARealCompany\x2C Inc.'\x2C\n    'yearCreated' : '2018'\x2C\n    'baseUrl' : 'http://localhost:4000/'\n  }\n};\n\n// Production environment\nenvironments.production = {\n  'httpPort' : 5000\x2C\n  'httpsPort' : 5001\x2C\n  'envName' : 'production'\x2C\n  'hashingSecret' : 'thisIsAlsoASecret'\x2C\n  'maxChecks' : 10\x2C\n  'twilio' : {\n    'accountSid' : ''\x2C\n    'authToken' : ''\x2C\n    'fromPhone' : ''\n  }\x2C\n  'templateGlobals' : {\n    'appName' : 'UptimeChecker'\x2C\n    'companyName' : 'NotARealCompany\x2C Inc.'\x2C\n    'yearCreated' : '2018'\x2C\n    'baseUrl' : 'http://localhost:5000/'\n  }\n};\n\n// Determine which environment was passed as a command-line argument\nvar currentEnvironment = typeof(process.env.NODE_ENV) == 'string' ? process.env.NODE_ENV.toLowerCase() : '';\n\n// Check that the current environment is one of the environments above\x2C if not default to staging\nvar environmentToExport = typeof(environments[currentEnvironment]) == 'object' ? environments[currentEnvironment] : environments.staging;\n\n// Export the module\nmodule.exports = environmentToExport;\n
code-source-info,0x2811abd22126,186,0,2080,C0O0C4O2080,,
code-creation,Function,10,97917,0x2811abd22576,100, /Users/vignesh/Projects/HTTP2/lib/config.js:1:1,0x2811abd220a0,~
code-source-info,0x2811abd22576,186,0,2080,C0O109C2O147C6O168C10O662C14O683C18O1180C22O1204C26O1699C30O1714C35O1718C43O1742C47O1750C52O1754C57O1763C62O1763C71O1908C73O1927C82O1975C87O2011C92O2042C94O2057C99O2079,,
code-creation,Function,11,97959,0x1051125e0,1296,Module.require node:internal/modules/cjs/loader:991:36,0x3172a1b2b470,^
code-source-info,0x1051125e0,103,30953,31244,,,
code-creation,Function,11,98000,0x105112b60,592,loadNativeModule node:internal/modules/cjs/helpers:44:26,0x3172a1b24d30,^
code-source-info,0x105112b60,102,1151,1431,,,
code-creation,Function,11,98000,0x105112e20,936,stat node:internal/modules/cjs/loader:151:14,0x3172a1b2a590,^
code-source-info,0x105112e20,103,4627,5024,,,
code-creation,Function,11,98042,0x105113240,672,splitRoot node:fs:2379:33,0xd2efcc367b0,^
code-source-info,0x105113240,81,63205,63397,,,
code-creation,Function,11,98042,0x105113540,696,handleErrorFromBinding node:internal/fs/utils:341:32,0xd2efcc3ede0,^
code-source-info,0x105113540,82,7964,8462,,,
code-creation,LazyCompile,10,98084,0x2811abd23386,11,get ReadStream node:fs:3001:17,0xd2efcc36e40,~
code-source-info,0x2811abd23386,81,79341,79395,C0O79350C3O79350C6O79373C10O79391,,
code-creation,LazyCompile,10,98125,0x2811abd234b6,71,lazyLoadStreams node:fs:2858:25,0xd2efcc36d08,~
code-source-info,0x2811abd234b6,81,76946,77113,C0O76953C6O76976C12O77007C17O76979C30O76991C43O77044C50O77059C56O77077C63O77093C70O77112,,
code-creation,Eval,10,98292,0x2811abd23cb6,5, node:internal/fs/streams:1:1,0x2811abd23930,~
script-source,187,node:internal/fs/streams,'use strict';\n\nconst {\n  Array\x2C\n  FunctionPrototypeBind\x2C\n  MathMin\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  PromisePrototypeThen\x2C\n  ReflectApply\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\x2C\n  ERR_METHOD_NOT_IMPLEMENTED\x2C\n} = require('internal/errors').codes;\nconst { deprecate } = require('internal/util');\nconst {\n  validateFunction\x2C\n  validateInteger\x2C\n} = require('internal/validators');\nconst { errorOrDestroy } = require('internal/streams/destroy');\nconst fs = require('fs');\nconst { kRef\x2C kUnref\x2C FileHandle } = require('internal/fs/promises');\nconst { Buffer } = require('buffer');\nconst {\n  copyObject\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  validatePath\x2C\n} = require('internal/fs/utils');\nconst { Readable\x2C Writable\x2C finished } = require('stream');\nconst { toPathIfFileURL } = require('internal/url');\nconst kIoDone = Symbol('kIoDone');\nconst kIsPerformingIO = Symbol('kIsPerformingIO');\n\nconst kFs = Symbol('kFs');\nconst kHandle = Symbol('kHandle');\n\nfunction _construct(callback) {\n  const stream = this;\n  if (typeof stream.fd === 'number') {\n    callback();\n    return;\n  }\n\n  if (stream.open !== openWriteFs && stream.open !== openReadFs) {\n    // Backwards compat for monkey patching open().\n    const orgEmit = stream.emit;\n    stream.emit = function(...args) {\n      if (args[0] === 'open') {\n        this.emit = orgEmit;\n        callback();\n        ReflectApply(orgEmit\x2C this\x2C args);\n      } else if (args[0] === 'error') {\n        this.emit = orgEmit;\n        callback(args[1]);\n      } else {\n        ReflectApply(orgEmit\x2C this\x2C args);\n      }\n    };\n    stream.open();\n  } else {\n    stream[kFs].open(stream.path\x2C stream.flags\x2C stream.mode\x2C (er\x2C fd) => {\n      if (er) {\n        callback(er);\n      } else {\n        stream.fd = fd;\n        callback();\n        stream.emit('open'\x2C stream.fd);\n        stream.emit('ready');\n      }\n    });\n  }\n}\n\n// This generates an fs operations structure for a FileHandle\nconst FileHandleOperations = (handle) => {\n  return {\n    open: (path\x2C flags\x2C mode\x2C cb) => {\n      throw new ERR_METHOD_NOT_IMPLEMENTED('open()');\n    }\x2C\n    close: (fd\x2C cb) => {\n      handle[kUnref]();\n      PromisePrototypeThen(handle.close()\x2C\n                           () => cb()\x2C cb);\n    }\x2C\n    read: (fd\x2C buf\x2C offset\x2C length\x2C pos\x2C cb) => {\n      PromisePrototypeThen(handle.read(buf\x2C offset\x2C length\x2C pos)\x2C\n                           (r) => cb(null\x2C r.bytesRead\x2C r.buffer)\x2C\n                           (err) => cb(err\x2C 0\x2C buf));\n    }\x2C\n    write: (fd\x2C buf\x2C offset\x2C length\x2C pos\x2C cb) => {\n      PromisePrototypeThen(handle.write(buf\x2C offset\x2C length\x2C pos)\x2C\n                           (r) => cb(null\x2C r.bytesWritten\x2C r.buffer)\x2C\n                           (err) => cb(err\x2C 0\x2C buf));\n    }\x2C\n    writev: (fd\x2C buffers\x2C pos\x2C cb) => {\n      PromisePrototypeThen(handle.writev(buffers\x2C pos)\x2C\n                           (r) => cb(null\x2C r.bytesWritten\x2C r.buffers)\x2C\n                           (err) => cb(err\x2C 0\x2C buffers));\n    }\n  };\n};\n\nfunction close(stream\x2C err\x2C cb) {\n  if (!stream.fd) {\n    // TODO(ronag)\n    // stream.closed = true;\n    cb(err);\n  } else {\n    stream[kFs].close(stream.fd\x2C (er) => {\n      stream.closed = true;\n      cb(er || err);\n    });\n    stream.fd = null;\n  }\n}\n\nfunction importFd(stream\x2C options) {\n  if (typeof options.fd === 'number') {\n    // When fd is a raw descriptor\x2C we must keep our fingers crossed\n    // that the descriptor won't get closed\x2C or worse\x2C replaced with\n    // another one\n    // https://github.com/nodejs/node/issues/35862\n    stream[kFs] = options.fs || fs;\n    return options.fd;\n  } else if (typeof options.fd === 'object' &&\n             options.fd instanceof FileHandle) {\n    // When fd is a FileHandle we can listen for 'close' events\n    if (options.fs) {\n      // FileHandle is not supported with custom fs operations\n      throw new ERR_METHOD_NOT_IMPLEMENTED('FileHandle with fs');\n    }\n    stream[kHandle] = options.fd;\n    stream[kFs] = FileHandleOperations(stream[kHandle]);\n    stream[kHandle][kRef]();\n    options.fd.on('close'\x2C FunctionPrototypeBind(stream.close\x2C stream));\n    return options.fd.fd;\n  }\n\n  throw ERR_INVALID_ARG_TYPE('options.fd'\x2C\n                             ['number'\x2C 'FileHandle']\x2C options.fd);\n}\n\nfunction ReadStream(path\x2C options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(path\x2C options);\n\n  // A little bit bigger buffer and water marks by default\n  options = copyObject(getOptions(options\x2C {}));\n  if (options.highWaterMark === undefined)\n    options.highWaterMark = 64 * 1024;\n\n  if (options.autoDestroy === undefined) {\n    options.autoDestroy = false;\n  }\n\n  if (options.fd == null) {\n    this.fd = null;\n    this[kFs] = options.fs || fs;\n    validateFunction(this[kFs].open\x2C 'options.fs.open');\n\n    // Path will be ignored when fd is specified\x2C so it can be falsy\n    this.path = toPathIfFileURL(path);\n    this.flags = options.flags === undefined ? 'r' : options.flags;\n    this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n    validatePath(this.path);\n  } else {\n    this.fd = getValidatedFd(importFd(this\x2C options));\n  }\n\n  options.autoDestroy = options.autoClose === undefined ?\n    true : options.autoClose;\n\n  validateFunction(this[kFs].read\x2C 'options.fs.read');\n\n  if (options.autoDestroy) {\n    validateFunction(this[kFs].close\x2C 'options.fs.close');\n  }\n\n  this.start = options.start;\n  this.end = options.end;\n  this.pos = undefined;\n  this.bytesRead = 0;\n  this.closed = false;\n  this[kIsPerformingIO] = false;\n\n  if (this.start !== undefined) {\n    validateInteger(this.start\x2C 'start'\x2C 0);\n\n    this.pos = this.start;\n  }\n\n\n  if (this.end === undefined) {\n    this.end = Infinity;\n  } else if (this.end !== Infinity) {\n    validateInteger(this.end\x2C 'end'\x2C 0);\n\n    if (this.start !== undefined && this.start > this.end) {\n      throw new ERR_OUT_OF_RANGE(\n        'start'\x2C\n        `<= "end" (here: ${this.end})`\x2C\n        this.start\n      );\n    }\n  }\n\n  ReflectApply(Readable\x2C this\x2C [options]);\n}\nObjectSetPrototypeOf(ReadStream.prototype\x2C Readable.prototype);\nObjectSetPrototypeOf(ReadStream\x2C Readable);\n\nObjectDefineProperty(ReadStream.prototype\x2C 'autoClose'\x2C {\n  get() {\n    return this._readableState.autoDestroy;\n  }\x2C\n  set(val) {\n    this._readableState.autoDestroy = val;\n  }\n});\n\nconst openReadFs = deprecate(function() {\n  // Noop.\n}\x2C 'ReadStream.prototype.open() is deprecated'\x2C 'DEP0135');\nReadStream.prototype.open = openReadFs;\n\nReadStream.prototype._construct = _construct;\n\nReadStream.prototype._read = function(n) {\n  n = this.pos !== undefined ?\n    MathMin(this.end - this.pos + 1\x2C n) :\n    MathMin(this.end - this.bytesRead + 1\x2C n);\n\n  if (n <= 0) {\n    this.push(null);\n    return;\n  }\n\n  const buf = Buffer.allocUnsafeSlow(n);\n\n  this[kIsPerformingIO] = true;\n  this[kFs]\n    .read(this.fd\x2C buf\x2C 0\x2C n\x2C this.pos\x2C (er\x2C bytesRead\x2C buf) => {\n      this[kIsPerformingIO] = false;\n\n      // Tell ._destroy() that it's safe to close the fd now.\n      if (this.destroyed) {\n        this.emit(kIoDone\x2C er);\n        return;\n      }\n\n      if (er) {\n        errorOrDestroy(this\x2C er);\n      } else if (bytesRead > 0) {\n        if (this.pos !== undefined) {\n          this.pos += bytesRead;\n        }\n\n        this.bytesRead += bytesRead;\n\n        if (bytesRead !== buf.length) {\n          // Slow path. Shrink to fit.\n          // Copy instead of slice so that we don't retain\n          // large backing buffer for small reads.\n          const dst = Buffer.allocUnsafeSlow(bytesRead);\n          buf.copy(dst\x2C 0\x2C 0\x2C bytesRead);\n          buf = dst;\n        }\n\n        this.push(buf);\n      } else {\n        this.push(null);\n      }\n    });\n};\n\nReadStream.prototype._destroy = function(err\x2C cb) {\n  // Usually for async IO it is safe to close a file descriptor\n  // even when there are pending operations. However\x2C due to platform\n  // differences file IO is implemented using synchronous operations\n  // running in a thread pool. Therefore\x2C file descriptors are not safe\n  // to close while used in a pending read or write operation. Wait for\n  // any pending IO (kIsPerformingIO) to complete (kIoDone).\n  if (this[kIsPerformingIO]) {\n    this.once(kIoDone\x2C (er) => close(this\x2C err || er\x2C cb));\n  } else {\n    close(this\x2C err\x2C cb);\n  }\n};\n\nReadStream.prototype.close = function(cb) {\n  if (typeof cb === 'function') finished(this\x2C cb);\n  this.destroy();\n};\n\nObjectDefineProperty(ReadStream.prototype\x2C 'pending'\x2C {\n  get() { return this.fd === null; }\x2C\n  configurable: true\n});\n\nfunction WriteStream(path\x2C options) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(path\x2C options);\n\n  options = copyObject(getOptions(options\x2C {}));\n\n  // Only buffers are supported.\n  options.decodeStrings = true;\n\n  if (options.fd == null) {\n    this.fd = null;\n    this[kFs] = options.fs || fs;\n    validateFunction(this[kFs].open\x2C 'options.fs.open');\n\n    // Path will be ignored when fd is specified\x2C so it can be falsy\n    this.path = toPathIfFileURL(path);\n    this.flags = options.flags === undefined ? 'w' : options.flags;\n    this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n    validatePath(this.path);\n  } else {\n    this.fd = getValidatedFd(importFd(this\x2C options));\n  }\n\n  options.autoDestroy = options.autoClose === undefined ?\n    true : options.autoClose;\n\n  if (!this[kFs].write && !this[kFs].writev) {\n    throw new ERR_INVALID_ARG_TYPE('options.fs.write'\x2C 'function'\x2C\n                                   this[kFs].write);\n  }\n\n  if (this[kFs].write) {\n    validateFunction(this[kFs].write\x2C 'options.fs.write');\n  }\n\n  if (this[kFs].writev) {\n    validateFunction(this[kFs].writev\x2C 'options.fs.writev');\n  }\n\n  if (options.autoDestroy) {\n    validateFunction(this[kFs].close\x2C 'options.fs.close');\n  }\n\n  // It's enough to override either\x2C in which case only one will be used.\n  if (!this[kFs].write) {\n    this._write = null;\n  }\n  if (!this[kFs].writev) {\n    this._writev = null;\n  }\n\n  this.start = options.start;\n  this.pos = undefined;\n  this.bytesWritten = 0;\n  this.closed = false;\n  this[kIsPerformingIO] = false;\n\n\n  if (this.start !== undefined) {\n    validateInteger(this.start\x2C 'start'\x2C 0);\n\n    this.pos = this.start;\n  }\n\n  ReflectApply(Writable\x2C this\x2C [options]);\n\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n}\nObjectSetPrototypeOf(WriteStream.prototype\x2C Writable.prototype);\nObjectSetPrototypeOf(WriteStream\x2C Writable);\n\nObjectDefineProperty(WriteStream.prototype\x2C 'autoClose'\x2C {\n  get() {\n    return this._writableState.autoDestroy;\n  }\x2C\n  set(val) {\n    this._writableState.autoDestroy = val;\n  }\n});\n\nconst openWriteFs = deprecate(function() {\n  // Noop.\n}\x2C 'WriteStream.prototype.open() is deprecated'\x2C 'DEP0135');\nWriteStream.prototype.open = openWriteFs;\n\nWriteStream.prototype._construct = _construct;\n\nWriteStream.prototype._write = function(data\x2C encoding\x2C cb) {\n  this[kIsPerformingIO] = true;\n  this[kFs].write(this.fd\x2C data\x2C 0\x2C data.length\x2C this.pos\x2C (er\x2C bytes) => {\n    this[kIsPerformingIO] = false;\n    if (this.destroyed) {\n      // Tell ._destroy() that it's safe to close the fd now.\n      cb(er);\n      return this.emit(kIoDone\x2C er);\n    }\n\n    if (er) {\n      return cb(er);\n    }\n\n    this.bytesWritten += bytes;\n    cb();\n  });\n\n  if (this.pos !== undefined)\n    this.pos += data.length;\n};\n\nWriteStream.prototype._writev = function(data\x2C cb) {\n  const len = data.length;\n  const chunks = new Array(len);\n  let size = 0;\n\n  for (let i = 0; i < len; i++) {\n    const chunk = data[i].chunk;\n\n    chunks[i] = chunk;\n    size += chunk.length;\n  }\n\n  this[kIsPerformingIO] = true;\n  this[kFs].writev(this.fd\x2C chunks\x2C this.pos\x2C (er\x2C bytes) => {\n    this[kIsPerformingIO] = false;\n    if (this.destroyed) {\n      // Tell ._destroy() that it's safe to close the fd now.\n      cb(er);\n      return this.emit(kIoDone\x2C er);\n    }\n\n    if (er) {\n      return cb(er);\n    }\n\n    this.bytesWritten += bytes;\n    cb();\n  });\n\n  if (this.pos !== undefined)\n    this.pos += size;\n};\n\nWriteStream.prototype._destroy = function(err\x2C cb) {\n  // Usually for async IO it is safe to close a file descriptor\n  // even when there are pending operations. However\x2C due to platform\n  // differences file IO is implemented using synchronous operations\n  // running in a thread pool. Therefore\x2C file descriptors are not safe\n  // to close while used in a pending read or write operation. Wait for\n  // any pending IO (kIsPerformingIO) to complete (kIoDone).\n  if (this[kIsPerformingIO]) {\n    this.once(kIoDone\x2C (er) => close(this\x2C err || er\x2C cb));\n  } else {\n    close(this\x2C err\x2C cb);\n  }\n};\n\nWriteStream.prototype.close = function(cb) {\n  if (cb) {\n    if (this.closed) {\n      process.nextTick(cb);\n      return;\n    }\n    this.on('close'\x2C cb);\n  }\n\n  // If we are not autoClosing\x2C we should call\n  // destroy on 'finish'.\n  if (!this.autoClose) {\n    this.on('finish'\x2C this.destroy);\n  }\n\n  // We use end() instead of destroy() because of\n  // https://github.com/nodejs/node/issues/2006\n  this.end();\n};\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\nObjectDefineProperty(WriteStream.prototype\x2C 'pending'\x2C {\n  get() { return this.fd === null; }\x2C\n  configurable: true\n});\n\nmodule.exports = {\n  ReadStream\x2C\n  WriteStream\n};\n
code-source-info,0x2811abd23cb6,187,0,13266,C0O0C4O13266,,
code-creation,Function,10,98792,0x2811abd2495e,866, node:internal/fs/streams:1:1,0x2811abd23c30,~
code-source-info,0x2811abd2495e,187,0,13266,C0O0C131O25C137O34C143O59C149O70C154O94C159O118C165O142C171O158C176O270C179O270C184O296C189O194C195O218C201O238C207O326C210O326C215O312C220O403C223O403C228O362C234O382C240O462C243O462C248O443C254O510C257O510C261O510C263O562C266O562C271O533C277O539C283O547C289O614C292O614C297O603C303O707C306O707C311O643C317O657C323O671C329O689C335O778C338O778C343O745C349O755C355O765C361O825C364O825C369O805C375O866C378O866C382O866C384O909C387O909C391O909C393O949C396O949C400O949C402O980C405O980C409O980C411O1996C415O1996C417O6007C420O6039C428O6059C433O6007C438O6071C444O6071C449O6116C452O6148C465O6176C473O6235C481O6116C486O6317C497O6317C502O6317C504O6411C507O6422C514O6437C518O6452C521O6463C528O6484C532O6499C535O6510C544O6526C548O7662C551O7673C560O7692C564O8258C567O8269C576O8285C580O8376C583O8408C596O8434C604O8376C609O10302C612O10335C620O10355C625O10302C630O10367C636O10367C641O10413C644O10446C657O10474C665O10533C673O10413C678O10616C689O10616C694O10616C696O10711C699O10723C706O10738C710O10754C713O10766C720O10787C724O10802C727O10814C736O10831C740O11307C743O11319C752O11337C756O11982C759O11994C768O12013C772O12579C775O12591C784O12607C788O13031C791O13043C799O13079C804O13089C808O13065C812O13095C815O13128C828O13154C836O13095C841O13216C848O13237C854O13251C860O13231C865O13265,,
tick,0x1007bca68,98875,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x2811abd234c2,0x2811abd23389,0x100d4d654,0x10510c9c8,0x10510b8cc,0x2cbd76493d88,0x1003a57dc,0x2cbd76493a22,0x26b72db365fd,0x105112d34,0x26b72db1b016,0x1051128a8,0x26b72db362ce,0x2cbd764a8a06,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,98917,0x2811abd264ae,11,get WriteStream node:fs:3010:18,0xd2efcc36f20,~
code-source-info,0x2811abd264ae,81,79467,79522,C0O79476C3O79476C6O79499C10O79518,,
code-creation,LazyCompile,10,98917,0x2811abd265be,11,get FileReadStream node:fs:3021:21,0xd2efcc37000,~
code-source-info,0x2811abd265be,81,79732,79790,C0O79741C3O79741C6O79764C10O79786,,
code-creation,LazyCompile,10,98959,0x2811abd266ce,11,get FileWriteStream node:fs:3030:22,0xd2efcc370f0,~
code-source-info,0x2811abd266ce,81,79874,79933,C0O79883C3O79883C6O79906C10O79929,,
code-creation,LazyCompile,10,98959,0x2811abd267c6,37,get node:fs:3056:8,0xd2efcc371e0,~
code-source-info,0x2811abd267c6,81,80429,80522,C0O80440C14O80453C19O80484C26O80449C32O80500C36O80516,,
code-creation,Eval,10,99375,0x2811abd27416,5, /Users/vignesh/Projects/HTTP2/lib/handlers.js:1:1,0x2811abd27250,~
script-source,188,/Users/vignesh/Projects/HTTP2/lib/handlers.js,/*\n * Request Handlers\n *\n */\n\n// Dependencies\nvar _data = require('./data');\nvar helpers = require('./helpers');\nvar config = require('./config');\nvar dns = require('dns');\nvar _url = require('url');\nvar _performance = require('perf_hooks').performance;\nvar util = require('util');\nvar debug = util.debuglog('performance');\n\n// Define all the handlers\nvar handlers = {};\n\n/*\n * HTML Handlers\n *\n */\n\n// Index\nhandlers.index = function(data\x2Ccallback){\n  // Reject any request that isn't a GET\n  if(data.method == 'get'){\n    // Prepare data for interpolation\n    var templateData = {\n      'head.title' : 'Uptime Monitoring - Made Simple'\x2C\n      'head.description' : 'We offer free\x2C simple uptime monitoring for HTTP/HTTPS sites all kinds. When your site goes down\x2C we\\'ll send you a text to let you know'\x2C\n      'body.class' : 'index'\n    };\n\n    // Read in a template as a string\n    helpers.getTemplate('index'\x2CtemplateData\x2Cfunction(err\x2Cstr){\n      if(!err && str){\n        // Add the universal header and footer\n        helpers.addUniversalTemplates(str\x2CtemplateData\x2Cfunction(err\x2Cstr){\n          if(!err && str){\n            // Return that page as HTML\n            callback(200\x2Cstr\x2C'html');\n          } else {\n            callback(500\x2Cundefined\x2C'html');\n          }\n        });\n      } else {\n        callback(500\x2Cundefined\x2C'html');\n      }\n    });\n  } else {\n    callback(405\x2Cundefined\x2C'html');\n  }\n};\n\n// Create Account\nhandlers.accountCreate = function(data\x2Ccallback){\n  // Reject any request that isn't a GET\n  if(data.method == 'get'){\n    // Prepare data for interpolation\n    var templateData = {\n      'head.title' : 'Create an Account'\x2C\n      'head.description' : 'Signup is easy and only takes a few seconds.'\x2C\n      'body.class' : 'accountCreate'\n    };\n    // Read in a template as a string\n    helpers.getTemplate('accountCreate'\x2CtemplateData\x2Cfunction(err\x2Cstr){\n      if(!err && str){\n        // Add the universal header and footer\n        helpers.addUniversalTemplates(str\x2CtemplateData\x2Cfunction(err\x2Cstr){\n          if(!err && str){\n            // Return that page as HTML\n            callback(200\x2Cstr\x2C'html');\n          } else {\n            callback(500\x2Cundefined\x2C'html');\n          }\n        });\n      } else {\n        callback(500\x2Cundefined\x2C'html');\n      }\n    });\n  } else {\n    callback(405\x2Cundefined\x2C'html');\n  }\n};\n\n// Create New Session\nhandlers.sessionCreate = function(data\x2Ccallback){\n  // Reject any request that isn't a GET\n  if(data.method == 'get'){\n    // Prepare data for interpolation\n    var templateData = {\n      'head.title' : 'Login to your account.'\x2C\n      'head.description' : 'Please enter your phone number and password to access your account.'\x2C\n      'body.class' : 'sessionCreate'\n    };\n    // Read in a template as a string\n    helpers.getTemplate('sessionCreate'\x2CtemplateData\x2Cfunction(err\x2Cstr){\n      if(!err && str){\n        // Add the universal header and footer\n        helpers.addUniversalTemplates(str\x2CtemplateData\x2Cfunction(err\x2Cstr){\n          if(!err && str){\n            // Return that page as HTML\n            callback(200\x2Cstr\x2C'html');\n          } else {\n            callback(500\x2Cundefined\x2C'html');\n          }\n        });\n      } else {\n        callback(500\x2Cundefined\x2C'html');\n      }\n    });\n  } else {\n    callback(405\x2Cundefined\x2C'html');\n  }\n};\n\n// Edit Your Account\nhandlers.accountEdit = function(data\x2Ccallback){\n  // Reject any request that isn't a GET\n  if(data.method == 'get'){\n    // Prepare data for interpolation\n    var templateData = {\n      'head.title' : 'Account Settings'\x2C\n      'body.class' : 'accountEdit'\n    };\n    // Read in a template as a string\n    helpers.getTemplate('accountEdit'\x2CtemplateData\x2Cfunction(err\x2Cstr){\n      if(!err && str){\n        // Add the universal header and footer\n        helpers.addUniversalTemplates(str\x2CtemplateData\x2Cfunction(err\x2Cstr){\n          if(!err && str){\n            // Return that page as HTML\n            callback(200\x2Cstr\x2C'html');\n          } else {\n            callback(500\x2Cundefined\x2C'html');\n          }\n        });\n      } else {\n        callback(500\x2Cundefined\x2C'html');\n      }\n    });\n  } else {\n    callback(405\x2Cundefined\x2C'html');\n  }\n};\n\n// Session has been deleted\nhandlers.sessionDeleted = function(data\x2Ccallback){\n  // Reject any request that isn't a GET\n  if(data.method == 'get'){\n    // Prepare data for interpolation\n    var templateData = {\n      'head.title' : 'Logged Out'\x2C\n      'head.description' : 'You have been logged out of your account.'\x2C\n      'body.class' : 'sessionDeleted'\n    };\n    // Read in a template as a string\n    helpers.getTemplate('sessionDeleted'\x2CtemplateData\x2Cfunction(err\x2Cstr){\n      if(!err && str){\n        // Add the universal header and footer\n        helpers.addUniversalTemplates(str\x2CtemplateData\x2Cfunction(err\x2Cstr){\n          if(!err && str){\n            // Return that page as HTML\n            callback(200\x2Cstr\x2C'html');\n          } else {\n            callback(500\x2Cundefined\x2C'html');\n          }\n        });\n      } else {\n        callback(500\x2Cundefined\x2C'html');\n      }\n    });\n  } else {\n    callback(405\x2Cundefined\x2C'html');\n  }\n};\n\n// Account has been deleted\nhandlers.accountDeleted = function(data\x2Ccallback){\n  // Reject any request that isn't a GET\n  if(data.method == 'get'){\n    // Prepare data for interpolation\n    var templateData = {\n      'head.title' : 'Account Deleted'\x2C\n      'head.description' : 'Your account has been deleted.'\x2C\n      'body.class' : 'accountDeleted'\n    };\n    // Read in a template as a string\n    helpers.getTemplate('accountDeleted'\x2CtemplateData\x2Cfunction(err\x2Cstr){\n      if(!err && str){\n        // Add the universal header and footer\n        helpers.addUniversalTemplates(str\x2CtemplateData\x2Cfunction(err\x2Cstr){\n          if(!err && str){\n            // Return that page as HTML\n            callback(200\x2Cstr\x2C'html');\n          } else {\n            callback(500\x2Cundefined\x2C'html');\n          }\n        });\n      } else {\n        callback(500\x2Cundefined\x2C'html');\n      }\n    });\n  } else {\n    callback(405\x2Cundefined\x2C'html');\n  }\n};\n\n// Create a new check\nhandlers.checksCreate = function(data\x2Ccallback){\n  // Reject any request that isn't a GET\n  if(data.method == 'get'){\n    // Prepare data for interpolation\n    var templateData = {\n      'head.title' : 'Create a New Check'\x2C\n      'body.class' : 'checksCreate'\n    };\n    // Read in a template as a string\n    helpers.getTemplate('checksCreate'\x2CtemplateData\x2Cfunction(err\x2Cstr){\n      if(!err && str){\n        // Add the universal header and footer\n        helpers.addUniversalTemplates(str\x2CtemplateData\x2Cfunction(err\x2Cstr){\n          if(!err && str){\n            // Return that page as HTML\n            callback(200\x2Cstr\x2C'html');\n          } else {\n            callback(500\x2Cundefined\x2C'html');\n          }\n        });\n      } else {\n        callback(500\x2Cundefined\x2C'html');\n      }\n    });\n  } else {\n    callback(405\x2Cundefined\x2C'html');\n  }\n};\n\n// Dashboard (view all checks)\nhandlers.checksList = function(data\x2Ccallback){\n  // Reject any request that isn't a GET\n  if(data.method == 'get'){\n    // Prepare data for interpolation\n    var templateData = {\n      'head.title' : 'Dashboard'\x2C\n      'body.class' : 'checksList'\n    };\n    // Read in a template as a string\n    helpers.getTemplate('checksList'\x2CtemplateData\x2Cfunction(err\x2Cstr){\n      if(!err && str){\n        // Add the universal header and footer\n        helpers.addUniversalTemplates(str\x2CtemplateData\x2Cfunction(err\x2Cstr){\n          if(!err && str){\n            // Return that page as HTML\n            callback(200\x2Cstr\x2C'html');\n          } else {\n            callback(500\x2Cundefined\x2C'html');\n          }\n        });\n      } else {\n        callback(500\x2Cundefined\x2C'html');\n      }\n    });\n  } else {\n    callback(405\x2Cundefined\x2C'html');\n  }\n};\n\n// Edit a Check\nhandlers.checksEdit = function(data\x2Ccallback){\n  // Reject any request that isn't a GET\n  if(data.method == 'get'){\n    // Prepare data for interpolation\n    var templateData = {\n      'head.title' : 'Check Details'\x2C\n      'body.class' : 'checksEdit'\n    };\n    // Read in a template as a string\n    helpers.getTemplate('checksEdit'\x2CtemplateData\x2Cfunction(err\x2Cstr){\n      if(!err && str){\n        // Add the universal header and footer\n        helpers.addUniversalTemplates(str\x2CtemplateData\x2Cfunction(err\x2Cstr){\n          if(!err && str){\n            // Return that page as HTML\n            callback(200\x2Cstr\x2C'html');\n          } else {\n            callback(500\x2Cundefined\x2C'html');\n          }\n        });\n      } else {\n        callback(500\x2Cundefined\x2C'html');\n      }\n    });\n  } else {\n    callback(405\x2Cundefined\x2C'html');\n  }\n};\n\n// Favicon\nhandlers.favicon = function(data\x2Ccallback){\n  // Reject any request that isn't a GET\n  if(data.method == 'get'){\n    // Read in the favicon's data\n    helpers.getStaticAsset('favicon.ico'\x2Cfunction(err\x2Cdata){\n      if(!err && data){\n        // Callback the data\n        callback(200\x2Cdata\x2C'favicon');\n      } else {\n        callback(500);\n      }\n    });\n  } else {\n    callback(405);\n  }\n};\n\n// Public assets\nhandlers.public = function(data\x2Ccallback){\n  // Reject any request that isn't a GET\n  if(data.method == 'get'){\n    // Get the filename being requested\n    var trimmedAssetName = data.trimmedPath.replace('public/'\x2C'').trim();\n    if(trimmedAssetName.length > 0){\n      // Read in the asset's data\n      helpers.getStaticAsset(trimmedAssetName\x2Cfunction(err\x2Cdata){\n        if(!err && data){\n\n          // Determine the content type (default to plain text)\n          var contentType = 'plain';\n\n          if(trimmedAssetName.indexOf('.css') > -1){\n            contentType = 'css';\n          }\n\n          if(trimmedAssetName.indexOf('.png') > -1){\n            contentType = 'png';\n          }\n\n          if(trimmedAssetName.indexOf('.jpg') > -1){\n            contentType = 'jpg';\n          }\n\n          if(trimmedAssetName.indexOf('.ico') > -1){\n            contentType = 'favicon';\n          }\n\n          // Callback the data\n          callback(200\x2Cdata\x2CcontentType);\n        } else {\n          callback(404);\n        }\n      });\n    } else {\n      callback(404);\n    }\n\n  } else {\n    callback(405);\n  }\n};\n\n/*\n * JSON API Handlers\n *\n */\n\n // Ping\n handlers.ping = function(data\x2Ccallback){\n     callback(200);\n };\n\n // Error example (this is why we're wrapping the handler caller in a try catch)\n handlers.exampleError = function(data\x2Ccallback){\n   var err = new Error('This is an example error.');\n   throw(err);\n };\n\n // Not-Found\n handlers.notFound = function(data\x2Ccallback){\n   callback(404);\n };\n\n\n// Users\nhandlers.users = function(data\x2Ccallback){\n  var acceptableMethods = ['post'\x2C'get'\x2C'put'\x2C'delete'];\n  if(acceptableMethods.indexOf(data.method) > -1){\n    handlers._users[data.method](data\x2Ccallback);\n  } else {\n    callback(405);\n  }\n};\n\n// Container for all the users methods\nhandlers._users  = {};\n\n// Users - post\n// Required data: firstName\x2C lastName\x2C phone\x2C password\x2C tosAgreement\n// Optional data: none\nhandlers._users.post = function(data\x2Ccallback){\n  // Check that all required fields are filled out\n  var firstName = typeof(data.payload.firstName) == 'string' && data.payload.firstName.trim().length > 0 ? data.payload.firstName.trim() : false;\n  var lastName = typeof(data.payload.lastName) == 'string' && data.payload.lastName.trim().length > 0 ? data.payload.lastName.trim() : false;\n  var phone = typeof(data.payload.phone) == 'string' && data.payload.phone.trim().length == 10 ? data.payload.phone.trim() : false;\n  var password = typeof(data.payload.password) == 'string' && data.payload.password.trim().length > 0 ? data.payload.password.trim() : false;\n  var tosAgreement = typeof(data.payload.tosAgreement) == 'boolean' && data.payload.tosAgreement == true ? true : false;\n\n  if(firstName && lastName && phone && password && tosAgreement){\n    // Make sure the user doesnt already exist\n    _data.read('users'\x2Cphone\x2Cfunction(err\x2Cdata){\n      if(err){\n        // Hash the password\n        var hashedPassword = helpers.hash(password);\n\n        // Create the user object\n        if(hashedPassword){\n          var userObject = {\n            'firstName' : firstName\x2C\n            'lastName' : lastName\x2C\n            'phone' : phone\x2C\n            'hashedPassword' : hashedPassword\x2C\n            'tosAgreement' : true\n          };\n\n          // Store the user\n          _data.create('users'\x2Cphone\x2CuserObject\x2Cfunction(err){\n            if(!err){\n              callback(200);\n            } else {\n              callback(500\x2C{'Error' : 'Could not create the new user'});\n            }\n          });\n        } else {\n          callback(500\x2C{'Error' : 'Could not hash the user\\'s password.'});\n        }\n\n      } else {\n        // User alread exists\n        callback(400\x2C{'Error' : 'A user with that phone number already exists'});\n      }\n    });\n\n  } else {\n    callback(400\x2C{'Error' : 'Missing required fields'});\n  }\n\n};\n\n// Required data: phone\n// Optional data: none\nhandlers._users.get = function(data\x2Ccallback){\n  // Check that phone number is valid\n  var phone = typeof(data.queryStringObject.phone) == 'string' && data.queryStringObject.phone.trim().length == 10 ? data.queryStringObject.phone.trim() : false;\n  if(phone){\n\n    // Get token from headers\n    var token = typeof(data.headers.token) == 'string' ? data.headers.token : false;\n    // Verify that the given token is valid for the phone number\n    handlers._tokens.verifyToken(token\x2Cphone\x2Cfunction(tokenIsValid){\n      if(tokenIsValid){\n        // Lookup the user\n        _data.read('users'\x2Cphone\x2Cfunction(err\x2Cdata){\n          if(!err && data){\n            // Remove the hashed password from the user user object before returning it to the requester\n            delete data.hashedPassword;\n            callback(200\x2Cdata);\n          } else {\n            callback(404);\n          }\n        });\n      } else {\n        callback(403\x2C{"Error" : "Missing required token in header\x2C or token is invalid."})\n      }\n    });\n  } else {\n    callback(400\x2C{'Error' : 'Missing required field'})\n  }\n};\n\n// Required data: phone\n// Optional data: firstName\x2C lastName\x2C password (at least one must be specified)\nhandlers._users.put = function(data\x2Ccallback){\n  // Check for required field\n  var phone = typeof(data.payload.phone) == 'string' && data.payload.phone.trim().length == 10 ? data.payload.phone.trim() : false;\n\n  // Check for optional fields\n  var firstName = typeof(data.payload.firstName) == 'string' && data.payload.firstName.trim().length > 0 ? data.payload.firstName.trim() : false;\n  var lastName = typeof(data.payload.lastName) == 'string' && data.payload.lastName.trim().length > 0 ? data.payload.lastName.trim() : false;\n  var password = typeof(data.payload.password) == 'string' && data.payload.password.trim().length > 0 ? data.payload.password.trim() : false;\n\n  // Error if phone is invalid\n  if(phone){\n    // Error if nothing is sent to update\n    if(firstName || lastName || password){\n\n      // Get token from headers\n      var token = typeof(data.headers.token) == 'string' ? data.headers.token : false;\n\n      // Verify that the given token is valid for the phone number\n      handlers._tokens.verifyToken(token\x2Cphone\x2Cfunction(tokenIsValid){\n        if(tokenIsValid){\n\n          // Lookup the user\n          _data.read('users'\x2Cphone\x2Cfunction(err\x2CuserData){\n            if(!err && userData){\n              // Update the fields if necessary\n              if(firstName){\n                userData.firstName = firstName;\n              }\n              if(lastName){\n                userData.lastName = lastName;\n              }\n              if(password){\n                userData.hashedPassword = helpers.hash(password);\n              }\n              // Store the new updates\n              _data.update('users'\x2Cphone\x2CuserData\x2Cfunction(err){\n                if(!err){\n                  callback(200);\n                } else {\n                  callback(500\x2C{'Error' : 'Could not update the user.'});\n                }\n              });\n            } else {\n              callback(400\x2C{'Error' : 'Specified user does not exist.'});\n            }\n          });\n        } else {\n          callback(403\x2C{"Error" : "Missing required token in header\x2C or token is invalid."});\n        }\n      });\n    } else {\n      callback(400\x2C{'Error' : 'Missing fields to update.'});\n    }\n  } else {\n    callback(400\x2C{'Error' : 'Missing required field.'});\n  }\n\n};\n\n// Required data: phone\n// Cleanup old checks associated with the user\nhandlers._users.delete = function(data\x2Ccallback){\n  // Check that phone number is valid\n  var phone = typeof(data.queryStringObject.phone) == 'string' && data.queryStringObject.phone.trim().length == 10 ? data.queryStringObject.phone.trim() : false;\n  if(phone){\n\n    // Get token from headers\n    var token = typeof(data.headers.token) == 'string' ? data.headers.token : false;\n\n    // Verify that the given token is valid for the phone number\n    handlers._tokens.verifyToken(token\x2Cphone\x2Cfunction(tokenIsValid){\n      if(tokenIsValid){\n        // Lookup the user\n        _data.read('users'\x2Cphone\x2Cfunction(err\x2CuserData){\n          if(!err && userData){\n            // Delete the user's data\n            _data.delete('users'\x2Cphone\x2Cfunction(err){\n              if(!err){\n                // Delete each of the checks associated with the user\n                var userChecks = typeof(userData.checks) == 'object' && userData.checks instanceof Array ? userData.checks : [];\n                var checksToDelete = userChecks.length;\n                if(checksToDelete > 0){\n                  var checksDeleted = 0;\n                  var deletionErrors = false;\n                  // Loop through the checks\n                  userChecks.forEach(function(checkId){\n                    // Delete the check\n                    _data.delete('checks'\x2CcheckId\x2Cfunction(err){\n                      if(err){\n                        deletionErrors = true;\n                      }\n                      checksDeleted++;\n                      if(checksDeleted == checksToDelete){\n                        if(!deletionErrors){\n                          callback(200);\n                        } else {\n                          callback(500\x2C{'Error' : "Errors encountered while attempting to delete all of the user's checks. All checks may not have been deleted from the system successfully."})\n                        }\n                      }\n                    });\n                  });\n                } else {\n                  callback(200);\n                }\n              } else {\n                callback(500\x2C{'Error' : 'Could not delete the specified user'});\n              }\n            });\n          } else {\n            callback(400\x2C{'Error' : 'Could not find the specified user.'});\n          }\n        });\n      } else {\n        callback(403\x2C{"Error" : "Missing required token in header\x2C or token is invalid."});\n      }\n    });\n  } else {\n    callback(400\x2C{'Error' : 'Missing required field'})\n  }\n};\n\n// Tokens\nhandlers.tokens = function(data\x2Ccallback){\n  var acceptableMethods = ['post'\x2C'get'\x2C'put'\x2C'delete'];\n  if(acceptableMethods.indexOf(data.method) > -1){\n    handlers._tokens[data.method](data\x2Ccallback);\n  } else {\n    callback(405);\n  }\n};\n\n// Container for all the tokens methods\nhandlers._tokens  = {};\n\n// Tokens - post\n// Required data: phone\x2C password\n// Optional data: none\nhandlers._tokens.post = function(data\x2Ccallback){\n  _performance.mark('entered function');\n  var phone = typeof(data.payload.phone) == 'string' && data.payload.phone.trim().length == 10 ? data.payload.phone.trim() : false;\n  var password = typeof(data.payload.password) == 'string' && data.payload.password.trim().length > 0 ? data.payload.password.trim() : false;\n  _performance.mark('inputs validated');\n  if(phone && password){\n    // Lookup the user who matches that phone number\n    _performance.mark('beginning user lookup');\n    _data.read('users'\x2Cphone\x2Cfunction(err\x2CuserData){\n      _performance.mark('user lookup complete');\n      if(!err && userData){\n        // Hash the sent password\x2C and compare it to the password stored in the user object\n        _performance.mark('beginning password hashing');\n        var hashedPassword = helpers.hash(password);\n        _performance.mark('password hashing complete');\n        if(hashedPassword == userData.hashedPassword){\n          // If valid\x2C create a new token with a random name. Set an expiration date 1 hour in the future.\n          _performance.mark('creating data for token');\n          var tokenId = helpers.createRandomString(20);\n          var expires = Date.now() + 1000 * 60 * 60;\n          var tokenObject = {\n            'phone' : phone\x2C\n            'id' : tokenId\x2C\n            'expires' : expires\n          };\n\n          // Store the token\n          _performance.mark('beginning storing token');\n          _data.create('tokens'\x2CtokenId\x2CtokenObject\x2Cfunction(err){\n            _performance.mark('storing token complete');\n            // Gather all measurements\n            _performance.measure('Beginning to end'\x2C 'entered function'\x2C 'storing token complete');\n            _performance.measure('Validating user inputs'\x2C 'entered function'\x2C 'inputs validated');\n            _performance.measure('User lookup'\x2C 'beginning user lookup'\x2C 'user lookup complete');\n            _performance.measure('Password hashing'\x2C 'beginning password hashing'\x2C 'password hashing complete');\n            _performance.measure('Token data creation'\x2C'creating data for token'\x2C 'beginning storing token');\n            _performance.measure('Token storing'\x2C'beginning storing token'\x2C 'storing token complete');\n\n            // Log out all the measurements\n            var measurements = _performance.getEntriesByType('measure');\n            measurements.forEach(function(measurement){\n              debug('\\x1b[33m%s\\x1b[0m'\x2Cmeasurement.name+' '+measurement.duration);\n            });\n\n            if(!err){\n              callback(200\x2CtokenObject);\n            } else {\n              callback(500\x2C{'Error' : 'Could not create the new token'});\n            }\n          });\n        } else {\n          callback(400\x2C{'Error' : 'Password did not match the specified user\\'s stored password'});\n        }\n      } else {\n        callback(400\x2C{'Error' : 'Could not find the specified user.'});\n      }\n    });\n  } else {\n    callback(400\x2C{'Error' : 'Missing required field(s).'})\n  }\n};\n\n// Tokens - get\n// Required data: id\n// Optional data: none\nhandlers._tokens.get = function(data\x2Ccallback){\n  // Check that id is valid\n  var id = typeof(data.queryStringObject.id) == 'string' && data.queryStringObject.id.trim().length == 20 ? data.queryStringObject.id.trim() : false;\n  if(id){\n    // Lookup the token\n    _data.read('tokens'\x2Cid\x2Cfunction(err\x2CtokenData){\n      if(!err && tokenData){\n        callback(200\x2CtokenData);\n      } else {\n        callback(404);\n      }\n    });\n  } else {\n    callback(400\x2C{'Error' : 'Missing required field\x2C or field invalid'})\n  }\n};\n\n// Tokens - put\n// Required data: id\x2C extend\n// Optional data: none\nhandlers._tokens.put = function(data\x2Ccallback){\n  var id = typeof(data.payload.id) == 'string' && data.payload.id.trim().length == 20 ? data.payload.id.trim() : false;\n  var extend = typeof(data.payload.extend) == 'boolean' && data.payload.extend == true ? true : false;\n  if(id && extend){\n    // Lookup the existing token\n    _data.read('tokens'\x2Cid\x2Cfunction(err\x2CtokenData){\n      if(!err && tokenData){\n        // Check to make sure the token isn't already expired\n        if(tokenData.expires > Date.now()){\n          // Set the expiration an hour from now\n          tokenData.expires = Date.now() + 1000 * 60 * 60;\n          // Store the new updates\n          _data.update('tokens'\x2Cid\x2CtokenData\x2Cfunction(err){\n            if(!err){\n              callback(200);\n            } else {\n              callback(500\x2C{'Error' : 'Could not update the token\\'s expiration.'});\n            }\n          });\n        } else {\n          callback(400\x2C{"Error" : "The token has already expired\x2C and cannot be extended."});\n        }\n      } else {\n        callback(400\x2C{'Error' : 'Specified user does not exist.'});\n      }\n    });\n  } else {\n    callback(400\x2C{"Error": "Missing required field(s) or field(s) are invalid."});\n  }\n};\n\n\n// Tokens - delete\n// Required data: id\n// Optional data: none\nhandlers._tokens.delete = function(data\x2Ccallback){\n  // Check that id is valid\n  var id = typeof(data.queryStringObject.id) == 'string' && data.queryStringObject.id.trim().length == 20 ? data.queryStringObject.id.trim() : false;\n  if(id){\n    // Lookup the token\n    _data.read('tokens'\x2Cid\x2Cfunction(err\x2CtokenData){\n      if(!err && tokenData){\n        // Delete the token\n        _data.delete('tokens'\x2Cid\x2Cfunction(err){\n          if(!err){\n            callback(200);\n          } else {\n            callback(500\x2C{'Error' : 'Could not delete the specified token'});\n          }\n        });\n      } else {\n        callback(400\x2C{'Error' : 'Could not find the specified token.'});\n      }\n    });\n  } else {\n    callback(400\x2C{'Error' : 'Missing required field'})\n  }\n};\n\n// Verify if a given token id is currently valid for a given user\nhandlers._tokens.verifyToken = function(id\x2Cphone\x2Ccallback){\n  // Lookup the token\n  _data.read('tokens'\x2Cid\x2Cfunction(err\x2CtokenData){\n    if(!err && tokenData){\n      // Check that the token is for the given user and has not expired\n      if(tokenData.phone == phone && tokenData.expires > Date.now()){\n        callback(true);\n      } else {\n        callback(false);\n      }\n    } else {\n      callback(false);\n    }\n  });\n};\n\n// Checks\nhandlers.checks = function(data\x2Ccallback){\n  var acceptableMethods = ['post'\x2C'get'\x2C'put'\x2C'delete'];\n  if(acceptableMethods.indexOf(data.method) > -1){\n    handlers._checks[data.method](data\x2Ccallback);\n  } else {\n    callback(405);\n  }\n};\n\n// Container for all the checks methods\nhandlers._checks  = {};\n\n\n// Checks - post\n// Required data: protocol\x2Curl\x2Cmethod\x2CsuccessCodes\x2CtimeoutSeconds\n// Optional data: none\nhandlers._checks.post = function(data\x2Ccallback){\n  // Validate inputs\n  var protocol = typeof(data.payload.protocol) == 'string' && ['https'\x2C'http'].indexOf(data.payload.protocol) > -1 ? data.payload.protocol : false;\n  var url = typeof(data.payload.url) == 'string' && data.payload.url.trim().length > 0 ? data.payload.url.trim() : false;\n  var method = typeof(data.payload.method) == 'string' && ['post'\x2C'get'\x2C'put'\x2C'delete'].indexOf(data.payload.method) > -1 ? data.payload.method : false;\n  var successCodes = typeof(data.payload.successCodes) == 'object' && data.payload.successCodes instanceof Array && data.payload.successCodes.length > 0 ? data.payload.successCodes : false;\n  var timeoutSeconds = typeof(data.payload.timeoutSeconds) == 'number' && data.payload.timeoutSeconds % 1 === 0 && data.payload.timeoutSeconds >= 1 && data.payload.timeoutSeconds <= 5 ? data.payload.timeoutSeconds : false;\n  if(protocol && url && method && successCodes && timeoutSeconds){\n\n    // Get token from headers\n    var token = typeof(data.headers.token) == 'string' ? data.headers.token : false;\n\n    // Lookup the user phone by reading the token\n    _data.read('tokens'\x2Ctoken\x2Cfunction(err\x2CtokenData){\n      if(!err && tokenData){\n        var userPhone = tokenData.phone;\n\n        // Lookup the user data\n        _data.read('users'\x2CuserPhone\x2Cfunction(err\x2CuserData){\n          if(!err && userData){\n            var userChecks = typeof(userData.checks) == 'object' && userData.checks instanceof Array ? userData.checks : [];\n            // Verify that user has less than the number of max-checks per user\n            if(userChecks.length < config.maxChecks){\n\n              // Verify that the URL given has DNS entries (and therefore can resolve)\n              var parsedUrl = _url.parse(protocol+'://'+url\x2C true);\n              var hostName = typeof(parsedUrl.hostname) == 'string' && parsedUrl.hostname.length > 0 ? parsedUrl.hostname : false;\n              dns.resolve(hostName\x2Cfunction(err\x2Crecords){\n                if(!err && records){\n\n                  // Create random id for check\n                  var checkId = helpers.createRandomString(20);\n\n                  // Create check object including userPhone\n                  var checkObject = {\n                    'id' : checkId\x2C\n                    'userPhone' : userPhone\x2C\n                    'protocol' : protocol\x2C\n                    'url' : url\x2C\n                    'method' : method\x2C\n                    'successCodes' : successCodes\x2C\n                    'timeoutSeconds' : timeoutSeconds\n                  };\n\n                  // Save the object\n                  _data.create('checks'\x2CcheckId\x2CcheckObject\x2Cfunction(err){\n                    if(!err){\n                      // Add check id to the user's object\n                      userData.checks = userChecks;\n                      userData.checks.push(checkId);\n\n                      // Save the new user data\n                      _data.update('users'\x2CuserPhone\x2CuserData\x2Cfunction(err){\n                        if(!err){\n                          // Return the data about the new check\n                          callback(200\x2CcheckObject);\n                        } else {\n                          callback(500\x2C{'Error' : 'Could not update the user with the new check.'});\n                        }\n                      });\n                    } else {\n                      callback(500\x2C{'Error' : 'Could not create the new check'});\n                    }\n                  });\n                } else {\n                  callback(400\x2C{'Error' : 'The hostname of the URL entrered did not resolve to any DNS entries'});\n                }\n              });\n            } else {\n              callback(400\x2C{'Error' : 'The user already has the maximum number of checks ('+config.maxChecks+').'})\n            }\n          } else {\n            callback(403);\n          }\n        });\n      } else {\n        callback(403);\n      }\n    });\n  } else {\n    callback(400\x2C{'Error' : 'Missing required inputs\x2C or inputs are invalid'});\n  }\n};\n\n// Checks - get\n// Required data: id\n// Optional data: none\nhandlers._checks.get = function(data\x2Ccallback){\n  // Check that id is valid\n  var id = typeof(data.queryStringObject.id) == 'string' && data.queryStringObject.id.trim().length == 20 ? data.queryStringObject.id.trim() : false;\n  if(id){\n    // Lookup the check\n    _data.read('checks'\x2Cid\x2Cfunction(err\x2CcheckData){\n      if(!err && checkData){\n        // Get the token that sent the request\n        var token = typeof(data.headers.token) == 'string' ? data.headers.token : false;\n        // Verify that the given token is valid and belongs to the user who created the check\n        handlers._tokens.verifyToken(token\x2CcheckData.userPhone\x2Cfunction(tokenIsValid){\n          if(tokenIsValid){\n            // Return check data\n            callback(200\x2CcheckData);\n          } else {\n            callback(403);\n          }\n        });\n      } else {\n        callback(404);\n      }\n    });\n  } else {\n    callback(400\x2C{'Error' : 'Missing required field\x2C or field invalid'})\n  }\n};\n\n// Checks - put\n// Required data: id\n// Optional data: protocol\x2Curl\x2Cmethod\x2CsuccessCodes\x2CtimeoutSeconds (one must be sent)\nhandlers._checks.put = function(data\x2Ccallback){\n  // Check for required field\n  var id = typeof(data.payload.id) == 'string' && data.payload.id.trim().length == 20 ? data.payload.id.trim() : false;\n\n  // Check for optional fields\n  var protocol = typeof(data.payload.protocol) == 'string' && ['https'\x2C'http'].indexOf(data.payload.protocol) > -1 ? data.payload.protocol : false;\n  var url = typeof(data.payload.url) == 'string' && data.payload.url.trim().length > 0 ? data.payload.url.trim() : false;\n  var method = typeof(data.payload.method) == 'string' && ['post'\x2C'get'\x2C'put'\x2C'delete'].indexOf(data.payload.method) > -1 ? data.payload.method : false;\n  var successCodes = typeof(data.payload.successCodes) == 'object' && data.payload.successCodes instanceof Array && data.payload.successCodes.length > 0 ? data.payload.successCodes : false;\n  var timeoutSeconds = typeof(data.payload.timeoutSeconds) == 'number' && data.payload.timeoutSeconds % 1 === 0 && data.payload.timeoutSeconds >= 1 && data.payload.timeoutSeconds <= 5 ? data.payload.timeoutSeconds : false;\n\n  // Error if id is invalid\n  if(id){\n    // Error if nothing is sent to update\n    if(protocol || url || method || successCodes || timeoutSeconds){\n      // Lookup the check\n      _data.read('checks'\x2Cid\x2Cfunction(err\x2CcheckData){\n        if(!err && checkData){\n          // Get the token that sent the request\n          var token = typeof(data.headers.token) == 'string' ? data.headers.token : false;\n          // Verify that the given token is valid and belongs to the user who created the check\n          handlers._tokens.verifyToken(token\x2CcheckData.userPhone\x2Cfunction(tokenIsValid){\n            if(tokenIsValid){\n              // Update check data where necessary\n              if(protocol){\n                checkData.protocol = protocol;\n              }\n              if(url){\n                checkData.url = url;\n              }\n              if(method){\n                checkData.method = method;\n              }\n              if(successCodes){\n                checkData.successCodes = successCodes;\n              }\n              if(timeoutSeconds){\n                checkData.timeoutSeconds = timeoutSeconds;\n              }\n\n              // Store the new updates\n              _data.update('checks'\x2Cid\x2CcheckData\x2Cfunction(err){\n                if(!err){\n                  callback(200);\n                } else {\n                  callback(500\x2C{'Error' : 'Could not update the check.'});\n                }\n              });\n            } else {\n              callback(403);\n            }\n          });\n        } else {\n          callback(400\x2C{'Error' : 'Check ID did not exist.'});\n        }\n      });\n    } else {\n      callback(400\x2C{'Error' : 'Missing fields to update.'});\n    }\n  } else {\n    callback(400\x2C{'Error' : 'Missing required field.'});\n  }\n};\n\n\n// Checks - delete\n// Required data: id\n// Optional data: none\nhandlers._checks.delete = function(data\x2Ccallback){\n  // Check that id is valid\n  var id = typeof(data.queryStringObject.id) == 'string' && data.queryStringObject.id.trim().length == 20 ? data.queryStringObject.id.trim() : false;\n  if(id){\n    // Lookup the check\n    _data.read('checks'\x2Cid\x2Cfunction(err\x2CcheckData){\n      if(!err && checkData){\n        // Get the token that sent the request\n        var token = typeof(data.headers.token) == 'string' ? data.headers.token : false;\n        // Verify that the given token is valid and belongs to the user who created the check\n        handlers._tokens.verifyToken(token\x2CcheckData.userPhone\x2Cfunction(tokenIsValid){\n          if(tokenIsValid){\n\n            // Delete the check data\n            _data.delete('checks'\x2Cid\x2Cfunction(err){\n              if(!err){\n                // Lookup the user's object to get all their checks\n                _data.read('users'\x2CcheckData.userPhone\x2Cfunction(err\x2CuserData){\n                  if(!err){\n                    var userChecks = typeof(userData.checks) == 'object' && userData.checks instanceof Array ? userData.checks : [];\n\n                    // Remove the deleted check from their list of checks\n                    var checkPosition = userChecks.indexOf(id);\n                    if(checkPosition > -1){\n                      userChecks.splice(checkPosition\x2C1);\n                      // Re-save the user's data\n                      userData.checks = userChecks;\n                      _data.update('users'\x2CcheckData.userPhone\x2CuserData\x2Cfunction(err){\n                        if(!err){\n                          callback(200);\n                        } else {\n                          callback(500\x2C{'Error' : 'Could not update the user.'});\n                        }\n                      });\n                    } else {\n                      callback(500\x2C{"Error" : "Could not find the check on the user's object\x2C so could not remove it."});\n                    }\n                  } else {\n                    callback(500\x2C{"Error" : "Could not find the user who created the check\x2C so could not remove the check from the list of checks on their user object."});\n                  }\n                });\n              } else {\n                callback(500\x2C{"Error" : "Could not delete the check data."})\n              }\n            });\n          } else {\n            callback(403);\n          }\n        });\n      } else {\n        callback(400\x2C{"Error" : "The check ID specified could not be found"});\n      }\n    });\n  } else {\n    callback(400\x2C{"Error" : "Missing valid id"});\n  }\n};\n\n\n// Export the handlers\nmodule.exports = handlers;\n
code-source-info,0x2811abd27416,188,0,36637,C0O0C4O36637,,
code-creation,Function,10,100667,0x2811abd292e6,517, /Users/vignesh/Projects/HTTP2/lib/handlers.js:1:1,0x2811abd27390,~
code-source-info,0x2811abd292e6,188,0,36637,C0O0C5O59C8O59C12O59C14O92C17O92C21O92C23O127C26O127C30O127C32O158C35O158C39O158C41O185C44O185C48O185C50O220C53O220C58O241C62O220C64O266C67O266C72O300C80O300C85O295C87O368C88O368C90O410C97O425C101O1426C108O1449C112O2363C119O2386C123O3327C130O3348C134O4188C141O4212C145O5124C152O5148C156O6048C163O6070C167O6917C174O6937C178O7756C185O7776C189O8594C196O8611C200O9002C207O9018C211O10150C218O10164C222O10298C229O10320C233O10435C240O10453C244O10513C251O10528C255O10789C259O10806C263O10921C266O10930C275O10942C279O12887C282O12896C291O12907C295O14077C298O14086C307O14097C311O16407C314O16416C323O16430C327O18911C334O18927C338O19190C342O19208C346O19289C349O19298C358O19311C362O22369C365O22378C374O22390C378O22957C381O22966C390O22978C394O24242C397O24251C406O24266C410O25074C413O25083C422O25103C426O25509C433O25525C437O25788C441O25806C445O25920C448O25929C457O25942C461O30023C464O30032C473O30044C477O31117C480O31126C489O31138C493O34011C496O34020C505O34035C509O36610C511O36625C516O36636,,
tick,0x1bfd70f34,100750,1,0x1003cc7d8,3,0x0,0x26b72db3352e,0x26b72db32c8f,0x26b72db31625,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x1051128a8,0x26b72db362ce,0x2cbd764a8a0e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Function,11,100792,0x105113860,744,Module node:internal/modules/cjs/loader:172:16,0x3172a1b2a630,^
code-source-info,0x105113860,103,5284,5521,,,
code-creation,Function,11,100792,0x105113bc0,136,require node:internal/modules/cjs/helpers:101:31,0x26b72db35f48,^
code-source-info,0x105113bc0,102,3108,3154,,,
code-creation,Function,11,100792,0x105113cc0,200,toPathIfFileURL node:internal/url:1559:25,0x815de62d9e0,^
code-source-info,0x105113cc0,39,43634,43755,,,
code-creation,Function,11,100834,0x105113e00,488,isAbsolute node:path:1156:13,0x815de63ada8,^
code-source-info,0x105113e00,41,35447,35593,,,
code-creation,Function,11,100834,0x105114060,1144,getOptions node:internal/fs/utils:315:20,0xd2efcc3ed90,^
code-source-info,0x105114060,82,7252,7875,,,
code-creation,Function,11,100875,0x105114540,520,toRealPath node:internal/modules/cjs/loader:393:20,0x3172a1b2a860,^
code-source-info,0x105114540,103,11292,11404,,,
tick,0x1bfb84f8c,100959,1,0x1003cc7d8,2,0x0,0x26b72db3352e,0x26b72db32c8f,0x26b72db31625,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x1051128a8,0x26b72db362ce,0x2811abd292ee,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x1051128a8,0x26b72db362ce,0x2cbd764a8a0e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,100959,0x2811abd2c4de,5, /Users/vignesh/Projects/HTTP2/lib/data.js:1:1,0x2811abd2c368,~
script-source,189,/Users/vignesh/Projects/HTTP2/lib/data.js,/*\n * Library for storing and editing data\n *\n */\n\n// Dependencies\nvar fs = require('fs');\nvar path = require('path');\nvar helpers = require('./helpers');\n\n// Container for module (to be exported)\nvar lib = {};\n\n// Base directory of data folder\nlib.baseDir = path.join(__dirname\x2C'/../.data/');\n\n// Write data to a file\nlib.create = function(dir\x2Cfile\x2Cdata\x2Ccallback){\n  // Open the file for writing\n  fs.open(lib.baseDir+dir+'/'+file+'.json'\x2C 'wx'\x2C function(err\x2C fileDescriptor){\n    if(!err && fileDescriptor){\n      // Convert data to string\n      var stringData = JSON.stringify(data);\n\n      // Write to file and close it\n      fs.writeFile(fileDescriptor\x2C stringData\x2Cfunction(err){\n        if(!err){\n          fs.close(fileDescriptor\x2Cfunction(err){\n            if(!err){\n              callback(false);\n            } else {\n              callback('Error closing new file');\n            }\n          });\n        } else {\n          callback('Error writing to new file');\n        }\n      });\n    } else {\n      callback('Could not create new file\x2C it may already exist');\n    }\n  });\n\n};\n\n// Read data from a file\nlib.read = function(dir\x2Cfile\x2Ccallback){\n  fs.readFile(lib.baseDir+dir+'/'+file+'.json'\x2C 'utf8'\x2C function(err\x2Cdata){\n    if(!err && data){\n      var parsedData = helpers.parseJsonToObject(data);\n      callback(false\x2CparsedData);\n    } else {\n      callback(err\x2Cdata);\n    }\n  });\n};\n\n// Update data in a file\nlib.update = function(dir\x2Cfile\x2Cdata\x2Ccallback){\n\n  // Open the file for writing\n  fs.open(lib.baseDir+dir+'/'+file+'.json'\x2C 'r+'\x2C function(err\x2C fileDescriptor){\n    if(!err && fileDescriptor){\n      // Convert data to string\n      var stringData = JSON.stringify(data);\n\n      // Truncate the file\n      fs.truncate(fileDescriptor\x2Cfunction(err){\n        if(!err){\n          // Write to file and close it\n          fs.writeFile(fileDescriptor\x2C stringData\x2Cfunction(err){\n            if(!err){\n              fs.close(fileDescriptor\x2Cfunction(err){\n                if(!err){\n                  callback(false);\n                } else {\n                  callback('Error closing existing file');\n                }\n              });\n            } else {\n              callback('Error writing to existing file');\n            }\n          });\n        } else {\n          callback('Error truncating file');\n        }\n      });\n    } else {\n      callback('Could not open file for updating\x2C it may not exist yet');\n    }\n  });\n\n};\n\n// Delete a file\nlib.delete = function(dir\x2Cfile\x2Ccallback){\n\n  // Unlink the file from the filesystem\n  fs.unlink(lib.baseDir+dir+'/'+file+'.json'\x2C function(err){\n    callback(err);\n  });\n\n};\n\n// List all the items in a directory\nlib.list = function(dir\x2Ccallback){\n  fs.readdir(lib.baseDir+dir+'/'\x2C function(err\x2Cdata){\n    if(!err && data && data.length > 0){\n      var trimmedFileNames = [];\n      data.forEach(function(fileName){\n        trimmedFileNames.push(fileName.replace('.json'\x2C''));\n      });\n      callback(false\x2CtrimmedFileNames);\n    } else {\n      callback(err\x2Cdata);\n    }\n  });\n};\n\n// Export the module\nmodule.exports = lib;\n
code-source-info,0x2811abd2c4de,189,0,3077,C0O0C4O3077,,
code-creation,Function,10,101084,0x2811abd2ca36,118, /Users/vignesh/Projects/HTTP2/lib/data.js:1:1,0x2811abd2c458,~
code-source-info,0x2811abd2ca36,189,0,3077,C0O0C5O76C8O76C12O76C14O102C17O102C22O133C25O133C29O133C31O207C32O207C34O245C37O264C45O264C51O257C55O319C62O330C66O1112C73O1121C77O1420C84O1431C88O2454C95O2465C99O2666C106O2675C110O3055C112O3070C117O3076,,
code-creation,Function,11,101209,0x1051147c0,920,findLongestRegisteredExtension node:internal/modules/cjs/loader:413:40,0x3172a1b2a900,^
code-source-info,0x1051147c0,103,11813,12242,,,
code-creation,Function,11,101209,0x105114bc0,1056, node:internal/fs/utils:358:35,0xd2efcc3ee30,^
code-source-info,0x105114bc0,82,8603,9192,,,
code-creation,Function,11,101250,0x105115040,816, node:internal/fs/utils:669:38,0xd2efcc3f7b8,^
code-source-info,0x105115040,82,18197,18467,,,
code-creation,Function,11,101250,0x1051153e0,392, node:internal/bootstrap/loaders:273:15,0x2cbd76493890,^
code-source-info,0x1051153e0,9,8596,8701,,,
code-creation,Function,11,101292,0x1051155e0,1264,getESMFacade node:internal/bootstrap/loaders:264:15,0x2b48e0c4fbf8,^
code-source-info,0x1051155e0,9,8232,8861,,,
code-creation,Eval,10,101417,0x2811abd2e04e,5, /Users/vignesh/Projects/HTTP2/lib/helpers.js:1:1,0x2811abd2de88,~
script-source,190,/Users/vignesh/Projects/HTTP2/lib/helpers.js,/*\n * Helpers for various tasks\n *\n */\n\n// Dependencies\nvar config = require('./config');\nvar crypto = require('crypto');\nvar https = require('https');\nvar querystring = require('querystring');\nvar path = require('path');\nvar fs = require('fs');\n\n// Container for all the helpers\nvar helpers = {};\n\n// Sample for testing that simply returns a number\nhelpers.getANumber = function(){\n  return 1;\n};\n\n// Parse a JSON string to an object in all cases\x2C without throwing\nhelpers.parseJsonToObject = function(str){\n  try{\n    var obj = JSON.parse(str);\n    return obj;\n  } catch(e){\n    return {};\n  }\n};\n\n// Create a SHA256 hash\nhelpers.hash = function(str){\n  if(typeof(str) == 'string' && str.length > 0){\n    var hash = crypto.createHmac('sha256'\x2C config.hashingSecret).update(str).digest('hex');\n    return hash;\n  } else {\n    return false;\n  }\n};\n\n// Create a string of random alphanumeric characters\x2C of a given length\nhelpers.createRandomString = function(strLength){\n  strLength = typeof(strLength) == 'number' && strLength > 0 ? strLength : false;\n  if(strLength){\n    // Define all the possible characters that could go into a string\n    var possibleCharacters = 'abcdefghijklmnopqrstuvwxyz0123456789';\n\n    // Start the final string\n    var str = '';\n    for(i = 1; i <= strLength; i++) {\n        // Get a random charactert from the possibleCharacters string\n        var randomCharacter = possibleCharacters.charAt(Math.floor(Math.random() * possibleCharacters.length));\n        // Append this character to the string\n        str+=randomCharacter;\n    }\n    // Return the final string\n    return str;\n  } else {\n    return false;\n  }\n};\n\nhelpers.sendTwilioSms = function(phone\x2Cmsg\x2Ccallback){\n  // Validate parameters\n  phone = typeof(phone) == 'string' && phone.trim().length == 10 ? phone.trim() : false;\n  msg = typeof(msg) == 'string' && msg.trim().length > 0 && msg.trim().length <= 1600 ? msg.trim() : false;\n  if(phone && msg){\n\n    // Configure the request payload\n    var payload = {\n      'From' : config.twilio.fromPhone\x2C\n      'To' : '+1'+phone\x2C\n      'Body' : msg\n    };\n    var stringPayload = querystring.stringify(payload);\n\n\n    // Configure the request details\n    var requestDetails = {\n      'protocol' : 'https:'\x2C\n      'hostname' : 'api.twilio.com'\x2C\n      'method' : 'POST'\x2C\n      'path' : '/2010-04-01/Accounts/'+config.twilio.accountSid+'/Messages.json'\x2C\n      'auth' : config.twilio.accountSid+':'+config.twilio.authToken\x2C\n      'headers' : {\n        'Content-Type' : 'application/x-www-form-urlencoded'\x2C\n        'Content-Length': Buffer.byteLength(stringPayload)\n      }\n    };\n\n    // Instantiate the request object\n    var req = https.request(requestDetails\x2Cfunction(res){\n        // Grab the status of the sent request\n        var status =  res.statusCode;\n        // Callback successfully if the request went through\n        if(status == 200 || status == 201){\n          callback(false);\n        } else {\n          callback('Status code returned was '+status);\n        }\n    });\n\n    // Bind to the error event so it doesn't get thrown\n    req.on('error'\x2Cfunction(e){\n      callback(e);\n    });\n\n    // Add the payload\n    req.write(stringPayload);\n\n    // End the request\n    req.end();\n\n  } else {\n    callback('Given parameters were missing or invalid');\n  }\n};\n\n// Get the string content of a template\x2C and use provided data for string interpolation\nhelpers.getTemplate = function(templateName\x2Cdata\x2Ccallback){\n  templateName = typeof(templateName) == 'string' && templateName.length > 0 ? templateName : false;\n  data = typeof(data) == 'object' && data !== null ? data : {};\n  if(templateName){\n    var templatesDir = path.join(__dirname\x2C'/../templates/');\n    fs.readFile(templatesDir+templateName+'.html'\x2C 'utf8'\x2C function(err\x2Cstr){\n      if(!err && str && str.length > 0){\n        // Do interpolation on the string\n        var finalString = helpers.interpolate(str\x2Cdata);\n        callback(false\x2CfinalString);\n      } else {\n        callback('No template could be found');\n      }\n    });\n  } else {\n    callback('A valid template name was not specified');\n  }\n};\n\n// Add the universal header and footer to a string\x2C and pass provided data object to header and footer for interpolation\nhelpers.addUniversalTemplates = function(str\x2Cdata\x2Ccallback){\n  str = typeof(str) == 'string' && str.length > 0 ? str : '';\n  data = typeof(data) == 'object' && data !== null ? data : {};\n  // Get the header\n  helpers.getTemplate('_header'\x2Cdata\x2Cfunction(err\x2CheaderString){\n    if(!err && headerString){\n      // Get the footer\n      helpers.getTemplate('_footer'\x2Cdata\x2Cfunction(err\x2CfooterString){\n        if(!err && headerString){\n          // Add them all together\n          var fullString = headerString+str+footerString;\n          callback(false\x2CfullString);\n        } else {\n          callback('Could not find the footer template');\n        }\n      });\n    } else {\n      callback('Could not find the header template');\n    }\n  });\n};\n\n// Take a given string and data object\x2C and find/replace all the keys within it\nhelpers.interpolate = function(str\x2Cdata){\n  str = typeof(str) == 'string' && str.length > 0 ? str : '';\n  data = typeof(data) == 'object' && data !== null ? data : {};\n\n  // Add the templateGlobals to the data object\x2C prepending their key name with "global."\n  for(var keyName in config.templateGlobals){\n     if(config.templateGlobals.hasOwnProperty(keyName)){\n       data['global.'+keyName] = config.templateGlobals[keyName]\n     }\n  }\n  // For each key in the data object\x2C insert its value into the string at the corresponding placeholder\n  for(var key in data){\n     if(data.hasOwnProperty(key) && typeof(data[key] == 'string')){\n        var replace = data[key];\n        var find = '{'+key+'}';\n        str = str.replace(find\x2Creplace);\n     }\n  }\n  return str;\n};\n\n// Get the contents of a static (public) asset\nhelpers.getStaticAsset = function(fileName\x2Ccallback){\n  fileName = typeof(fileName) == 'string' && fileName.length > 0 ? fileName : false;\n  if(fileName){\n    var publicDir = path.join(__dirname\x2C'/../public/');\n    fs.readFile(publicDir+fileName\x2C function(err\x2Cdata){\n      if(!err && data){\n        callback(false\x2Cdata);\n      } else {\n        callback('No file could be found');\n      }\n    });\n  } else {\n    callback('A valid file name was not specified');\n  }\n};\n\n// Export the module\nmodule.exports = helpers;\n
code-source-info,0x2811abd2e04e,190,0,6377,C0O0C4O6377,,
code-creation,Function,10,101625,0x2811abd2e76e,173, /Users/vignesh/Projects/HTTP2/lib/helpers.js:1:1,0x2811abd2dfc8,~
code-source-info,0x2811abd2e76e,190,0,6377,C0O0C9O69C12O69C16O69C18O103C21O103C25O103C27O134C30O134C34O134C36O170C39O170C43O170C45O205C48O205C52O205C54O231C57O231C61O231C63O294C64O294C66O350C73O369C77O466C84O492C88O624C95O637C99O921C106O948C110O1645C117O1667C121O3390C128O3410C132O4228C139O4258C143O5046C150O5066C154O5862C161O5885C165O6351C167O6366C172O6376,,
code-creation,LazyCompile,10,101709,0x2811abd2f676,12,get node:crypto:296:8,0x29d5d5bb3198,~
code-source-info,0x2811abd2f676,170,6969,7006,C0O6974C3O6981C7O6996C11O7004,,
code-creation,LazyCompile,10,101709,0x2811abd30226,32,lazyWebCrypto node:crypto:127:23,0x29d5d5bb2ce8,~
code-source-info,0x2811abd30226,170,3225,3305,C0O3232C14O3246C21O3242C27O3286C31O3303,,
code-creation,Eval,10,101917,0x2811abd30aa6,5, node:internal/crypto/webcrypto:1:1,0x2811abd30660,~
script-source,191,node:internal/crypto/webcrypto,'use strict';\n\nconst {\n  ArrayPrototypeIncludes\x2C\n  JSONParse\x2C\n  JSONStringify\x2C\n  ObjectDefineProperties\x2C\n  ReflectApply\x2C\n  SafeSet\x2C\n  SymbolToStringTag\x2C\n  StringPrototypeRepeat\x2C\n} = primordials;\n\nconst {\n  kWebCryptoKeyFormatRaw\x2C\n  kWebCryptoKeyFormatPKCS8\x2C\n  kWebCryptoKeyFormatSPKI\x2C\n  kWebCryptoCipherEncrypt\x2C\n  kWebCryptoCipherDecrypt\x2C\n} = internalBinding('crypto');\n\nconst {\n  validateArray\x2C\n  validateBoolean\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst { TextDecoder\x2C TextEncoder } = require('internal/encoding');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_THIS\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  CryptoKey\x2C\n  InternalCryptoKey\x2C\n  createSecretKey\x2C\n  isCryptoKey\x2C\n  isKeyObject\x2C\n} = require('internal/crypto/keys');\n\nconst {\n  asyncDigest\x2C\n} = require('internal/crypto/hash');\n\nconst {\n  getArrayBufferOrView\x2C\n  hasAnyNotIn\x2C\n  lazyRequire\x2C\n  normalizeAlgorithm\x2C\n  normalizeHashName\x2C\n  validateMaxBufferLength\x2C\n  kExportFormats\x2C\n  kHandle\x2C\n  kKeyObject\x2C\n} = require('internal/crypto/util');\n\nconst {\n  kEnumerableProperty\x2C\n  lazyDOMException\x2C\n} = require('internal/util');\n\nconst {\n  getRandomValues: _getRandomValues\x2C\n  randomUUID: _randomUUID\x2C\n} = require('internal/crypto/random');\n\nconst randomUUID = () => _randomUUID();\n\nasync function generateKey(\n  algorithm\x2C\n  extractable\x2C\n  keyUsages) {\n  algorithm = normalizeAlgorithm(algorithm);\n  validateBoolean(extractable\x2C 'extractable');\n  validateArray(keyUsages\x2C 'keyUsages');\n  switch (algorithm.name) {\n    case 'RSASSA-PKCS1-v1_5':\n      // Fall through\n    case 'RSA-PSS':\n      // Fall through\n    case 'RSA-OAEP':\n      return lazyRequire('internal/crypto/rsa')\n        .rsaKeyGenerate(algorithm\x2C extractable\x2C keyUsages);\n    case 'NODE-ED25519':\n      // Fall through\n    case 'NODE-ED448':\n      // Fall through\n    case 'ECDSA':\n      // Fall through\n    case 'ECDH':\n      return lazyRequire('internal/crypto/ec')\n        .ecGenerateKey(algorithm\x2C extractable\x2C keyUsages);\n    case 'HMAC':\n      return lazyRequire('internal/crypto/mac')\n        .hmacGenerateKey(algorithm\x2C extractable\x2C keyUsages);\n    case 'AES-CTR':\n      // Fall through\n    case 'AES-CBC':\n      // Fall through\n    case 'AES-GCM':\n      // Fall through\n    case 'AES-KW':\n      return lazyRequire('internal/crypto/aes')\n        .aesGenerateKey(algorithm\x2C extractable\x2C keyUsages);\n\n    // Following are Node.js specific extensions. Names must be prefixed\n    // with the `NODE-`\n    case 'NODE-DSA':\n      return lazyRequire('internal/crypto/dsa')\n        .dsaGenerateKey(algorithm\x2C extractable\x2C keyUsages);\n    case 'NODE-DH':\n      return lazyRequire('internal/crypto/diffiehellman')\n        .dhGenerateKey(algorithm\x2C extractable\x2C keyUsages);\n    default:\n      throw lazyDOMException('Unrecognized name.');\n  }\n}\n\nasync function deriveBits(algorithm\x2C baseKey\x2C length) {\n  algorithm = normalizeAlgorithm(algorithm);\n  if (!isCryptoKey(baseKey))\n    throw new ERR_INVALID_ARG_TYPE('baseKey'\x2C 'CryptoKey'\x2C baseKey);\n  if (!ArrayPrototypeIncludes(baseKey.usages\x2C 'deriveBits')) {\n    throw lazyDOMException(\n      'baseKey does not have deriveBits usage'\x2C\n      'InvalidAccessError');\n  }\n  if (baseKey.algorithm.name !== algorithm.name)\n    throw lazyDOMException('Key algorithm mismatch'\x2C 'InvalidAccessError');\n  switch (algorithm.name) {\n    case 'ECDH':\n      return lazyRequire('internal/crypto/diffiehellman')\n        .asyncDeriveBitsECDH(algorithm\x2C baseKey\x2C length);\n    case 'HKDF':\n      return lazyRequire('internal/crypto/hkdf')\n        .hkdfDeriveBits(algorithm\x2C baseKey\x2C length);\n    case 'PBKDF2':\n      return lazyRequire('internal/crypto/pbkdf2')\n        .pbkdf2DeriveBits(algorithm\x2C baseKey\x2C length);\n    case 'NODE-SCRYPT':\n      return lazyRequire('internal/crypto/scrypt')\n        .scryptDeriveBits(algorithm\x2C baseKey\x2C length);\n    case 'NODE-DH':\n      return lazyRequire('internal/crypto/diffiehellman')\n        .asyncDeriveBitsDH(algorithm\x2C baseKey\x2C length);\n  }\n  throw lazyDOMException('Unrecognized name.');\n}\n\nasync function deriveKey(\n  algorithm\x2C\n  baseKey\x2C\n  derivedKeyAlgorithm\x2C\n  extractable\x2C\n  keyUsages) {\n  algorithm = normalizeAlgorithm(algorithm);\n  derivedKeyAlgorithm = normalizeAlgorithm(derivedKeyAlgorithm);\n  if (!isCryptoKey(baseKey))\n    throw new ERR_INVALID_ARG_TYPE('baseKey'\x2C 'CryptoKey'\x2C baseKey);\n  if (!ArrayPrototypeIncludes(baseKey.usages\x2C 'deriveKey')) {\n    throw lazyDOMException(\n      'baseKey does not have deriveKey usage'\x2C\n      'InvalidAccessError');\n  }\n  if (baseKey.algorithm.name !== algorithm.name)\n    throw lazyDOMException('Key algorithm mismatch'\x2C 'InvalidAccessError');\n  validateObject(derivedKeyAlgorithm\x2C 'derivedKeyAlgorithm'\x2C {\n    allowArray: true\x2C allowFunction: true\x2C\n  });\n  validateBoolean(extractable\x2C 'extractable');\n  validateArray(keyUsages\x2C 'keyUsages');\n\n  const { length } = derivedKeyAlgorithm;\n  let bits;\n  switch (algorithm.name) {\n    case 'ECDH':\n      bits = await lazyRequire('internal/crypto/diffiehellman')\n        .asyncDeriveBitsECDH(algorithm\x2C baseKey\x2C length);\n      break;\n    case 'HKDF':\n      bits = await lazyRequire('internal/crypto/hkdf')\n        .hkdfDeriveBits(algorithm\x2C baseKey\x2C length);\n      break;\n    case 'PBKDF2':\n      bits = await lazyRequire('internal/crypto/pbkdf2')\n        .pbkdf2DeriveBits(algorithm\x2C baseKey\x2C length);\n      break;\n    case 'NODE-SCRYPT':\n      bits = await lazyRequire('internal/crypto/scrypt')\n        .scryptDeriveBits(algorithm\x2C baseKey\x2C length);\n      break;\n    case 'NODE-DH':\n      bits = await lazyRequire('internal/crypto/diffiehellman')\n        .asyncDeriveBitsDH(algorithm\x2C baseKey\x2C length);\n      break;\n    default:\n      throw lazyDOMException('Unrecognized name.');\n  }\n\n  return importKey('raw'\x2C bits\x2C derivedKeyAlgorithm\x2C extractable\x2C keyUsages);\n}\n\nasync function exportKeySpki(key) {\n  switch (key.algorithm.name) {\n    case 'RSASSA-PKCS1-v1_5':\n      // Fall through\n    case 'RSA-PSS':\n      // Fall through\n    case 'RSA-OAEP':\n      if (key.type === 'public') {\n        return lazyRequire('internal/crypto/rsa')\n          .rsaExportKey(key\x2C kWebCryptoKeyFormatSPKI);\n      }\n      break;\n    case 'NODE-ED25519':\n      // Fall through\n    case 'NODE-ED448':\n      // Fall through\n    case 'ECDSA':\n      // Fall through\n    case 'ECDH':\n      if (key.type === 'public') {\n        return lazyRequire('internal/crypto/ec')\n          .ecExportKey(key\x2C kWebCryptoKeyFormatSPKI);\n      }\n      break;\n    case 'NODE-DSA':\n      if (key.type === 'public') {\n        return lazyRequire('internal/crypto/dsa')\n          .dsaExportKey(key\x2C kWebCryptoKeyFormatSPKI);\n      }\n      break;\n    case 'NODE-DH':\n      if (key.type === 'public') {\n        return lazyRequire('internal/crypto/diffiehellman')\n          .dhExportKey(key\x2C kWebCryptoKeyFormatSPKI);\n      }\n      break;\n  }\n\n  throw lazyDOMException(\n    `Unable to export a raw ${key.algorithm.name} ${key.type} key`\x2C\n    'InvalidAccessError');\n}\n\nasync function exportKeyPkcs8(key) {\n  switch (key.algorithm.name) {\n    case 'RSASSA-PKCS1-v1_5':\n      // Fall through\n    case 'RSA-PSS':\n      // Fall through\n    case 'RSA-OAEP':\n      if (key.type === 'private') {\n        return lazyRequire('internal/crypto/rsa')\n          .rsaExportKey(key\x2C kWebCryptoKeyFormatPKCS8);\n      }\n      break;\n    case 'NODE-ED25519':\n      // Fall through\n    case 'NODE-ED448':\n      // Fall through\n    case 'ECDSA':\n      // Fall through\n    case 'ECDH':\n      if (key.type === 'private') {\n        return lazyRequire('internal/crypto/ec')\n          .ecExportKey(key\x2C kWebCryptoKeyFormatPKCS8);\n      }\n      break;\n    case 'NODE-DSA':\n      if (key.type === 'private') {\n        return lazyRequire('internal/crypto/dsa')\n          .dsaExportKey(key\x2C kWebCryptoKeyFormatPKCS8);\n      }\n      break;\n    case 'NODE-DH':\n      if (key.type === 'private') {\n        return lazyRequire('internal/crypto/diffiehellman')\n          .dhExportKey(key\x2C kWebCryptoKeyFormatPKCS8);\n      }\n      break;\n  }\n\n  throw lazyDOMException(\n    `Unable to export a pkcs8 ${key.algorithm.name} ${key.type} key`\x2C\n    'InvalidAccessError');\n}\n\nasync function exportKeyRaw(key) {\n  switch (key.algorithm.name) {\n    case 'NODE-ED25519':\n      // Fall through\n    case 'NODE-ED448':\n      if (key.type === 'public') {\n        return lazyRequire('internal/crypto/ec')\n          .ecExportKey(key\x2C kWebCryptoKeyFormatRaw);\n      }\n      break;\n    case 'ECDSA':\n      // Fall through\n    case 'ECDH':\n      if (key.type === 'public') {\n        return lazyRequire('internal/crypto/ec')\n          .ecExportKey(key\x2C kWebCryptoKeyFormatRaw);\n      }\n      break;\n    case 'AES-CTR':\n      // Fall through\n    case 'AES-CBC':\n      // Fall through\n    case 'AES-GCM':\n      // Fall through\n    case 'AES-KW':\n      // Fall through\n    case 'HMAC':\n      return key[kKeyObject].export().buffer;\n  }\n\n  throw lazyDOMException(\n    `Unable to export a raw ${key.algorithm.name} ${key.type} key`\x2C\n    'InvalidAccessError');\n}\n\nasync function exportKeyJWK(key) {\n  const jwk = key[kKeyObject][kHandle].exportJwk({\n    key_ops: key.usages\x2C\n    ext: key.extractable\x2C\n  }\x2C true);\n  switch (key.algorithm.name) {\n    case 'RSASSA-PKCS1-v1_5':\n      jwk.alg = normalizeHashName(\n        key.algorithm.hash.name\x2C\n        normalizeHashName.kContextJwkRsa);\n      return jwk;\n    case 'RSA-PSS':\n      jwk.alg = normalizeHashName(\n        key.algorithm.hash.name\x2C\n        normalizeHashName.kContextJwkRsaPss);\n      return jwk;\n    case 'RSA-OAEP':\n      jwk.alg = normalizeHashName(\n        key.algorithm.hash.name\x2C\n        normalizeHashName.kContextJwkRsaOaep);\n      return jwk;\n    case 'ECDSA':\n      // Fall through\n    case 'ECDH':\n      jwk.crv ||= key.algorithm.namedCurve;\n      return jwk;\n    case 'AES-CTR':\n      // Fall through\n    case 'AES-CBC':\n      // Fall through\n    case 'AES-GCM':\n      // Fall through\n    case 'AES-KW':\n      jwk.alg = lazyRequire('internal/crypto/aes')\n        .getAlgorithmName(key.algorithm.name\x2C key.algorithm.length);\n      return jwk;\n    case 'HMAC':\n      jwk.alg = normalizeHashName(\n        key.algorithm.hash.name\x2C\n        normalizeHashName.kContextJwkHmac);\n      return jwk;\n    case 'NODE-DSA':\n      jwk.alg = normalizeHashName(\n        key.algorithm.hash.name\x2C\n        normalizeHashName.kContextJwkDsa);\n      return jwk;\n    case 'NODE-ED25519':\n      // Fall through\n    case 'NODE-ED448':\n      return jwk;\n    default:\n      // Fall through\n  }\n\n  throw lazyDOMException('Not yet supported'\x2C 'NotSupportedError');\n}\n\nasync function exportKey(format\x2C key) {\n  validateString(format\x2C 'format');\n  validateOneOf(format\x2C 'format'\x2C kExportFormats);\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE('key'\x2C 'CryptoKey'\x2C key);\n\n  if (!key.extractable)\n    throw lazyDOMException('key is not extractable'\x2C 'InvalidAccessException');\n\n  switch (format) {\n    case 'node.keyObject': return key[kKeyObject];\n    case 'spki': return exportKeySpki(key);\n    case 'pkcs8': return exportKeyPkcs8(key);\n    case 'jwk': return exportKeyJWK(key);\n    case 'raw': return exportKeyRaw(key);\n  }\n  throw lazyDOMException(\n    'Export format is unsupported'\x2C 'NotSupportedError');\n}\n\nasync function importGenericSecretKey(\n  { name\x2C length }\x2C\n  format\x2C\n  keyData\x2C\n  extractable\x2C\n  keyUsages) {\n  const usagesSet = new SafeSet(keyUsages);\n  if (extractable)\n    throw lazyDOMException(`${name} keys are not extractable`\x2C 'SyntaxError');\n\n  if (hasAnyNotIn(usagesSet\x2C ['deriveKey'\x2C 'deriveBits'])) {\n    throw lazyDOMException(\n      `Unsupported key usage for a ${name} key`\x2C\n      'SyntaxError');\n  }\n\n  switch (format) {\n    case 'node.keyObject': {\n      if (!isKeyObject(keyData))\n        throw new ERR_INVALID_ARG_TYPE('keyData'\x2C 'KeyObject'\x2C keyData);\n\n      if (keyData.type === 'secret')\n        return new InternalCryptoKey(keyData\x2C { name }\x2C keyUsages\x2C extractable);\n\n      break;\n    }\n    case 'raw': {\n      if (hasAnyNotIn(usagesSet\x2C ['deriveKey'\x2C 'deriveBits'])) {\n        throw lazyDOMException(\n          `Unsupported key usage for a ${name} key`\x2C\n          'SyntaxError');\n      }\n\n      const checkLength = keyData.byteLength * 8;\n\n      if (checkLength === 0 || length === 0)\n        throw lazyDOMException('Zero-length key is not supported'\x2C 'DataError');\n\n      // The Web Crypto spec allows for key lengths that are not multiples of\n      // 8. We don't. Our check here is stricter than that defined by the spec\n      // in that we require that algorithm.length match keyData.length * 8 if\n      // algorithm.length is specified.\n      if (length !== undefined && length !== checkLength) {\n        throw lazyDOMException('Invalid key length'\x2C 'DataError');\n      }\n\n      const keyObject = createSecretKey(keyData);\n      return new InternalCryptoKey(keyObject\x2C { name }\x2C keyUsages\x2C false);\n    }\n  }\n\n  throw lazyDOMException(\n    `Unable to import ${name} key with format ${format}`\x2C\n    'NotSupportedError');\n}\n\nasync function importKey(\n  format\x2C\n  keyData\x2C\n  algorithm\x2C\n  extractable\x2C\n  keyUsages) {\n  validateString(format\x2C 'format');\n  validateOneOf(format\x2C 'format'\x2C kExportFormats);\n  if (format !== 'node.keyObject' && format !== 'jwk')\n    keyData = getArrayBufferOrView(keyData\x2C 'keyData');\n  algorithm = normalizeAlgorithm(algorithm);\n  validateBoolean(extractable\x2C 'extractable');\n  validateArray(keyUsages\x2C 'keyUsages');\n  switch (algorithm.name) {\n    case 'RSASSA-PKCS1-v1_5':\n      // Fall through\n    case 'RSA-PSS':\n      // Fall through\n    case 'RSA-OAEP':\n      return lazyRequire('internal/crypto/rsa')\n        .rsaImportKey(format\x2C keyData\x2C algorithm\x2C extractable\x2C keyUsages);\n    case 'NODE-ED25519':\n      // Fall through\n    case 'NODE-ED448':\n      // Fall through\n    case 'ECDSA':\n      // Fall through\n    case 'ECDH':\n      return lazyRequire('internal/crypto/ec')\n        .ecImportKey(format\x2C keyData\x2C algorithm\x2C extractable\x2C keyUsages);\n    case 'HMAC':\n      return lazyRequire('internal/crypto/mac')\n        .hmacImportKey(format\x2C keyData\x2C algorithm\x2C extractable\x2C keyUsages);\n    case 'AES-CTR':\n      // Fall through\n    case 'AES-CBC':\n      // Fall through\n    case 'AES-GCM':\n      // Fall through\n    case 'AES-KW':\n      return lazyRequire('internal/crypto/aes')\n        .aesImportKey(algorithm\x2C format\x2C keyData\x2C extractable\x2C keyUsages);\n    case 'HKDF':\n      // Fall through\n    case 'NODE-SCRYPT':\n      // Fall through\n    case 'PBKDF2':\n      return importGenericSecretKey(\n        algorithm\x2C\n        format\x2C\n        keyData\x2C\n        extractable\x2C\n        keyUsages);\n    case 'NODE-DSA':\n      return lazyRequire('internal/crypto/dsa')\n        .dsaImportKey(format\x2C keyData\x2C algorithm\x2C extractable\x2C keyUsages);\n    case 'NODE-DH':\n      return lazyRequire('internal/crypto/diffiehellman')\n        .dhImportKey(format\x2C keyData\x2C algorithm\x2C extractable\x2C keyUsages);\n  }\n\n  throw lazyDOMException('Unrecognized name.'\x2C 'NotSupportedError');\n}\n\n// subtle.wrapKey() is essentially a subtle.exportKey() followed\n// by a subtle.encrypt().\nasync function wrapKey(format\x2C key\x2C wrappingKey\x2C algorithm) {\n  algorithm = normalizeAlgorithm(algorithm);\n  let keyData = await exportKey(format\x2C key);\n\n  if (format === 'jwk') {\n    if (keyData == null || typeof keyData !== 'object')\n      throw lazyDOMException('Invalid exported JWK key'\x2C 'DataError');\n    const ec = new TextEncoder();\n    const raw = JSONStringify(keyData);\n    keyData = ec.encode(raw + StringPrototypeRepeat(' '\x2C 8 - (raw.length % 8)));\n  }\n\n  return cipherOrWrap(\n    kWebCryptoCipherEncrypt\x2C\n    algorithm\x2C\n    wrappingKey\x2C\n    keyData\x2C\n    'wrapKey');\n}\n\n// subtle.unwrapKey() is essentially a subtle.decrypt() followed\n// by a subtle.importKey().\nasync function unwrapKey(\n  format\x2C\n  wrappedKey\x2C\n  unwrappingKey\x2C\n  unwrapAlgo\x2C\n  unwrappedKeyAlgo\x2C\n  extractable\x2C\n  keyUsages) {\n  wrappedKey = getArrayBufferOrView(wrappedKey\x2C 'wrappedKey');\n\n  let keyData = await cipherOrWrap(\n    kWebCryptoCipherDecrypt\x2C\n    normalizeAlgorithm(unwrapAlgo)\x2C\n    unwrappingKey\x2C\n    wrappedKey\x2C\n    'unwrapKey');\n\n  if (format === 'jwk') {\n    // The fatal: true option is only supported in builds that have ICU.\n    const options = process.versions.icu !== undefined ?\n      { fatal: true } : undefined;\n    const dec = new TextDecoder('utf-8'\x2C options);\n    try {\n      keyData = JSONParse(dec.decode(keyData));\n    } catch {\n      throw lazyDOMException('Invalid imported JWK key'\x2C 'DataError');\n    }\n  }\n\n  return importKey(format\x2C keyData\x2C unwrappedKeyAlgo\x2C extractable\x2C keyUsages);\n}\n\nfunction signVerify(algorithm\x2C key\x2C data\x2C signature) {\n  algorithm = normalizeAlgorithm(algorithm);\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE('key'\x2C 'CryptoKey'\x2C key);\n  data = getArrayBufferOrView(data\x2C 'data');\n  let usage = 'sign';\n  if (signature !== undefined) {\n    signature = getArrayBufferOrView(signature\x2C 'signature');\n    usage = 'verify';\n  }\n\n  if (!ArrayPrototypeIncludes(key.usages\x2C usage) ||\n      algorithm.name !== key.algorithm.name) {\n    throw lazyDOMException(\n      `Unable to use this key to ${usage}`\x2C\n      'InvalidAccessError');\n  }\n\n  switch (algorithm.name) {\n    case 'RSA-PSS':\n      // Fall through\n    case 'RSASSA-PKCS1-v1_5':\n      return lazyRequire('internal/crypto/rsa')\n        .rsaSignVerify(key\x2C data\x2C algorithm\x2C signature);\n    case 'NODE-ED25519':\n      // Fall through\n    case 'NODE-ED448':\n      // Fall through\n    case 'ECDSA':\n      return lazyRequire('internal/crypto/ec')\n        .ecdsaSignVerify(key\x2C data\x2C algorithm\x2C signature);\n    case 'HMAC':\n      return lazyRequire('internal/crypto/mac')\n        .hmacSignVerify(key\x2C data\x2C algorithm\x2C signature);\n    // The following are Node.js specific extensions. They must begin with\n    // the `NODE-` prefix\n    case 'NODE-DSA':\n      return lazyRequire('internal/crypto/dsa')\n        .dsaSignVerify(key\x2C data\x2C algorithm\x2C signature);\n  }\n  throw lazyDOMException('Unrecognized named.'\x2C 'NotSupportedError');\n}\n\nasync function sign(algorithm\x2C key\x2C data) {\n  return signVerify(algorithm\x2C key\x2C data);\n}\n\nasync function verify(algorithm\x2C key\x2C signature\x2C data) {\n  return signVerify(algorithm\x2C key\x2C data\x2C signature);\n}\n\nasync function cipherOrWrap(mode\x2C algorithm\x2C key\x2C data\x2C op) {\n  algorithm = normalizeAlgorithm(algorithm);\n  // We use a Node.js style error here instead of a DOMException because\n  // the WebCrypto spec is not specific what kind of error is to be thrown\n  // in this case. Both Firefox and Chrome throw simple TypeErrors here.\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE('key'\x2C 'CryptoKey'\x2C key);\n  // The key algorithm and cipher algorithm must match\x2C and the\n  // key must have the proper usage.\n  if (key.algorithm.name !== algorithm.name ||\n      !ArrayPrototypeIncludes(key.usages\x2C op)) {\n    throw lazyDOMException(\n      'The requested operation is not valid for the provided key'\x2C\n      'InvalidAccessError');\n  }\n\n  // For the Web Crypto API\x2C the input data can be any ArrayBuffer\x2C\n  // TypedArray\x2C or DataView.\n  data = getArrayBufferOrView(data\x2C 'data');\n\n  // While WebCrypto allows for larger input buffer sizes\x2C we limit\n  // those to sizes that can fit within uint32_t because of limitations\n  // in the OpenSSL API.\n  validateMaxBufferLength(data\x2C 'data');\n\n  switch (algorithm.name) {\n    case 'RSA-OAEP':\n      return lazyRequire('internal/crypto/rsa')\n        .rsaCipher(mode\x2C key\x2C data\x2C algorithm);\n    case 'AES-CTR':\n      // Fall through\n    case 'AES-CBC':\n      // Fall through\n    case 'AES-GCM':\n      return lazyRequire('internal/crypto/aes')\n        .aesCipher(mode\x2C key\x2C data\x2C algorithm);\n    case 'AES-KW':\n      if (op === 'wrapKey' || op === 'unwrapKey') {\n        return lazyRequire('internal/crypto/aes')\n          .aesCipher(mode\x2C key\x2C data\x2C algorithm);\n      }\n  }\n  throw lazyDOMException('Unrecognized name.'\x2C 'NotSupportedError');\n}\n\nasync function encrypt(algorithm\x2C key\x2C data) {\n  return cipherOrWrap(kWebCryptoCipherEncrypt\x2C algorithm\x2C key\x2C data\x2C 'encrypt');\n}\n\nasync function decrypt(algorithm\x2C key\x2C data) {\n  return cipherOrWrap(kWebCryptoCipherDecrypt\x2C algorithm\x2C key\x2C data\x2C 'decrypt');\n}\n\n// The SubtleCrypto and Crypto classes are defined as part of the\n// Web Crypto API standard: https://www.w3.org/TR/WebCryptoAPI/\n\nclass SubtleCrypto {}\nconst subtle = new SubtleCrypto();\n\nclass Crypto {\n  get subtle() {\n    return subtle;\n  }\n}\nconst crypto = new Crypto();\n\nfunction getRandomValues(array) {\n  if (!(this instanceof Crypto)) {\n    throw new ERR_INVALID_THIS('Crypto');\n  }\n  return ReflectApply(_getRandomValues\x2C this\x2C arguments);\n}\n\nObjectDefineProperties(\n  Crypto.prototype\x2C {\n    [SymbolToStringTag]: {\n      enumerable: false\x2C\n      configurable: true\x2C\n      writable: false\x2C\n      value: 'Crypto'\x2C\n    }\x2C\n    subtle: kEnumerableProperty\x2C\n    getRandomValues: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: getRandomValues\x2C\n    }\x2C\n    randomUUID: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: randomUUID\x2C\n    }\x2C\n    CryptoKey: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: CryptoKey\x2C\n    }\n  });\n\nObjectDefineProperties(\n  SubtleCrypto.prototype\x2C {\n    [SymbolToStringTag]: {\n      enumerable: false\x2C\n      configurable: true\x2C\n      writable: false\x2C\n      value: 'SubtleCrypto'\x2C\n    }\x2C\n    encrypt: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: encrypt\x2C\n    }\x2C\n    decrypt: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: decrypt\x2C\n    }\x2C\n    sign: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: sign\x2C\n    }\x2C\n    verify: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: verify\x2C\n    }\x2C\n    digest: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: asyncDigest\x2C\n    }\x2C\n    generateKey: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: generateKey\x2C\n    }\x2C\n    deriveKey: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: deriveKey\x2C\n    }\x2C\n    deriveBits: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: deriveBits\x2C\n    }\x2C\n    importKey: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: importKey\x2C\n    }\x2C\n    exportKey: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: exportKey\x2C\n    }\x2C\n    wrapKey: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: wrapKey\x2C\n    }\x2C\n    unwrapKey: {\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: unwrapKey\x2C\n    }\n  });\n\nmodule.exports = {\n  Crypto\x2C\n  CryptoKey\x2C\n  SubtleCrypto\x2C\n  crypto\x2C\n};\n
code-source-info,0x2811abd30aa6,191,0,22852,C0O0C4O22852,,
code-creation,Function,10,102834,0x2811abd31ece,1107, node:internal/crypto/webcrypto:1:1,0x2811abd30a20,~
code-source-info,0x2811abd31ece,191,0,22852,C0O0C228O25C234O51C240O64C246O81C251O107C257O123C263O134C268O155C274O343C278O343C284O206C290O232C296O260C302O287C308O314C314O472C318O472C324O381C330O398C336O417C342O435C348O452C354O542C358O542C364O513C370O526C376O648C380O648C386O648C392O596C398O622C404O772C408O772C414O687C419O700C425O721C431O740C437O755C443O833C447O833C453O816C458O1046C462O1046C468O877C474O901C480O916C486O931C492O953C498O974C504O1001C510O1019C516O1030C522O1135C526O1135C532O1090C537O1113C543O1238C547O1238C553O1189C559O1221C565O1293C573O1293C596O20295C598O20295C603O20295C636O20316C638O20388C642O20388C649O20579C653O20612C667O20630C669O20650C684O20768C693O20810C701O20897C716O20937C724O21024C739O21058C747O21145C758O20579C763O21208C777O21226C779O21246C792O21371C800O21458C815O21487C823O21574C838O21600C846O21687C861O21712C869O21799C884O21826C892O21913C907O21950C915O22037C930O22072C938O22159C953O22193C961O22280C976O22314C984O22401C999O22434C1007O22521C1022O22552C1030O22639C1045O22670C1053O22757C1064O21169C1069O22781C1077O22802C1083O22812C1089O22825C1095O22841C1101O22796C1106O22851,,
tick,0x1bfd39474,102875,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x2811abd30234,0x2811abd2f679,0x100d4d654,0x10510c9c8,0x10510b8cc,0x105115470,0x1003a57dc,0x1051159f0,0x26b72db365fd,0x105112d34,0x26b72db1b016,0x1051128a8,0x105113c1c,0x2811abd2e783,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x1051128a8,0x105113c1c,0x2811abd2ca4f,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x1051128a8,0x26b72db362ce,0x2811abd292ee,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x1051128a8,0x26b72db362ce,0x2cbd764a8a0e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,102959,0x2811abd3425e,2,SubtleCrypto node:internal/crypto/webcrypto:690:1,0x2811abd31118,~
code-source-info,0x2811abd3425e,191,20258,20258,C1O20258,,
code-creation,LazyCompile,10,102959,0x2811abd35ce6,2,Crypto node:internal/crypto/webcrypto:693:1,0x2811abd31168,~
code-source-info,0x2811abd35ce6,191,20316,20316,C1O20316,,
code-creation,LazyCompile,10,103000,0x2811abd35dfe,17,get node:crypto:303:8,0x29d5d5bb31e8,~
code-source-info,0x2811abd35dfe,170,7100,7144,C0O7105C3O7112C7O7127C12O7134C16O7142,,
code-creation,LazyCompile,10,103000,0x2811abd35f06,5,get subtle node:internal/crypto/webcrypto:694:13,0x2811abd311d8,~
code-source-info,0x2811abd35f06,191,20343,20370,C0O20352C4O20366,,
code-creation,LazyCompile,10,103000,0x2811abd35fae,3,get node:crypto:310:10,0x29d5d5bb3238,~
code-source-info,0x2811abd35fae,170,7249,7270,C0O7255C2O7270,,
code-creation,Function,11,103084,0x105115b40,1080,compileForPublicLoader node:internal/bootstrap/loaders:246:25,0x2b48e0c4fb80,^
code-source-info,0x105115b40,9,7544,8216,,,
code-creation,Function,11,103084,0x105115fe0,400,isEncoding node:buffer:530:40,0x232faba322d0,^
code-source-info,0x105115fe0,24,14808,14940,,,
code-creation,Function,11,103084,0x1051161e0,392, node:internal/fs/utils:681:42,0xd2efcc3f808,^
code-source-info,0x1051161e0,82,18512,18647,,,
code-creation,Function,11,103125,0x1051163e0,968,openSync node:fs:576:18,0xd2efcc34ae0,^
code-source-info,0x1051163e0,81,14454,14833,,,
code-creation,Function,11,103125,0x105116820,216,allocUnsafe node:buffer:373:42,0x232faba31e48,^
code-source-info,0x105116820,24,10905,10960,,,
code-creation,Function,11,103125,0x105116960,480,closeSync node:fs:526:19,0xd2efcc34a08,^
code-source-info,0x105116960,81,13323,13445,,,
code-creation,Function,11,103125,0x105116ba0,128,slice node:buffer:594:12,0x232faba324f0,^
code-source-info,0x105116ba0,24,16636,16682,,,
code-creation,Function,11,103167,0x105116c80,272,importModuleDynamicallyWrap node:internal/vm/module:435:37,0x26b72db10b30,^
code-source-info,0x105116c80,131,11705,12148,,,
code-creation,LazyCompile,10,103209,0x2811abd3692e,118,join node:path:1166:7,0x815de63adf8,~
code-source-info,0x2811abd3692e,41,35666,36076,C0O35666C3O35691C9O35698C14O35711C16O35722C17O35731C19O35756C21O35768C25O35761C30O35801C32O35805C36O35816C44O35816C49O35859C55O35866C60O35881C64O35917C71O35954C76O35968C87O35778C92O35743C95O35993C99O36025C101O36036C102O36041C107O36054C112O36054C117O36072,,
code-creation,LazyCompile,10,103250,0x2811abd36b1e,159,normalize node:path:1127:12,0x815de63ad58,~
code-source-info,0x2811abd36b1e,41,34766,35370,C0O34779C8O34779C13O34823C19O34830C24O34843C26O34854C27O34885C34O34885C42O34924C44O34920C48O34980C53O35017C57O35024C61O34980C69O35033C71O35029C75O35084C80O35114C91O35091C98O35168C104O35175C109O35190C113O35214C115O35225C116O35232C126O35270C127O35281C131O35310C141O35328C150O35352C158O35366,,
code-creation,Eval,10,103417,0x2811abd37cce,5, node:dns:1:1,0x2811abd37958,~
script-source,192,node:dns,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst cares = internalBinding('cares_wrap');\nconst { toASCII } = require('internal/idna');\nconst { isIP } = require('internal/net');\nconst { customPromisifyArgs } = require('internal/util');\nconst errors = require('internal/errors');\nconst {\n  bindDefaultResolver\x2C\n  getDefaultResolver\x2C\n  setDefaultResolver\x2C\n  Resolver\x2C\n  validateHints\x2C\n  emitInvalidHostnameWarning\x2C\n  emitTypeCoercionDeprecationWarning\x2C\n  getDefaultVerbatim\x2C\n  setDefaultResultOrder\x2C\n} = require('internal/dns/utils');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_MISSING_ARGS\x2C\n} = errors.codes;\nconst {\n  validateCallback\x2C\n  validatePort\x2C\n  validateString\x2C\n  validateOneOf\x2C\n} = require('internal/validators');\n\nconst {\n  GetAddrInfoReqWrap\x2C\n  GetNameInfoReqWrap\x2C\n  QueryReqWrap\x2C\n} = cares;\n\nconst dnsException = errors.dnsException;\n\nlet promises = null; // Lazy loaded\n\nfunction onlookup(err\x2C addresses) {\n  if (err) {\n    return this.callback(dnsException(err\x2C 'getaddrinfo'\x2C this.hostname));\n  }\n  this.callback(null\x2C addresses[0]\x2C this.family || isIP(addresses[0]));\n}\n\n\nfunction onlookupall(err\x2C addresses) {\n  if (err) {\n    return this.callback(dnsException(err\x2C 'getaddrinfo'\x2C this.hostname));\n  }\n\n  const family = this.family;\n  for (let i = 0; i < addresses.length; i++) {\n    const addr = addresses[i];\n    addresses[i] = {\n      address: addr\x2C\n      family: family || isIP(addr)\n    };\n  }\n\n  this.callback(null\x2C addresses);\n}\n\n\n// Easy DNS A/AAAA look up\n// lookup(hostname\x2C [options\x2C] callback)\nfunction lookup(hostname\x2C options\x2C callback) {\n  let hints = 0;\n  let family = -1;\n  let all = false;\n  let verbatim = getDefaultVerbatim();\n\n  // Parse arguments\n  if (hostname) {\n    validateString(hostname\x2C 'hostname');\n  }\n\n  if (typeof options === 'function') {\n    callback = options;\n    family = 0;\n  } else {\n    validateCallback(callback);\n\n    if (options !== null && typeof options === 'object') {\n      if (options.hints != null && typeof options.hints !== 'number') {\n        emitTypeCoercionDeprecationWarning();\n      }\n      hints = options.hints >>> 0;\n      if (options.family != null && typeof options.family !== 'number') {\n        emitTypeCoercionDeprecationWarning();\n      }\n      family = options.family >>> 0;\n      if (options.all != null && typeof options.all !== 'boolean') {\n        emitTypeCoercionDeprecationWarning();\n      }\n      all = options.all === true;\n      if (typeof options.verbatim === 'boolean') {\n        verbatim = options.verbatim === true;\n      } else if (options.verbatim != null) {\n        emitTypeCoercionDeprecationWarning();\n      }\n\n      validateHints(hints);\n    } else {\n      if (options != null && typeof options !== 'number') {\n        emitTypeCoercionDeprecationWarning();\n      }\n      family = options >>> 0;\n    }\n  }\n\n  validateOneOf(family\x2C 'family'\x2C [0\x2C 4\x2C 6]);\n\n  if (!hostname) {\n    emitInvalidHostnameWarning(hostname);\n    if (all) {\n      process.nextTick(callback\x2C null\x2C []);\n    } else {\n      process.nextTick(callback\x2C null\x2C null\x2C family === 6 ? 6 : 4);\n    }\n    return {};\n  }\n\n  const matchedFamily = isIP(hostname);\n  if (matchedFamily) {\n    if (all) {\n      process.nextTick(\n        callback\x2C null\x2C [{ address: hostname\x2C family: matchedFamily }]);\n    } else {\n      process.nextTick(callback\x2C null\x2C hostname\x2C matchedFamily);\n    }\n    return {};\n  }\n\n  const req = new GetAddrInfoReqWrap();\n  req.callback = callback;\n  req.family = family;\n  req.hostname = hostname;\n  req.oncomplete = all ? onlookupall : onlookup;\n\n  const err = cares.getaddrinfo(\n    req\x2C toASCII(hostname)\x2C family\x2C hints\x2C verbatim\n  );\n  if (err) {\n    process.nextTick(callback\x2C dnsException(err\x2C 'getaddrinfo'\x2C hostname));\n    return {};\n  }\n  return req;\n}\n\nObjectDefineProperty(lookup\x2C customPromisifyArgs\x2C\n                     { value: ['address'\x2C 'family']\x2C enumerable: false });\n\n\nfunction onlookupservice(err\x2C hostname\x2C service) {\n  if (err)\n    return this.callback(dnsException(err\x2C 'getnameinfo'\x2C this.hostname));\n\n  this.callback(null\x2C hostname\x2C service);\n}\n\n\nfunction lookupService(address\x2C port\x2C callback) {\n  if (arguments.length !== 3)\n    throw new ERR_MISSING_ARGS('address'\x2C 'port'\x2C 'callback');\n\n  if (isIP(address) === 0)\n    throw new ERR_INVALID_ARG_VALUE('address'\x2C address);\n\n  validatePort(port);\n\n  validateCallback(callback);\n\n  port = +port;\n\n  const req = new GetNameInfoReqWrap();\n  req.callback = callback;\n  req.hostname = address;\n  req.port = port;\n  req.oncomplete = onlookupservice;\n\n  const err = cares.getnameinfo(req\x2C address\x2C port);\n  if (err) throw dnsException(err\x2C 'getnameinfo'\x2C address);\n  return req;\n}\n\nObjectDefineProperty(lookupService\x2C customPromisifyArgs\x2C\n                     { value: ['hostname'\x2C 'service']\x2C enumerable: false });\n\n\nfunction onresolve(err\x2C result\x2C ttls) {\n  if (ttls && this.ttl)\n    result = ArrayPrototypeMap(\n      result\x2C (address\x2C index) => ({ address\x2C ttl: ttls[index] }));\n\n  if (err)\n    this.callback(dnsException(err\x2C this.bindingName\x2C this.hostname));\n  else\n    this.callback(null\x2C result);\n}\n\nfunction resolver(bindingName) {\n  function query(name\x2C /* options\x2C */ callback) {\n    let options;\n    if (arguments.length > 2) {\n      options = callback;\n      callback = arguments[2];\n    }\n\n    validateString(name\x2C 'name');\n    validateCallback(callback);\n\n    const req = new QueryReqWrap();\n    req.bindingName = bindingName;\n    req.callback = callback;\n    req.hostname = name;\n    req.oncomplete = onresolve;\n    req.ttl = !!(options && options.ttl);\n    const err = this._handle[bindingName](req\x2C toASCII(name));\n    if (err) throw dnsException(err\x2C bindingName\x2C name);\n    return req;\n  }\n  ObjectDefineProperty(query\x2C 'name'\x2C { value: bindingName });\n  return query;\n}\n\nconst resolveMap = ObjectCreate(null);\nResolver.prototype.resolveAny = resolveMap.ANY = resolver('queryAny');\nResolver.prototype.resolve4 = resolveMap.A = resolver('queryA');\nResolver.prototype.resolve6 = resolveMap.AAAA = resolver('queryAaaa');\nResolver.prototype.resolveCaa = resolveMap.CAA = resolver('queryCaa');\nResolver.prototype.resolveCname = resolveMap.CNAME = resolver('queryCname');\nResolver.prototype.resolveMx = resolveMap.MX = resolver('queryMx');\nResolver.prototype.resolveNs = resolveMap.NS = resolver('queryNs');\nResolver.prototype.resolveTxt = resolveMap.TXT = resolver('queryTxt');\nResolver.prototype.resolveSrv = resolveMap.SRV = resolver('querySrv');\nResolver.prototype.resolvePtr = resolveMap.PTR = resolver('queryPtr');\nResolver.prototype.resolveNaptr = resolveMap.NAPTR = resolver('queryNaptr');\nResolver.prototype.resolveSoa = resolveMap.SOA = resolver('querySoa');\nResolver.prototype.reverse = resolver('getHostByAddr');\n\nResolver.prototype.resolve = resolve;\n\nfunction resolve(hostname\x2C rrtype\x2C callback) {\n  let resolver;\n  if (typeof rrtype === 'string') {\n    resolver = resolveMap[rrtype];\n  } else if (typeof rrtype === 'function') {\n    resolver = resolveMap.A;\n    callback = rrtype;\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('rrtype'\x2C 'string'\x2C rrtype);\n  }\n\n  if (typeof resolver === 'function') {\n    return ReflectApply(resolver\x2C this\x2C [hostname\x2C callback]);\n  }\n  throw new ERR_INVALID_ARG_VALUE('rrtype'\x2C rrtype);\n}\n\nfunction defaultResolverSetServers(servers) {\n  const resolver = new Resolver();\n\n  resolver.setServers(servers);\n  setDefaultResolver(resolver);\n  bindDefaultResolver(module.exports\x2C Resolver.prototype);\n\n  if (promises !== null)\n    bindDefaultResolver(promises\x2C promises.Resolver.prototype);\n}\n\nmodule.exports = {\n  lookup\x2C\n  lookupService\x2C\n\n  Resolver\x2C\n  setDefaultResultOrder\x2C\n  setServers: defaultResolverSetServers\x2C\n\n  // uv_getaddrinfo flags\n  ADDRCONFIG: cares.AI_ADDRCONFIG\x2C\n  ALL: cares.AI_ALL\x2C\n  V4MAPPED: cares.AI_V4MAPPED\x2C\n\n  // ERROR CODES\n  NODATA: 'ENODATA'\x2C\n  FORMERR: 'EFORMERR'\x2C\n  SERVFAIL: 'ESERVFAIL'\x2C\n  NOTFOUND: 'ENOTFOUND'\x2C\n  NOTIMP: 'ENOTIMP'\x2C\n  REFUSED: 'EREFUSED'\x2C\n  BADQUERY: 'EBADQUERY'\x2C\n  BADNAME: 'EBADNAME'\x2C\n  BADFAMILY: 'EBADFAMILY'\x2C\n  BADRESP: 'EBADRESP'\x2C\n  CONNREFUSED: 'ECONNREFUSED'\x2C\n  TIMEOUT: 'ETIMEOUT'\x2C\n  EOF: 'EOF'\x2C\n  FILE: 'EFILE'\x2C\n  NOMEM: 'ENOMEM'\x2C\n  DESTRUCTION: 'EDESTRUCTION'\x2C\n  BADSTR: 'EBADSTR'\x2C\n  BADFLAGS: 'EBADFLAGS'\x2C\n  NONAME: 'ENONAME'\x2C\n  BADHINTS: 'EBADHINTS'\x2C\n  NOTINITIALIZED: 'ENOTINITIALIZED'\x2C\n  LOADIPHLPAPI: 'ELOADIPHLPAPI'\x2C\n  ADDRGETNETWORKPARAMS: 'EADDRGETNETWORKPARAMS'\x2C\n  CANCELLED: 'ECANCELLED'\n};\n\nbindDefaultResolver(module.exports\x2C getDefaultResolver());\n\nObjectDefineProperties(module.exports\x2C {\n  promises: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      if (promises === null) {\n        promises = require('internal/dns/promises');\n        promises.setServers = defaultResolverSetServers;\n        promises.setDefaultResultOrder = setDefaultResultOrder;\n      }\n      return promises;\n    }\n  }\n});\n
code-source-info,0x2811abd37cce,192,0,10048,C0O0C4O10048,,
code-creation,Function,10,103834,0x2811abd38736,961, node:dns:1:1,0x2811abd37c48,~
code-source-info,0x2811abd38736,192,0,10048,C0O0C148O1159C154O1180C159O1196C164O1222C170O1246C176O1292C179O1292C183O1292C185O1343C191O1343C196O1331C202O1386C208O1386C213O1377C219O1443C225O1443C230O1419C235O1484C241O1484C246O1735C252O1735C257O1522C263O1545C268O1567C274O1589C280O1601C286O1618C292O1648C298O1686C304O1708C310O1854C315O1776C321O1800C327O1825C333O1944C339O1944C344O1871C350O1891C356O1907C362O1925C368O2049C371O1987C377O2009C383O2031C389O2085C393O2078C395O2115C396O2115C398O4997C401O5026C412O4997C417O5887C420O5923C431O5887C436O7016C438O7016C442O7016C444O7036C447O7045C458O7085C463O7083C469O7066C473O7107C476O7116C487O7152C492O7150C498O7135C502O7172C505O7181C516O7220C521O7218C527O7200C531O7243C534O7252C545O7292C550O7290C556O7273C560O7314C563O7323C574O7367C579O7365C585O7346C589O7391C592O7400C603O7438C608O7436C614O7420C618O7459C621O7468C632O7506C637O7504C643O7488C647O7527C650O7536C661O7576C666O7574C672O7557C676O7598C679O7607C690O7647C695O7645C701O7628C705O7669C708O7678C719O7718C724O7716C730O7699C734O7740C737O7749C748O7793C753O7791C759O7772C763O7817C766O7826C777O7866C782O7864C788O7847C792O7888C795O7897C803O7917C807O7915C811O7945C814O7954C821O7972C825O8756C835O8777C841O8787C847O8805C853O8817C859O8854C866O8928C877O8956C888O8982C898O8771C902O9625C908O9652C913O9661C917O9625C922O9685C925O9715C935O9738C940O9790C954O9685C960O10047,,
tick,0x1bfcb0bb8,103875,1,0x10041f4d8,3,0x0,0x105108c5c,0x105115cac,0x105112d34,0x26b72db1b016,0x1051128a8,0x105113c1c,0x2811abd29309,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x1051128a8,0x26b72db362ce,0x2cbd764a8a0e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,104000,0x2811abd3a06e,5, node:internal/dns/utils:1:1,0x2811abd39d28,~
script-source,193,node:internal/dns/utils,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  NumberParseInt\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeReplace\x2C\n} = primordials;\n\nconst errors = require('internal/errors');\nconst { isIP } = require('internal/net');\nconst { getOptionValue } = require('internal/options');\nconst {\n  validateArray\x2C\n  validateInt32\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst {\n  ChannelWrap\x2C\n  strerror\x2C\n  AI_ADDRCONFIG\x2C\n  AI_ALL\x2C\n  AI_V4MAPPED\x2C\n} = internalBinding('cares_wrap');\nconst IANA_DNS_PORT = 53;\nconst IPv6RE = /^\\[([^[\\]]*)\\]/;\nconst addrSplitRE = /(^.+?)(?::(\\d+))?$/;\nconst {\n  ERR_DNS_SET_SERVERS_FAILED\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_IP_ADDRESS\x2C\n} = errors.codes;\n\nfunction validateTimeout(options) {\n  const { timeout = -1 } = { ...options };\n  validateInt32(timeout\x2C 'options.timeout'\x2C -1\x2C 2 ** 31 - 1);\n  return timeout;\n}\n\nfunction validateTries(options) {\n  const { tries = 4 } = { ...options };\n  validateInt32(tries\x2C 'options.tries'\x2C 1\x2C 2 ** 31 - 1);\n  return tries;\n}\n\n// Resolver instances correspond 1:1 to c-ares channels.\nclass Resolver {\n  constructor(options = undefined) {\n    const timeout = validateTimeout(options);\n    const tries = validateTries(options);\n    this._handle = new ChannelWrap(timeout\x2C tries);\n  }\n\n  cancel() {\n    this._handle.cancel();\n  }\n\n  getServers() {\n    return ArrayPrototypeMap(this._handle.getServers()\x2C (val) => {\n      if (!val[1] || val[1] === IANA_DNS_PORT)\n        return val[0];\n\n      const host = isIP(val[0]) === 6 ? `[${val[0]}]` : val[0];\n      return `${host}:${val[1]}`;\n    });\n  }\n\n  setServers(servers) {\n    validateArray(servers\x2C 'servers');\n\n    // Cache the original servers because in the event of an error while\n    // setting the servers\x2C c-ares won't have any servers available for\n    // resolution.\n    const orig = this._handle.getServers();\n    const newSet = [];\n\n    ArrayPrototypeForEach(servers\x2C (serv\x2C index) => {\n      validateString(serv\x2C `servers[${index}]`);\n      let ipVersion = isIP(serv);\n\n      if (ipVersion !== 0)\n        return ArrayPrototypePush(newSet\x2C [ipVersion\x2C serv\x2C IANA_DNS_PORT]);\n\n      const match = StringPrototypeMatch(serv\x2C IPv6RE);\n\n      // Check for an IPv6 in brackets.\n      if (match) {\n        ipVersion = isIP(match[1]);\n\n        if (ipVersion !== 0) {\n          const port = NumberParseInt(\n            StringPrototypeReplace(serv\x2C addrSplitRE\x2C '$2')) || IANA_DNS_PORT;\n          return ArrayPrototypePush(newSet\x2C [ipVersion\x2C match[1]\x2C port]);\n        }\n      }\n\n      // addr::port\n      const addrSplitMatch = StringPrototypeMatch(serv\x2C addrSplitRE);\n\n      if (addrSplitMatch) {\n        const hostIP = addrSplitMatch[1];\n        const port = addrSplitMatch[2] || IANA_DNS_PORT;\n\n        ipVersion = isIP(hostIP);\n\n        if (ipVersion !== 0) {\n          return ArrayPrototypePush(\n            newSet\x2C [ipVersion\x2C hostIP\x2C NumberParseInt(port)]);\n        }\n      }\n\n      throw new ERR_INVALID_IP_ADDRESS(serv);\n    });\n\n    const errorNumber = this._handle.setServers(newSet);\n\n    if (errorNumber !== 0) {\n      // Reset the servers to the old servers\x2C because ares probably unset them.\n      this._handle.setServers(ArrayPrototypeJoin(orig\x2C '\x2C'));\n      const err = strerror(errorNumber);\n      throw new ERR_DNS_SET_SERVERS_FAILED(err\x2C servers);\n    }\n  }\n\n  setLocalAddress(ipv4\x2C ipv6) {\n    validateString(ipv4\x2C 'ipv4');\n\n    if (ipv6 !== undefined) {\n      validateString(ipv6\x2C 'ipv6');\n    }\n\n    this._handle.setLocalAddress(ipv4\x2C ipv6);\n  }\n}\n\nlet defaultResolver = new Resolver();\nconst resolverKeys = [\n  'getServers'\x2C\n  'resolve'\x2C\n  'resolve4'\x2C\n  'resolve6'\x2C\n  'resolveAny'\x2C\n  'resolveCaa'\x2C\n  'resolveCname'\x2C\n  'resolveMx'\x2C\n  'resolveNaptr'\x2C\n  'resolveNs'\x2C\n  'resolvePtr'\x2C\n  'resolveSoa'\x2C\n  'resolveSrv'\x2C\n  'resolveTxt'\x2C\n  'reverse'\x2C\n];\n\nfunction getDefaultResolver() {\n  return defaultResolver;\n}\n\nfunction setDefaultResolver(resolver) {\n  defaultResolver = resolver;\n}\n\nfunction bindDefaultResolver(target\x2C source) {\n  ArrayPrototypeForEach(resolverKeys\x2C (key) => {\n    target[key] = FunctionPrototypeBind(source[key]\x2C defaultResolver);\n  });\n}\n\nfunction validateHints(hints) {\n  if ((hints & ~(AI_ADDRCONFIG | AI_ALL | AI_V4MAPPED)) !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('hints'\x2C hints);\n  }\n}\n\nlet invalidHostnameWarningEmitted = false;\nfunction emitInvalidHostnameWarning(hostname) {\n  if (!invalidHostnameWarningEmitted) {\n    process.emitWarning(\n      `The provided hostname "${hostname}" is not a valid ` +\n      'hostname\x2C and is supported in the dns module solely for compatibility.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0118'\n    );\n    invalidHostnameWarningEmitted = true;\n  }\n}\n\nlet typeCoercionWarningEmitted = false;\nfunction emitTypeCoercionDeprecationWarning() {\n  if (!typeCoercionWarningEmitted) {\n    process.emitWarning(\n      'Type coercion of dns.lookup options is deprecated'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0153'\n    );\n    typeCoercionWarningEmitted = true;\n  }\n}\n\nlet dnsOrder = getOptionValue('--dns-result-order') || 'verbatim';\n\nfunction getDefaultVerbatim() {\n  return dnsOrder !== 'ipv4first';\n}\n\nfunction setDefaultResultOrder(value) {\n  validateOneOf(value\x2C 'dnsOrder'\x2C ['verbatim'\x2C 'ipv4first']);\n  dnsOrder = value;\n}\n\nmodule.exports = {\n  bindDefaultResolver\x2C\n  getDefaultResolver\x2C\n  setDefaultResolver\x2C\n  validateHints\x2C\n  validateTimeout\x2C\n  validateTries\x2C\n  Resolver\x2C\n  emitInvalidHostnameWarning\x2C\n  emitTypeCoercionDeprecationWarning\x2C\n  getDefaultVerbatim\x2C\n  setDefaultResultOrder\x2C\n};\n
code-source-info,0x2811abd3a06e,193,0,5606,C0O0C4O5606,,
code-creation,Function,10,104209,0x2811abd3aa8e,499, node:internal/dns/utils:1:1,0x2811abd39fe8,~
code-source-info,0x2811abd3aa8e,193,0,5606,C0O0C148O25C154O50C160O72C166O93C172O115C178O140C184O158C190O182C196O239C199O239C204O284C207O284C212O275C218O336C221O336C226O317C231O446C234O446C239O375C245O392C251O409C257O426C263O559C266O559C271O488C277O503C283O515C289O532C295O542C301O612C303O612C305O631C309O631C311O669C315O669C317O791C322O701C328O731C334O756C386O3627C388O3627C393O3627C395O3664C399O3664C401O4405C402O4405C404O4800C405O4800C407O5088C410O5088C418O5088C420O5337C427O5358C433O5381C439O5403C445O5425C451O5442C457O5461C463O5478C469O5490C475O5520C481O5558C487O5580C493O5352C498O5605,,
code-creation,LazyCompile,10,104292,0x2811abd3b776,50,Resolver node:internal/dns/utils:53:14,0x2811abd3a3c0,~
code-source-info,0x2811abd3b776,193,1198,1365,C10O1242C13O1242C18O1286C21O1286C26O1314C28O1333C39O1329C44O1327C49O1364,,
code-creation,LazyCompile,10,104334,0x2811abd3bfee,43,validateTimeout node:internal/dns/utils:39:25,0x2811abd3a0a0,~
code-source-info,0x2811abd3bfee,193,823,959,C0O862C5O845C14O880C35O880C40O942C42O957,,
code-creation,LazyCompile,10,104334,0x2811abd3c12e,43,validateTries node:internal/dns/utils:45:23,0x2811abd3a0f0,~
code-source-info,0x2811abd3c12e,193,983,1109,C0O1019C5O1005C14O1037C35O1037C40O1094C42O1107,,
code-creation,LazyCompile,10,104417,0x2811abd3c396,46,resolver node:dns:233:18,0x2811abd37ee0,~
code-source-info,0x2811abd3c396,192,6330,6995,C0O6330C14O6917C24O6938C31O6962C38O6917C43O6980C45O6993,,
code-creation,LazyCompile,10,104500,0x2811abd3d166,5,getDefaultResolver node:internal/dns/utils:160:28,0x2811abd3a140,~
code-source-info,0x2811abd3d166,193,3929,3961,C0O3936C4O3959,,
code-creation,LazyCompile,10,104500,0x2811abd3d2ae,39,bindDefaultResolver node:internal/dns/utils:168:29,0x2811abd3a1e0,~
code-source-info,0x2811abd3d2ae,193,4064,4210,C0O4064C13O4085C24O4107C32O4085C38O4209,,
code-creation,LazyCompile,10,104542,0x2811abd3d3e6,37, node:internal/dns/utils:169:39,0x2811abd3d1f8,~
code-source-info,0x2811abd3d3e6,193,4121,4206,C0O4136C7O4150C15O4178C23O4185C26O4150C31O4148C36O4205,,
code-creation,LazyCompile,10,104584,0x2811abd3d9fe,54,get node:dns:349:8,0x2811abd37ff8,~
code-source-info,0x2811abd3d9fe,192,9793,10039,C0O9804C6O9837C12O9848C19O9846C25O9890C32O9910C36O9947C43O9980C45O9978C49O10017C53O10033,,
code-creation,Eval,10,104709,0x2811abd3dfae,5, node:internal/dns/promises:1:1,0x2811abd3dc68,~
script-source,194,node:internal/dns/promises,'use strict';\nconst {\n  ArrayPrototypeMap\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  Promise\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst {\n  bindDefaultResolver\x2C\n  Resolver: CallbackResolver\x2C\n  validateHints\x2C\n  validateTimeout\x2C\n  validateTries\x2C\n  emitInvalidHostnameWarning\x2C\n  emitTypeCoercionDeprecationWarning\x2C\n  getDefaultVerbatim\x2C\n} = require('internal/dns/utils');\nconst { codes\x2C dnsException } = require('internal/errors');\nconst { toASCII } = require('internal/idna');\nconst { isIP } = require('internal/net');\nconst {\n  getaddrinfo\x2C\n  getnameinfo\x2C\n  ChannelWrap\x2C\n  GetAddrInfoReqWrap\x2C\n  GetNameInfoReqWrap\x2C\n  QueryReqWrap\n} = internalBinding('cares_wrap');\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_MISSING_ARGS\x2C\n} = codes;\nconst {\n  validatePort\x2C\n  validateString\x2C\n  validateOneOf\x2C\n} = require('internal/validators');\n\nfunction onlookup(err\x2C addresses) {\n  if (err) {\n    this.reject(dnsException(err\x2C 'getaddrinfo'\x2C this.hostname));\n    return;\n  }\n\n  const family = this.family || isIP(addresses[0]);\n  this.resolve({ address: addresses[0]\x2C family });\n}\n\nfunction onlookupall(err\x2C addresses) {\n  if (err) {\n    this.reject(dnsException(err\x2C 'getaddrinfo'\x2C this.hostname));\n    return;\n  }\n\n  const family = this.family;\n\n  for (var i = 0; i < addresses.length; i++) {\n    const address = addresses[i];\n\n    addresses[i] = {\n      address\x2C\n      family: family || isIP(addresses[i])\n    };\n  }\n\n  this.resolve(addresses);\n}\n\nfunction createLookupPromise(family\x2C hostname\x2C all\x2C hints\x2C verbatim) {\n  return new Promise((resolve\x2C reject) => {\n    if (!hostname) {\n      emitInvalidHostnameWarning(hostname);\n      resolve(all ? [] : { address: null\x2C family: family === 6 ? 6 : 4 });\n      return;\n    }\n\n    const matchedFamily = isIP(hostname);\n\n    if (matchedFamily !== 0) {\n      const result = { address: hostname\x2C family: matchedFamily };\n      resolve(all ? [result] : result);\n      return;\n    }\n\n    const req = new GetAddrInfoReqWrap();\n\n    req.family = family;\n    req.hostname = hostname;\n    req.oncomplete = all ? onlookupall : onlookup;\n    req.resolve = resolve;\n    req.reject = reject;\n\n    const err = getaddrinfo(req\x2C toASCII(hostname)\x2C family\x2C hints\x2C verbatim);\n\n    if (err) {\n      reject(dnsException(err\x2C 'getaddrinfo'\x2C hostname));\n    }\n  });\n}\n\nfunction lookup(hostname\x2C options) {\n  var hints = 0;\n  var family = -1;\n  var all = false;\n  var verbatim = getDefaultVerbatim();\n\n  // Parse arguments\n  if (hostname) {\n    validateString(hostname\x2C 'hostname');\n  }\n\n  if (options !== null && typeof options === 'object') {\n    if (options.hints != null && typeof options.hints !== 'number') {\n      emitTypeCoercionDeprecationWarning();\n    }\n    hints = options.hints >>> 0;\n    if (options.family != null && typeof options.family !== 'number') {\n      emitTypeCoercionDeprecationWarning();\n    }\n    family = options.family >>> 0;\n    if (options.all != null && typeof options.all !== 'boolean') {\n      emitTypeCoercionDeprecationWarning();\n    }\n    all = options.all === true;\n    if (typeof options.verbatim === 'boolean') {\n      verbatim = options.verbatim === true;\n    } else if (options.verbatim != null) {\n      emitTypeCoercionDeprecationWarning();\n    }\n\n    validateHints(hints);\n  } else {\n    if (options != null && typeof options !== 'number') {\n      emitTypeCoercionDeprecationWarning();\n    }\n    family = options >>> 0;\n  }\n\n  validateOneOf(family\x2C 'family'\x2C [0\x2C 4\x2C 6]\x2C true);\n\n  return createLookupPromise(family\x2C hostname\x2C all\x2C hints\x2C verbatim);\n}\n\n\nfunction onlookupservice(err\x2C hostname\x2C service) {\n  if (err) {\n    this.reject(dnsException(err\x2C 'getnameinfo'\x2C this.host));\n    return;\n  }\n\n  this.resolve({ hostname\x2C service });\n}\n\nfunction createLookupServicePromise(hostname\x2C port) {\n  return new Promise((resolve\x2C reject) => {\n    const req = new GetNameInfoReqWrap();\n\n    req.hostname = hostname;\n    req.port = port;\n    req.oncomplete = onlookupservice;\n    req.resolve = resolve;\n    req.reject = reject;\n\n    const err = getnameinfo(req\x2C hostname\x2C port);\n\n    if (err)\n      reject(dnsException(err\x2C 'getnameinfo'\x2C hostname));\n  });\n}\n\nfunction lookupService(address\x2C port) {\n  if (arguments.length !== 2)\n    throw new ERR_MISSING_ARGS('address'\x2C 'port');\n\n  if (isIP(address) === 0)\n    throw new ERR_INVALID_ARG_VALUE('address'\x2C address);\n\n  validatePort(port);\n\n  return createLookupServicePromise(address\x2C +port);\n}\n\n\nfunction onresolve(err\x2C result\x2C ttls) {\n  if (err) {\n    this.reject(dnsException(err\x2C this.bindingName\x2C this.hostname));\n    return;\n  }\n\n  if (ttls && this.ttl)\n    result = ArrayPrototypeMap(\n      result\x2C (address\x2C index) => ({ address\x2C ttl: ttls[index] }));\n\n  this.resolve(result);\n}\n\nfunction createResolverPromise(resolver\x2C bindingName\x2C hostname\x2C ttl) {\n  return new Promise((resolve\x2C reject) => {\n    const req = new QueryReqWrap();\n\n    req.bindingName = bindingName;\n    req.hostname = hostname;\n    req.oncomplete = onresolve;\n    req.resolve = resolve;\n    req.reject = reject;\n    req.ttl = ttl;\n\n    const err = resolver._handle[bindingName](req\x2C toASCII(hostname));\n\n    if (err)\n      reject(dnsException(err\x2C bindingName\x2C hostname));\n  });\n}\n\nfunction resolver(bindingName) {\n  function query(name\x2C options) {\n    validateString(name\x2C 'name');\n\n    const ttl = !!(options && options.ttl);\n    return createResolverPromise(this\x2C bindingName\x2C name\x2C ttl);\n  }\n\n  ObjectDefineProperty(query\x2C 'name'\x2C { value: bindingName });\n  return query;\n}\n\n\nconst resolveMap = ObjectCreate(null);\n\n// Resolver instances correspond 1:1 to c-ares channels.\nclass Resolver {\n  constructor(options = undefined) {\n    const timeout = validateTimeout(options);\n    const tries = validateTries(options);\n    this._handle = new ChannelWrap(timeout\x2C tries);\n  }\n}\n\nResolver.prototype.getServers = CallbackResolver.prototype.getServers;\nResolver.prototype.setServers = CallbackResolver.prototype.setServers;\nResolver.prototype.cancel = CallbackResolver.prototype.cancel;\nResolver.prototype.setLocalAddress = CallbackResolver.prototype.setLocalAddress;\nResolver.prototype.resolveAny = resolveMap.ANY = resolver('queryAny');\nResolver.prototype.resolve4 = resolveMap.A = resolver('queryA');\nResolver.prototype.resolve6 = resolveMap.AAAA = resolver('queryAaaa');\nResolver.prototype.resolveCaa = resolveMap.CAA = resolver('queryCaa');\nResolver.prototype.resolveCname = resolveMap.CNAME = resolver('queryCname');\nResolver.prototype.resolveMx = resolveMap.MX = resolver('queryMx');\nResolver.prototype.resolveNs = resolveMap.NS = resolver('queryNs');\nResolver.prototype.resolveTxt = resolveMap.TXT = resolver('queryTxt');\nResolver.prototype.resolveSrv = resolveMap.SRV = resolver('querySrv');\nResolver.prototype.resolvePtr = resolveMap.PTR = resolver('queryPtr');\nResolver.prototype.resolveNaptr = resolveMap.NAPTR = resolver('queryNaptr');\nResolver.prototype.resolveSoa = resolveMap.SOA = resolver('querySoa');\nResolver.prototype.reverse = resolver('getHostByAddr');\nResolver.prototype.resolve = function resolve(hostname\x2C rrtype) {\n  var resolver;\n\n  if (rrtype !== undefined) {\n    validateString(rrtype\x2C 'rrtype');\n\n    resolver = resolveMap[rrtype];\n\n    if (typeof resolver !== 'function')\n      throw new ERR_INVALID_ARG_VALUE('rrtype'\x2C rrtype);\n  } else {\n    resolver = resolveMap.A;\n  }\n\n  return ReflectApply(resolver\x2C this\x2C [hostname]);\n};\n\n\nmodule.exports = { lookup\x2C lookupService\x2C Resolver };\nbindDefaultResolver(module.exports\x2C Resolver.prototype);\n
code-source-info,0x2811abd3dfae,194,0,7434,C0O0C4O7434,,
code-creation,Function,10,105000,0x2811abd3e88e,838, node:internal/dns/promises:1:1,0x2811abd3df28,~
code-source-info,0x2811abd3e88e,194,0,7434,C0O0C137O24C143O45C148O61C154O85C160O96C166O336C169O336C174O138C179O171C184O191C190O208C196O227C202O244C208O274C214O312C220O399C223O399C228O375C233O382C239O447C242O447C247O435C253O490C256O490C261O481C267O631C270O631C275O525C281O540C287O555C293O570C299O592C305O614C311O672C317O697C323O789C326O789C331O736C337O752C343O770C349O5464C351O5464C355O5464C379O5752C384O5792C389O5802C393O5773C397O5823C402O5863C407O5873C411O5844C415O5894C420O5930C425O5940C429O5911C433O5957C438O6002C443O6012C447O5983C451O6038C462O6078C467O6076C473O6059C477O6109C488O6145C493O6143C499O6128C503O6174C514O6213C519O6211C525O6193C529O6245C540O6285C545O6283C551O6266C555O6316C566O6360C571O6358C577O6339C581O6393C592O6431C597O6429C603O6413C607O6461C618O6499C623O6497C629O6481C633O6529C644O6569C649O6567C655O6550C659O6600C670O6640C675O6638C681O6621C685O6671C696O6711C701O6709C707O6692C711O6742C722O6786C727O6784C733O6765C737O6819C748O6859C753O6857C759O6840C763O6890C771O6910C775O6908C779O6946C788O6964C792O7323C799O7342C805O7350C811O7365C817O7338C821O7404C826O7422C831O7377C837O7433,,
tick,0x1bfcb0bb8,105084,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x2811abd3da0a,0x100d4d654,0x10510c9c8,0x10510b8cc,0x105115470,0x1003a57dc,0x1051159f0,0x105115e88,0x105112d34,0x26b72db1b016,0x1051128a8,0x105113c1c,0x2811abd29309,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x1051128a8,0x26b72db362ce,0x2cbd764a8a0e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
new,MemoryChunk,0x1208b700000,262144
code-creation,LazyCompile,10,105125,0x2811abd3f96e,46,resolver node:internal/dns/promises:217:18,0x2811abd3e2b0,~
code-source-info,0x2811abd3f96e,194,5164,5442,C0O5164C14O5364C24O5385C31O5409C38O5364C43O5427C45O5440,,
new,MemoryChunk,0x2c127a640000,262144
new,MemoryChunk,0x114c8b180000,262144
new,MemoryChunk,0x2ca1433c0000,262144
new,MemoryChunk,0x113616e80000,262144
scavenge,begin,0,105296,1648733370740
scavenge,end,0,105737,1648733370740
code-creation,LazyCompile,10,105667,0x1208b7027f6,19,createServer node:http:58:22,0x2cbd764a9930,~
code-source-info,0x1208b7027f6,152,1965,2036,C0O1993C13O2000C18O2034,,
code-creation,LazyCompile,10,105750,0x1208b702aae,223,Server node:_http_server:368:16,0x29d5d5b86ea8,~
code-source-info,0x1208b702aae,160,13005,14164,C0O13036C2O13047C7O13067C18O13074C23O13111C24O13115C30O13156C33O13187C38O13210C49O13268C57O13309C73O13315C78O13309C79O13378C82O13395C87O13395C93O13418C98O13422C103O13429C113O13489C121O13523C129O13571C137O13429C143O13600C147O13632C155O13632C161O13892C162O13915C166O13932C177O13932C183O13973C184O13986C188O13993C192O14015C196O14025C197O14046C201O14056C202O14082C206O14089C212O14109C216O14138C217O14158C222O14163,,
code-creation,LazyCompile,10,105792,0x1208b704e56,287,Server node:net:1217:16,0x120d44382400,~
code-source-info,0x1208b704e56,113,32014,33260,C0O32048C2O32059C7O32083C18O32090C23O32130C24O32134C29O32147C34O32147C39O32162C45O32203C48O32237C51O32260C59O32260C67O32307C78O32365C84O32396C90O32455C98O32455C106O32514C122O32520C127O32514C128O32601C136O32646C141O32676C149O32646C154O32755C160O32777C165O32790C166O32820C170O32838C171O32856C175O32864C177O32869C182O32886C186O32894C187O32907C191O32917C192O32936C196O32947C198O32961C202O32969C203O32981C207O33022C217O33012C221O33080C227O33068C231O33098C233O33113C236O33129C241O33113C245O33111C249O33141C251O33158C254O33174C259O33158C263O33156C267O33228C271O33250C277O33218C279O33217C281O33215C286O33259,,
code-creation,LazyCompile,10,105834,0x1208b70516e,101,storeHTTPOptions node:_http_server:353:26,0x29d5d5b86e58,~
code-source-info,0x1208b70516e,160,12442,12988,C0O12456C2O12461C5O12489C16O12508C18O12479C22O12527C24O12532C27O12559C38O12549C42O12626C47O12643C49O12680C62O12680C67O12734C69O12753C73O12808C78O12830C80O12872C88O12872C93O12941C95O12965C100O12987,,
code-creation,LazyCompile,10,105917,0x1208b7053d6,70,createPool node:buffer:151:20,0x232faba31980,~
code-source-info,0x1208b7053d6,24,3858,3998,C0O3865C3O3883C10O3874C16O3895C23O3926C26O3907C31O3935C38O3905C44O3946C51O3967C54O3946C58O3981C62O3992C69O3997,,
code-creation,LazyCompile,10,105917,0x1208b705516,40,markAsUntransferable node:internal/buffer:1048:30,0x232faba3ed90,~
code-source-info,0x1208b705516,25,29781,30016,C0O29791C16O29871C17O29878C18O29950C25O29970C33O29950C39O30015,,
tick,0x100912704,106000,0,0x0,0,0x0,0x100d2d18c,0x2811abd36b40,0x2811abd3699e,0x2cbd764a8a87,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Function,11,106000,0x105116e00,1624, node:internal/validators:84:3,0x2b48e0c7bf48,^
code-source-info,0x105116e00,15,2255,2836,,,
code-creation,Function,11,106000,0x1051174c0,520,updateChildren node:internal/modules/cjs/loader:165:24,0x3172a1b2a5e0,^
code-source-info,0x1051174c0,103,5049,5222,,,
code-creation,Function,11,106042,0x105117740,440,resolver node:dns:233:18,0x2811abd37ee0,^
code-source-info,0x105117740,192,6330,6995,,,
code-creation,Function,11,106042,0x105117960,336, node:internal/dns/utils:169:39,0x2811abd3d1f8,^
code-source-info,0x105117960,193,4121,4206,,,
code-creation,Function,11,106042,0x105117b20,440,resolver node:internal/dns/promises:217:18,0x2811abd3e2b0,^
code-source-info,0x105117b20,194,5164,5442,,,
code-creation,LazyCompile,10,106084,0x1208b705a26,17,createServer node:https:104:22,0x29d5d5b8e5d8,~
code-source-info,0x1208b705a26,162,3351,3422,C0O3379C11O3386C16O3420,,
code-creation,LazyCompile,10,106125,0x1208b705c56,185,Server node:https:52:16,0x29d5d5b8e560,~
code-source-info,0x1208b705c56,162,1859,2880,C0O1887C2O1898C7O1918C18O1925C23O1959C24O1963C30O2001C33O2029C36O2053C42O2086C48O2290C52O2309C56O2332C63O2354C72O2332C77O2387C84O2409C87O2413C94O2433C103O2387C108O2458C109O2481C113O2493C117O2525C125O2525C131O2578C144O2578C150O2722C151O2735C155O2742C159O2764C163O2774C164O2795C168O2805C174O2825C178O2854C179O2874C184O2879,,
code-creation,LazyCompile,10,106209,0x1208b706106,475,Server node:_tls_wrap:1179:16,0x29d5d5babd68,~
code-source-info,0x1208b706106,169,34149,35958,C0O34173C2O34184C7O34208C18O34215C23O34245C24O34249C30O34290C33O34314C38O34337C49O34395C58O34435C74O34441C79O34435C80O34504C82O34519C86O34554C92O34566C95O34544C99O34612C105O34631C109O34602C113O34657C119O34707C123O34697C127O34738C133O34780C137O34770C141O34807C147O34826C152O34830C157O34859C162O34830C168O34889C173O34889C178O34919C180O34924C183O34953C198O34943C202O34989C204O34994C207O35018C211O35008C215O35033C217O35038C220O35062C224O35052C228O35077C230O35082C233O35110C237O35100C241O35130C248O35150C250O35149C257O35130C262O35202C264O35211C266O35210C273O35240C275O35239C282O35276C293O35357C300O35282C305O35276C306O35378C308O35387C310O35386C317O35416C319O35415C326O35452C337O35533C344O35458C349O35452C350O35553C352O35562C354O35561C361O35595C363O35594C370O35633C381O35728C388O35639C393O35633C394O35780C401O35793C404O35797C418O35812C427O35821C437O35780C442O35849C446O35874C454O35874C460O35915C462O35920C465O35944C469O35934C474O35957,,
code-creation,LazyCompile,10,106250,0x1208b706576,56,convertALPNProtocols node:tls:144:61,0x29d5d5b90fd8,~
code-source-info,0x1208b706576,163,4834,5142,C0O4909C5O4913C11O4944C14O4964C18O4962C24O5002C29O5006C35O5093C37O5113C40O5120C45O5120C50O5111C55O5141,,
code-creation,LazyCompile,10,106292,0x1208b707346,149,convertProtocols node:tls:122:26,0x29d5d5b90d20,~
code-source-info,0x1208b707346,163,4185,4772,C0O4185C8O4214C15O4234C22O4214C27O4214C29O4258C36O4265C45O4277C48O4298C58O4277C64O4265C70O4603C72O4621C74O4638C79O4648C81O4648C86O4664C99O4685C102O4679C106O4699C113O4714C117O4699C123O4732C128O4746C138O4654C143O4608C146O4758C148O4770,,
code-creation,LazyCompile,10,106334,0x1208b70755e,89, node:tls:124:67,0x1208b707270,~
code-source-info,0x1208b70755e,163,4309,4580,C0O4340C7O4347C12O4347C18O4366C22O4374C27O4389C39O4473C46O4460C60O4395C65O4389C66O4538C73O4546C77O4557C79O4566C85O4570C88O4576,,
code-creation,LazyCompile,10,106375,0x1208b707746,158,byteLength node:buffer:729:20,0x232faba33b78,~
code-source-info,0x1208b707746,24,21787,22425,C0O21787C2O21810C8O21848C13O21852C21O21881C24O21881C30O21929C34O21940C35O21952C53O21958C58O21952C59O22077C64O22116C71O22123C78O22139C83O22143C87O22156C90O22178C95O22189C96O22198C97O22202C101O22221C111O22246C114O22246C118O22270C119O22286C122O22286C127O22314C129O22341C139O22366C142O22366C146O22390C147O22404C152O22404C157O22423,,
code-creation,LazyCompile,10,106417,0x1208b70793e,224,write node:buffer:1051:40,0x232faba34058,~
code-source-info,0x1208b70793e,24,31191,32192,C0O31257C4O31301C11O31327C22O31301C27O31335C28O31378C38O31440C41O31477C47O31489C52O31573C62O31614C70O31573C75O31651C82O31658C86O31673C90O31707C97O31738C103O31778C106O31803C113O31842C123O31883C131O31842C136O31898C138O31909C143O31930C148O31963C152O31994C169O31994C174O32028C175O32044C178O32044C183O32072C185O32099C192O32105C197O32099C198O32154C218O32154C223O32190,,
code-creation,LazyCompile,10,106417,0x1208b707b66,52,validateOffset node:buffer:112:24,0x232faba30ba8,~
code-source-info,0x1208b707b66,24,3005,3089,C22O3034C29O3051C46O3051C51O3089,,
code-creation,LazyCompile,10,106500,0x1208b707f26,666,Server.setSecureContext node:_tls_wrap:1249:45,0x29d5d5baca50,~
code-source-info,0x1208b707f26,169,36244,39139,C0O36258C8O36258C13O36309C19O36337C23O36327C29O36353C30O36362C34O36390C40O36418C44O36408C50O36434C51O36443C55O36471C61O36513C65O36503C71O36536C72O36552C76O36580C82O36610C86O36600C92O36627C93O36637C97O36665C103O36719C107O36709C113O36748C114O36770C118O36798C124O36824C128O36814C134O36839C135O36847C139O36875C145O36917C149O36907C155O36940C156O36956C160O36984C166O37026C170O37016C176O37049C177O37065C181O37093C187O37143C191O37133C197O37170C198O37190C202O37218C208O37246C212O37236C218O37262C219O37271C223O37310C227O37300C231O37334C237O37370C241O37360C247O37390C248O37403C252O37444C256O37434C260O37470C266O37506C270O37496C276O37526C277O37539C281O37567C287O37637C293O37625C299O37666C300O37688C304O37729C312O37752C314O37775C316O37794C322O37822C323O37841C327O37869C333O37925C337O37915C343O37958C345O37982C350O38010C353O38017C361O38017C367O38044C374O38052C380O38079C388O38052C394O38045C400O38099C408O38100C419O37982C424O37980C428O38142C434O38192C438O38182C442O38223C448O38265C452O38255C456O38316C460O38306C464O38372C468O38362C472O38393C474O38413C477O38417C487O38453C495O38472C503O38498C511O38525C519O38558C527O38589C535O38611C543O38638C551O38667C559O38696C567O38726C575O38759C583O38796C591O38836C599O38878C607O38910C615O38942C623O38981C631O39018C639O39065C647O39114C655O38417C660O38411C665O39138,,
code-creation,LazyCompile,10,106542,0x1208b70844e,19,createHash node:crypto:134:20,0x29d5d5bb2d38,~
code-source-info,0x1208b70844e,170,3466,3529,C0O3491C13O3498C18O3527,,
code-creation,LazyCompile,10,106584,0x1208b7085fe,170,Hash node:internal/crypto/hash:58:14,0x2811abd0e620,~
code-source-info,0x1208b7085fe,181,975,1481,C0O1000C2O1011C7O1033C18O1040C23O1069C24O1072C26O1099C28O1088C33O1111C41O1111C46O1168C56O1230C64O1258C66O1288C74O1288C79O1338C81O1343C86O1358C97O1354C102O1352C106O1386C108O1391C118O1408C123O1421C130O1399C134O1434C141O1447C153O1469C163O1434C169O1480,,
code-creation,LazyCompile,10,106625,0x1208b708dbe,8,LazyTransform node:internal/streams/lazy_transform:20:23,0x2811abd0a7f8,~
code-source-info,0x1208b708dbe,179,490,530,C0O504C2O518C7O529,,
code-creation,LazyCompile,10,106625,0x1208b708ef6,109,Transform node:internal/streams/transform:81:19,0xd2efcc0b530,~
script-source,66,node:internal/streams/transform,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a "filter"\x2C\n// but that's not a great name for it\x2C since that implies a thing where\n// some bits pass through\x2C and others are simply ignored.  (That would\n// be a valid example of a transform\x2C of course.)\n//\n// While the output is causally related to the input\x2C it's not a\n// necessarily symmetric or synchronous transformation.  For example\x2C\n// a zlib stream might take multiple plain-text writes()\x2C and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk)\x2C that calls _write(chunk\x2Ccb)\n// internally\x2C and returns false if there's a lot of pending writes\n// buffered up.  When you call read()\x2C that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream\x2C the written data is placed in a buffer.  When\n// _read(n) is called\x2C it transforms the queued up data\x2C calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks\x2C then the first\n// outputted bit calls the readcb\x2C and subsequent chunks just go into\n// the read buffer\x2C and will cause it to emit 'readable' if necessary.\n//\n// This way\x2C back-pressure is actually determined by the reading side\x2C\n// since _read has to be called to start processing a new chunk.  However\x2C\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example\x2C imagine a stream where every byte of input is\n// interpreted as an integer from 0-255\x2C and then results in that many\n// bytes of output.  Writing the 4 bytes {ff\x2Cff\x2Cff\x2Cff} would result in\n// 1kb of data being output.  In this case\x2C you could write a very small\n// amount of input\x2C and end up with a very large amount of output.  In\n// such a pathological inflating mechanism\x2C there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However\x2C even in such a pathological case\x2C only a single written chunk\n// would be consumed\x2C and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  Symbol\n} = primordials;\n\nmodule.exports = Transform;\nconst {\n  ERR_METHOD_NOT_IMPLEMENTED\n} = require('internal/errors').codes;\nconst Duplex = require('internal/streams/duplex');\nObjectSetPrototypeOf(Transform.prototype\x2C Duplex.prototype);\nObjectSetPrototypeOf(Transform\x2C Duplex);\n\nconst kCallback = Symbol('kCallback');\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this\x2C options);\n\n  // We have implemented the _read method\x2C and done the other things\n  // that Readable wants before the first _read call\x2C so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this[kCallback] = null;\n\n  if (options) {\n    if (typeof options.transform === 'function')\n      this._transform = options.transform;\n\n    if (typeof options.flush === 'function')\n      this._flush = options.flush;\n  }\n\n  // When the writable side finishes\x2C then flush out anything remaining.\n  // Backwards compat. Some Transform streams incorrectly implement _final\n  // instead of or in addition to _flush. By using 'prefinish' instead of\n  // implementing _final we continue supporting this unfortunate use case.\n  this.on('prefinish'\x2C prefinish);\n}\n\nfunction final(cb) {\n  let called = false;\n  if (typeof this._flush === 'function' && !this.destroyed) {\n    const result = this._flush((er\x2C data) => {\n      called = true;\n      if (er) {\n        if (cb) {\n          cb(er);\n        } else {\n          this.destroy(er);\n        }\n        return;\n      }\n\n      if (data != null) {\n        this.push(data);\n      }\n      this.push(null);\n      if (cb) {\n        cb();\n      }\n    });\n    if (result !== undefined && result !== null) {\n      try {\n        const then = result.then;\n        if (typeof then === 'function') {\n          then.call(\n            result\x2C\n            (data) => {\n              if (called)\n                return;\n              if (data != null)\n                this.push(data);\n              this.push(null);\n              if (cb)\n                process.nextTick(cb);\n            }\x2C\n            (err) => {\n              if (cb) {\n                process.nextTick(cb\x2C err);\n              } else {\n                process.nextTick(() => this.destroy(err));\n              }\n            });\n        }\n      } catch (err) {\n        process.nextTick(() => this.destroy(err));\n      }\n    }\n  } else {\n    this.push(null);\n    if (cb) {\n      cb();\n    }\n  }\n}\n\nfunction prefinish() {\n  if (this._final !== final) {\n    final.call(this);\n  }\n}\n\nTransform.prototype._final = final;\n\nTransform.prototype._transform = function(chunk\x2C encoding\x2C callback) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()');\n};\n\nTransform.prototype._write = function(chunk\x2C encoding\x2C callback) {\n  const rState = this._readableState;\n  const wState = this._writableState;\n  const length = rState.length;\n\n  let called = false;\n  const result = this._transform(chunk\x2C encoding\x2C (err\x2C val) => {\n    called = true;\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (val != null) {\n      this.push(val);\n    }\n\n    if (\n      wState.ended || // Backwards compat.\n      length === rState.length || // Backwards compat.\n      rState.length < rState.highWaterMark ||\n      rState.highWaterMark === 0 ||\n      rState.length === 0\n    ) {\n      callback();\n    } else {\n      this[kCallback] = callback;\n    }\n  });\n  if (result !== undefined && result != null) {\n    try {\n      const then = result.then;\n      if (typeof then === 'function') {\n        then.call(\n          result\x2C\n          (val) => {\n            if (called)\n              return;\n\n            if (val != null) {\n              this.push(val);\n            }\n\n            if (\n              wState.ended ||\n              length === rState.length ||\n              rState.length < rState.highWaterMark ||\n              rState.length === 0) {\n              process.nextTick(callback);\n            } else {\n              this[kCallback] = callback;\n            }\n          }\x2C\n          (err) => {\n            process.nextTick(callback\x2C err);\n          });\n      }\n    } catch (err) {\n      process.nextTick(callback\x2C err);\n    }\n  }\n};\n\nTransform.prototype._read = function() {\n  if (this[kCallback]) {\n    const callback = this[kCallback];\n    this[kCallback] = null;\n    callback();\n  }\n};\n
code-source-info,0x1208b708ef6,66,3872,4737,C0O3886C2O3897C7O3924C12O3931C17O3954C18O3958C23O3965C28O3965C34O4152C40O4172C44O4184C46O4189C50O4200C54O4211C58O4249C66O4307C70O4297C74O4342C82O4392C86O4382C90O4708C101O4708C108O4736,,
code-creation,LazyCompile,10,107042,0x1208b7099b6,130,update node:internal/crypto/hash:95:40,0x2811abd0e800,~
code-source-info,0x1208b7099b6,181,2065,2562,C0O2086C6O2109C9O2109C14O2148C16O2153C18O2152C22O2164C24O2174C26O2173C31O2191C36O2197C41O2191C42O2233C48O2269C53O2269C60O2312C65O2317C71O2348C89O2354C94O2348C95O2456C97O2466C99O2465C103O2475C108O2475C116O2503C121O2509C126O2503C127O2548C129O2560,,
code-creation,LazyCompile,10,107042,0x1208b709b36,3,getDefaultEncoding node:internal/crypto/util:80:28,0x29d5d5ba56f0,~
code-source-info,0x1208b709b36,166,1470,1502,C0O1477C2O1500,,
code-creation,LazyCompile,10,107084,0x1208b70aa3e,65,validateEncoding node:internal/validators:199:26,0x2b48e0c7c300,~
code-source-info,0x1208b70aa3e,15,5940,6249,C0O5988C5O5988C10O6039C15O6050C17O6073C24O6093C29O6097C34O6110C47O6233C57O6116C62O6110C64O6248,,
code-creation,LazyCompile,10,107125,0x1208b70adb6,488,slowCases node:internal/util:165:19,0x232faba01ec8,~
code-source-info,0x1208b70adb6,16,4331,6064,C0O4353C57O4381C59O4389C64O4401C66O4415C67O4422C69O4430C76O4448C81O4460C83O4477C84O4484C88O4499C93O4499C99O4520C101O4528C106O4540C108O4554C109O4561C111O4569C116O4581C118O4598C119O4605C121O4630C123O4638C130O4655C137O4681C139O4687C144O4687C151O4701C156O4720C158O4733C159O4740C161O4765C163O4773C168O4786C170O4801C171O4808C173O4816C178O4829C180O4846C181O4853C183O4861C188O4874C190O4888C191O4895C193O4903C198O4916C200O4931C201O4938C203O4946C208O4959C210O4976C211O4983C215O4998C220O4998C226O5019C228O5027C233O5040C235O5054C236O5061C238O5069C243O5082C245O5097C246O5104C248O5112C253O5125C255O5142C256O5149C258O5174C260O5182C265O5196C267O5212C268O5219C270O5227C277O5247C282O5261C284O5277C285O5284C287O5292C292O5306C294O5322C295O5329C297O5337C304O5357C309O5371C311O5387C312O5394C316O5409C321O5409C327O5430C329O5438C334O5452C336O5468C337O5475C339O5483C346O5503C351O5517C353O5533C354O5540C356O5565C358O5573C365O5594C372O5624C374O5630C379O5630C386O5644C391O5667C393O5684C394O5691C396O5716C398O5724C405O5746C412O5775C414O5781C419O5781C426O5795C431O5819C433O5836C434O5843C436O5868C438O5876C445O5899C452O5931C454O5937C459O5937C466O5951C471O5976C473O5995C474O6002C476O6028C478O6036C483O6044C485O6058C487O6063,,
code-creation,LazyCompile,10,107167,0x1208b70b1de,78,digest node:internal/crypto/hash:115:40,0x2811abd0e850,~
code-source-info,0x1208b70b1de,181,2605,2935,C0O2640C2O2645C4O2644C8O2656C10O2666C12O2665C17O2683C22O2689C27O2683C28O2724C34O2759C37O2759C42O2849C44O2854C46O2853C50O2863C57O2873C59O2863C65O2894C67O2900C71O2912C75O2922C77O2933,,
tick,0x10093eb90,107250,0,0x0,2,0x0,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,107250,0x1208b70b3ce,88,createSecureContext node:_tls_common:99:29,0x29d5d5ba2330,~
code-source-info,0x1208b70b3ce,164,3045,3477,C0O3059C4O3073C7O3102C12O3124C17O3140C22O3156C27O3196C32O3226C36O3252C38O3269C47O3315C64O3315C70O3422C75O3444C80O3422C85O3466C87O3475,,
code-creation,LazyCompile,10,107292,0x1208b70baee,198,SecureContext node:_tls_common:75:23,0x29d5d5ba22e0,~
code-source-info,0x1208b70baee,164,2200,3015,C0O2260C2O2271C7O2304C24O2311C29O2413C30O2421C34O2447C39O2477C52O2483C57O2477C58O2554C63O2584C76O2590C81O2584C82O2664C84O2683C87O2679C92O2677C96O2713C101O2721C114O2789C117O2793C125O2762C139O2862C142O2866C150O2835C159O2721C164O2892C168O2917C176O2917C181O2975C186O2983C191O2983C197O3014,,
code-creation,LazyCompile,10,107334,0x1208b70bd6e,77,toV node:_tls_common:62:13,0x29d5d5ba2290,~
code-source-info,0x1208b70bd6e,164,1817,2098,C0O1837C5O1852C10O1863C12O1869C17O1882C21O1902C22O1905C24O1911C29O1926C33O1948C34O1951C36O1957C41O1972C45O1994C46O1997C48O2003C53O2018C57O2040C58O2043C71O2049C76O2043,,
code-creation,LazyCompile,10,107709,0x1208b70c536,1878,configSecureContext node:internal/tls/secure-context:120:29,0x29d5d5ba3698,~
code-source-info,0x1208b70c536,165,2854,9214,C0O2854C40O2900C48O2900C53O2946C58O2954C63O2964C78O2974C82O2999C87O3021C92O3030C97O3043C109O3055C113O3082C118O3091C124O3107C129O3116C134O3142C139O3164C144O3186C149O3206C155O3219C161O3447C165O3461C181O3481C185O3481C195O3500C206O3506C216O3514C226O3461C233O3541C239O3549C245O3549C249O3572C253O3588C269O3606C273O3606C283O3627C294O3635C304O3645C314O3588C319O3888C323O3903C331O3907C337O3947C340O3958C344O3952C349O3993C351O3996C356O4021C360O4036C369O4062C379O4095C386O4110C395O4143C405O4177C426O4177C431O3968C437O3934C442O4238C464O4238C469O4291C477O4344C487O4371C497O4344C502O4393C504O4405C509O4419C519O4454C534O4425C539O4419C540O4485C546O4493C552O4493C557O4521C565O4600C573O4738C583O4773C598O4744C603O4738C604O4865C608O4950C618O4985C633O4956C638O4950C639O5086C651O5188C657O5200C663O5222C669O5230C675O5230C683O5303C691O5309C696O5303C699O5366C705O5420C715O5454C736O5426C741O5420C742O5632C752O5666C773O5638C778O5632C779O5830C787O5881C797O5908C807O5881C812O6266C820O6293C830O6266C837O6230C843O6246C849O6313C855O6321C861O6321C866O6354C872O6362C878O6362C883O6389C885O6406C896O6430C902O6430C912O6446C914O6444C925O6478C931O6478C941O6494C943O6492C948O6516C954O6524C964O6536C968O6524C973O6560C975O6575C986O6599C992O6599C1002O6615C1004O6613C1015O6647C1021O6647C1031O6663C1033O6661C1038O6685C1044O6693C1054O6705C1058O6693C1063O6729C1073O6758C1083O6729C1088O6779C1094O6787C1100O6787C1105O6815C1113O6868C1121O6895C1131O6868C1136O6941C1142O6949C1148O6949C1155O6974C1157O6993C1163O7001C1173O7001C1179O7049C1187O7094C1195O7098C1201O7143C1229O7136C1260O7136C1263O7158C1271O7185C1281O7158C1286O7211C1292O7219C1298O7219C1306O7125C1379O7259C1387O7286C1397O7259C1402O7310C1408O7318C1414O7318C1419O7344C1427O7415C1437O7451C1447O7415C1452O7481C1458O7489C1464O7489C1469O7535C1477O7580C1485O7584C1491O7611C1499O7633C1505O7611C1512O7941C1516O7965C1522O7973C1532O7984C1536O7984C1546O7996C1554O7996C1560O7973C1568O8035C1574O8043C1584O8054C1588O8054C1594O8043C1599O8080C1605O8128C1611O8147C1619O8189C1627O8195C1632O8189C1633O8256C1639O8264C1645O8264C1652O8312C1660O8383C1670O8417C1691O8389C1696O8383C1697O8571C1705O8630C1713O8635C1719O8674C1729O8717C1750O8680C1755O8674C1756O8828C1764O8839C1769O8855C1779O8899C1789O8937C1801O8861C1806O8855C1807O8996C1813O9004C1819O9004C1824O9038C1832O9105C1842O9138C1852O9105C1857O9166C1863O9174C1869O9174C1877O9213,,
code-creation,LazyCompile,10,107792,0x1208b70da8e,16,getDefaultCiphers node:internal/tls/secure-context:48:27,0x29d5d5ba34b8,~
code-source-info,0x1208b70da8e,165,932,1138,C0O1098C6O1105C11O1119C15O1136,,
code-creation,LazyCompile,10,107792,0x1208b70db86,20,getDefaultEcdhCurve node:internal/tls/secure-context:41:29,0x29d5d5ba3468,~
code-source-info,0x1208b70db86,165,682,904,C0O851C6O858C11O872C19O902,,
tick,0x1bfb84cec,108500,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d418,109750,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100efe4a8,111000,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d7bc,112250,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d440,113500,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d440,114792,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100efcc30,116042,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100efb6f4,117292,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d44c,118542,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f30250,119792,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x10152ea64,121042,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x1bfd8a8b8,122292,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d450,123584,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x1bfd8a550,124834,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x10152ea64,126084,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d440,127334,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d450,128584,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d448,129834,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x1bfd8ad48,131125,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d440,132375,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x1bfb8501c,133625,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100efb588,134875,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d440,136125,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d418,137375,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f031ac,138667,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d440,139917,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d440,141167,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x1bfc3e504,142417,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100e487a0,143667,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x100f0d418,144917,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x1bfd72b28,146167,1,0x1004cbb38,6,0x0,0x1208b70c62b,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,146542,0x1208b70dcf6,32,setCerts node:internal/tls/secure-context:62:18,0x29d5d5ba3558,~
code-source-info,0x1208b70dcf6,165,1323,1466,C0O1323C13O1350C20O1372C25O1350C31O1465,,
code-creation,LazyCompile,10,146584,0x1208b70de1e,28, node:internal/tls/secure-context:63:32,0x1208b70dc48,~
code-source-info,0x1208b70de1e,165,1379,1462,C0O1395C8O1395C13O1436C16O1444C21O1444C27O1461,,
code-creation,LazyCompile,10,146584,0x1208b70df6e,43,validateKeyOrCertOption node:internal/tls/secure-context:69:33,0x29d5d5ba35a8,~
code-source-info,0x1208b70df6e,165,1500,1747,C0O1518C8O1552C11O1552C17O1584C22O1622C35O1590C40O1584C42O1746,,
code-creation,LazyCompile,10,147209,0x1208b70e0ce,59,setKey node:internal/tls/secure-context:84:16,0x29d5d5ba35f8,~
code-source-info,0x1208b70e0ce,165,1764,1991,C0O1801C5O1828C13O1801C18O1848C26O1905C33O1935C41O1905C46O1965C51O1965C58O1990,,
tick,0x1bfd710fc,147459,1,0x1004cb370,6,0x0,0x1208b70e101,0x1208b70c706,0x1208b70b41e,0x1208b7081b5,0x1208b7061b3,0x1208b705cbd,0x1208b705a31,0x2cbd764a8ab2,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x26b72db1ac4a,0x26b72db362ce,0x2cbd764a6e8e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,147750,0x1208b70e336,139,processCiphers node:internal/tls/secure-context:91:24,0x29d5d5ba3648,~
code-source-info,0x1208b70e336,165,2016,2824,C0O2036C7O2067C12O2078C19O2046C26O2131C33O2157C36O2187C41O2157C50O2131C56O2358C63O2384C66O2414C71O2384C80O2358C86O2685C88O2702C95O2723C100O2735C113O2741C118O2735C119O2786C126O2795C132O2807C138O2822,,
code-creation,LazyCompile,10,147792,0x1208b70e52e,26, node:internal/tls/secure-context:98:9,0x1208b70e1c0,~
code-source-info,0x1208b70e52e,165,2204,2321,C0O2242C6O2249C13O2269C19O2269C25O2311,,
code-creation,LazyCompile,10,147792,0x1208b70e686,25, node:internal/tls/secure-context:107:9,0x1208b70e210,~
code-source-info,0x1208b70e686,165,2431,2547,C0O2469C6O2476C13O2495C19O2495C24O2537,,
code-creation,Function,11,147959,0x105117d40,5216,Module._load node:internal/modules/cjs/loader:757:24,0x3172a1b2b2d0,^
code-source-info,0x105117d40,103,23190,26108,,,
code-creation,Function,11,147959,0x105119200,1384, node:internal/validators:73:3,0x2b48e0c7bef8,^
code-source-info,0x105119200,15,1828,2209,,,
code-creation,Function,11,147959,0x1051197e0,304, node:internal/tls/secure-context:98:9,0x1208b70e1c0,^
code-source-info,0x1051197e0,165,2204,2321,,,
code-creation,Function,11,148000,0x105119980,280, node:internal/tls/secure-context:107:9,0x1208b70e210,^
code-source-info,0x105119980,165,2431,2547,,,
code-creation,Function,11,148125,0x105119b00,744,tryReadSync node:fs:429:21,0xd2efcc348a8,^
code-source-info,0x105119b00,81,10903,11138,,,
code-creation,Function,11,148125,0x105119e60,1328,allocate node:buffer:398:18,0x232faba31f98,^
code-source-info,0x105119e60,24,11607,11922,,,
code-creation,Function,11,148167,0x10511a400,2200,readSync node:fs:684:18,0xd2efcc34bb0,^
code-source-info,0x10511a400,81,17188,18177,,,
code-creation,Eval,10,148292,0x1208b70fb96,5, /Users/vignesh/Projects/HTTP2/lib/workers.js:1:1,0x1208b70f9d0,~
script-source,195,/Users/vignesh/Projects/HTTP2/lib/workers.js,/*\n * Worker-related tasks\n *\n */\n\n // Dependencies\nvar path = require('path');\nvar fs = require('fs');\nvar _data = require('./data');\nvar https = require('https');\nvar http = require('http');\nvar helpers = require('./helpers');\nvar url = require('url');\nvar _logs = require('./logs');\nvar util = require('util');\nvar debug = util.debuglog('workers');\n\n// Instantiate the worker module object\nvar workers = {};\n\n// Lookup all checks\x2C get their data\x2C send to validator\nworkers.gatherAllChecks = function(){\n  // Get all the checks\n  _data.list('checks'\x2Cfunction(err\x2Cchecks){\n    if(!err && checks && checks.length > 0){\n      checks.forEach(function(check){\n        // Read in the check data\n        _data.read('checks'\x2Ccheck\x2Cfunction(err\x2CoriginalCheckData){\n          if(!err && originalCheckData){\n            // Pass it to the check validator\x2C and let that function continue the function or log the error(s) as needed\n            workers.validateCheckData(originalCheckData);\n          } else {\n            debug("Error reading one of the check's data: "\x2Cerr);\n          }\n        });\n      });\n    } else {\n      debug('Error: Could not find any checks to process');\n    }\n  });\n};\n\n// Sanity-check the check-data\x2C\nworkers.validateCheckData = function(originalCheckData){\n  originalCheckData = typeof(originalCheckData) == 'object' && originalCheckData !== null ? originalCheckData : {};\n  originalCheckData.id = typeof(originalCheckData.id) == 'string' && originalCheckData.id.trim().length == 20 ? originalCheckData.id.trim() : false;\n  originalCheckData.userPhone = typeof(originalCheckData.userPhone) == 'string' && originalCheckData.userPhone.trim().length == 10 ? originalCheckData.userPhone.trim() : false;\n  originalCheckData.protocol = typeof(originalCheckData.protocol) == 'string' && ['http'\x2C'https'].indexOf(originalCheckData.protocol) > -1 ? originalCheckData.protocol : false;\n  originalCheckData.url = typeof(originalCheckData.url) == 'string' && originalCheckData.url.trim().length > 0 ? originalCheckData.url.trim() : false;\n  originalCheckData.method = typeof(originalCheckData.method) == 'string' &&  ['post'\x2C'get'\x2C'put'\x2C'delete'].indexOf(originalCheckData.method) > -1 ? originalCheckData.method : false;\n  originalCheckData.successCodes = typeof(originalCheckData.successCodes) == 'object' && originalCheckData.successCodes instanceof Array && originalCheckData.successCodes.length > 0 ? originalCheckData.successCodes : false;\n  originalCheckData.timeoutSeconds = typeof(originalCheckData.timeoutSeconds) == 'number' && originalCheckData.timeoutSeconds % 1 === 0 && originalCheckData.timeoutSeconds >= 1 && originalCheckData.timeoutSeconds <= 5 ? originalCheckData.timeoutSeconds : false;\n  // Set the keys that may not be set (if the workers have never seen this check before)\n  originalCheckData.state = typeof(originalCheckData.state) == 'string' && ['up'\x2C'down'].indexOf(originalCheckData.state) > -1 ? originalCheckData.state : 'down';\n  originalCheckData.lastChecked = typeof(originalCheckData.lastChecked) == 'number' && originalCheckData.lastChecked > 0 ? originalCheckData.lastChecked : false;\n\n  // If all checks pass\x2C pass the data along to the next step in the process\n  if(originalCheckData.id &&\n  originalCheckData.userPhone &&\n  originalCheckData.protocol &&\n  originalCheckData.url &&\n  originalCheckData.method &&\n  originalCheckData.successCodes &&\n  originalCheckData.timeoutSeconds){\n    workers.performCheck(originalCheckData);\n  } else {\n    // If checks fail\x2C log the error and fail silently\n    debug("Error: one of the checks is not properly formatted. Skipping.");\n  }\n};\n\n// Perform the check\x2C send the originalCheck data and the outcome of the check process to the next step in the process\nworkers.performCheck = function(originalCheckData){\n\n  // Prepare the intial check outcome\n  var checkOutcome = {\n    'error' : false\x2C\n    'responseCode' : false\n  };\n\n  // Mark that the outcome has not been sent yet\n  var outcomeSent = false;\n\n  // Parse the hostname and path out of the originalCheckData\n  var parsedUrl = url.parse(originalCheckData.protocol+'://'+originalCheckData.url\x2C true);\n  var hostName = parsedUrl.hostname;\n  var path = parsedUrl.path; // Using path not pathname because we want the query string\n\n  // Construct the request\n  var requestDetails = {\n    'protocol' : originalCheckData.protocol+':'\x2C\n    'hostname' : hostName\x2C\n    'method' : originalCheckData.method.toUpperCase()\x2C\n    'path' : path\x2C\n    'timeout' : originalCheckData.timeoutSeconds * 1000\n  };\n\n  // Instantiate the request object (using either the http or https module)\n  var _moduleToUse = originalCheckData.protocol == 'http' ? http : https;\n  var req = _moduleToUse.request(requestDetails\x2Cfunction(res){\n      // Grab the status of the sent request\n      var status =  res.statusCode;\n\n      // Update the checkOutcome and pass the data along\n      checkOutcome.responseCode = status;\n      if(!outcomeSent){\n        workers.processCheckOutcome(originalCheckData\x2CcheckOutcome);\n        outcomeSent = true;\n      }\n  });\n\n  // Bind to the error event so it doesn't get thrown\n  req.on('error'\x2Cfunction(e){\n    // Update the checkOutcome and pass the data along\n    checkOutcome.error = {'error' : true\x2C 'value' : e};\n    if(!outcomeSent){\n      workers.processCheckOutcome(originalCheckData\x2CcheckOutcome);\n      outcomeSent = true;\n    }\n  });\n\n  // Bind to the timeout event\n  req.on('timeout'\x2Cfunction(){\n    // Update the checkOutcome and pass the data along\n    checkOutcome.error = {'error' : true\x2C 'value' : 'timeout'};\n    if(!outcomeSent){\n      workers.processCheckOutcome(originalCheckData\x2CcheckOutcome);\n      outcomeSent = true;\n    }\n  });\n\n  // End the request\n  req.end();\n};\n\n// Process the check outcome\x2C update the check data as needed\x2C trigger an alert if needed\n// Special logic for accomodating a check that has never been tested before (don't alert on that one)\nworkers.processCheckOutcome = function(originalCheckData\x2CcheckOutcome){\n\n  // Decide if the check is considered up or down\n  var state = !checkOutcome.error && checkOutcome.responseCode && originalCheckData.successCodes.indexOf(checkOutcome.responseCode) > -1 ? 'up' : 'down';\n\n  // Decide if an alert is warranted\n  var alertWarranted = originalCheckData.lastChecked && originalCheckData.state !== state ? true : false;\n\n  // Log the outcome\n  var timeOfCheck = Date.now();\n  workers.log(originalCheckData\x2CcheckOutcome\x2Cstate\x2CalertWarranted\x2CtimeOfCheck);\n\n  // Update the check data\n  var newCheckData = originalCheckData;\n  newCheckData.state = state;\n  newCheckData.lastChecked = timeOfCheck;\n\n  // Save the updates\n  _data.update('checks'\x2CnewCheckData.id\x2CnewCheckData\x2Cfunction(err){\n    if(!err){\n      // Send the new check data to the next phase in the process if needed\n      if(alertWarranted){\n        workers.alertUserToStatusChange(newCheckData);\n      } else {\n        debug("Check outcome has not changed\x2C no alert needed");\n      }\n    } else {\n      debug("Error trying to save updates to one of the checks");\n    }\n  });\n};\n\n// Alert the user as to a change in their check status\nworkers.alertUserToStatusChange = function(newCheckData){\n  var msg = 'Alert: Your check for '+newCheckData.method.toUpperCase()+' '+newCheckData.protocol+'://'+newCheckData.url+' is currently '+newCheckData.state;\n  helpers.sendTwilioSms(newCheckData.userPhone\x2Cmsg\x2Cfunction(err){\n    if(!err){\n      debug("Success: User was alerted to a status change in their check\x2C via sms: "\x2Cmsg);\n    } else {\n      debug("Error: Could not send sms alert to user who had a state change in their check"\x2Cerr);\n    }\n  });\n};\n\n// Send check data to a log file\nworkers.log = function(originalCheckData\x2CcheckOutcome\x2Cstate\x2CalertWarranted\x2CtimeOfCheck){\n  // Form the log data\n  var logData = {\n    'check' : originalCheckData\x2C\n    'outcome' : checkOutcome\x2C\n    'state' : state\x2C\n    'alert' : alertWarranted\x2C\n    'time' : timeOfCheck\n  };\n\n  // Convert the data to a string\n  var logString = JSON.stringify(logData);\n\n  // Determine the name of the log file\n  var logFileName = originalCheckData.id;\n\n  // Append the log string to the file\n  _logs.append(logFileName\x2ClogString\x2Cfunction(err){\n    if(!err){\n      debug("Logging to file succeeded");\n    } else {\n      debug("Logging to file failed");\n    }\n  });\n\n};\n\n// Timer to execute the worker-process once per minute\nworkers.loop = function(){\n  setInterval(function(){\n    workers.gatherAllChecks();\n  }\x2C1000 * 60);\n};\n\n// Rotate (compress) the log files\nworkers.rotateLogs = function(){\n  // List all the (non compressed) log files\n  _logs.list(false\x2Cfunction(err\x2Clogs){\n    if(!err && logs && logs.length > 0){\n      logs.forEach(function(logName){\n        // Compress the data to a different file\n        var logId = logName.replace('.log'\x2C'');\n        var newFileId = logId+'-'+Date.now();\n        _logs.compress(logId\x2CnewFileId\x2Cfunction(err){\n          if(!err){\n            // Truncate the log\n            _logs.truncate(logId\x2Cfunction(err){\n              if(!err){\n                debug("Success truncating logfile");\n              } else {\n                debug("Error truncating logfile");\n              }\n            });\n          } else {\n            debug("Error compressing one of the log files."\x2Cerr);\n          }\n        });\n      });\n    } else {\n      debug('Error: Could not find any logs to rotate');\n    }\n  });\n};\n\n// Timer to execute the log-rotation process once per day\nworkers.logRotationLoop = function(){\n  setInterval(function(){\n    workers.rotateLogs();\n  }\x2C1000 * 60 * 60 * 24);\n}\n\n// Init script\nworkers.init = function(){\n\n  // Send to console\x2C in yellow\n  console.log('\\x1b[33m%s\\x1b[0m'\x2C'Background workers are running');\n\n  // Execute all the checks immediately\n  workers.gatherAllChecks();\n\n  // Call the loop so the checks will execute later on\n  workers.loop();\n\n  // Compress all the logs immediately\n  workers.rotateLogs();\n\n  // Call the compression loop so checks will execute later on\n  workers.logRotationLoop();\n\n};\n\n\n // Export the module\n module.exports = workers;\n
code-source-info,0x1208b70fb96,195,0,10070,C0O0C4O10070,,
code-creation,Function,10,148667,0x1208b7104b6,219, /Users/vignesh/Projects/HTTP2/lib/workers.js:1:1,0x1208b70fb10,~
code-source-info,0x1208b7104b6,195,0,10070,C0O0C5O63C8O63C13O89C16O89C21O116C24O116C28O116C30O147C33O147C37O147C39O176C42O176C46O176C48O207C51O207C55O207C57O239C60O239C64O239C66O267C69O267C73O267C75O297C78O297C83O331C91O331C96O326C98O407C99O407C101O468C108O492C112O1218C119O1244C123O3744C130O3765C134O5925C141O5953C145O7120C152O7152C156O7666C163O7678C167O8373C174O8386C178O8512C185O8531C189O9451C196O9475C200O9585C207O9598C211O10044C213O10059C218O10069,,
tick,0x1bfc3b840,148709,1,0x1003cc7d8,3,0x0,0x26b72db3352e,0x26b72db32c8f,0x26b72db31625,0x26b72db2d3e3,0x26b72db2c8a6,0x105118954,0x1051128a8,0x105113c1c,0x2cbd764a6e97,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Function,11,148750,0x10511ad00,4056,compileFunction node:vm:308:25,0x3beccad0070,^
code-source-info,0x10511ad00,89,9562,11817,,,
code-creation,Function,11,148750,0x10511bd40,832, node:internal/validators:168:39,0x2b48e0c7c1e8,^
code-source-info,0x10511bd40,15,4985,5263,,,
code-creation,Function,11,148875,0x10511c0e0,2952,readFileSync node:fs:450:22,0xd2efcc348f8,^
code-source-info,0x10511c0e0,81,11383,12760,,,
code-creation,Function,11,148917,0x10511cce0,1896,readPackage node:internal/modules/cjs/loader:290:21,0x3172a1b2a720,^
code-source-info,0x10511cce0,103,8102,8892,,,
code-creation,Eval,10,149000,0x1208b712126,5, /Users/vignesh/Projects/HTTP2/lib/logs.js:1:1,0x1208b711fb0,~
script-source,196,/Users/vignesh/Projects/HTTP2/lib/logs.js,/*\n * Library for storing and rotating logs\n *\n */\n\n// Dependencies\nvar fs = require('fs');\nvar path = require('path');\nvar zlib = require('zlib');\n\n// Container for module (to be exported)\nvar lib = {};\n\n// Base directory of data folder\nlib.baseDir = path.join(__dirname\x2C'/../.logs/');\n\n// Append a string to a file. Create the file if it does not exist\nlib.append = function(file\x2Cstr\x2Ccallback){\n  // Open the file for appending\n  fs.open(lib.baseDir+file+'.log'\x2C 'a'\x2C function(err\x2C fileDescriptor){\n    if(!err && fileDescriptor){\n      // Append to file and close it\n      fs.appendFile(fileDescriptor\x2C str+'\\n'\x2Cfunction(err){\n        if(!err){\n          fs.close(fileDescriptor\x2Cfunction(err){\n            if(!err){\n              callback(false);\n            } else {\n              callback('Error closing file that was being appended');\n            }\n          });\n        } else {\n          callback('Error appending to file');\n        }\n      });\n    } else {\n      callback('Could open file for appending');\n    }\n  });\n};\n\n// List all the logs\x2C and optionally include the compressed logs\nlib.list = function(includeCompressedLogs\x2Ccallback){\n  fs.readdir(lib.baseDir\x2C function(err\x2Cdata){\n    if(!err && data && data.length > 0){\n      var trimmedFileNames = [];\n      data.forEach(function(fileName){\n\n        // Add the .log files\n        if(fileName.indexOf('.log') > -1){\n          trimmedFileNames.push(fileName.replace('.log'\x2C''));\n        }\n\n        // Add the .gz files\n        if(fileName.indexOf('.gz.b64') > -1 && includeCompressedLogs){\n          trimmedFileNames.push(fileName.replace('.gz.b64'\x2C''));\n        }\n\n      });\n      callback(false\x2CtrimmedFileNames);\n    } else {\n      callback(err\x2Cdata);\n    }\n  });\n};\n\n// Compress the contents of one .log file into a .gz.b64 file within the same directory\nlib.compress = function(logId\x2CnewFileId\x2Ccallback){\n  var sourceFile = logId+'.log';\n  var destFile = newFileId+'.gz.b64';\n\n  // Read the source file\n  fs.readFile(lib.baseDir+sourceFile\x2C 'utf8'\x2C function(err\x2CinputString){\n    if(!err && inputString){\n      // Compress the data using gzip\n      zlib.gzip(inputString\x2Cfunction(err\x2Cbuffer){\n        if(!err && buffer){\n          // Send the data to the destination file\n          fs.open(lib.baseDir+destFile\x2C 'wx'\x2C function(err\x2C fileDescriptor){\n            if(!err && fileDescriptor){\n              // Write to the destination file\n              fs.writeFile(fileDescriptor\x2C buffer.toString('base64')\x2Cfunction(err){\n                if(!err){\n                  // Close the destination file\n                  fs.close(fileDescriptor\x2Cfunction(err){\n                    if(!err){\n                      callback(false);\n                    } else {\n                      callback(err);\n                    }\n                  });\n                } else {\n                  callback(err);\n                }\n              });\n            } else {\n              callback(err);\n            }\n          });\n        } else {\n          callback(err);\n        }\n      });\n\n    } else {\n      callback(err);\n    }\n  });\n};\n\n// Decompress the contents of a .gz file into a string variable\nlib.decompress = function(fileId\x2Ccallback){\n  var fileName = fileId+'.gz.b64';\n  fs.readFile(lib.baseDir+fileName\x2C 'utf8'\x2C function(err\x2Cstr){\n    if(!err && str){\n      // Inflate the data\n      var inputBuffer = Buffer.from(str\x2C 'base64');\n      zlib.unzip(inputBuffer\x2Cfunction(err\x2CoutputBuffer){\n        if(!err && outputBuffer){\n          // Callback\n          var str = outputBuffer.toString();\n          callback(false\x2Cstr);\n        } else {\n          callback(err);\n        }\n      });\n    } else {\n      callback(err);\n    }\n  });\n};\n\n// Truncate a log file\nlib.truncate = function(logId\x2Ccallback){\n  fs.truncate(lib.baseDir+logId+'.log'\x2C 0\x2C function(err){\n    if(!err){\n      callback(false);\n    } else {\n      callback(err);\n    }\n  });\n};\n\n// Export the module\nmodule.exports = lib;\n
code-source-info,0x1208b712126,196,0,3943,C0O0C4O3943,,
code-creation,Function,10,149167,0x1208b7126ee,118, /Users/vignesh/Projects/HTTP2/lib/logs.js:1:1,0x1208b7120a0,~
code-source-info,0x1208b7126ee,196,0,3943,C0O0C5O77C8O77C12O77C14O103C17O103C22O131C25O131C29O131C31O200C32O200C34O238C37O257C45O257C51O250C55O355C62O366C66O1096C73O1105C77O1824C84O1837C88O3149C95O3164C99O3714C106O3727C110O3921C112O3936C117O3942,,
code-creation,Eval,10,149584,0x1208b714366,5, node:zlib:1:1,0x1208b713c80,~
script-source,197,node:zlib,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayBuffer\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  MathMaxApply\x2C\n  NumberIsFinite\x2C\n  NumberIsNaN\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  TypedArrayPrototypeFill\x2C\n  Uint32Array\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_BROTLI_INVALID_PARAM\x2C\n    ERR_BUFFER_TOO_LARGE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_ZLIB_INITIALIZATION_FAILED\x2C\n  }\x2C\n  genericNodeError\x2C\n  hideStackFrames\x2C\n} = require('internal/errors');\nconst { Transform\x2C finished } = require('stream');\nconst {\n  deprecate\n} = require('internal/util');\nconst {\n  isArrayBufferView\x2C\n  isAnyArrayBuffer\x2C\n  isUint8Array\x2C\n} = require('internal/util/types');\nconst binding = internalBinding('zlib');\nconst assert = require('internal/assert');\nconst {\n  Buffer\x2C\n  kMaxLength\n} = require('buffer');\nconst { owner_symbol } = require('internal/async_hooks').symbols;\nconst {\n  validateFunction\x2C\n  validateNumber\x2C\n} = require('internal/validators');\n\nconst kFlushFlag = Symbol('kFlushFlag');\nconst kError = Symbol('kError');\n\nconst constants = internalBinding('constants').zlib;\nconst {\n  // Zlib flush levels\n  Z_NO_FLUSH\x2C Z_BLOCK\x2C Z_PARTIAL_FLUSH\x2C Z_SYNC_FLUSH\x2C Z_FULL_FLUSH\x2C Z_FINISH\x2C\n  // Zlib option values\n  Z_MIN_CHUNK\x2C Z_MIN_WINDOWBITS\x2C Z_MAX_WINDOWBITS\x2C Z_MIN_LEVEL\x2C Z_MAX_LEVEL\x2C\n  Z_MIN_MEMLEVEL\x2C Z_MAX_MEMLEVEL\x2C Z_DEFAULT_CHUNK\x2C Z_DEFAULT_COMPRESSION\x2C\n  Z_DEFAULT_STRATEGY\x2C Z_DEFAULT_WINDOWBITS\x2C Z_DEFAULT_MEMLEVEL\x2C Z_FIXED\x2C\n  // Node's compression stream modes (node_zlib_mode)\n  DEFLATE\x2C DEFLATERAW\x2C INFLATE\x2C INFLATERAW\x2C GZIP\x2C GUNZIP\x2C UNZIP\x2C\n  BROTLI_DECODE\x2C BROTLI_ENCODE\x2C\n  // Brotli operations (~flush levels)\n  BROTLI_OPERATION_PROCESS\x2C BROTLI_OPERATION_FLUSH\x2C\n  BROTLI_OPERATION_FINISH\x2C BROTLI_OPERATION_EMIT_METADATA\x2C\n} = constants;\n\n// Translation table for return codes.\nconst codes = {\n  Z_OK: constants.Z_OK\x2C\n  Z_STREAM_END: constants.Z_STREAM_END\x2C\n  Z_NEED_DICT: constants.Z_NEED_DICT\x2C\n  Z_ERRNO: constants.Z_ERRNO\x2C\n  Z_STREAM_ERROR: constants.Z_STREAM_ERROR\x2C\n  Z_DATA_ERROR: constants.Z_DATA_ERROR\x2C\n  Z_MEM_ERROR: constants.Z_MEM_ERROR\x2C\n  Z_BUF_ERROR: constants.Z_BUF_ERROR\x2C\n  Z_VERSION_ERROR: constants.Z_VERSION_ERROR\n};\n\nfor (const ckey of ObjectKeys(codes)) {\n  codes[codes[ckey]] = ckey;\n}\n\nfunction zlibBuffer(engine\x2C buffer\x2C callback) {\n  validateFunction(callback\x2C 'callback');\n  // Streams do not support non-Uint8Array ArrayBufferViews yet. Convert it to a\n  // Buffer without copying.\n  if (isArrayBufferView(buffer) && !isUint8Array(buffer)) {\n    buffer = Buffer.from(buffer.buffer\x2C buffer.byteOffset\x2C buffer.byteLength);\n  } else if (isAnyArrayBuffer(buffer)) {\n    buffer = Buffer.from(buffer);\n  }\n  engine.buffers = null;\n  engine.nread = 0;\n  engine.cb = callback;\n  engine.on('data'\x2C zlibBufferOnData);\n  engine.on('error'\x2C zlibBufferOnError);\n  engine.on('end'\x2C zlibBufferOnEnd);\n  engine.end(buffer);\n}\n\nfunction zlibBufferOnData(chunk) {\n  if (!this.buffers)\n    this.buffers = [chunk];\n  else\n    ArrayPrototypePush(this.buffers\x2C chunk);\n  this.nread += chunk.length;\n  if (this.nread > this._maxOutputLength) {\n    this.close();\n    this.removeAllListeners('end');\n    this.cb(new ERR_BUFFER_TOO_LARGE(this._maxOutputLength));\n  }\n}\n\nfunction zlibBufferOnError(err) {\n  this.removeAllListeners('end');\n  this.cb(err);\n}\n\nfunction zlibBufferOnEnd() {\n  let buf;\n  if (this.nread === 0) {\n    buf = Buffer.alloc(0);\n  } else {\n    const bufs = this.buffers;\n    buf = (bufs.length === 1 ? bufs[0] : Buffer.concat(bufs\x2C this.nread));\n  }\n  this.close();\n  if (this._info)\n    this.cb(null\x2C { buffer: buf\x2C engine: this });\n  else\n    this.cb(null\x2C buf);\n}\n\nfunction zlibBufferSync(engine\x2C buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  } else if (!isArrayBufferView(buffer)) {\n    if (isAnyArrayBuffer(buffer)) {\n      buffer = Buffer.from(buffer);\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(\n        'buffer'\x2C\n        ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView'\x2C 'ArrayBuffer']\x2C\n        buffer\n      );\n    }\n  }\n  buffer = processChunkSync(engine\x2C buffer\x2C engine._finishFlushFlag);\n  if (engine._info)\n    return { buffer\x2C engine };\n  return buffer;\n}\n\nfunction zlibOnError(message\x2C errno\x2C code) {\n  const self = this[owner_symbol];\n  // There is no way to cleanly recover.\n  // Continuing only obscures problems.\n\n  const error = genericNodeError(message\x2C { errno\x2C code });\n  error.errno = errno;\n  error.code = code;\n  self.destroy(error);\n  self[kError] = error;\n}\n\n// 1. Returns false for undefined and NaN\n// 2. Returns true for finite numbers\n// 3. Throws ERR_INVALID_ARG_TYPE for non-numbers\n// 4. Throws ERR_OUT_OF_RANGE for infinite numbers\nconst checkFiniteNumber = hideStackFrames((number\x2C name) => {\n  // Common case\n  if (number === undefined) {\n    return false;\n  }\n\n  if (NumberIsFinite(number)) {\n    return true; // Is a valid number\n  }\n\n  if (NumberIsNaN(number)) {\n    return false;\n  }\n\n  validateNumber(number\x2C name);\n\n  // Infinite numbers\n  throw new ERR_OUT_OF_RANGE(name\x2C 'a finite number'\x2C number);\n});\n\n// 1. Returns def for number when it's undefined or NaN\n// 2. Returns number for finite numbers >= lower and <= upper\n// 3. Throws ERR_INVALID_ARG_TYPE for non-numbers\n// 4. Throws ERR_OUT_OF_RANGE for infinite numbers or numbers > upper or < lower\nconst checkRangesOrGetDefault = hideStackFrames(\n  (number\x2C name\x2C lower\x2C upper\x2C def) => {\n    if (!checkFiniteNumber(number\x2C name)) {\n      return def;\n    }\n    if (number < lower || number > upper) {\n      throw new ERR_OUT_OF_RANGE(name\x2C\n                                 `>= ${lower} and <= ${upper}`\x2C number);\n    }\n    return number;\n  }\n);\n\nconst FLUSH_BOUND = [\n  [ Z_NO_FLUSH\x2C Z_BLOCK ]\x2C\n  [ BROTLI_OPERATION_PROCESS\x2C BROTLI_OPERATION_EMIT_METADATA ]\x2C\n];\nconst FLUSH_BOUND_IDX_NORMAL = 0;\nconst FLUSH_BOUND_IDX_BROTLI = 1;\n\n// The base class for all Zlib-style streams.\nfunction ZlibBase(opts\x2C mode\x2C handle\x2C { flush\x2C finishFlush\x2C fullFlush }) {\n  let chunkSize = Z_DEFAULT_CHUNK;\n  let maxOutputLength = kMaxLength;\n  // The ZlibBase class is not exported to user land\x2C the mode should only be\n  // passed in by us.\n  assert(typeof mode === 'number');\n  assert(mode >= DEFLATE && mode <= BROTLI_ENCODE);\n\n  let flushBoundIdx;\n  if (mode !== BROTLI_ENCODE && mode !== BROTLI_DECODE) {\n    flushBoundIdx = FLUSH_BOUND_IDX_NORMAL;\n  } else {\n    flushBoundIdx = FLUSH_BOUND_IDX_BROTLI;\n  }\n\n  if (opts) {\n    chunkSize = opts.chunkSize;\n    if (!checkFiniteNumber(chunkSize\x2C 'options.chunkSize')) {\n      chunkSize = Z_DEFAULT_CHUNK;\n    } else if (chunkSize < Z_MIN_CHUNK) {\n      throw new ERR_OUT_OF_RANGE('options.chunkSize'\x2C\n                                 `>= ${Z_MIN_CHUNK}`\x2C chunkSize);\n    }\n\n    flush = checkRangesOrGetDefault(\n      opts.flush\x2C 'options.flush'\x2C\n      FLUSH_BOUND[flushBoundIdx][0]\x2C FLUSH_BOUND[flushBoundIdx][1]\x2C flush);\n\n    finishFlush = checkRangesOrGetDefault(\n      opts.finishFlush\x2C 'options.finishFlush'\x2C\n      FLUSH_BOUND[flushBoundIdx][0]\x2C FLUSH_BOUND[flushBoundIdx][1]\x2C\n      finishFlush);\n\n    maxOutputLength = checkRangesOrGetDefault(\n      opts.maxOutputLength\x2C 'options.maxOutputLength'\x2C\n      1\x2C kMaxLength\x2C kMaxLength);\n\n    if (opts.encoding || opts.objectMode || opts.writableObjectMode) {\n      opts = { ...opts };\n      opts.encoding = null;\n      opts.objectMode = false;\n      opts.writableObjectMode = false;\n    }\n  }\n\n  ReflectApply(Transform\x2C this\x2C [{ autoDestroy: true\x2C ...opts }]);\n  this[kError] = null;\n  this.bytesWritten = 0;\n  this._handle = handle;\n  handle[owner_symbol] = this;\n  // Used by processCallback() and zlibOnError()\n  handle.onerror = zlibOnError;\n  this._outBuffer = Buffer.allocUnsafe(chunkSize);\n  this._outOffset = 0;\n\n  this._chunkSize = chunkSize;\n  this._defaultFlushFlag = flush;\n  this._finishFlushFlag = finishFlush;\n  this._defaultFullFlushFlag = fullFlush;\n  this._info = opts && opts.info;\n  this._maxOutputLength = maxOutputLength;\n}\nObjectSetPrototypeOf(ZlibBase.prototype\x2C Transform.prototype);\nObjectSetPrototypeOf(ZlibBase\x2C Transform);\n\nObjectDefineProperty(ZlibBase.prototype\x2C '_closed'\x2C {\n  configurable: true\x2C\n  enumerable: true\x2C\n  get() {\n    return !this._handle;\n  }\n});\n\n// `bytesRead` made sense as a name when looking from the zlib engine's\n// perspective\x2C but it is inconsistent with all other streams exposed by Node.js\n// that have this concept\x2C where it stands for the number of bytes read\n// *from* the stream (that is\x2C net.Socket/tls.Socket & file system streams).\nObjectDefineProperty(ZlibBase.prototype\x2C 'bytesRead'\x2C {\n  configurable: true\x2C\n  enumerable: true\x2C\n  get: deprecate(function() {\n    return this.bytesWritten;\n  }\x2C 'zlib.bytesRead is deprecated and will change its meaning in the ' +\n     'future. Use zlib.bytesWritten instead.'\x2C 'DEP0108')\x2C\n  set: deprecate(function(value) {\n    this.bytesWritten = value;\n  }\x2C 'Setting zlib.bytesRead is deprecated. ' +\n     'This feature will be removed in the future.'\x2C 'DEP0108')\n});\n\nZlibBase.prototype.reset = function() {\n  if (!this._handle)\n    assert(false\x2C 'zlib binding closed');\n  return this._handle.reset();\n};\n\n// This is the _flush function called by the transform class\x2C\n// internally\x2C when the last chunk has been written.\nZlibBase.prototype._flush = function(callback) {\n  this._transform(Buffer.alloc(0)\x2C ''\x2C callback);\n};\n\n// Force Transform compat behavior.\nZlibBase.prototype._final = function(callback) {\n  callback();\n};\n\n// If a flush is scheduled while another flush is still pending\x2C a way to figure\n// out which one is the "stronger" flush is needed.\n// This is currently only used to figure out which flush flag to use for the\n// last chunk.\n// Roughly\x2C the following holds:\n// Z_NO_FLUSH (< Z_TREES) < Z_BLOCK < Z_PARTIAL_FLUSH <\n//     Z_SYNC_FLUSH < Z_FULL_FLUSH < Z_FINISH\nconst flushiness = [];\nlet i = 0;\nconst kFlushFlagList = [Z_NO_FLUSH\x2C Z_BLOCK\x2C Z_PARTIAL_FLUSH\x2C\n                        Z_SYNC_FLUSH\x2C Z_FULL_FLUSH\x2C Z_FINISH];\nfor (const flushFlag of kFlushFlagList) {\n  flushiness[flushFlag] = i++;\n}\n\nfunction maxFlush(a\x2C b) {\n  return flushiness[a] > flushiness[b] ? a : b;\n}\n\n// Set up a list of 'special' buffers that can be written using .write()\n// from the .flush() code as a way of introducing flushing operations into the\n// write sequence.\nconst kFlushBuffers = [];\n{\n  const dummyArrayBuffer = new ArrayBuffer();\n  for (const flushFlag of kFlushFlagList) {\n    kFlushBuffers[flushFlag] = Buffer.from(dummyArrayBuffer);\n    kFlushBuffers[flushFlag][kFlushFlag] = flushFlag;\n  }\n}\n\nZlibBase.prototype.flush = function(kind\x2C callback) {\n  if (typeof kind === 'function' || (kind === undefined && !callback)) {\n    callback = kind;\n    kind = this._defaultFullFlushFlag;\n  }\n\n  if (this.writableFinished) {\n    if (callback)\n      process.nextTick(callback);\n  } else if (this.writableEnded) {\n    if (callback)\n      this.once('end'\x2C callback);\n  } else {\n    this.write(kFlushBuffers[kind]\x2C ''\x2C callback);\n  }\n};\n\nZlibBase.prototype.close = function(callback) {\n  if (callback) finished(this\x2C callback);\n  this.destroy();\n};\n\nZlibBase.prototype._destroy = function(err\x2C callback) {\n  _close(this);\n  callback(err);\n};\n\nZlibBase.prototype._transform = function(chunk\x2C encoding\x2C cb) {\n  let flushFlag = this._defaultFlushFlag;\n  // We use a 'fake' zero-length chunk to carry information about flushes from\n  // the public API to the actual stream implementation.\n  if (typeof chunk[kFlushFlag] === 'number') {\n    flushFlag = chunk[kFlushFlag];\n  }\n\n  // For the last chunk\x2C also apply `_finishFlushFlag`.\n  if (this.writableEnded && this.writableLength === chunk.byteLength) {\n    flushFlag = maxFlush(flushFlag\x2C this._finishFlushFlag);\n  }\n  processChunk(this\x2C chunk\x2C flushFlag\x2C cb);\n};\n\nZlibBase.prototype._processChunk = function(chunk\x2C flushFlag\x2C cb) {\n  // _processChunk() is left for backwards compatibility\n  if (typeof cb === 'function')\n    processChunk(this\x2C chunk\x2C flushFlag\x2C cb);\n  else\n    return processChunkSync(this\x2C chunk\x2C flushFlag);\n};\n\nfunction processChunkSync(self\x2C chunk\x2C flushFlag) {\n  let availInBefore = chunk.byteLength;\n  let availOutBefore = self._chunkSize - self._outOffset;\n  let inOff = 0;\n  let availOutAfter;\n  let availInAfter;\n\n  let buffers = null;\n  let nread = 0;\n  let inputRead = 0;\n  const state = self._writeState;\n  const handle = self._handle;\n  let buffer = self._outBuffer;\n  let offset = self._outOffset;\n  const chunkSize = self._chunkSize;\n\n  let error;\n  self.on('error'\x2C function onError(er) {\n    error = er;\n  });\n\n  while (true) {\n    handle.writeSync(flushFlag\x2C\n                     chunk\x2C // in\n                     inOff\x2C // in_off\n                     availInBefore\x2C // in_len\n                     buffer\x2C // out\n                     offset\x2C // out_off\n                     availOutBefore); // out_len\n    if (error)\n      throw error;\n    else if (self[kError])\n      throw self[kError];\n\n    availOutAfter = state[0];\n    availInAfter = state[1];\n\n    const inDelta = (availInBefore - availInAfter);\n    inputRead += inDelta;\n\n    const have = availOutBefore - availOutAfter;\n    if (have > 0) {\n      const out = buffer.slice(offset\x2C offset + have);\n      offset += have;\n      if (!buffers)\n        buffers = [out];\n      else\n        ArrayPrototypePush(buffers\x2C out);\n      nread += out.byteLength;\n\n      if (nread > self._maxOutputLength) {\n        _close(self);\n        throw new ERR_BUFFER_TOO_LARGE(self._maxOutputLength);\n      }\n\n    } else {\n      assert(have === 0\x2C 'have should not go down');\n    }\n\n    // Exhausted the output buffer\x2C or used all the input create a new one.\n    if (availOutAfter === 0 || offset >= chunkSize) {\n      availOutBefore = chunkSize;\n      offset = 0;\n      buffer = Buffer.allocUnsafe(chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done. Need to reprocess.\n      // Also\x2C update the availInBefore to the availInAfter value\x2C\n      // so that if we have to hit it a third (fourth\x2C etc.) time\x2C\n      // it'll have the correct byte counts.\n      inOff += inDelta;\n      availInBefore = availInAfter;\n    } else {\n      break;\n    }\n  }\n\n  self.bytesWritten = inputRead;\n  _close(self);\n\n  if (nread === 0)\n    return Buffer.alloc(0);\n\n  return (buffers.length === 1 ? buffers[0] : Buffer.concat(buffers\x2C nread));\n}\n\nfunction processChunk(self\x2C chunk\x2C flushFlag\x2C cb) {\n  const handle = self._handle;\n  if (!handle) return process.nextTick(cb);\n\n  handle.buffer = chunk;\n  handle.cb = cb;\n  handle.availOutBefore = self._chunkSize - self._outOffset;\n  handle.availInBefore = chunk.byteLength;\n  handle.inOff = 0;\n  handle.flushFlag = flushFlag;\n\n  handle.write(flushFlag\x2C\n               chunk\x2C // in\n               0\x2C // in_off\n               handle.availInBefore\x2C // in_len\n               self._outBuffer\x2C // out\n               self._outOffset\x2C // out_off\n               handle.availOutBefore); // out_len\n}\n\nfunction processCallback() {\n  // This callback's context (`this`) is the `_handle` (ZCtx) object. It is\n  // important to null out the values once they are no longer needed since\n  // `_handle` can stay in memory long after the buffer is needed.\n  const handle = this;\n  const self = this[owner_symbol];\n  const state = self._writeState;\n\n  if (self.destroyed) {\n    this.buffer = null;\n    this.cb();\n    return;\n  }\n\n  const availOutAfter = state[0];\n  const availInAfter = state[1];\n\n  const inDelta = handle.availInBefore - availInAfter;\n  self.bytesWritten += inDelta;\n\n  const have = handle.availOutBefore - availOutAfter;\n  if (have > 0) {\n    const out = self._outBuffer.slice(self._outOffset\x2C self._outOffset + have);\n    self._outOffset += have;\n    self.push(out);\n  } else {\n    assert(have === 0\x2C 'have should not go down');\n  }\n\n  if (self.destroyed) {\n    this.cb();\n    return;\n  }\n\n  // Exhausted the output buffer\x2C or used all the input create a new one.\n  if (availOutAfter === 0 || self._outOffset >= self._chunkSize) {\n    handle.availOutBefore = self._chunkSize;\n    self._outOffset = 0;\n    self._outBuffer = Buffer.allocUnsafe(self._chunkSize);\n  }\n\n  if (availOutAfter === 0) {\n    // Not actually done. Need to reprocess.\n    // Also\x2C update the availInBefore to the availInAfter value\x2C\n    // so that if we have to hit it a third (fourth\x2C etc.) time\x2C\n    // it'll have the correct byte counts.\n    handle.inOff += inDelta;\n    handle.availInBefore = availInAfter;\n\n    this.write(handle.flushFlag\x2C\n               this.buffer\x2C // in\n               handle.inOff\x2C // in_off\n               handle.availInBefore\x2C // in_len\n               self._outBuffer\x2C // out\n               self._outOffset\x2C // out_off\n               self._chunkSize); // out_len\n    return;\n  }\n\n  if (availInAfter > 0) {\n    // If we have more input that should be written\x2C but we also have output\n    // space available\x2C that means that the compression library was not\n    // interested in receiving more data\x2C and in particular that the input\n    // stream has ended early.\n    // This applies to streams where we don't check data past the end of\n    // what was consumed; that is\x2C everything except Gunzip/Unzip.\n    self.push(null);\n  }\n\n  // Finished with the chunk.\n  this.buffer = null;\n  this.cb();\n}\n\nfunction _close(engine) {\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle)\n    return;\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nconst zlibDefaultOpts = {\n  flush: Z_NO_FLUSH\x2C\n  finishFlush: Z_FINISH\x2C\n  fullFlush: Z_FULL_FLUSH\n};\n// Base class for all streams actually backed by zlib and using zlib-specific\n// parameters.\nfunction Zlib(opts\x2C mode) {\n  let windowBits = Z_DEFAULT_WINDOWBITS;\n  let level = Z_DEFAULT_COMPRESSION;\n  let memLevel = Z_DEFAULT_MEMLEVEL;\n  let strategy = Z_DEFAULT_STRATEGY;\n  let dictionary;\n\n  if (opts) {\n    // windowBits is special. On the compression side\x2C 0 is an invalid value.\n    // But on the decompression side\x2C a value of 0 for windowBits tells zlib\n    // to use the window size in the zlib header of the compressed stream.\n    if ((opts.windowBits == null || opts.windowBits === 0) &&\n        (mode === INFLATE ||\n         mode === GUNZIP ||\n         mode === UNZIP)) {\n      windowBits = 0;\n    } else {\n      // `{ windowBits: 8 }` is valid for deflate but not gzip.\n      const min = Z_MIN_WINDOWBITS + (mode === GZIP ? 1 : 0);\n      windowBits = checkRangesOrGetDefault(\n        opts.windowBits\x2C 'options.windowBits'\x2C\n        min\x2C Z_MAX_WINDOWBITS\x2C Z_DEFAULT_WINDOWBITS);\n    }\n\n    level = checkRangesOrGetDefault(\n      opts.level\x2C 'options.level'\x2C\n      Z_MIN_LEVEL\x2C Z_MAX_LEVEL\x2C Z_DEFAULT_COMPRESSION);\n\n    memLevel = checkRangesOrGetDefault(\n      opts.memLevel\x2C 'options.memLevel'\x2C\n      Z_MIN_MEMLEVEL\x2C Z_MAX_MEMLEVEL\x2C Z_DEFAULT_MEMLEVEL);\n\n    strategy = checkRangesOrGetDefault(\n      opts.strategy\x2C 'options.strategy'\x2C\n      Z_DEFAULT_STRATEGY\x2C Z_FIXED\x2C Z_DEFAULT_STRATEGY);\n\n    dictionary = opts.dictionary;\n    if (dictionary !== undefined && !isArrayBufferView(dictionary)) {\n      if (isAnyArrayBuffer(dictionary)) {\n        dictionary = Buffer.from(dictionary);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(\n          'options.dictionary'\x2C\n          ['Buffer'\x2C 'TypedArray'\x2C 'DataView'\x2C 'ArrayBuffer']\x2C\n          dictionary\n        );\n      }\n    }\n  }\n\n  const handle = new binding.Zlib(mode);\n  // Ideally\x2C we could let ZlibBase() set up _writeState. I haven't been able\n  // to come up with a good solution that doesn't break our internal API\x2C\n  // and with it all supported npm versions at the time of writing.\n  this._writeState = new Uint32Array(2);\n  handle.init(windowBits\x2C\n              level\x2C\n              memLevel\x2C\n              strategy\x2C\n              this._writeState\x2C\n              processCallback\x2C\n              dictionary);\n\n  ReflectApply(ZlibBase\x2C this\x2C [opts\x2C mode\x2C handle\x2C zlibDefaultOpts]);\n\n  this._level = level;\n  this._strategy = strategy;\n}\nObjectSetPrototypeOf(Zlib.prototype\x2C ZlibBase.prototype);\nObjectSetPrototypeOf(Zlib\x2C ZlibBase);\n\n// This callback is used by `.params()` to wait until a full flush happened\n// before adjusting the parameters. In particular\x2C the call to the native\n// `params()` function should not happen while a write is currently in progress\n// on the threadpool.\nfunction paramsAfterFlushCallback(level\x2C strategy\x2C callback) {\n  assert(this._handle\x2C 'zlib binding closed');\n  this._handle.params(level\x2C strategy);\n  if (!this.destroyed) {\n    this._level = level;\n    this._strategy = strategy;\n    if (callback) callback();\n  }\n}\n\nZlib.prototype.params = function params(level\x2C strategy\x2C callback) {\n  checkRangesOrGetDefault(level\x2C 'level'\x2C Z_MIN_LEVEL\x2C Z_MAX_LEVEL);\n  checkRangesOrGetDefault(strategy\x2C 'strategy'\x2C Z_DEFAULT_STRATEGY\x2C Z_FIXED);\n\n  if (this._level !== level || this._strategy !== strategy) {\n    this.flush(Z_SYNC_FLUSH\x2C\n               FunctionPrototypeBind(paramsAfterFlushCallback\x2C this\x2C\n                                     level\x2C strategy\x2C callback));\n  } else {\n    process.nextTick(callback);\n  }\n};\n\n// generic zlib\n// minimal 2-byte header\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate))\n    return new Deflate(opts);\n  ReflectApply(Zlib\x2C this\x2C [opts\x2C DEFLATE]);\n}\nObjectSetPrototypeOf(Deflate.prototype\x2C Zlib.prototype);\nObjectSetPrototypeOf(Deflate\x2C Zlib);\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate))\n    return new Inflate(opts);\n  ReflectApply(Zlib\x2C this\x2C [opts\x2C INFLATE]);\n}\nObjectSetPrototypeOf(Inflate.prototype\x2C Zlib.prototype);\nObjectSetPrototypeOf(Inflate\x2C Zlib);\n\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip))\n    return new Gzip(opts);\n  ReflectApply(Zlib\x2C this\x2C [opts\x2C GZIP]);\n}\nObjectSetPrototypeOf(Gzip.prototype\x2C Zlib.prototype);\nObjectSetPrototypeOf(Gzip\x2C Zlib);\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip))\n    return new Gunzip(opts);\n  ReflectApply(Zlib\x2C this\x2C [opts\x2C GUNZIP]);\n}\nObjectSetPrototypeOf(Gunzip.prototype\x2C Zlib.prototype);\nObjectSetPrototypeOf(Gunzip\x2C Zlib);\n\nfunction DeflateRaw(opts) {\n  if (opts && opts.windowBits === 8) opts.windowBits = 9;\n  if (!(this instanceof DeflateRaw))\n    return new DeflateRaw(opts);\n  ReflectApply(Zlib\x2C this\x2C [opts\x2C DEFLATERAW]);\n}\nObjectSetPrototypeOf(DeflateRaw.prototype\x2C Zlib.prototype);\nObjectSetPrototypeOf(DeflateRaw\x2C Zlib);\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw))\n    return new InflateRaw(opts);\n  ReflectApply(Zlib\x2C this\x2C [opts\x2C INFLATERAW]);\n}\nObjectSetPrototypeOf(InflateRaw.prototype\x2C Zlib.prototype);\nObjectSetPrototypeOf(InflateRaw\x2C Zlib);\n\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip))\n    return new Unzip(opts);\n  ReflectApply(Zlib\x2C this\x2C [opts\x2C UNZIP]);\n}\nObjectSetPrototypeOf(Unzip.prototype\x2C Zlib.prototype);\nObjectSetPrototypeOf(Unzip\x2C Zlib);\n\nfunction createConvenienceMethod(ctor\x2C sync) {\n  if (sync) {\n    return function syncBufferWrapper(buffer\x2C opts) {\n      return zlibBufferSync(new ctor(opts)\x2C buffer);\n    };\n  }\n  return function asyncBufferWrapper(buffer\x2C opts\x2C callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    return zlibBuffer(new ctor(opts)\x2C buffer\x2C callback);\n  };\n}\n\nconst kMaxBrotliParam = MathMaxApply(ArrayPrototypeMap(\n  ObjectKeys(constants)\x2C\n  (key) => (StringPrototypeStartsWith(key\x2C 'BROTLI_PARAM_') ?\n    constants[key] :\n    0)\n));\n\nconst brotliInitParamsArray = new Uint32Array(kMaxBrotliParam + 1);\n\nconst brotliDefaultOpts = {\n  flush: BROTLI_OPERATION_PROCESS\x2C\n  finishFlush: BROTLI_OPERATION_FINISH\x2C\n  fullFlush: BROTLI_OPERATION_FLUSH\n};\nfunction Brotli(opts\x2C mode) {\n  assert(mode === BROTLI_DECODE || mode === BROTLI_ENCODE);\n\n  TypedArrayPrototypeFill(brotliInitParamsArray\x2C -1);\n  if (opts?.params) {\n    ArrayPrototypeForEach(ObjectKeys(opts.params)\x2C (origKey) => {\n      const key = +origKey;\n      if (NumberIsNaN(key) || key < 0 || key > kMaxBrotliParam ||\n          (brotliInitParamsArray[key] | 0) !== -1) {\n        throw new ERR_BROTLI_INVALID_PARAM(origKey);\n      }\n\n      const value = opts.params[origKey];\n      if (typeof value !== 'number' && typeof value !== 'boolean') {\n        throw new ERR_INVALID_ARG_TYPE('options.params[key]'\x2C\n                                       'number'\x2C opts.params[origKey]);\n      }\n      brotliInitParamsArray[key] = value;\n    });\n  }\n\n  const handle = mode === BROTLI_DECODE ?\n    new binding.BrotliDecoder(mode) : new binding.BrotliEncoder(mode);\n\n  this._writeState = new Uint32Array(2);\n  // TODO(addaleax): Sometimes we generate better error codes in C++ land\x2C\n  // e.g. ERR_BROTLI_PARAM_SET_FAILED -- it's hard to access them with\n  // the current bindings setup\x2C though.\n  if (!handle.init(brotliInitParamsArray\x2C\n                   this._writeState\x2C\n                   processCallback)) {\n    throw new ERR_ZLIB_INITIALIZATION_FAILED();\n  }\n\n  ReflectApply(ZlibBase\x2C this\x2C [opts\x2C mode\x2C handle\x2C brotliDefaultOpts]);\n}\nObjectSetPrototypeOf(Brotli.prototype\x2C Zlib.prototype);\nObjectSetPrototypeOf(Brotli\x2C Zlib);\n\nfunction BrotliCompress(opts) {\n  if (!(this instanceof BrotliCompress))\n    return new BrotliCompress(opts);\n  ReflectApply(Brotli\x2C this\x2C [opts\x2C BROTLI_ENCODE]);\n}\nObjectSetPrototypeOf(BrotliCompress.prototype\x2C Brotli.prototype);\nObjectSetPrototypeOf(BrotliCompress\x2C Brotli);\n\nfunction BrotliDecompress(opts) {\n  if (!(this instanceof BrotliDecompress))\n    return new BrotliDecompress(opts);\n  ReflectApply(Brotli\x2C this\x2C [opts\x2C BROTLI_DECODE]);\n}\nObjectSetPrototypeOf(BrotliDecompress.prototype\x2C Brotli.prototype);\nObjectSetPrototypeOf(BrotliDecompress\x2C Brotli);\n\n\nfunction createProperty(ctor) {\n  return {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: function(options) {\n      return new ctor(options);\n    }\n  };\n}\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(binding.Zlib.prototype\x2C 'jsref'\x2C {\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\n});\n\nmodule.exports = {\n  Deflate\x2C\n  Inflate\x2C\n  Gzip\x2C\n  Gunzip\x2C\n  DeflateRaw\x2C\n  InflateRaw\x2C\n  Unzip\x2C\n  BrotliCompress\x2C\n  BrotliDecompress\x2C\n\n  // Convenience methods.\n  // compress/decompress a string or buffer in one step.\n  deflate: createConvenienceMethod(Deflate\x2C false)\x2C\n  deflateSync: createConvenienceMethod(Deflate\x2C true)\x2C\n  gzip: createConvenienceMethod(Gzip\x2C false)\x2C\n  gzipSync: createConvenienceMethod(Gzip\x2C true)\x2C\n  deflateRaw: createConvenienceMethod(DeflateRaw\x2C false)\x2C\n  deflateRawSync: createConvenienceMethod(DeflateRaw\x2C true)\x2C\n  unzip: createConvenienceMethod(Unzip\x2C false)\x2C\n  unzipSync: createConvenienceMethod(Unzip\x2C true)\x2C\n  inflate: createConvenienceMethod(Inflate\x2C false)\x2C\n  inflateSync: createConvenienceMethod(Inflate\x2C true)\x2C\n  gunzip: createConvenienceMethod(Gunzip\x2C false)\x2C\n  gunzipSync: createConvenienceMethod(Gunzip\x2C true)\x2C\n  inflateRaw: createConvenienceMethod(InflateRaw\x2C false)\x2C\n  inflateRawSync: createConvenienceMethod(InflateRaw\x2C true)\x2C\n  brotliCompress: createConvenienceMethod(BrotliCompress\x2C false)\x2C\n  brotliCompressSync: createConvenienceMethod(BrotliCompress\x2C true)\x2C\n  brotliDecompress: createConvenienceMethod(BrotliDecompress\x2C false)\x2C\n  brotliDecompressSync: createConvenienceMethod(BrotliDecompress\x2C true)\x2C\n};\n\nObjectDefineProperties(module.exports\x2C {\n  createDeflate: createProperty(Deflate)\x2C\n  createInflate: createProperty(Inflate)\x2C\n  createDeflateRaw: createProperty(DeflateRaw)\x2C\n  createInflateRaw: createProperty(InflateRaw)\x2C\n  createGzip: createProperty(Gzip)\x2C\n  createGunzip: createProperty(Gunzip)\x2C\n  createUnzip: createProperty(Unzip)\x2C\n  createBrotliCompress: createProperty(BrotliCompress)\x2C\n  createBrotliDecompress: createProperty(BrotliDecompress)\x2C\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  codes: {\n    enumerable: true\x2C\n    writable: false\x2C\n    value: ObjectFreeze(codes)\n  }\n});\n\n// These should be considered deprecated\n// expose all the zlib constants\nfor (const bkey of ObjectKeys(constants)) {\n  if (StringPrototypeStartsWith(bkey\x2C 'BROTLI')) continue;\n  ObjectDefineProperty(module.exports\x2C bkey\x2C {\n    enumerable: false\x2C value: constants[bkey]\x2C writable: false\n  });\n}\n
code-source-info,0x1208b714366,197,0,29376,C0O0C4O29376,,
code-creation,Function,10,150667,0x1208b716176,4132, node:zlib:1:1,0x1208b7142e0,~
code-source-info,0x1208b716176,197,0,29376,C0O0C360O1159C365O1174C371O1199C376O1220C382O1242C388O1267C393O1283C399O1301C405O1316C410O1342C415O1366C420O1382C426O1396C431O1420C437O1436C443O1465C448O1475C454O1502C460O1740C464O1740C470O1740C476O1556C482O1586C488O1612C494O1638C500O1660C506O1699C512O1719C517O1800C521O1800C527O1776C533O1787C539O1843C543O1843C549O1829C554O1938C558O1938C564O1879C570O1900C576O1920C582O1986C586O1986C590O1986C592O2026C596O2026C600O2026C602O2089C606O2089C612O2064C618O2074C624O2133C628O2133C634O2164C640O2116C646O2224C650O2224C656O2184C662O2204C668O2276C672O2276C676O2276C678O2313C682O2313C686O2313C688O2350C692O2350C698O2378C702O2350C704O3047C708O2418C713O2430C718O2439C723O2456C729O2470C734O2484C739O2520C745O2533C751O2551C757O2569C763O2582C769O2597C775O2613C781O2629C787O2646C793O2671C799O2691C805O2713C811O2733C817O2798C823O2807C829O2819C835O2828C841O2840C847O2846C853O2854C859O2863C865O2878C871O2934C876O2960C882O2986C888O3011C894O3112C904O3132C916O3164C928O3203C940O3237C952O3274C964O3316C976O3355C988O3393C1000O3435C1011O3474C1015O3474C1049O3466C1080O3466C1083O3497C1085O3508C1092O3516C1099O3455C1170O5973C1176O5973C1180O5973C1182O6610C1188O6610C1192O6610C1194O6945C1214O6951C1224O6963C1249O6978C1259O7004C1271O6945C1273O7072C1274O7072C1276O7106C1278O7106C1280O9209C1284O9239C1294O9260C1300O9209C1305O9272C1313O9272C1318O9316C1322O9346C1338O9414C1346O9316C1351O9759C1355O9789C1371O9864C1383O9989C1392O9864C1401O10057C1413O10162C1425O10057C1443O9759C1453O10232C1457O10241C1467O10257C1475O10485C1479O10494C1489O10511C1497O10624C1501O10633C1511O10650C1519O11070C1523O11070C1525O11082C1528O11108C1542O11109C1556O11121C1570O11130C1584O11171C1598O11185C1612O11199C1623O11234C1659O11221C1702O11221C1705O11254C1711O11265C1725O11276C1736O11210C1815O11556C1819O11556C1821O11589C1823O11589C1835O11634C1871O11621C1914O11621C1917O11656C1925O11690C1935O11690C1945O11681C1953O11718C1959O11731C1973O11755C1984O11610C2063O11775C2067O11784C2077O11800C2085O12207C2089O12216C2099O12232C2107O12319C2111O12328C2121O12347C2129O12412C2133O12421C2143O12442C2151O12981C2155O12990C2165O13014C2173O18647C2184O18658C2194O18685C2204O18708C2214O18647C2216O21135C2220O21161C2234O21181C2240O21135C2250O21193C2258O21193C2268O21752C2272O21757C2286O21774C2294O22423C2298O22452C2312O22468C2322O22423C2332O22480C2340O22480C2350O22654C2354O22683C2368O22699C2378O22654C2388O22711C2396O22711C2406O22873C2410O22899C2424O22915C2434O22873C2444O22927C2452O22927C2462O23094C2466O23122C2480O23138C2490O23094C2500O23150C2508O23150C2518O23393C2522O23425C2536O23441C2546O23393C2556O23453C2564O23453C2574O23642C2578O23674C2592O23690C2602O23642C2612O23702C2620O23702C2630O23871C2634O23898C2648O23914C2658O23871C2668O23926C2676O23926C2686O24377C2694O24411C2710O24390C2722O24377C2730O24377C2732O24559C2738O24591C2748O24559C2758O24559C2760O24624C2771O24635C2781O24676C2791O24714C2801O24624C2803O26078C2807O26106C2821O26122C2831O26078C2841O26134C2849O26134C2859O26336C2863O26372C2877O26390C2887O26336C2897O26402C2905O26402C2915O26620C2919O26658C2933O26676C2943O26620C2953O26688C2961O26688C2971O27054C2975O27083C2985O27088C3008O27112C3020O27152C3032O27054C3042O27199C3053O27220C3063O27231C3073O27242C3083O27250C3093O27260C3103O27274C3113O27288C3123O27297C3133O27315C3148O27428C3173O27484C3198O27532C3223O27582C3248O27633C3273O27695C3298O27747C3323O27799C3348O27848C3373O27904C3398O27954C3423O28008C3448O28061C3473O28123C3498O28184C3523O28254C3548O28321C3573O28395C3593O27214C3601O28478C3624O28506C3644O28548C3664O28593C3684O28641C3704O28683C3724O28721C3744O28760C3764O28807C3784O28865C3800O28912C3811O28972C3829O28996C3838O29052C3864O28448C3874O29174C3882O29174C3928O29166C3971O29166C3974O29201C3982O29205C3997O29248C3999O29288C4009O29297C4024O29344C4041O29260C4051O29155C4131O29375,,
tick,0x1bfcb1688,150792,1,0x10041f4d8,3,0x0,0x105108c5c,0x105115cac,0x105112d34,0x1051186b8,0x1051128a8,0x105113c1c,0x1208b712707,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x105118954,0x1051128a8,0x105113c1c,0x1208b7104fb,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x105118954,0x1051128a8,0x105113c1c,0x2cbd764a6e97,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,150959,0x1208b71b5c6,135,fromArrayBuffer node:buffer:449:25,0x232faba32128,~
code-source-info,0x1208b71b5c6,24,12951,13624,C0O13016C4O13052C9O13083C11O13096C15O13113C20O13117C26O13148C29O13193C36O13204C40O13221C41O13235C46O13244C56O13250C61O13244C62O13293C66O13325C73O13407C75O13416C79O13429C80O13440C85O13453C87O13464C92O13485C102O13491C107O13485C110O13550C113O13575C129O13582C134O13622,,
code-creation,LazyCompile,10,151000,0x1208b71b90e,29, node:zlib:804:3,0x1208b715278,~
code-source-info,0x1208b71b90e,197,24436,24523,C0O24446C8O24446C17O24500C22O24509C28O24523,,
code-creation,LazyCompile,10,151084,0x1208b71d95e,23,createConvenienceMethod node:zlib:787:33,0x1208b714a58,~
code-source-info,0x1208b71d95e,197,23994,24351,C0O23994C9O24011C13O24027C17O24136C18O24143C22O24349,,
code-creation,LazyCompile,10,151084,0x1208b71db8e,25,createProperty node:zlib:872:24,0x1208b714bc8,~
code-source-info,0x1208b71db8e,197,26761,26902,C0O26761C9O26772C14O26838C24O26900,,
tick,0x100c8a1d4,151209,0,0x0,0,0x105115e88,0x105112d34,0x1051186b8,0x1051128a8,0x105113c1c,0x1208b712707,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x105118954,0x1051128a8,0x105113c1c,0x1208b7104fb,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x105118954,0x1051128a8,0x105113c1c,0x2cbd764a6e97,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,151459,0x1208b71ef16,5, /Users/vignesh/Projects/HTTP2/lib/cli.js:1:1,0x1208b71ed18,~
script-source,198,/Users/vignesh/Projects/HTTP2/lib/cli.js,/*\n * CLI-related tasks\n *\n */\n\n // Dependencies\nvar readline = require('readline');\nvar util = require('util');\nvar debug = util.debuglog('cli');\nvar events = require('events');\nclass _events extends events{};\nvar e = new _events();\nvar os = require('os');\nvar v8 = require('v8');\nvar _data = require('./data');\nvar _logs = require('./logs');\nvar helpers = require('./helpers');\nvar childProcess = require('child_process');\n\n// Instantiate the cli module object\nvar cli = {};\n\n// Input handlers\ne.on('man'\x2Cfunction(str){\n  cli.responders.help();\n});\n\ne.on('help'\x2Cfunction(str){\n  cli.responders.help();\n});\n\ne.on('exit'\x2Cfunction(str){\n  cli.responders.exit();\n});\n\ne.on('stats'\x2Cfunction(str){\n  cli.responders.stats();\n});\n\ne.on('list users'\x2Cfunction(str){\n  cli.responders.listUsers();\n});\n\ne.on('more user info'\x2Cfunction(str){\n  cli.responders.moreUserInfo(str);\n});\n\ne.on('list checks'\x2Cfunction(str){\n  cli.responders.listChecks(str);\n});\n\ne.on('more check info'\x2Cfunction(str){\n  cli.responders.moreCheckInfo(str);\n});\n\ne.on('list logs'\x2Cfunction(str){\n  cli.responders.listLogs();\n});\n\ne.on('more log info'\x2Cfunction(str){\n  cli.responders.moreLogInfo(str);\n});\n\n\n// Responders object\ncli.responders = {};\n\n// Help / Man\ncli.responders.help = function(){\n\n  // Codify the commands and their explanations\n  var commands = {\n    'exit' : 'Kill the CLI (and the rest of the application)'\x2C\n    'man' : 'Show this help page'\x2C\n    'help' : 'Alias of the "man" command'\x2C\n    'stats' : 'Get statistics on the underlying operating system and resource utilization'\x2C\n    'List users' : 'Show a list of all the registered (undeleted) users in the system'\x2C\n    'More user info --{userId}' : 'Show details of a specified user'\x2C\n    'List checks --up --down' : 'Show a list of all the active checks in the system\x2C including their state. The "--up" and "--down flags are both optional."'\x2C\n    'More check info --{checkId}' : 'Show details of a specified check'\x2C\n    'List logs' : 'Show a list of all the log files available to be read (compressed and uncompressed)'\x2C\n    'More log info --{logFileName}' : 'Show details of a specified log file'\x2C\n  };\n\n  // Show a header for the help page that is as wide as the screen\n  cli.horizontalLine();\n  cli.centered('CLI MANUAL');\n  cli.horizontalLine();\n  cli.verticalSpace(2);\n\n  // Show each command\x2C followed by its explanation\x2C in white and yellow respectively\n  for(var key in commands){\n     if(commands.hasOwnProperty(key)){\n        var value = commands[key];\n        var line = '      \\x1b[33m '+key+'      \\x1b[0m';\n        var padding = 60 - line.length;\n        for (i = 0; i < padding; i++) {\n            line+=' ';\n        }\n        line+=value;\n        console.log(line);\n        cli.verticalSpace();\n     }\n  }\n  cli.verticalSpace(1);\n\n  // End with another horizontal line\n  cli.horizontalLine();\n\n};\n\n// Create a vertical space\ncli.verticalSpace = function(lines){\n  lines = typeof(lines) == 'number' && lines > 0 ? lines : 1;\n  for (i = 0; i < lines; i++) {\n      console.log('');\n  }\n};\n\n// Create a horizontal line across the screen\ncli.horizontalLine = function(){\n\n  // Get the available screen size\n  var width = process.stdout.columns;\n\n  // Put in enough dashes to go across the screen\n  var line = '';\n  for (i = 0; i < width; i++) {\n      line+='-';\n  }\n  console.log(line);\n\n\n};\n\n// Create centered text on the screen\ncli.centered = function(str){\n  str = typeof(str) == 'string' && str.trim().length > 0 ? str.trim() : '';\n\n  // Get the available screen size\n  var width = process.stdout.columns;\n\n  // Calculate the left padding there should be\n  var leftPadding = Math.floor((width - str.length) / 2);\n\n  // Put in left padded spaces before the string itself\n  var line = '';\n  for (i = 0; i < leftPadding; i++) {\n      line+=' ';\n  }\n  line+= str;\n  console.log(line);\n};\n\n// Exit\ncli.responders.exit = function(){\n  process.exit(0);\n};\n\n// Stats\ncli.responders.stats = function(){\n  // Compile an object of stats\n  var stats = {\n    'Load Average' : os.loadavg().join(' ')\x2C\n    'CPU Count' : os.cpus().length\x2C\n    'Free Memory' : os.freemem()\x2C\n    'Current Malloced Memory' : v8.getHeapStatistics().malloced_memory\x2C\n    'Peak Malloced Memory' : v8.getHeapStatistics().peak_malloced_memory\x2C\n    'Allocated Heap Used (%)' : Math.round((v8.getHeapStatistics().used_heap_size / v8.getHeapStatistics().total_heap_size) * 100)\x2C\n    'Available Heap Allocated (%)' : Math.round((v8.getHeapStatistics().total_heap_size / v8.getHeapStatistics().heap_size_limit) * 100)\x2C\n    'Uptime' : os.uptime()+' Seconds'\n  };\n\n  // Create a header for the stats\n  cli.horizontalLine();\n  cli.centered('SYSTEM STATISTICS');\n  cli.horizontalLine();\n  cli.verticalSpace(2);\n\n  // Log out each stat\n  for(var key in stats){\n     if(stats.hasOwnProperty(key)){\n        var value = stats[key];\n        var line = '      \\x1b[33m '+key+'      \\x1b[0m';\n        var padding = 60 - line.length;\n        for (i = 0; i < padding; i++) {\n            line+=' ';\n        }\n        line+=value;\n        console.log(line);\n        cli.verticalSpace();\n     }\n  }\n\n  // Create a footer for the stats\n  cli.verticalSpace();\n  cli.horizontalLine();\n\n};\n\n// List Users\ncli.responders.listUsers = function(){\n  _data.list('users'\x2Cfunction(err\x2CuserIds){\n    if(!err && userIds && userIds.length > 0){\n      cli.verticalSpace();\n      userIds.forEach(function(userId){\n        _data.read('users'\x2CuserId\x2Cfunction(err\x2CuserData){\n          if(!err && userData){\n            var line = 'Name: '+userData.firstName+' '+userData.lastName+' Phone: '+userData.phone+' Checks: ';\n            var numberOfChecks = typeof(userData.checks) == 'object' && userData.checks instanceof Array && userData.checks.length > 0 ? userData.checks.length : 0;\n            line+=numberOfChecks;\n            console.log(line);\n            cli.verticalSpace();\n          }\n        });\n      });\n    }\n  });\n};\n\n// More user info\ncli.responders.moreUserInfo = function(str){\n  // Get ID from string\n  var arr = str.split('--');\n  var userId = typeof(arr[1]) == 'string' && arr[1].trim().length > 0 ? arr[1].trim() : false;\n  if(userId){\n    // Lookup the user\n    _data.read('users'\x2CuserId\x2Cfunction(err\x2CuserData){\n      if(!err && userData){\n        // Remove the hashed password\n        delete userData.hashedPassword;\n\n        // Print their JSON object with text highlighting\n        cli.verticalSpace();\n        console.dir(userData\x2C{'colors' : true});\n        cli.verticalSpace();\n      }\n    });\n  }\n\n};\n\n// List Checks\ncli.responders.listChecks = function(str){\n  _data.list('checks'\x2Cfunction(err\x2CcheckIds){\n    if(!err && checkIds && checkIds.length > 0){\n      cli.verticalSpace();\n      checkIds.forEach(function(checkId){\n        _data.read('checks'\x2CcheckId\x2Cfunction(err\x2CcheckData){\n          if(!err && checkData){\n            var includeCheck = false;\n            var lowerString = str.toLowerCase();\n            // Get the state\x2C default to down\n            var state = typeof(checkData.state) == 'string' ? checkData.state : 'down';\n            // Get the state\x2C default to unknown\n            var stateOrUnknown = typeof(checkData.state) == 'string' ? checkData.state : 'unknown';\n            // If the user has specified that state\x2C or hasn't specified any state\n            if((lowerString.indexOf('--'+state) > -1) || (lowerString.indexOf('--down') == -1 && lowerString.indexOf('--up') == -1)){\n              var line = 'ID: '+checkData.id+' '+checkData.method.toUpperCase()+' '+checkData.protocol+'://'+checkData.url+' State: '+stateOrUnknown;\n              console.log(line);\n              cli.verticalSpace();\n            }\n          }\n        });\n      });\n    }\n  });\n};\n\n// More check info\ncli.responders.moreCheckInfo = function(str){\n  // Get ID from string\n  var arr = str.split('--');\n  var checkId = typeof(arr[1]) == 'string' && arr[1].trim().length > 0 ? arr[1].trim() : false;\n  if(checkId){\n    // Lookup the user\n    _data.read('checks'\x2CcheckId\x2Cfunction(err\x2CcheckData){\n      if(!err && checkData){\n\n        // Print their JSON object with text highlighting\n        cli.verticalSpace();\n        console.dir(checkData\x2C{'colors' : true});\n        cli.verticalSpace();\n      }\n    });\n  }\n};\n\n// List Logs\ncli.responders.listLogs = function(){\n  cli.verticalSpace();\n  var ls = childProcess.spawn('ls'\x2C ['./.logs/']);\n  ls.stdout.on('data'\x2C function(dataObj){\n    // Explode into separate lines\n    var dataStr = dataObj.toString();\n    var logFileNames = dataStr.split('\\n');\n    logFileNames.forEach(function(logFileName){\n      if(typeof(logFileName) == 'string' && logFileName.trim().length > 0 && logFileName.indexOf('-') > -1){\n        console.log(logFileName.trim().split('.')[0]);\n        cli.verticalSpace();\n      }\n    });\n  });\n};\n\n// More logs info\ncli.responders.moreLogInfo = function(str){\n  // Get logFileName from string\n  var arr = str.split('--');\n  var logFileName = typeof(arr[1]) == 'string' && arr[1].trim().length > 0 ? arr[1].trim() : false;\n  if(logFileName){\n    cli.verticalSpace();\n    // Decompress it\n    _logs.decompress(logFileName\x2Cfunction(err\x2CstrData){\n      if(!err && strData){\n        // Split it into lines\n        var arr = strData.split('\\n');\n        arr.forEach(function(jsonString){\n          var logObject = helpers.parseJsonToObject(jsonString);\n          if(logObject && JSON.stringify(logObject) !== '{}'){\n            console.dir(logObject\x2C{'colors' : true});\n            cli.verticalSpace();\n          }\n        });\n      }\n    });\n  }\n};\n\n// Input processor\ncli.processInput = function(str){\n  str = typeof(str) == 'string' && str.trim().length > 0 ? str.trim() : false;\n  // Only process the input if the user actually wrote something\x2C otherwise ignore it\n  if(str){\n    // Codify the unique strings that identify the different unique questions allowed be the asked\n    var uniqueInputs = [\n      'man'\x2C\n      'help'\x2C\n      'exit'\x2C\n      'stats'\x2C\n      'list users'\x2C\n      'more user info'\x2C\n      'list checks'\x2C\n      'more check info'\x2C\n      'list logs'\x2C\n      'more log info'\n    ];\n\n    // Go through the possible inputs\x2C emit event when a match is found\n    var matchFound = false;\n    var counter = 0;\n    uniqueInputs.some(function(input){\n      if(str.toLowerCase().indexOf(input) > -1){\n        matchFound = true;\n        // Emit event matching the unique input\x2C and include the full string given\n        e.emit(input\x2Cstr);\n        return true;\n      }\n    });\n\n    // If no match is found\x2C tell the user to try again\n    if(!matchFound){\n      console.log("Sorry\x2C try again");\n    }\n\n  }\n};\n\n// Init script\ncli.init = function(){\n\n  // Send to console\x2C in dark blue\n  console.log('\\x1b[34m%s\\x1b[0m'\x2C'The CLI is running');\n\n  // Start the interface\n  var _interface = readline.createInterface({\n    input: process.stdin\x2C\n    output: process.stdout\x2C\n    prompt: ''\n  });\n\n  // Create an initial prompt\n  _interface.prompt();\n\n  // Handle each line of input separately\n  _interface.on('line'\x2C function(str){\n\n    // Send to the input processor\n    cli.processInput(str);\n\n    // Re-initialize the prompt afterwards\n    _interface.prompt();\n  });\n\n  // If the user stops the CLI\x2C kill the associated process\n  _interface.on('close'\x2C function(){\n    process.exit(0);\n  });\n\n};\n\n // Export the module\n module.exports = cli;\n
code-source-info,0x1208b71ef16,198,0,11301,C0O0C4O11301,,
code-creation,Function,10,151875,0x1208b720256,574, /Users/vignesh/Projects/HTTP2/lib/cli.js:1:1,0x1208b71ee90,~
code-source-info,0x1208b720256,198,0,11301,C0O0C5O64C8O64C12O64C14O96C17O96C22O130C30O130C36O160C39O160C44O160C48O201C73O219C75O219C80O219C82O243C85O243C89O243C91O267C94O267C98O267C100O294C103O294C107O294C109O325C112O325C116O325C118O358C121O358C125O358C127O399C130O399C134O399C136O473C137O473C139O496C142O498C155O498C161O552C164O554C177O554C183O609C186O611C199O611C205O666C208O668C221O668C227O725C230O727C243O727C249O793C252O795C265O795C271O871C274O873C287O873C293O944C296O946C309O946C315O1024C318O1026C331O1026C337O1090C340O1092C353O1092C359O1188C363O1203C367O1224C370O1228C379O1244C383O2874C390O2892C394O3082C401O3101C405O3375C412O3388C416O3842C419O3846C428O3862C432O3908C435O3912C444O3929C448O5188C451O5192C460O5213C464O5918C467O5922C476O5946C480O6514C483O6518C492O6540C496O7703C499O7707C508O7732C512O8226C515O8230C524O8250C528O8782C531O8786C540O8809C544O9530C551O9547C555O10589C562O10598C566O11279C568O11294C573O11300,,
code-creation,Eval,10,152084,0x1208b722646,5, node:readline:1:1,0x1208b722380,~
script-source,199,node:readline,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  DateNow\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromiseReject\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\n\nconst {\n  clearLine\x2C\n  clearScreenDown\x2C\n  cursorTo\x2C\n  moveCursor\x2C\n} = require('internal/readline/callbacks');\nconst emitKeypressEvents = require('internal/readline/emitKeypressEvents');\nconst promises = require('readline/promises');\n\nconst {\n  AbortError\x2C\n} = require('internal/errors');\nconst {\n  inspect\x2C\n} = require('internal/util/inspect');\nconst { promisify } = require('internal/util');\nconst { validateAbortSignal } = require('internal/validators');\n\n/**\n * @typedef {import('./stream.js').Readable} Readable\n * @typedef {import('./stream.js').Writable} Writable\n */\n\nconst {\n  Interface: _Interface\x2C\n  InterfaceConstructor\x2C\n  kAddHistory\x2C\n  kDecoder\x2C\n  kDeleteLeft\x2C\n  kDeleteLineLeft\x2C\n  kDeleteLineRight\x2C\n  kDeleteRight\x2C\n  kDeleteWordLeft\x2C\n  kDeleteWordRight\x2C\n  kGetDisplayPos\x2C\n  kHistoryNext\x2C\n  kHistoryPrev\x2C\n  kInsertString\x2C\n  kLine\x2C\n  kLine_buffer\x2C\n  kMoveCursor\x2C\n  kNormalWrite\x2C\n  kOldPrompt\x2C\n  kOnLine\x2C\n  kPreviousKey\x2C\n  kPrompt\x2C\n  kQuestionCallback\x2C\n  kQuestionCancel\x2C\n  kRefreshLine\x2C\n  kSawKeyPress\x2C\n  kSawReturnAt\x2C\n  kSetRawMode\x2C\n  kTabComplete\x2C\n  kTabCompleter\x2C\n  kTtyWrite\x2C\n  kWordLeft\x2C\n  kWordRight\x2C\n  kWriteToOutput\x2C\n} = require('internal/readline/interface');\n\nfunction Interface(input\x2C output\x2C completer\x2C terminal) {\n  if (!(this instanceof Interface)) {\n    return new Interface(input\x2C output\x2C completer\x2C terminal);\n  }\n\n  if (input?.input &&\n      typeof input.completer === 'function' && input.completer.length !== 2) {\n    const { completer } = input;\n    input.completer = (v\x2C cb) => cb(null\x2C completer(v));\n  } else if (typeof completer === 'function' && completer.length !== 2) {\n    const realCompleter = completer;\n    completer = (v\x2C cb) => cb(null\x2C realCompleter(v));\n  }\n\n  FunctionPrototypeCall(InterfaceConstructor\x2C this\x2C\n                        input\x2C output\x2C completer\x2C terminal);\n\n  if (process.env.TERM === 'dumb') {\n    this._ttyWrite = FunctionPrototypeBind(_ttyWriteDumb\x2C this);\n  }\n}\n\nObjectSetPrototypeOf(Interface.prototype\x2C _Interface.prototype);\nObjectSetPrototypeOf(Interface\x2C _Interface);\n\nconst superQuestion = _Interface.prototype.question;\n\n/**\n * Displays `query` by writing it to the `output`.\n * @param {string} query\n * @param {{ signal?: AbortSignal; }} [options]\n * @param {Function} cb\n * @returns {void}\n */\nInterface.prototype.question = function(query\x2C options\x2C cb) {\n  cb = typeof options === 'function' ? options : cb;\n  options = typeof options === 'object' && options !== null ? options : {};\n\n  if (options.signal) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n    if (options.signal.aborted) {\n      return;\n    }\n\n    const onAbort = () => {\n      this[kQuestionCancel]();\n    };\n    options.signal.addEventListener('abort'\x2C onAbort\x2C { once: true });\n    const cleanup = () => {\n      options.signal.removeEventListener(onAbort);\n    };\n    cb = typeof cb === 'function' ? (answer) => {\n      cleanup();\n      return cb(answer);\n    } : cleanup;\n  }\n\n  if (typeof cb === 'function') {\n    FunctionPrototypeCall(superQuestion\x2C this\x2C query\x2C cb);\n  }\n};\nInterface.prototype.question[promisify.custom] = function(query\x2C options) {\n  options = typeof options === 'object' && options !== null ? options : {};\n\n  if (options.signal && options.signal.aborted) {\n    return PromiseReject(\n      new AbortError(undefined\x2C { cause: options.signal.reason }));\n  }\n\n  return new Promise((resolve\x2C reject) => {\n    let cb = resolve;\n\n    if (options.signal) {\n      const onAbort = () => {\n        reject(new AbortError(undefined\x2C { cause: options.signal.reason }));\n      };\n      options.signal.addEventListener('abort'\x2C onAbort\x2C { once: true });\n      cb = (answer) => {\n        options.signal.removeEventListener('abort'\x2C onAbort);\n        resolve(answer);\n      };\n    }\n\n    this.question(query\x2C options\x2C cb);\n  });\n};\n\n/**\n * Creates a new `readline.Interface` instance.\n * @param {Readable | {\n *   input: Readable;\n *   output: Writable;\n *   completer?: Function;\n *   terminal?: boolean;\n *   history?: string[];\n *   historySize?: number;\n *   removeHistoryDuplicates?: boolean;\n *   prompt?: string;\n *   crlfDelay?: number;\n *   escapeCodeTimeout?: number;\n *   tabSize?: number;\n *   signal?: AbortSignal;\n *   }} input\n * @param {Writable} [output]\n * @param {Function} [completer]\n * @param {boolean} [terminal]\n * @returns {Interface}\n */\nfunction createInterface(input\x2C output\x2C completer\x2C terminal) {\n  return new Interface(input\x2C output\x2C completer\x2C terminal);\n}\n\nObjectDefineProperties(Interface.prototype\x2C {\n  // Redirect internal prototype methods to the underscore notation for backward\n  // compatibility.\n  [kSetRawMode]: {\n    get() {\n      return this._setRawMode;\n    }\n  }\x2C\n  [kOnLine]: {\n    get() {\n      return this._onLine;\n    }\n  }\x2C\n  [kWriteToOutput]: {\n    get() {\n      return this._writeToOutput;\n    }\n  }\x2C\n  [kAddHistory]: {\n    get() {\n      return this._addHistory;\n    }\n  }\x2C\n  [kRefreshLine]: {\n    get() {\n      return this._refreshLine;\n    }\n  }\x2C\n  [kNormalWrite]: {\n    get() {\n      return this._normalWrite;\n    }\n  }\x2C\n  [kInsertString]: {\n    get() {\n      return this._insertString;\n    }\n  }\x2C\n  [kTabComplete]: {\n    get() {\n      return this._tabComplete;\n    }\n  }\x2C\n  [kWordLeft]: {\n    get() {\n      return this._wordLeft;\n    }\n  }\x2C\n  [kWordRight]: {\n    get() {\n      return this._wordRight;\n    }\n  }\x2C\n  [kDeleteLeft]: {\n    get() {\n      return this._deleteLeft;\n    }\n  }\x2C\n  [kDeleteRight]: {\n    get() {\n      return this._deleteRight;\n    }\n  }\x2C\n  [kDeleteWordLeft]: {\n    get() {\n      return this._deleteWordLeft;\n    }\n  }\x2C\n  [kDeleteWordRight]: {\n    get() {\n      return this._deleteWordRight;\n    }\n  }\x2C\n  [kDeleteLineLeft]: {\n    get() {\n      return this._deleteLineLeft;\n    }\n  }\x2C\n  [kDeleteLineRight]: {\n    get() {\n      return this._deleteLineRight;\n    }\n  }\x2C\n  [kLine]: {\n    get() {\n      return this._line;\n    }\n  }\x2C\n  [kHistoryNext]: {\n    get() {\n      return this._historyNext;\n    }\n  }\x2C\n  [kHistoryPrev]: {\n    get() {\n      return this._historyPrev;\n    }\n  }\x2C\n  [kGetDisplayPos]: {\n    get() {\n      return this._getDisplayPos;\n    }\n  }\x2C\n  [kMoveCursor]: {\n    get() {\n      return this._moveCursor;\n    }\n  }\x2C\n  [kTtyWrite]: {\n    get() {\n      return this._ttyWrite;\n    }\n  }\x2C\n\n  // Defining proxies for the internal instance properties for backward\n  // compatibility.\n  _decoder: {\n    get() {\n      return this[kDecoder];\n    }\x2C\n    set(value) {\n      this[kDecoder] = value;\n    }\x2C\n  }\x2C\n  _line_buffer: {\n    get() {\n      return this[kLine_buffer];\n    }\x2C\n    set(value) {\n      this[kLine_buffer] = value;\n    }\x2C\n  }\x2C\n  _oldPrompt: {\n    get() {\n      return this[kOldPrompt];\n    }\x2C\n    set(value) {\n      this[kOldPrompt] = value;\n    }\x2C\n  }\x2C\n  _previousKey: {\n    get() {\n      return this[kPreviousKey];\n    }\x2C\n    set(value) {\n      this[kPreviousKey] = value;\n    }\x2C\n  }\x2C\n  _prompt: {\n    get() {\n      return this[kPrompt];\n    }\x2C\n    set(value) {\n      this[kPrompt] = value;\n    }\x2C\n  }\x2C\n  _questionCallback: {\n    get() {\n      return this[kQuestionCallback];\n    }\x2C\n    set(value) {\n      this[kQuestionCallback] = value;\n    }\x2C\n  }\x2C\n  _sawKeyPress: {\n    get() {\n      return this[kSawKeyPress];\n    }\x2C\n    set(value) {\n      this[kSawKeyPress] = value;\n    }\x2C\n  }\x2C\n  _sawReturnAt: {\n    get() {\n      return this[kSawReturnAt];\n    }\x2C\n    set(value) {\n      this[kSawReturnAt] = value;\n    }\x2C\n  }\x2C\n});\n\n// Make internal methods public for backward compatibility.\nInterface.prototype._setRawMode = _Interface.prototype[kSetRawMode];\nInterface.prototype._onLine = _Interface.prototype[kOnLine];\nInterface.prototype._writeToOutput = _Interface.prototype[kWriteToOutput];\nInterface.prototype._addHistory = _Interface.prototype[kAddHistory];\nInterface.prototype._refreshLine = _Interface.prototype[kRefreshLine];\nInterface.prototype._normalWrite = _Interface.prototype[kNormalWrite];\nInterface.prototype._insertString = _Interface.prototype[kInsertString];\nInterface.prototype._tabComplete = function(lastKeypressWasTab) {\n  // Overriding parent method because `this.completer` in the legacy\n  // implementation takes a callback instead of being an async function.\n  this.pause();\n  const string = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n  this.completer(string\x2C (err\x2C value) => {\n    this.resume();\n\n    if (err) {\n      this._writeToOutput(`Tab completion error: ${inspect(err)}`);\n      return;\n    }\n\n    this[kTabCompleter](lastKeypressWasTab\x2C value);\n  });\n};\nInterface.prototype._wordLeft = _Interface.prototype[kWordLeft];\nInterface.prototype._wordRight = _Interface.prototype[kWordRight];\nInterface.prototype._deleteLeft = _Interface.prototype[kDeleteLeft];\nInterface.prototype._deleteRight = _Interface.prototype[kDeleteRight];\nInterface.prototype._deleteWordLeft = _Interface.prototype[kDeleteWordLeft];\nInterface.prototype._deleteWordRight = _Interface.prototype[kDeleteWordRight];\nInterface.prototype._deleteLineLeft = _Interface.prototype[kDeleteLineLeft];\nInterface.prototype._deleteLineRight = _Interface.prototype[kDeleteLineRight];\nInterface.prototype._line = _Interface.prototype[kLine];\nInterface.prototype._historyNext = _Interface.prototype[kHistoryNext];\nInterface.prototype._historyPrev = _Interface.prototype[kHistoryPrev];\nInterface.prototype._getDisplayPos = _Interface.prototype[kGetDisplayPos];\nInterface.prototype._getCursorPos = _Interface.prototype.getCursorPos;\nInterface.prototype._moveCursor = _Interface.prototype[kMoveCursor];\nInterface.prototype._ttyWrite = _Interface.prototype[kTtyWrite];\n\nfunction _ttyWriteDumb(s\x2C key) {\n  key = key || {};\n\n  if (key.name === 'escape') return;\n\n  if (this[kSawReturnAt] && key.name !== 'enter')\n    this[kSawReturnAt] = 0;\n\n  if (key.ctrl) {\n    if (key.name === 'c') {\n      if (this.listenerCount('SIGINT') > 0) {\n        this.emit('SIGINT');\n      } else {\n        // This readline instance is finished\n        this.close();\n      }\n\n      return;\n    } else if (key.name === 'd') {\n      this.close();\n      return;\n    }\n  }\n\n  switch (key.name) {\n    case 'return':  // Carriage return\x2C i.e. \\r\n      this[kSawReturnAt] = DateNow();\n      this._line();\n      break;\n\n    case 'enter':\n      // When key interval > crlfDelay\n      if (this[kSawReturnAt] === 0 ||\n          DateNow() - this[kSawReturnAt] > this.crlfDelay) {\n        this._line();\n      }\n      this[kSawReturnAt] = 0;\n      break;\n\n    default:\n      if (typeof s === 'string' && s) {\n        this.line += s;\n        this.cursor += s.length;\n        this._writeToOutput(s);\n      }\n  }\n}\n\nmodule.exports = {\n  Interface\x2C\n  clearLine\x2C\n  clearScreenDown\x2C\n  createInterface\x2C\n  cursorTo\x2C\n  emitKeypressEvents\x2C\n  moveCursor\x2C\n  promises\x2C\n};\n
code-source-info,0x1208b722646,199,0,12006,C0O0C4O12006,,
code-creation,Function,10,152542,0x1208b7240c6,2305, node:readline:1:1,0x1208b7225c0,~
code-source-info,0x1208b7240c6,199,0,12006,C0O0C90O1159C96O1170C102O1195C108O1220C113O1246C118O1270C124O1281C130O1298C136O1408C140O1408C146O1348C151O1361C156O1380C161O1392C166O1475C170O1475C175O1541C179O1541C184O1598C188O1598C194O1582C200O1649C204O1649C210O1636C216O1705C220O1705C226O1691C231O1763C235O1763C241O1739C247O2479C251O2479C257O1934C262O1948C268O1972C273O1987C279O1999C284O2014C289O2033C294O2053C299O2069C304O2088C310O2108C316O2126C322O2142C328O2158C334O2175C340O2184C346O2200C352O2215C358O2231C364O2245C370O2256C376O2272C382O2283C388O2304C394O2323C400O2339C406O2355C412O2371C418O2386C424O2402C430O2419C436O2432C442O2445C448O2459C454O3267C458O3298C464O3320C470O3267C475O3332C479O3332C484O3411C490O3421C494O3400C496O3607C500O3617C510O3636C514O4374C518O4384C524O4394C530O4413C540O4421C544O5792C548O5825C562O5942C564O5956C570O5962C587O6015C589O6025C595O6031C612O6080C614O6097C620O6103C637O6159C639O6173C645O6179C662O6232C664O6247C670O6253C687O6307C689O6322C695O6328C712O6382C714O6398C720O6404C737O6459C739O6474C745O6480C762O6534C764O6546C770O6552C787O6603C789O6616C795O6622C812O6674C814O6688C820O6694C837O6747C839O6762C845O6768C862O6822C864O6840C870O6846C887O6903C889O6922C895O6928C912O6986C914O7004C920O7010C937O7067C939O7086C945O7092C962O7150C964O7158C970O7164C987O7211C989O7226C995O7232C1012O7286C1014O7301C1020O7307C1037O7361C1039O7378C1045O7384C1062O7440C1064O7454C1070O7460C1087O7513C1089O7525C1095O7531C1114O7684C1120O7690C1128O7738C1147O7809C1153O7815C1161O7867C1184O7940C1193O7946C1205O7996C1232O8069C1241O8075C1253O8127C1280O8197C1289O8203C1301O8250C1328O8325C1337O8331C1349O8388C1376O8468C1385O8474C1397O8526C1424O8601C1433O8607C1445O8659C1468O5792C1478O8783C1482O8793C1488O8828C1496O8837C1502O8815C1510O8852C1514O8862C1520O8893C1528O8902C1534O8880C1542O8913C1546O8923C1552O8961C1560O8970C1566O8948C1574O8988C1578O8998C1584O9033C1592O9042C1598O9020C1606O9057C1610O9067C1616O9103C1624O9112C1630O9090C1638O9128C1642O9138C1648O9174C1656O9183C1662O9161C1670O9199C1674O9209C1680O9246C1688O9255C1694O9233C1702O9272C1706O9282C1716O9305C1724O9790C1728O9800C1734O9833C1742O9842C1748O9820C1756O9855C1760O9865C1766O9899C1774O9908C1780O9886C1788O9922C1792O9932C1798O9967C1806O9976C1812O9954C1820O9991C1824O10001C1830O10037C1838O10046C1844O10024C1852O10062C1856O10072C1862O10111C1870O10120C1876O10098C1884O10139C1888O10149C1894O10189C1902O10198C1908O10176C1916O10218C1920O10228C1926O10267C1934O10276C1940O10254C1948O10295C1952O10305C1958O10345C1966O10354C1972O10332C1980O10374C1984O10384C1990O10413C1998O10422C2004O10400C2012O10431C2016O10441C2022O10477C2030O10486C2036O10464C2044O10502C2048O10512C2054O10548C2062O10557C2068O10535C2076O10573C2080O10583C2086O10621C2094O10630C2100O10608C2108O10648C2112O10658C2118O10695C2124O10705C2132O10682C2140O10719C2144O10729C2150O10764C2158O10773C2164O10751C2172O10788C2176O10798C2182O10831C2190O10840C2196O10818C2204O11860C2215O11881C2225O11894C2235O11907C2245O11926C2255O11945C2265O11957C2275O11979C2285O11993C2295O11875C2304O12005,,
tick,0x1bfd39474,152667,1,0x10041f4d8,3,0x0,0x105108c5c,0x105115cac,0x105112d34,0x1051186b8,0x1051128a8,0x105113c1c,0x1208b72025e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x105118954,0x1051128a8,0x105113c1c,0x2cbd764a6ea0,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,152750,0x1208b726676,5, node:internal/readline/callbacks:1:1,0x1208b726490,~
script-source,200,node:internal/readline/callbacks,'use strict';\n\nconst {\n  NumberIsNaN\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_CURSOR_POS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  validateCallback\x2C\n} = require('internal/validators');\nconst {\n  CSI\x2C\n} = require('internal/readline/utils');\n\nconst {\n  kClearLine\x2C\n  kClearScreenDown\x2C\n  kClearToLineBeginning\x2C\n  kClearToLineEnd\x2C\n} = CSI;\n\n\n/**\n * moves the cursor to the x and y coordinate on the given stream\n */\n\nfunction cursorTo(stream\x2C x\x2C y\x2C callback) {\n  if (callback !== undefined) {\n    validateCallback(callback);\n  }\n\n  if (typeof y === 'function') {\n    callback = y;\n    y = undefined;\n  }\n\n  if (NumberIsNaN(x)) throw new ERR_INVALID_ARG_VALUE('x'\x2C x);\n  if (NumberIsNaN(y)) throw new ERR_INVALID_ARG_VALUE('y'\x2C y);\n\n  if (stream == null || (typeof x !== 'number' && typeof y !== 'number')) {\n    if (typeof callback === 'function') process.nextTick(callback\x2C null);\n    return true;\n  }\n\n  if (typeof x !== 'number') throw new ERR_INVALID_CURSOR_POS();\n\n  const data = typeof y !== 'number' ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n  return stream.write(data\x2C callback);\n}\n\n/**\n * moves the cursor relative to its current location\n */\n\nfunction moveCursor(stream\x2C dx\x2C dy\x2C callback) {\n  if (callback !== undefined) {\n    validateCallback(callback);\n  }\n\n  if (stream == null || !(dx || dy)) {\n    if (typeof callback === 'function') process.nextTick(callback\x2C null);\n    return true;\n  }\n\n  let data = '';\n\n  if (dx < 0) {\n    data += CSI`${-dx}D`;\n  } else if (dx > 0) {\n    data += CSI`${dx}C`;\n  }\n\n  if (dy < 0) {\n    data += CSI`${-dy}A`;\n  } else if (dy > 0) {\n    data += CSI`${dy}B`;\n  }\n\n  return stream.write(data\x2C callback);\n}\n\n/**\n * clears the current line the cursor is on:\n *   -1 for left of the cursor\n *   +1 for right of the cursor\n *    0 for the entire line\n */\n\nfunction clearLine(stream\x2C dir\x2C callback) {\n  if (callback !== undefined) {\n    validateCallback(callback);\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === 'function') process.nextTick(callback\x2C null);\n    return true;\n  }\n\n  const type =\n    dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;\n  return stream.write(type\x2C callback);\n}\n\n/**\n * clears the screen from the current position of the cursor down\n */\n\nfunction clearScreenDown(stream\x2C callback) {\n  if (callback !== undefined) {\n    validateCallback(callback);\n  }\n\n  if (stream === null || stream === undefined) {\n    if (typeof callback === 'function') process.nextTick(callback\x2C null);\n    return true;\n  }\n\n  return stream.write(kClearScreenDown\x2C callback);\n}\n\nmodule.exports = {\n  clearLine\x2C\n  clearScreenDown\x2C\n  cursorTo\x2C\n  moveCursor\x2C\n};\n
code-source-info,0x1208b726676,200,0,2706,C0O0C4O2706,,
code-creation,Function,10,152875,0x1208b726946,179, node:internal/readline/callbacks:1:1,0x1208b7265f0,~
code-source-info,0x1208b726946,200,0,2706,C0O0C56O25C62O139C65O139C70O139C75O79C81O106C87O200C90O200C95O178C101O251C104O251C109O242C115O378C118O298C124O312C130O332C136O357C142O2626C149O2647C155O2660C161O2679C167O2691C173O2641C178O2705,,
code-creation,Eval,10,153000,0x1208b7274a6,5, node:internal/readline/utils:1:1,0x1208b7272a0,~
script-source,201,node:internal/readline/utils,'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  RegExpPrototypeTest\x2C\n  StringFromCharCode\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n} = primordials;\n\nconst kUTF16SurrogateThreshold = 0x10000; // 2 ** 16\nconst kEscape = '\\x1b';\nconst kSubstringSearch = Symbol('kSubstringSearch');\n\nfunction CSI(strings\x2C ...args) {\n  let ret = `${kEscape}[`;\n  for (let n = 0; n < strings.length; n++) {\n    ret += strings[n];\n    if (n < args.length)\n      ret += args[n];\n  }\n  return ret;\n}\n\nCSI.kEscape = kEscape;\nCSI.kClearToLineBeginning = CSI`1K`;\nCSI.kClearToLineEnd = CSI`0K`;\nCSI.kClearLine = CSI`2K`;\nCSI.kClearScreenDown = CSI`0J`;\n\n// TODO(BridgeAR): Treat combined characters as single character\x2C i.e\x2C\n// 'a\\u0301' and '\\u0301a' (both have the same visual output).\n// Check Canonical_Combining_Class in\n// http://userguide.icu-project.org/strings/properties\nfunction charLengthLeft(str\x2C i) {\n  if (i <= 0)\n    return 0;\n  if ((i > 1 &&\n      StringPrototypeCodePointAt(str\x2C i - 2) >= kUTF16SurrogateThreshold) ||\n      StringPrototypeCodePointAt(str\x2C i - 1) >= kUTF16SurrogateThreshold) {\n    return 2;\n  }\n  return 1;\n}\n\nfunction charLengthAt(str\x2C i) {\n  if (str.length <= i) {\n    // Pretend to move to the right. This is necessary to autocomplete while\n    // moving to the right.\n    return 1;\n  }\n  return StringPrototypeCodePointAt(str\x2C i) >= kUTF16SurrogateThreshold ? 2 : 1;\n}\n\n/*\n  Some patterns seen in terminal key escape codes\x2C derived from combos seen\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\n\n  ESC letter\n  ESC [ letter\n  ESC [ modifier letter\n  ESC [ 1 ; modifier letter\n  ESC [ num char\n  ESC [ num ; modifier char\n  ESC O letter\n  ESC O modifier letter\n  ESC O 1 ; modifier letter\n  ESC N letter\n  ESC [ [ num ; modifier char\n  ESC [ [ 1 ; modifier letter\n  ESC ESC [ num char\n  ESC ESC O letter\n\n  - char is usually ~ but $ and ^ also happen with rxvt\n  - modifier is 1 +\n                (shift     * 1) +\n                (left_alt  * 2) +\n                (ctrl      * 4) +\n                (right_alt * 8)\n  - two leading ESCs apparently mean the same as one leading ESC\n*/\nfunction* emitKeys(stream) {\n  while (true) {\n    let ch = yield;\n    let s = ch;\n    let escaped = false;\n    const key = {\n      sequence: null\x2C\n      name: undefined\x2C\n      ctrl: false\x2C\n      meta: false\x2C\n      shift: false\n    };\n\n    if (ch === kEscape) {\n      escaped = true;\n      s += (ch = yield);\n\n      if (ch === kEscape) {\n        s += (ch = yield);\n      }\n    }\n\n    if (escaped && (ch === 'O' || ch === '[')) {\n      // ANSI escape sequence\n      let code = ch;\n      let modifier = 0;\n\n      if (ch === 'O') {\n        // ESC O letter\n        // ESC O modifier letter\n        s += (ch = yield);\n\n        if (ch >= '0' && ch <= '9') {\n          modifier = (ch >> 0) - 1;\n          s += (ch = yield);\n        }\n\n        code += ch;\n      } else if (ch === '[') {\n        // ESC [ letter\n        // ESC [ modifier letter\n        // ESC [ [ modifier letter\n        // ESC [ [ num char\n        s += (ch = yield);\n\n        if (ch === '[') {\n          // \\x1b[[A\n          //      ^--- escape codes might have a second bracket\n          code += ch;\n          s += (ch = yield);\n        }\n\n        /*\n         * Here and later we try to buffer just enough data to get\n         * a complete ascii sequence.\n         *\n         * We have basically two classes of ascii characters to process:\n         *\n         *\n         * 1. `\\x1b[24;5~` should be parsed as { code: '[24~'\x2C modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+F12 in xterm.\n         *\n         *  - `;5` part is optional\x2C e.g. it could be `\\x1b[24~`\n         *  - first part can contain one or two digits\n         *\n         * So the generic regexp is like /^\\d\\d?(;\\d)?[~^$]$/\n         *\n         *\n         * 2. `\\x1b[1;5H` should be parsed as { code: '[H'\x2C modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+Home in xterm.\n         *\n         *  - `1;5` part is optional\x2C e.g. it could be `\\x1b[H`\n         *  - `1;` part is optional\x2C e.g. it could be `\\x1b[5H`\n         *\n         * So the generic regexp is like /^((\\d;)?\\d)?[A-Za-z]$/\n         *\n         */\n        const cmdStart = s.length - 1;\n\n        // Skip one or two leading digits\n        if (ch >= '0' && ch <= '9') {\n          s += (ch = yield);\n\n          if (ch >= '0' && ch <= '9') {\n            s += (ch = yield);\n          }\n        }\n\n        // skip modifier\n        if (ch === ';') {\n          s += (ch = yield);\n\n          if (ch >= '0' && ch <= '9') {\n            s += yield;\n          }\n        }\n\n        /*\n         * We buffered enough data\x2C now trying to extract code\n         * and modifier from it\n         */\n        const cmd = StringPrototypeSlice(s\x2C cmdStart);\n        let match;\n\n        if ((match = StringPrototypeMatch(cmd\x2C /^(\\d\\d?)(;(\\d))?([~^$])$/))) {\n          code += match[1] + match[4];\n          modifier = (match[3] || 1) - 1;\n        } else if (\n          (match = StringPrototypeMatch(cmd\x2C /^((\\d;)?(\\d))?([A-Za-z])$/))\n        ) {\n          code += match[4];\n          modifier = (match[3] || 1) - 1;\n        } else {\n          code += cmd;\n        }\n      }\n\n      // Parse the key modifier\n      key.ctrl = !!(modifier & 4);\n      key.meta = !!(modifier & 10);\n      key.shift = !!(modifier & 1);\n      key.code = code;\n\n      // Parse the key itself\n      switch (code) {\n        /* xterm/gnome ESC [ letter (with modifier) */\n        case '[P': key.name = 'f1'; break;\n        case '[Q': key.name = 'f2'; break;\n        case '[R': key.name = 'f3'; break;\n        case '[S': key.name = 'f4'; break;\n\n        /* xterm/gnome ESC O letter (without modifier) */\n        case 'OP': key.name = 'f1'; break;\n        case 'OQ': key.name = 'f2'; break;\n        case 'OR': key.name = 'f3'; break;\n        case 'OS': key.name = 'f4'; break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case '[11~': key.name = 'f1'; break;\n        case '[12~': key.name = 'f2'; break;\n        case '[13~': key.name = 'f3'; break;\n        case '[14~': key.name = 'f4'; break;\n\n        /* from Cygwin and used in libuv */\n        case '[[A': key.name = 'f1'; break;\n        case '[[B': key.name = 'f2'; break;\n        case '[[C': key.name = 'f3'; break;\n        case '[[D': key.name = 'f4'; break;\n        case '[[E': key.name = 'f5'; break;\n\n        /* common */\n        case '[15~': key.name = 'f5'; break;\n        case '[17~': key.name = 'f6'; break;\n        case '[18~': key.name = 'f7'; break;\n        case '[19~': key.name = 'f8'; break;\n        case '[20~': key.name = 'f9'; break;\n        case '[21~': key.name = 'f10'; break;\n        case '[23~': key.name = 'f11'; break;\n        case '[24~': key.name = 'f12'; break;\n\n        /* xterm ESC [ letter */\n        case '[A': key.name = 'up'; break;\n        case '[B': key.name = 'down'; break;\n        case '[C': key.name = 'right'; break;\n        case '[D': key.name = 'left'; break;\n        case '[E': key.name = 'clear'; break;\n        case '[F': key.name = 'end'; break;\n        case '[H': key.name = 'home'; break;\n\n        /* xterm/gnome ESC O letter */\n        case 'OA': key.name = 'up'; break;\n        case 'OB': key.name = 'down'; break;\n        case 'OC': key.name = 'right'; break;\n        case 'OD': key.name = 'left'; break;\n        case 'OE': key.name = 'clear'; break;\n        case 'OF': key.name = 'end'; break;\n        case 'OH': key.name = 'home'; break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case '[1~': key.name = 'home'; break;\n        case '[2~': key.name = 'insert'; break;\n        case '[3~': key.name = 'delete'; break;\n        case '[4~': key.name = 'end'; break;\n        case '[5~': key.name = 'pageup'; break;\n        case '[6~': key.name = 'pagedown'; break;\n\n        /* putty */\n        case '[[5~': key.name = 'pageup'; break;\n        case '[[6~': key.name = 'pagedown'; break;\n\n        /* rxvt */\n        case '[7~': key.name = 'home'; break;\n        case '[8~': key.name = 'end'; break;\n\n        /* rxvt keys with modifiers */\n        case '[a': key.name = 'up'; key.shift = true; break;\n        case '[b': key.name = 'down'; key.shift = true; break;\n        case '[c': key.name = 'right'; key.shift = true; break;\n        case '[d': key.name = 'left'; key.shift = true; break;\n        case '[e': key.name = 'clear'; key.shift = true; break;\n\n        case '[2$': key.name = 'insert'; key.shift = true; break;\n        case '[3$': key.name = 'delete'; key.shift = true; break;\n        case '[5$': key.name = 'pageup'; key.shift = true; break;\n        case '[6$': key.name = 'pagedown'; key.shift = true; break;\n        case '[7$': key.name = 'home'; key.shift = true; break;\n        case '[8$': key.name = 'end'; key.shift = true; break;\n\n        case 'Oa': key.name = 'up'; key.ctrl = true; break;\n        case 'Ob': key.name = 'down'; key.ctrl = true; break;\n        case 'Oc': key.name = 'right'; key.ctrl = true; break;\n        case 'Od': key.name = 'left'; key.ctrl = true; break;\n        case 'Oe': key.name = 'clear'; key.ctrl = true; break;\n\n        case '[2^': key.name = 'insert'; key.ctrl = true; break;\n        case '[3^': key.name = 'delete'; key.ctrl = true; break;\n        case '[5^': key.name = 'pageup'; key.ctrl = true; break;\n        case '[6^': key.name = 'pagedown'; key.ctrl = true; break;\n        case '[7^': key.name = 'home'; key.ctrl = true; break;\n        case '[8^': key.name = 'end'; key.ctrl = true; break;\n\n        /* misc. */\n        case '[Z': key.name = 'tab'; key.shift = true; break;\n        default: key.name = 'undefined'; break;\n      }\n    } else if (ch === '\\r') {\n      // carriage return\n      key.name = 'return';\n      key.meta = escaped;\n    } else if (ch === '\\n') {\n      // Enter\x2C should have been called linefeed\n      key.name = 'enter';\n      key.meta = escaped;\n    } else if (ch === '\\t') {\n      // tab\n      key.name = 'tab';\n      key.meta = escaped;\n    } else if (ch === '\\b' || ch === '\\x7f') {\n      // backspace or ctrl+h\n      key.name = 'backspace';\n      key.meta = escaped;\n    } else if (ch === kEscape) {\n      // escape key\n      key.name = 'escape';\n      key.meta = escaped;\n    } else if (ch === ' ') {\n      key.name = 'space';\n      key.meta = escaped;\n    } else if (!escaped && ch <= '\\x1a') {\n      // ctrl+letter\n      key.name = StringFromCharCode(\n        StringPrototypeCharCodeAt(ch) + StringPrototypeCharCodeAt('a') - 1\n      );\n      key.ctrl = true;\n    } else if (RegExpPrototypeTest(/^[0-9A-Za-z]$/\x2C ch)) {\n      // Letter\x2C number\x2C shift+letter\n      key.name = StringPrototypeToLowerCase(ch);\n      key.shift = RegExpPrototypeTest(/^[A-Z]$/\x2C ch);\n      key.meta = escaped;\n    } else if (escaped) {\n      // Escape sequence timeout\n      key.name = ch.length ? undefined : 'escape';\n      key.meta = true;\n    }\n\n    key.sequence = s;\n\n    if (s.length !== 0 && (key.name !== undefined || escaped)) {\n      /* Named character or sequence */\n      stream.emit('keypress'\x2C escaped ? undefined : s\x2C key);\n    } else if (charLengthAt(s\x2C 0) === s.length) {\n      /* Single unnamed character\x2C e.g. "." */\n      stream.emit('keypress'\x2C s\x2C key);\n    }\n    /* Unrecognized or broken escape sequence\x2C don't emit anything */\n  }\n}\n\n// This runs in O(n log n).\nfunction commonPrefix(strings) {\n  if (strings.length === 1) {\n    return strings[0];\n  }\n  const sorted = ArrayPrototypeSort(ArrayPrototypeSlice(strings));\n  const min = sorted[0];\n  const max = sorted[sorted.length - 1];\n  for (let i = 0; i < min.length; i++) {\n    if (min[i] !== max[i]) {\n      return StringPrototypeSlice(min\x2C 0\x2C i);\n    }\n  }\n  return min;\n}\n\nmodule.exports = {\n  charLengthAt\x2C\n  charLengthLeft\x2C\n  commonPrefix\x2C\n  emitKeys\x2C\n  kSubstringSearch\x2C\n  CSI\n};\n
code-source-info,0x1208b7274a6,201,0,11859,C0O0C4O11859,,
code-creation,Function,10,153417,0x1208b7278f6,246, node:internal/readline/utils:1:1,0x1208b727420,~
code-source-info,0x1208b7278f6,201,0,11859,C0O0C64O25C70O48C76O70C82O93C88O115C94O144C100O174C106O198C112O222C118O252C123O311C129O311C131O347C133O347C135O380C138O380C143O605C145O617C149O659C153O659C157O654C161O690C165O690C169O685C173O716C177O716C181O711C185O748C189O748C193O743C197O11749C204O11770C210O11786C216O11804C222O11820C228O11832C234O11852C240O11764C245O11858,,
code-creation,LazyCompile,10,153500,0x1208b728916,75,CSI node:internal/readline/utils:20:13,0x1208b7274d8,~
code-source-info,0x1208b728916,201,421,603,C0O421C8O454C20O484C22O499C26O489C31O518C33O532C43O554C47O547C52O568C54O579C64O508C69O471C72O590C74O601,,
code-creation,Eval,10,153542,0x1208b729b06,5, node:internal/readline/emitKeypressEvents:1:1,0x1208b729910,~
script-source,202,node:internal/readline/emitKeypressEvents,'use strict';\n\nconst {\n  SafeStringIterator\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  charLengthAt\x2C\n  CSI\x2C\n  emitKeys\x2C\n} = require('internal/readline/utils');\nconst {\n  kSawKeyPress\x2C\n} = require('internal/readline/interface');\n\nconst { clearTimeout\x2C setTimeout } = require('timers');\nconst {\n  kEscape\x2C\n} = CSI;\n\nconst { StringDecoder } = require('string_decoder');\n\nconst KEYPRESS_DECODER = Symbol('keypress-decoder');\nconst ESCAPE_DECODER = Symbol('escape-decoder');\n\n// GNU readline library - keyseq-timeout is 500ms (default)\nconst ESCAPE_CODE_TIMEOUT = 500;\n\n/**\n * accepts a readable Stream instance and makes it emit "keypress" events\n */\n\nfunction emitKeypressEvents(stream\x2C iface = {}) {\n  if (stream[KEYPRESS_DECODER]) return;\n\n  stream[KEYPRESS_DECODER] = new StringDecoder('utf8');\n\n  stream[ESCAPE_DECODER] = emitKeys(stream);\n  stream[ESCAPE_DECODER].next();\n\n  const triggerEscape = () => stream[ESCAPE_DECODER].next('');\n  const { escapeCodeTimeout = ESCAPE_CODE_TIMEOUT } = iface;\n  let timeoutId;\n\n  function onData(input) {\n    if (stream.listenerCount('keypress') > 0) {\n      const string = stream[KEYPRESS_DECODER].write(input);\n      if (string) {\n        clearTimeout(timeoutId);\n\n        // This supports characters of length 2.\n        iface[kSawKeyPress] = charLengthAt(string\x2C 0) === string.length;\n        iface.isCompletionEnabled = false;\n\n        let length = 0;\n        for (const character of new SafeStringIterator(string)) {\n          length += character.length;\n          if (length === string.length) {\n            iface.isCompletionEnabled = true;\n          }\n\n          try {\n            stream[ESCAPE_DECODER].next(character);\n            // Escape letter at the tail position\n            if (length === string.length && character === kEscape) {\n              timeoutId = setTimeout(triggerEscape\x2C escapeCodeTimeout);\n            }\n          } catch (err) {\n            // If the generator throws (it could happen in the `keypress`\n            // event)\x2C we need to restart it.\n            stream[ESCAPE_DECODER] = emitKeys(stream);\n            stream[ESCAPE_DECODER].next();\n            throw err;\n          }\n        }\n      }\n    } else {\n      // Nobody's watching anyway\n      stream.removeListener('data'\x2C onData);\n      stream.on('newListener'\x2C onNewListener);\n    }\n  }\n\n  function onNewListener(event) {\n    if (event === 'keypress') {\n      stream.on('data'\x2C onData);\n      stream.removeListener('newListener'\x2C onNewListener);\n    }\n  }\n\n  if (stream.listenerCount('keypress') > 0) {\n    stream.on('data'\x2C onData);\n  } else {\n    stream.on('newListener'\x2C onNewListener);\n  }\n}\n\nmodule.exports = emitKeypressEvents;\n
code-source-info,0x1208b729b06,202,0,2663,C0O0C4O2663,,
code-creation,Function,10,153667,0x1208b729c96,165, node:internal/readline/emitKeypressEvents:1:1,0x1208b729a80,~
code-source-info,0x1208b729c96,202,0,2663,C0O0C43O25C49O47C54O120C57O120C62O83C68O99C73O106C79O184C82O184C87O166C93O262C96O262C101O233C107O247C113O291C119O336C122O336C127O318C133O389C136O389C140O389C142O440C145O440C149O440C151O555C155O555C157O2626C159O2641C164O2662,,
tick,0x1bfb8aa60,153709,1,0x10041f4d8,6,0x0,0x105108c5c,0x10510894c,0x1208b724170,0x105108d28,0x105115cac,0x105112d34,0x1051186b8,0x1051128a8,0x105113c1c,0x1208b72025e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x105118954,0x1051128a8,0x105113c1c,0x2cbd764a6ea0,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,154084,0x1208b72b60e,5, node:internal/readline/interface:1:1,0x1208b72ae68,~
script-source,203,node:internal/readline/interface,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReverse\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeUnshift\x2C\n  DateNow\x2C\n  FunctionPrototypeCall\x2C\n  MathCeil\x2C\n  MathFloor\x2C\n  MathMax\x2C\n  MathMaxApply\x2C\n  NumberIsFinite\x2C\n  NumberIsNaN\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeTest\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeTrim\x2C\n  Symbol\x2C\n  SymbolAsyncIterator\x2C\n  SafeStringIterator\x2C\n} = primordials;\n\nconst { codes } = require('internal/errors');\n\nconst { ERR_INVALID_ARG_VALUE } = codes;\nconst {\n  validateAbortSignal\x2C\n  validateArray\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst {\n  inspect\x2C\n  getStringWidth\x2C\n  stripVTControlCharacters\x2C\n} = require('internal/util/inspect');\nconst EventEmitter = require('events');\nconst {\n  charLengthAt\x2C\n  charLengthLeft\x2C\n  commonPrefix\x2C\n  kSubstringSearch\x2C\n} = require('internal/readline/utils');\nlet emitKeypressEvents;\nconst {\n  clearScreenDown\x2C\n  cursorTo\x2C\n  moveCursor\x2C\n} = require('internal/readline/callbacks');\n\nconst { StringDecoder } = require('string_decoder');\n\n// Lazy load Readable for startup performance.\nlet Readable;\n\nconst kHistorySize = 30;\nconst kMaxUndoRedoStackSize = 2048;\nconst kMincrlfDelay = 100;\n// \\r\\n\x2C \\n\x2C or \\r followed by something other than \\n\nconst lineEnding = /\\r?\\n|\\r(?!\\n)/;\n\nconst kLineObjectStream = Symbol('line object stream');\nconst kQuestionCancel = Symbol('kQuestionCancel');\n\n// GNU readline library - keyseq-timeout is 500ms (default)\nconst ESCAPE_CODE_TIMEOUT = 500;\n\n// Max length of the kill ring\nconst kMaxLengthOfKillRing = 32;\n\nconst kAddHistory = Symbol('_addHistory');\nconst kBeforeEdit = Symbol('_beforeEdit');\nconst kDecoder = Symbol('_decoder');\nconst kDeleteLeft = Symbol('_deleteLeft');\nconst kDeleteLineLeft = Symbol('_deleteLineLeft');\nconst kDeleteLineRight = Symbol('_deleteLineRight');\nconst kDeleteRight = Symbol('_deleteRight');\nconst kDeleteWordLeft = Symbol('_deleteWordLeft');\nconst kDeleteWordRight = Symbol('_deleteWordRight');\nconst kGetDisplayPos = Symbol('_getDisplayPos');\nconst kHistoryNext = Symbol('_historyNext');\nconst kHistoryPrev = Symbol('_historyPrev');\nconst kInsertString = Symbol('_insertString');\nconst kLine = Symbol('_line');\nconst kLine_buffer = Symbol('_line_buffer');\nconst kKillRing = Symbol('_killRing');\nconst kKillRingCursor = Symbol('_killRingCursor');\nconst kMoveCursor = Symbol('_moveCursor');\nconst kNormalWrite = Symbol('_normalWrite');\nconst kOldPrompt = Symbol('_oldPrompt');\nconst kOnLine = Symbol('_onLine');\nconst kPreviousKey = Symbol('_previousKey');\nconst kPrompt = Symbol('_prompt');\nconst kPushToKillRing = Symbol('_pushToKillRing');\nconst kPushToUndoStack = Symbol('_pushToUndoStack');\nconst kQuestionCallback = Symbol('_questionCallback');\nconst kRedo = Symbol('_redo');\nconst kRedoStack = Symbol('_redoStack');\nconst kRefreshLine = Symbol('_refreshLine');\nconst kSawKeyPress = Symbol('_sawKeyPress');\nconst kSawReturnAt = Symbol('_sawReturnAt');\nconst kSetRawMode = Symbol('_setRawMode');\nconst kTabComplete = Symbol('_tabComplete');\nconst kTabCompleter = Symbol('_tabCompleter');\nconst kTtyWrite = Symbol('_ttyWrite');\nconst kUndo = Symbol('_undo');\nconst kUndoStack = Symbol('_undoStack');\nconst kWordLeft = Symbol('_wordLeft');\nconst kWordRight = Symbol('_wordRight');\nconst kWriteToOutput = Symbol('_writeToOutput');\nconst kYank = Symbol('_yank');\nconst kYanking = Symbol('_yanking');\nconst kYankPop = Symbol('_yankPop');\n\nfunction InterfaceConstructor(input\x2C output\x2C completer\x2C terminal) {\n  this[kSawReturnAt] = 0;\n  // TODO(BridgeAR): Document this property. The name is not ideal\x2C so we\n  // might want to expose an alias and document that instead.\n  this.isCompletionEnabled = true;\n  this[kSawKeyPress] = false;\n  this[kPreviousKey] = null;\n  this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT;\n  this.tabSize = 8;\n\n  FunctionPrototypeCall(EventEmitter\x2C this);\n\n  let history;\n  let historySize;\n  let removeHistoryDuplicates = false;\n  let crlfDelay;\n  let prompt = '> ';\n  let signal;\n\n  if (input?.input) {\n    // An options object was given\n    output = input.output;\n    completer = input.completer;\n    terminal = input.terminal;\n    history = input.history;\n    historySize = input.historySize;\n    signal = input.signal;\n    if (input.tabSize !== undefined) {\n      validateUint32(input.tabSize\x2C 'tabSize'\x2C true);\n      this.tabSize = input.tabSize;\n    }\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n    if (input.prompt !== undefined) {\n      prompt = input.prompt;\n    }\n    if (input.escapeCodeTimeout !== undefined) {\n      if (NumberIsFinite(input.escapeCodeTimeout)) {\n        this.escapeCodeTimeout = input.escapeCodeTimeout;\n      } else {\n        throw new ERR_INVALID_ARG_VALUE(\n          'input.escapeCodeTimeout'\x2C\n          this.escapeCodeTimeout\n        );\n      }\n    }\n\n    if (signal) {\n      validateAbortSignal(signal\x2C 'options.signal');\n    }\n\n    crlfDelay = input.crlfDelay;\n    input = input.input;\n  }\n\n  if (completer !== undefined && typeof completer !== 'function') {\n    throw new ERR_INVALID_ARG_VALUE('completer'\x2C completer);\n  }\n\n  if (history === undefined) {\n    history = [];\n  } else {\n    validateArray(history\x2C 'history');\n  }\n\n  if (historySize === undefined) {\n    historySize = kHistorySize;\n  }\n\n  if (\n    typeof historySize !== 'number' ||\n      NumberIsNaN(historySize) ||\n      historySize < 0\n  ) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('historySize'\x2C historySize);\n  }\n\n  // Backwards compat; check the isTTY prop of the output stream\n  //  when `terminal` was not specified\n  if (terminal === undefined && !(output === null || output === undefined)) {\n    terminal = !!output.isTTY;\n  }\n\n  const self = this;\n\n  this.line = '';\n  this[kSubstringSearch] = null;\n  this.output = output;\n  this.input = input;\n  this[kUndoStack] = [];\n  this[kRedoStack] = [];\n  this.history = history;\n  this.historySize = historySize;\n\n  // The kill ring is a global list of blocks of text that were previously\n  // killed (deleted). If its size exceeds kMaxLengthOfKillRing\x2C the oldest\n  // element will be removed to make room for the latest deletion. With kill\n  // ring\x2C users are able to recall (yank) or cycle (yank pop) among previously\n  // killed texts\x2C quite similar to the behavior of Emacs.\n  this[kKillRing] = [];\n  this[kKillRingCursor] = 0;\n\n  this.removeHistoryDuplicates = !!removeHistoryDuplicates;\n  this.crlfDelay = crlfDelay ?\n    MathMax(kMincrlfDelay\x2C crlfDelay) :\n    kMincrlfDelay;\n  this.completer = completer;\n\n  this.setPrompt(prompt);\n\n  this.terminal = !!terminal;\n\n\n  function onerror(err) {\n    self.emit('error'\x2C err);\n  }\n\n  function ondata(data) {\n    self[kNormalWrite](data);\n  }\n\n  function onend() {\n    if (\n      typeof self[kLine_buffer] === 'string' &&\n        self[kLine_buffer].length > 0\n    ) {\n      self.emit('line'\x2C self[kLine_buffer]);\n    }\n    self.close();\n  }\n\n  function ontermend() {\n    if (typeof self.line === 'string' && self.line.length > 0) {\n      self.emit('line'\x2C self.line);\n    }\n    self.close();\n  }\n\n  function onkeypress(s\x2C key) {\n    self[kTtyWrite](s\x2C key);\n    if (key && key.sequence) {\n      // If the key.sequence is half of a surrogate pair\n      // (>= 0xd800 and <= 0xdfff)\x2C refresh the line so\n      // the character is displayed appropriately.\n      const ch = StringPrototypeCodePointAt(key.sequence\x2C 0);\n      if (ch >= 0xd800 && ch <= 0xdfff) self[kRefreshLine]();\n    }\n  }\n\n  function onresize() {\n    self[kRefreshLine]();\n  }\n\n  this[kLineObjectStream] = undefined;\n\n  input.on('error'\x2C onerror);\n\n  if (!this.terminal) {\n    function onSelfCloseWithoutTerminal() {\n      input.removeListener('data'\x2C ondata);\n      input.removeListener('error'\x2C onerror);\n      input.removeListener('end'\x2C onend);\n    }\n\n    input.on('data'\x2C ondata);\n    input.on('end'\x2C onend);\n    self.once('close'\x2C onSelfCloseWithoutTerminal);\n    this[kDecoder] = new StringDecoder('utf8');\n  } else {\n    function onSelfCloseWithTerminal() {\n      input.removeListener('keypress'\x2C onkeypress);\n      input.removeListener('error'\x2C onerror);\n      input.removeListener('end'\x2C ontermend);\n      if (output !== null && output !== undefined) {\n        output.removeListener('resize'\x2C onresize);\n      }\n    }\n\n    emitKeypressEvents ??= require('internal/readline/emitKeypressEvents');\n    emitKeypressEvents(input\x2C this);\n\n    // `input` usually refers to stdin\n    input.on('keypress'\x2C onkeypress);\n    input.on('end'\x2C ontermend);\n\n    this[kSetRawMode](true);\n    this.terminal = true;\n\n    // Cursor position on the line.\n    this.cursor = 0;\n\n    this.historyIndex = -1;\n\n    if (output !== null && output !== undefined)\n      output.on('resize'\x2C onresize);\n\n    self.once('close'\x2C onSelfCloseWithTerminal);\n  }\n\n  if (signal) {\n    const onAborted = () => self.close();\n    if (signal.aborted) {\n      process.nextTick(onAborted);\n    } else {\n      signal.addEventListener('abort'\x2C onAborted\x2C { once: true });\n      self.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n    }\n  }\n\n  // Current line\n  this.line = '';\n\n  input.resume();\n}\n\nObjectSetPrototypeOf(InterfaceConstructor.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(InterfaceConstructor\x2C EventEmitter);\n\nclass Interface extends InterfaceConstructor {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input\x2C output\x2C completer\x2C terminal) {\n    super(input\x2C output\x2C completer\x2C terminal);\n  }\n  get columns() {\n    if (this.output && this.output.columns) return this.output.columns;\n    return Infinity;\n  }\n\n  /**\n   * Sets the prompt written to the output.\n   * @param {string} prompt\n   * @returns {void}\n   */\n  setPrompt(prompt) {\n    this[kPrompt] = prompt;\n  }\n\n  /**\n   * Returns the current prompt used by `rl.prompt()`.\n   * @returns {string}\n   */\n  getPrompt() {\n    return this[kPrompt];\n  }\n\n  [kSetRawMode](mode) {\n    const wasInRawMode = this.input.isRaw;\n\n    if (typeof this.input.setRawMode === 'function') {\n      this.input.setRawMode(mode);\n    }\n\n    return wasInRawMode;\n  }\n\n  /**\n   * Writes the configured `prompt` to a new line in `output`.\n   * @param {boolean} [preserveCursor]\n   * @returns {void}\n   */\n  prompt(preserveCursor) {\n    if (this.paused) this.resume();\n    if (this.terminal && process.env.TERM !== 'dumb') {\n      if (!preserveCursor) this.cursor = 0;\n      this[kRefreshLine]();\n    } else {\n      this[kWriteToOutput](this[kPrompt]);\n    }\n  }\n\n  question(query\x2C cb) {\n    if (this[kQuestionCallback]) {\n      this.prompt();\n    } else {\n      this[kOldPrompt] = this[kPrompt];\n      this.setPrompt(query);\n      this[kQuestionCallback] = cb;\n      this.prompt();\n    }\n  }\n\n  [kOnLine](line) {\n    if (this[kQuestionCallback]) {\n      const cb = this[kQuestionCallback];\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      cb(line);\n    } else {\n      this.emit('line'\x2C line);\n    }\n  }\n\n  [kBeforeEdit](oldText\x2C oldCursor) {\n    this[kPushToUndoStack](oldText\x2C oldCursor);\n  }\n\n  [kQuestionCancel]() {\n    if (this[kQuestionCallback]) {\n      this[kQuestionCallback] = null;\n      this.setPrompt(this[kOldPrompt]);\n      this.clearLine();\n    }\n  }\n\n  [kWriteToOutput](stringToWrite) {\n    validateString(stringToWrite\x2C 'stringToWrite');\n\n    if (this.output !== null && this.output !== undefined) {\n      this.output.write(stringToWrite);\n    }\n  }\n\n  [kAddHistory]() {\n    if (this.line.length === 0) return '';\n\n    // If the history is disabled then return the line\n    if (this.historySize === 0) return this.line;\n\n    // If the trimmed line is empty then return the line\n    if (StringPrototypeTrim(this.line).length === 0) return this.line;\n\n    if (this.history.length === 0 || this.history[0] !== this.line) {\n      if (this.removeHistoryDuplicates) {\n        // Remove older history line if identical to new one\n        const dupIndex = ArrayPrototypeIndexOf(this.history\x2C this.line);\n        if (dupIndex !== -1) ArrayPrototypeSplice(this.history\x2C dupIndex\x2C 1);\n      }\n\n      ArrayPrototypeUnshift(this.history\x2C this.line);\n\n      // Only store so many\n      if (this.history.length > this.historySize)\n        ArrayPrototypePop(this.history);\n    }\n\n    this.historyIndex = -1;\n\n    // The listener could change the history object\x2C possibly\n    // to remove the last added entry if it is sensitive and should\n    // not be persisted in the history\x2C like a password\n    const line = this.history[0];\n\n    // Emit history event to notify listeners of update\n    this.emit('history'\x2C this.history);\n\n    return line;\n  }\n\n  [kRefreshLine]() {\n    // line length\n    const line = this[kPrompt] + this.line;\n    const dispPos = this[kGetDisplayPos](line);\n    const lineCols = dispPos.cols;\n    const lineRows = dispPos.rows;\n\n    // cursor position\n    const cursorPos = this.getCursorPos();\n\n    // First move to the bottom of the current line\x2C based on cursor pos\n    const prevRows = this.prevRows || 0;\n    if (prevRows > 0) {\n      moveCursor(this.output\x2C 0\x2C -prevRows);\n    }\n\n    // Cursor to left edge.\n    cursorTo(this.output\x2C 0);\n    // erase data\n    clearScreenDown(this.output);\n\n    // Write the prompt and the current buffer content.\n    this[kWriteToOutput](line);\n\n    // Force terminal to allocate a new line\n    if (lineCols === 0) {\n      this[kWriteToOutput](' ');\n    }\n\n    // Move cursor to original position.\n    cursorTo(this.output\x2C cursorPos.cols);\n\n    const diff = lineRows - cursorPos.rows;\n    if (diff > 0) {\n      moveCursor(this.output\x2C 0\x2C -diff);\n    }\n\n    this.prevRows = cursorPos.rows;\n  }\n\n  /**\n   * Closes the `readline.Interface` instance.\n   * @returns {void}\n   */\n  close() {\n    if (this.closed) return;\n    this.pause();\n    if (this.terminal) {\n      this[kSetRawMode](false);\n    }\n    this.closed = true;\n    this.emit('close');\n  }\n\n  /**\n   * Pauses the `input` stream.\n   * @returns {void | Interface}\n   */\n  pause() {\n    if (this.paused) return;\n    this.input.pause();\n    this.paused = true;\n    this.emit('pause');\n    return this;\n  }\n\n  /**\n   * Resumes the `input` stream if paused.\n   * @returns {void | Interface}\n   */\n  resume() {\n    if (!this.paused) return;\n    this.input.resume();\n    this.paused = false;\n    this.emit('resume');\n    return this;\n  }\n\n  /**\n   * Writes either `data` or a `key` sequence identified by\n   * `key` to the `output`.\n   * @param {string} d\n   * @param {{\n   *   ctrl?: boolean;\n   *   meta?: boolean;\n   *   shift?: boolean;\n   *   name?: string;\n   *   }} [key]\n   * @returns {void}\n   */\n  write(d\x2C key) {\n    if (this.paused) this.resume();\n    if (this.terminal) {\n      this[kTtyWrite](d\x2C key);\n    } else {\n      this[kNormalWrite](d);\n    }\n  }\n\n  [kNormalWrite](b) {\n    if (b === undefined) {\n      return;\n    }\n    let string = this[kDecoder].write(b);\n    if (\n      this[kSawReturnAt] &&\n      DateNow() - this[kSawReturnAt] <= this.crlfDelay\n    ) {\n      string = StringPrototypeReplace(string\x2C /^\\n/\x2C '');\n      this[kSawReturnAt] = 0;\n    }\n\n    // Run test() on the new string chunk\x2C not on the entire line buffer.\n    const newPartContainsEnding = RegExpPrototypeTest(lineEnding\x2C string);\n\n    if (this[kLine_buffer]) {\n      string = this[kLine_buffer] + string;\n      this[kLine_buffer] = null;\n    }\n    if (newPartContainsEnding) {\n      this[kSawReturnAt] = StringPrototypeEndsWith(string\x2C '\\r') ?\n        DateNow() :\n        0;\n\n      // Got one or more newlines; process into "line" events\n      const lines = StringPrototypeSplit(string\x2C lineEnding);\n      // Either '' or (conceivably) the unfinished portion of the next line\n      string = ArrayPrototypePop(lines);\n      this[kLine_buffer] = string;\n      for (let n = 0; n < lines.length; n++) this[kOnLine](lines[n]);\n    } else if (string) {\n      // No newlines this time\x2C save what we have for next time\n      this[kLine_buffer] = string;\n    }\n  }\n\n  [kInsertString](c) {\n    this[kBeforeEdit](this.line\x2C this.cursor);\n    if (this.cursor < this.line.length) {\n      const beg = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n      const end = StringPrototypeSlice(\n        this.line\x2C\n        this.cursor\x2C\n        this.line.length\n      );\n      this.line = beg + c + end;\n      this.cursor += c.length;\n      this[kRefreshLine]();\n    } else {\n      const oldPos = this.getCursorPos();\n      this.line += c;\n      this.cursor += c.length;\n      const newPos = this.getCursorPos();\n\n      if (oldPos.rows < newPos.rows) {\n        this[kRefreshLine]();\n      } else {\n        this[kWriteToOutput](c);\n      }\n    }\n  }\n\n  async [kTabComplete](lastKeypressWasTab) {\n    this.pause();\n    const string = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n    let value;\n    try {\n      value = await this.completer(string);\n    } catch (err) {\n      this[kWriteToOutput](`Tab completion error: ${inspect(err)}`);\n      return;\n    } finally {\n      this.resume();\n    }\n    this[kTabCompleter](lastKeypressWasTab\x2C value);\n  }\n\n  [kTabCompleter](lastKeypressWasTab\x2C { 0: completions\x2C 1: completeOn }) {\n    // Result and the text that was completed.\n\n    if (!completions || completions.length === 0) {\n      return;\n    }\n\n    // If there is a common prefix to all matches\x2C then apply that portion.\n    const prefix = commonPrefix(\n      ArrayPrototypeFilter(completions\x2C (e) => e !== '')\n    );\n    if (StringPrototypeStartsWith(prefix\x2C completeOn) &&\n        prefix.length > completeOn.length) {\n      this[kInsertString](StringPrototypeSlice(prefix\x2C completeOn.length));\n      return;\n    } else if (!StringPrototypeStartsWith(completeOn\x2C prefix)) {\n      this.line = StringPrototypeSlice(this.line\x2C\n                                       0\x2C\n                                       this.cursor - completeOn.length) +\n                  prefix +\n                  StringPrototypeSlice(this.line\x2C\n                                       this.cursor\x2C\n                                       this.line.length);\n      this.cursor = this.cursor - completeOn.length + prefix.length;\n      this._refreshLine();\n      return;\n    }\n\n    if (!lastKeypressWasTab) {\n      return;\n    }\n\n    this[kBeforeEdit](this.line\x2C this.cursor);\n\n    // Apply/show completions.\n    const completionsWidth = ArrayPrototypeMap(completions\x2C (e) =>\n      getStringWidth(e)\n    );\n    const width = MathMaxApply(completionsWidth) + 2; // 2 space padding\n    let maxColumns = MathFloor(this.columns / width) || 1;\n    if (maxColumns === Infinity) {\n      maxColumns = 1;\n    }\n    let output = '\\r\\n';\n    let lineIndex = 0;\n    let whitespace = 0;\n    for (let i = 0; i < completions.length; i++) {\n      const completion = completions[i];\n      if (completion === '' || lineIndex === maxColumns) {\n        output += '\\r\\n';\n        lineIndex = 0;\n        whitespace = 0;\n      } else {\n        output += StringPrototypeRepeat(' '\x2C whitespace);\n      }\n      if (completion !== '') {\n        output += completion;\n        whitespace = width - completionsWidth[i];\n        lineIndex++;\n      } else {\n        output += '\\r\\n';\n      }\n    }\n    if (lineIndex !== 0) {\n      output += '\\r\\n\\r\\n';\n    }\n    this[kWriteToOutput](output);\n    this[kRefreshLine]();\n  }\n\n  [kWordLeft]() {\n    if (this.cursor > 0) {\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      const leading = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n      const reversed = ArrayPrototypeJoin(\n        ArrayPrototypeReverse(ArrayFrom(leading))\x2C\n        ''\n      );\n      const match = StringPrototypeMatch(reversed\x2C /^\\s*(?:[^\\w\\s]+|\\w+)?/);\n      this[kMoveCursor](-match[0].length);\n    }\n  }\n\n  [kWordRight]() {\n    if (this.cursor < this.line.length) {\n      const trailing = StringPrototypeSlice(this.line\x2C this.cursor);\n      const match = StringPrototypeMatch(trailing\x2C /^(?:\\s+|[^\\w\\s]+|\\w+)\\s*/);\n      this[kMoveCursor](match[0].length);\n    }\n  }\n\n  [kDeleteLeft]() {\n    if (this.cursor > 0 && this.line.length > 0) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      const charSize = charLengthLeft(this.line\x2C this.cursor);\n      this.line =\n        StringPrototypeSlice(this.line\x2C 0\x2C this.cursor - charSize) +\n        StringPrototypeSlice(this.line\x2C this.cursor\x2C this.line.length);\n\n      this.cursor -= charSize;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      // The number of UTF-16 units comprising the character to the left\n      const charSize = charLengthAt(this.line\x2C this.cursor);\n      this.line =\n        StringPrototypeSlice(this.line\x2C 0\x2C this.cursor) +\n        StringPrototypeSlice(\n          this.line\x2C\n          this.cursor + charSize\x2C\n          this.line.length\n        );\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordLeft]() {\n    if (this.cursor > 0) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      // Reverse the string and match a word near beginning\n      // to avoid quadratic time complexity\n      let leading = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n      const reversed = ArrayPrototypeJoin(\n        ArrayPrototypeReverse(ArrayFrom(leading))\x2C\n        ''\n      );\n      const match = StringPrototypeMatch(reversed\x2C /^\\s*(?:[^\\w\\s]+|\\w+)?/);\n      leading = StringPrototypeSlice(\n        leading\x2C\n        0\x2C\n        leading.length - match[0].length\n      );\n      this.line =\n        leading +\n        StringPrototypeSlice(this.line\x2C this.cursor\x2C this.line.length);\n      this.cursor = leading.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteWordRight]() {\n    if (this.cursor < this.line.length) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      const trailing = StringPrototypeSlice(this.line\x2C this.cursor);\n      const match = StringPrototypeMatch(trailing\x2C /^(?:\\s+|\\W+|\\w+)\\s*/);\n      this.line =\n        StringPrototypeSlice(this.line\x2C 0\x2C this.cursor) +\n        StringPrototypeSlice(trailing\x2C match[0].length);\n      this[kRefreshLine]();\n    }\n  }\n\n  [kDeleteLineLeft]() {\n    this[kBeforeEdit](this.line\x2C this.cursor);\n    const del = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n    this.line = StringPrototypeSlice(this.line\x2C this.cursor);\n    this.cursor = 0;\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kDeleteLineRight]() {\n    this[kBeforeEdit](this.line\x2C this.cursor);\n    const del = StringPrototypeSlice(this.line\x2C this.cursor);\n    this.line = StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n    this[kPushToKillRing](del);\n    this[kRefreshLine]();\n  }\n\n  [kPushToKillRing](del) {\n    if (!del || del === this[kKillRing][0]) return;\n    ArrayPrototypeUnshift(this[kKillRing]\x2C del);\n    this[kKillRingCursor] = 0;\n    while (this[kKillRing].length > kMaxLengthOfKillRing)\n      ArrayPrototypePop(this[kKillRing]);\n  }\n\n  [kYank]() {\n    if (this[kKillRing].length > 0) {\n      this[kYanking] = true;\n      this[kInsertString](this[kKillRing][this[kKillRingCursor]]);\n    }\n  }\n\n  [kYankPop]() {\n    if (!this[kYanking]) {\n      return;\n    }\n    if (this[kKillRing].length > 1) {\n      const lastYank = this[kKillRing][this[kKillRingCursor]];\n      this[kKillRingCursor]++;\n      if (this[kKillRingCursor] >= this[kKillRing].length) {\n        this[kKillRingCursor] = 0;\n      }\n      const currentYank = this[kKillRing][this[kKillRingCursor]];\n      const head =\n            StringPrototypeSlice(this.line\x2C 0\x2C this.cursor - lastYank.length);\n      const tail =\n            StringPrototypeSlice(this.line\x2C this.cursor);\n      this.line = head + currentYank + tail;\n      this.cursor = head.length + currentYank.length;\n      this[kRefreshLine]();\n    }\n  }\n\n  clearLine() {\n    this[kMoveCursor](+Infinity);\n    this[kWriteToOutput]('\\r\\n');\n    this.line = '';\n    this.cursor = 0;\n    this.prevRows = 0;\n  }\n\n  [kLine]() {\n    const line = this[kAddHistory]();\n    this[kUndoStack] = [];\n    this[kRedoStack] = [];\n    this.clearLine();\n    this[kOnLine](line);\n  }\n\n  [kPushToUndoStack](text\x2C cursor) {\n    if (ArrayPrototypePush(this[kUndoStack]\x2C { text\x2C cursor }) >\n        kMaxUndoRedoStackSize) {\n      ArrayPrototypeShift(this[kUndoStack]);\n    }\n  }\n\n  [kUndo]() {\n    if (this[kUndoStack].length <= 0) return;\n\n    ArrayPrototypePush(\n      this[kRedoStack]\x2C\n      { text: this.line\x2C cursor: this.cursor }\x2C\n    );\n\n    const entry = ArrayPrototypePop(this[kUndoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  [kRedo]() {\n    if (this[kRedoStack].length <= 0) return;\n\n    ArrayPrototypePush(\n      this[kUndoStack]\x2C\n      { text: this.line\x2C cursor: this.cursor }\x2C\n    );\n\n    const entry = ArrayPrototypePop(this[kRedoStack]);\n    this.line = entry.text;\n    this.cursor = entry.cursor;\n\n    this[kRefreshLine]();\n  }\n\n  // TODO(BridgeAR): Add underscores to the search part and a red background in\n  // case no match is found. This should only be the visual part and not the\n  // actual line content!\n  // TODO(BridgeAR): In case the substring based search is active and the end is\n  // reached\x2C show a comment how to search the history as before. E.g.\x2C using\n  // <ctrl> + N. Only show this after two/three UPs or DOWNs\x2C not on the first\n  // one.\n  [kHistoryNext]() {\n    if (this.historyIndex >= 0) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      const search = this[kSubstringSearch] || '';\n      let index = this.historyIndex - 1;\n      while (\n        index >= 0 &&\n        (!StringPrototypeStartsWith(this.history[index]\x2C search) ||\n          this.line === this.history[index])\n      ) {\n        index--;\n      }\n      if (index === -1) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  [kHistoryPrev]() {\n    if (this.historyIndex < this.history.length && this.history.length) {\n      this[kBeforeEdit](this.line\x2C this.cursor);\n      const search = this[kSubstringSearch] || '';\n      let index = this.historyIndex + 1;\n      while (\n        index < this.history.length &&\n        (!StringPrototypeStartsWith(this.history[index]\x2C search) ||\n          this.line === this.history[index])\n      ) {\n        index++;\n      }\n      if (index === this.history.length) {\n        this.line = search;\n      } else {\n        this.line = this.history[index];\n      }\n      this.historyIndex = index;\n      this.cursor = this.line.length; // Set cursor to end of line.\n      this[kRefreshLine]();\n    }\n  }\n\n  // Returns the last character's display position of the given string\n  [kGetDisplayPos](str) {\n    let offset = 0;\n    const col = this.columns;\n    let rows = 0;\n    str = stripVTControlCharacters(str);\n    for (const char of new SafeStringIterator(str)) {\n      if (char === '\\n') {\n        // Rows must be incremented by 1 even if offset = 0 or col = +Infinity.\n        rows += MathCeil(offset / col) || 1;\n        offset = 0;\n        continue;\n      }\n      // Tabs must be aligned by an offset of the tab size.\n      if (char === '\\t') {\n        offset += this.tabSize - (offset % this.tabSize);\n        continue;\n      }\n      const width = getStringWidth(char\x2C false /* stripVTControlCharacters */);\n      if (width === 0 || width === 1) {\n        offset += width;\n      } else {\n        // width === 2\n        if ((offset + 1) % col === 0) {\n          offset++;\n        }\n        offset += 2;\n      }\n    }\n    const cols = offset % col;\n    rows += (offset - cols) / col;\n    return { cols\x2C rows };\n  }\n\n  /**\n   * Returns the real position of the cursor in relation\n   * to the input prompt + string.\n   * @returns {{\n   *   rows: number;\n   *   cols: number;\n   *   }}\n   */\n  getCursorPos() {\n    const strBeforeCursor =\n      this[kPrompt] + StringPrototypeSlice(this.line\x2C 0\x2C this.cursor);\n    return this[kGetDisplayPos](strBeforeCursor);\n  }\n\n  // This function moves cursor dx places to the right\n  // (-dx for left) and refreshes the line if it is needed.\n  [kMoveCursor](dx) {\n    if (dx === 0) {\n      return;\n    }\n    const oldPos = this.getCursorPos();\n    this.cursor += dx;\n\n    // Bounds check\n    if (this.cursor < 0) {\n      this.cursor = 0;\n    } else if (this.cursor > this.line.length) {\n      this.cursor = this.line.length;\n    }\n\n    const newPos = this.getCursorPos();\n\n    // Check if cursor stayed on the line.\n    if (oldPos.rows === newPos.rows) {\n      const diffWidth = newPos.cols - oldPos.cols;\n      moveCursor(this.output\x2C diffWidth\x2C 0);\n    } else {\n      this[kRefreshLine]();\n    }\n  }\n\n  // Handle a write from the tty\n  [kTtyWrite](s\x2C key) {\n    const previousKey = this[kPreviousKey];\n    key = key || {};\n    this[kPreviousKey] = key;\n\n    if (!key.meta || key.name !== 'y') {\n      // Reset yanking state unless we are doing yank pop.\n      this[kYanking] = false;\n    }\n\n    // Activate or deactivate substring search.\n    if (\n      (key.name === 'up' || key.name === 'down') &&\n      !key.ctrl &&\n      !key.meta &&\n      !key.shift\n    ) {\n      if (this[kSubstringSearch] === null) {\n        this[kSubstringSearch] = StringPrototypeSlice(\n          this.line\x2C\n          0\x2C\n          this.cursor\n        );\n      }\n    } else if (this[kSubstringSearch] !== null) {\n      this[kSubstringSearch] = null;\n      // Reset the index in case there's no match.\n      if (this.history.length === this.historyIndex) {\n        this.historyIndex = -1;\n      }\n    }\n\n    // Undo & Redo\n    if (typeof key.sequence === 'string') {\n      switch (StringPrototypeCodePointAt(key.sequence\x2C 0)) {\n        case 0x1f:\n          this[kUndo]();\n          return;\n        case 0x1e:\n          this[kRedo]();\n          return;\n        default:\n          break;\n      }\n    }\n\n    // Ignore escape key\x2C fixes\n    // https://github.com/nodejs/node-v0.x-archive/issues/2876.\n    if (key.name === 'escape') return;\n\n    if (key.ctrl && key.shift) {\n      /* Control and shift pressed */\n      switch (key.name) {\n        // TODO(BridgeAR): The transmitted escape sequence is `\\b` and that is\n        // identical to <ctrl>-h. It should have a unique escape sequence.\n        case 'backspace':\n          this[kDeleteLineLeft]();\n          break;\n\n        case 'delete':\n          this[kDeleteLineRight]();\n          break;\n      }\n    } else if (key.ctrl) {\n      /* Control key pressed */\n\n      switch (key.name) {\n        case 'c':\n          if (this.listenerCount('SIGINT') > 0) {\n            this.emit('SIGINT');\n          } else {\n            // This readline instance is finished\n            this.close();\n          }\n          break;\n\n        case 'h': // delete left\n          this[kDeleteLeft]();\n          break;\n\n        case 'd': // delete right or EOF\n          if (this.cursor === 0 && this.line.length === 0) {\n            // This readline instance is finished\n            this.close();\n          } else if (this.cursor < this.line.length) {\n            this[kDeleteRight]();\n          }\n          break;\n\n        case 'u': // Delete from current to start of line\n          this[kDeleteLineLeft]();\n          break;\n\n        case 'k': // Delete from current to end of line\n          this[kDeleteLineRight]();\n          break;\n\n        case 'a': // Go to the start of the line\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case 'e': // Go to the end of the line\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case 'b': // back one character\n          this[kMoveCursor](-charLengthLeft(this.line\x2C this.cursor));\n          break;\n\n        case 'f': // Forward one character\n          this[kMoveCursor](+charLengthAt(this.line\x2C this.cursor));\n          break;\n\n        case 'l': // Clear the whole screen\n          cursorTo(this.output\x2C 0\x2C 0);\n          clearScreenDown(this.output);\n          this[kRefreshLine]();\n          break;\n\n        case 'n': // next history item\n          this[kHistoryNext]();\n          break;\n\n        case 'p': // Previous history item\n          this[kHistoryPrev]();\n          break;\n\n        case 'y': // Yank killed string\n          this[kYank]();\n          break;\n\n        case 'z':\n          if (process.platform === 'win32') break;\n          if (this.listenerCount('SIGTSTP') > 0) {\n            this.emit('SIGTSTP');\n          } else {\n            process.once('SIGCONT'\x2C () => {\n              // Don't raise events if stream has already been abandoned.\n              if (!this.paused) {\n                // Stream must be paused and resumed after SIGCONT to catch\n                // SIGINT\x2C SIGTSTP\x2C and EOF.\n                this.pause();\n                this.emit('SIGCONT');\n              }\n              // Explicitly re-enable "raw mode" and move the cursor to\n              // the correct position.\n              // See https://github.com/joyent/node/issues/3295.\n              this[kSetRawMode](true);\n              this[kRefreshLine]();\n            });\n            this[kSetRawMode](false);\n            process.kill(process.pid\x2C 'SIGTSTP');\n          }\n          break;\n\n        case 'w': // Delete backwards to a word boundary\n        // TODO(BridgeAR): The transmitted escape sequence is `\\b` and that is\n        // identical to <ctrl>-h. It should have a unique escape sequence.\n        // Falls through\n        case 'backspace':\n          this[kDeleteWordLeft]();\n          break;\n\n        case 'delete': // Delete forward to a word boundary\n          this[kDeleteWordRight]();\n          break;\n\n        case 'left':\n          this[kWordLeft]();\n          break;\n\n        case 'right':\n          this[kWordRight]();\n          break;\n      }\n    } else if (key.meta) {\n      /* Meta key pressed */\n\n      switch (key.name) {\n        case 'b': // backward word\n          this[kWordLeft]();\n          break;\n\n        case 'f': // forward word\n          this[kWordRight]();\n          break;\n\n        case 'd': // delete forward word\n        case 'delete':\n          this[kDeleteWordRight]();\n          break;\n\n        case 'backspace': // Delete backwards to a word boundary\n          this[kDeleteWordLeft]();\n          break;\n\n        case 'y': // Doing yank pop\n          this[kYankPop]();\n          break;\n      }\n    } else {\n      /* No modifier keys used */\n\n      // \\r bookkeeping is only relevant if a \\n comes right after.\n      if (this[kSawReturnAt] && key.name !== 'enter') this[kSawReturnAt] = 0;\n\n      switch (key.name) {\n        case 'return': // Carriage return\x2C i.e. \\r\n          this[kSawReturnAt] = DateNow();\n          this[kLine]();\n          break;\n\n        case 'enter':\n          // When key interval > crlfDelay\n          if (\n            this[kSawReturnAt] === 0 ||\n            DateNow() - this[kSawReturnAt] > this.crlfDelay\n          ) {\n            this[kLine]();\n          }\n          this[kSawReturnAt] = 0;\n          break;\n\n        case 'backspace':\n          this[kDeleteLeft]();\n          break;\n\n        case 'delete':\n          this[kDeleteRight]();\n          break;\n\n        case 'left':\n          // Obtain the code point to the left\n          this[kMoveCursor](-charLengthLeft(this.line\x2C this.cursor));\n          break;\n\n        case 'right':\n          this[kMoveCursor](+charLengthAt(this.line\x2C this.cursor));\n          break;\n\n        case 'home':\n          this[kMoveCursor](-Infinity);\n          break;\n\n        case 'end':\n          this[kMoveCursor](+Infinity);\n          break;\n\n        case 'up':\n          this[kHistoryPrev]();\n          break;\n\n        case 'down':\n          this[kHistoryNext]();\n          break;\n\n        case 'tab':\n          // If tab completion enabled\x2C do that...\n          if (\n            typeof this.completer === 'function' &&\n            this.isCompletionEnabled\n          ) {\n            const lastKeypressWasTab =\n              previousKey && previousKey.name === 'tab';\n            this[kTabComplete](lastKeypressWasTab);\n            break;\n          }\n        // falls through\n        default:\n          if (typeof s === 'string' && s) {\n            const lines = StringPrototypeSplit(s\x2C /\\r\\n|\\n|\\r/);\n            for (let i = 0\x2C len = lines.length; i < len; i++) {\n              if (i > 0) {\n                this[kLine]();\n              }\n              this[kInsertString](lines[i]);\n            }\n          }\n      }\n    }\n  }\n\n  /**\n   * Creates an `AsyncIterator` object that iterates through\n   * each line in the input stream as a string.\n   * @typedef {{\n   *   [Symbol.asyncIterator]: () => InterfaceAsyncIterator\x2C\n   *   next: () => Promise<string>\n   * }} InterfaceAsyncIterator\n   * @returns {InterfaceAsyncIterator}\n   */\n  [SymbolAsyncIterator]() {\n    if (this[kLineObjectStream] === undefined) {\n      if (Readable === undefined) {\n        Readable = require('stream').Readable;\n      }\n      const readable = new Readable({\n        objectMode: true\x2C\n        read: () => {\n          this.resume();\n        }\x2C\n        destroy: (err\x2C cb) => {\n          this.off('line'\x2C lineListener);\n          this.off('close'\x2C closeListener);\n          this.close();\n          cb(err);\n        }\x2C\n      });\n      const lineListener = (input) => {\n        if (!readable.push(input)) {\n          // TODO(rexagod): drain to resume flow\n          this.pause();\n        }\n      };\n      const closeListener = () => {\n        readable.push(null);\n      };\n      const errorListener = (err) => {\n        readable.destroy(err);\n      };\n      this.on('error'\x2C errorListener);\n      this.on('line'\x2C lineListener);\n      this.on('close'\x2C closeListener);\n      this[kLineObjectStream] = readable;\n    }\n\n    return this[kLineObjectStream][SymbolAsyncIterator]();\n  }\n}\n\nmodule.exports = {\n  Interface\x2C\n  InterfaceConstructor\x2C\n  kAddHistory\x2C\n  kDecoder\x2C\n  kDeleteLeft\x2C\n  kDeleteLineLeft\x2C\n  kDeleteLineRight\x2C\n  kDeleteRight\x2C\n  kDeleteWordLeft\x2C\n  kDeleteWordRight\x2C\n  kGetDisplayPos\x2C\n  kHistoryNext\x2C\n  kHistoryPrev\x2C\n  kInsertString\x2C\n  kLine\x2C\n  kLine_buffer\x2C\n  kMoveCursor\x2C\n  kNormalWrite\x2C\n  kOldPrompt\x2C\n  kOnLine\x2C\n  kPreviousKey\x2C\n  kPrompt\x2C\n  kQuestionCallback\x2C\n  kQuestionCancel\x2C\n  kRefreshLine\x2C\n  kSawKeyPress\x2C\n  kSawReturnAt\x2C\n  kSetRawMode\x2C\n  kTabComplete\x2C\n  kTabCompleter\x2C\n  kTtyWrite\x2C\n  kWordLeft\x2C\n  kWordRight\x2C\n  kWriteToOutput\x2C\n};\n
code-source-info,0x1208b72b60e,203,0,38563,C0O0C4O38563,,
code-creation,Function,10,155500,0x1208b72e1b6,1837, node:internal/readline/interface:1:1,0x1208b72b588,~
code-source-info,0x1208b72e1b6,203,0,38563,C0O0C318O25C324O38C330O62C336O87C342O109C348O130C354O151C360O173C366O198C372O222C378O245C384O270C390O281C396O306C402O318C408O331C414O342C420O358C426O376C432O391C437O415C443O438C449O468C455O495C461O519C467O544C473O570C479O594C485O618C491O647C497O670C502O680C508O703C514O759C520O759C525O749C530O796C536O917C542O917C547O839C553O862C559O879C565O897C571O1018C577O1018C582O959C588O970C594O988C600O1073C606O1073C610O1073C612O1174C618O1174C623O1102C629O1118C635O1136C641O1152C647O1214C648O1214C650O1291C656O1291C661O1244C667O1263C673O1275C679O1358C685O1358C690O1340C696O1437C697O1437C699O1469C701O1469C703O1503C707O1503C709O1531C711O1531C713O1610C717O1610C719O1655C722O1655C726O1655C728O1709C731O1709C736O1825C740O1825C742O1891C744O1891C746O1916C749O1916C753O1916C755O1959C758O1959C762O1959C764O1999C767O1999C771O1999C773O2039C776O2039C780O2039C782O2086C785O2086C789O2086C791O2138C794O2138C798O2138C800O2187C803O2187C807O2187C809O2235C812O2235C816O2235C818O2287C821O2287C825O2287C827O2338C830O2338C834O2338C836O2385C839O2385C843O2385C845O2430C848O2430C852O2430C854O2476C857O2476C861O2476C863O2515C866O2515C870O2515C872O2553C875O2553C879O2553C881O2595C884O2595C888O2595C890O2640C893O2640C897O2640C899O2687C902O2687C906O2687C908O2731C911O2731C915O2731C917O2774C920O2774C924O2774C926O2812C929O2812C933O2812C935O2852C938O2852C942O2852C944O2892C947O2892C951O2892C953O2935C956O2935C960O2935C962O2987C965O2987C969O2987C971O3041C974O3041C978O3041C980O3084C983O3084C987O3084C989O3120C992O3120C996O3120C998O3163C1001O3163C1005O3163C1007O3208C1010O3208C1014O3208C1016O3253C1019O3253C1023O3253C1025O3297C1028O3297C1032O3297C1034O3341C1037O3341C1041O3341C1043O3387C1046O3387C1050O3387C1052O3430C1055O3430C1059O3430C1061O3465C1064O3465C1068O3465C1070O3501C1073O3501C1077O3501C1079O3541C1082O3541C1086O3541C1088O3581C1091O3581C1095O3581C1097O3626C1100O3626C1104O3626C1106O3666C1109O3666C1113O3666C1115O3700C1118O3700C1122O3700C1124O3737C1127O3737C1131O3737C1133O9464C1141O9488C1146O9422C1151O9500C1154O9500C1159O9583C1182O10178C1203O10996C1213O11242C1221O11333C1233O11505C1243O11706C1253O12888C1287O15022C1297O16204C1307O16882C1317O17279C1327O19489C1337O19954C1347O20217C1357O20703C1367O21187C1377O21950C1387O22382C1397O22664C1407O22926C1417O23190C1427O23349C1443O24181C1453O24339C1463O24530C1473O24842C1483O25585C1493O26223C1503O27006C1519O28411C1529O29005C1539O36978C1564O37999C1571O38020C1577O38033C1583O38057C1589O38072C1595O38084C1601O38099C1607O38118C1613O38138C1619O38154C1625O38173C1631O38193C1637O38211C1643O38227C1649O38243C1655O38260C1661O38269C1667O38285C1673O38300C1679O38316C1685O38330C1691O38341C1697O38357C1707O38368C1717O38389C1727O38408C1737O38424C1747O38440C1757O38456C1767O38471C1777O38487C1787O38504C1797O38517C1807O38530C1817O38544C1827O38014C1836O38562,,
tick,0x1bfd39474,155625,1,0x10041f4d8,3,0x0,0x105108c5c,0x10510894c,0x1208b729ce8,0x105108d28,0x10510894c,0x1208b724170,0x105108d28,0x105115cac,0x105112d34,0x1051186b8,0x1051128a8,0x105113c1c,0x1208b72025e,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x105118954,0x1051128a8,0x105113c1c,0x2cbd764a6ea0,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,Eval,10,155750,0x1208b732656,5, node:readline/promises:1:1,0x1208b732478,~
script-source,204,node:readline/promises,'use strict';\n\nconst {\n  Promise\x2C\n} = primordials;\n\nconst {\n  Readline\x2C\n} = require('internal/readline/promises');\n\nconst {\n  Interface: _Interface\x2C\n  kQuestionCancel\x2C\n} = require('internal/readline/interface');\n\nconst {\n  AbortError\x2C\n} = require('internal/errors');\nconst { validateAbortSignal } = require('internal/validators');\n\nclass Interface extends _Interface {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(input\x2C output\x2C completer\x2C terminal) {\n    super(input\x2C output\x2C completer\x2C terminal);\n  }\n  question(query\x2C options = {}) {\n    return new Promise((resolve\x2C reject) => {\n      let cb = resolve;\n\n      if (options?.signal) {\n        validateAbortSignal(options.signal\x2C 'options.signal');\n        if (options.signal.aborted) {\n          return reject(\n            new AbortError(undefined\x2C { cause: options.signal.reason }));\n        }\n\n        const onAbort = () => {\n          this[kQuestionCancel]();\n          reject(new AbortError(undefined\x2C { cause: options.signal.reason }));\n        };\n        options.signal.addEventListener('abort'\x2C onAbort\x2C { once: true });\n        cb = (answer) => {\n          options.signal.removeEventListener('abort'\x2C onAbort);\n          resolve(answer);\n        };\n      }\n\n      super.question(query\x2C cb);\n    });\n  }\n}\n\nfunction createInterface(input\x2C output\x2C completer\x2C terminal) {\n  return new Interface(input\x2C output\x2C completer\x2C terminal);\n}\n\nmodule.exports = {\n  Interface\x2C\n  Readline\x2C\n  createInterface\x2C\n};\n
code-source-info,0x1208b732656,204,0,1480,C0O0C4O1480,,
code-creation,Function,10,155792,0x1208b7329ee,161, node:readline/promises:1:1,0x1208b7325d0,~
code-source-info,0x1208b7329ee,204,0,1480,C0O0C25O25C31O76C34O76C39O62C44O172C47O172C52O137C57O151C63O239C66O239C71O223C77O299C80O299C85O275C95O356C128O332C130O1414C137O1435C143O1448C149O1460C155O1429C160O1479,,
code-creation,Eval,10,155875,0x1208b7331ee,5, node:internal/readline/promises:1:1,0x1208b732f30,~
script-source,205,node:internal/readline/promises,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  Promise\x2C\n} = primordials;\n\nconst { CSI } = require('internal/readline/utils');\nconst { validateBoolean\x2C validateInteger } = require('internal/validators');\nconst { isWritable } = require('internal/streams/utils');\nconst { codes: { ERR_INVALID_ARG_TYPE } } = require('internal/errors');\n\nconst {\n  kClearToLineBeginning\x2C\n  kClearToLineEnd\x2C\n  kClearLine\x2C\n  kClearScreenDown\x2C\n} = CSI;\n\nclass Readline {\n  #autoCommit = false;\n  #stream;\n  #todo = [];\n\n  constructor(stream\x2C options = undefined) {\n    if (!isWritable(stream))\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'Writable'\x2C stream);\n    this.#stream = stream;\n    if (options?.autoCommit != null) {\n      validateBoolean(options.autoCommit\x2C 'options.autoCommit');\n      this.#autoCommit = options.autoCommit;\n    }\n  }\n\n  /**\n   * Moves the cursor to the x and y coordinate on the given stream.\n   * @param {integer} x\n   * @param {integer} [y]\n   * @returns {Readline} this\n   */\n  cursorTo(x\x2C y = undefined) {\n    validateInteger(x\x2C 'x');\n    if (y != null) validateInteger(y\x2C 'y');\n\n    const data = y == null ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;\n    if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n    else ArrayPrototypePush(this.#todo\x2C data);\n\n    return this;\n  }\n\n  /**\n   * Moves the cursor relative to its current location.\n   * @param {integer} dx\n   * @param {integer} dy\n   * @returns {Readline} this\n   */\n  moveCursor(dx\x2C dy) {\n    if (dx || dy) {\n      validateInteger(dx\x2C 'dx');\n      validateInteger(dy\x2C 'dy');\n\n      let data = '';\n\n      if (dx < 0) {\n        data += CSI`${-dx}D`;\n      } else if (dx > 0) {\n        data += CSI`${dx}C`;\n      }\n\n      if (dy < 0) {\n        data += CSI`${-dy}A`;\n      } else if (dy > 0) {\n        data += CSI`${dy}B`;\n      }\n      if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n      else ArrayPrototypePush(this.#todo\x2C data);\n    }\n    return this;\n  }\n\n  /**\n   * Clears the current line the cursor is on.\n   * @param {-1|0|1} dir Direction to clear:\n   *   -1 for left of the cursor\n   *   +1 for right of the cursor\n   *    0 for the entire line\n   * @returns {Readline} this\n   */\n  clearLine(dir) {\n    validateInteger(dir\x2C 'dir'\x2C -1\x2C 1);\n\n    const data =\n      dir < 0 ? kClearToLineBeginning :\n        dir > 0 ? kClearToLineEnd :\n          kClearLine;\n    if (this.#autoCommit) process.nextTick(() => this.#stream.write(data));\n    else ArrayPrototypePush(this.#todo\x2C data);\n    return this;\n  }\n\n  /**\n   * Clears the screen from the current position of the cursor down.\n   * @returns {Readline} this\n   */\n  clearScreenDown() {\n    if (this.#autoCommit) {\n      process.nextTick(() => this.#stream.write(kClearScreenDown));\n    } else {\n      ArrayPrototypePush(this.#todo\x2C kClearScreenDown);\n    }\n    return this;\n  }\n\n  /**\n   * Sends all the pending actions to the associated `stream` and clears the\n   * internal list of pending actions.\n   * @returns {Promise<void>} Resolves when all pending actions have been\n   * flushed to the associated `stream`.\n   */\n  commit() {\n    return new Promise((resolve) => {\n      this.#stream.write(ArrayPrototypeJoin(this.#todo\x2C '')\x2C resolve);\n      this.#todo = [];\n    });\n  }\n\n  /**\n   * Clears the internal list of pending actions without sending it to the\n   * associated `stream`.\n   * @returns {Readline} this\n   */\n  rollback() {\n    this.#todo = [];\n    return this;\n  }\n}\n\nmodule.exports = {\n  Readline\x2C\n};\n
code-source-info,0x1208b7331ee,205,0,3509,C0O0C4O3509,,
code-creation,Function,10,156042,0x1208b7337d6,282, node:internal/readline/promises:1:1,0x1208b733168,~
code-source-info,0x1208b7337d6,205,0,3509,C0O0C45O25C51O47C57O69C63O112C66O112C71O104C77O193C80O193C85O156C91O173C97O248C100O248C105O233C111O327C114O327C119O327C124O300C130O446C133O366C139O391C145O410C151O424C263O3475C270O3496C276O3490C281O3508,,
code-creation,Function,10,156042,0x1208b7339ae,36,<instance_members_initializer> node:internal/readline/promises:22:3,0x1208b733450,~
code-source-info,0x1208b7339ae,205,471,515,C3O485C26O513C35O515,,
code-creation,LazyCompile,10,156167,0x1208b734706,16,get node:events:222:6,0x232faba26448,~
code-source-info,0x1208b734706,23,6682,6735,C0O6691C3O6711C10O6721C12O6720C15O6731,,
code-creation,LazyCompile,10,156209,0x1208b735066,181,lazyEventEmitterAsyncResource node:events:91:39,0x232faba25a60,~
code-source-info,0x1208b735066,23,2840,6112,C0O2847C6O2877C19O2934C27O2934C32O2912C37O2985C47O2985C51O2985C53O3037C63O3037C67O3037C69O3118C96O3067C98O3709C110O3783C166O3735C176O6077C180O6110,,
tick,0x1bfd3cab0,156250,0,0x0,3,0x0,0x100d4d654,0x10510c9c8,0x10510b8cc,0x105115470,0x1003a57dc,0x1051159f0,0x105115e88,0x105112d34,0x1051186b8,0x1051128a8,0x105113c1c,0x1208b72027d,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x105118954,0x1051128a8,0x105113c1c,0x2cbd764a6ea0,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,156250,0x1208b7353f6,5,get node:events:264:16,0x232faba26588,~
code-source-info,0x1208b7353f6,23,7780,7820,C0O7789C4O7816,,
code-creation,LazyCompile,10,156292,0x1208b73549e,19,_events /Users/vignesh/Projects/HTTP2/lib/cli.js:11:1,0x1208b71ef48,~
code-source-info,0x1208b73549e,198,179,179,C0O179C5O179C13O179C18O179,,
code-creation,Function,11,156292,0x10511d4c0,184,EventEmitter node:events:208:22,0x232faba263a0,^
code-source-info,0x10511d4c0,23,6267,6315,,,
code-creation,Function,11,156292,0x10511d5e0,360, node:zlib:804:3,0x1208b715278,^
code-source-info,0x10511d5e0,197,24436,24523,,,
code-creation,Function,11,156334,0x10511d7c0,288,createConvenienceMethod node:zlib:787:33,0x1208b714a58,^
code-source-info,0x10511d7c0,197,23994,24351,,,
code-creation,Function,11,156334,0x10511d940,280,createProperty node:zlib:872:24,0x1208b714bc8,^
code-source-info,0x10511d940,197,26761,26902,,,
code-creation,Function,11,156334,0x10511dac0,440,tryExtensions node:internal/modules/cjs/loader:400:23,0x3172a1b2a8b0,^
code-source-info,0x10511dac0,103,11501,11685,,,
code-creation,Function,11,156375,0x10511dce0,600, node:buffer:349:36,0x232faba31d90,^
code-source-info,0x10511dce0,24,10203,10358,,,
code-creation,Function,11,156375,0x10511dfa0,952,tryCreateBuffer node:fs:414:25,0xd2efcc34858,^
code-source-info,0x10511dfa0,81,10594,10881,,,
code-creation,Eval,10,156542,0x1208b7362ce,5, node:os:1:1,0x1208b735f78,~
script-source,206,node:os,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  Float64Array\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperties\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  SymbolToPrimitive\x2C\n} = primordials;\n\nconst { safeGetenv } = internalBinding('credentials');\nconst constants = internalBinding('constants').os;\nconst isWindows = process.platform === 'win32';\n\nconst {\n  codes: {\n    ERR_SYSTEM_ERROR\n  }\x2C\n  hideStackFrames\n} = require('internal/errors');\nconst { validateInt32 } = require('internal/validators');\n\nconst {\n  getCPUs\x2C\n  getFreeMem\x2C\n  getHomeDirectory: _getHomeDirectory\x2C\n  getHostname: _getHostname\x2C\n  getInterfaceAddresses: _getInterfaceAddresses\x2C\n  getLoadAvg\x2C\n  getPriority: _getPriority\x2C\n  getOSInformation: _getOSInformation\x2C\n  getTotalMem\x2C\n  getUserInfo\x2C\n  getUptime\x2C\n  isBigEndian\x2C\n  setPriority: _setPriority\n} = internalBinding('os');\n\nfunction getCheckedFunction(fn) {\n  return hideStackFrames(function checkError(...args) {\n    const ctx = {};\n    const ret = fn(...args\x2C ctx);\n    if (ret === undefined) {\n      throw new ERR_SYSTEM_ERROR(ctx);\n    }\n    return ret;\n  });\n}\n\nconst {\n  0: type\x2C\n  1: version\x2C\n  2: release\x2C\n} = _getOSInformation();\n\nconst getHomeDirectory = getCheckedFunction(_getHomeDirectory);\nconst getHostname = getCheckedFunction(_getHostname);\nconst getInterfaceAddresses = getCheckedFunction(_getInterfaceAddresses);\n/**\n * @returns {string}\n */\nconst getOSRelease = () => release;\n/**\n * @returns {string}\n */\nconst getOSType = () => type;\n/**\n * @returns {string}\n */\nconst getOSVersion = () => version;\n\ngetFreeMem[SymbolToPrimitive] = () => getFreeMem();\ngetHostname[SymbolToPrimitive] = () => getHostname();\ngetOSVersion[SymbolToPrimitive] = () => getOSVersion();\ngetOSType[SymbolToPrimitive] = () => getOSType();\ngetOSRelease[SymbolToPrimitive] = () => getOSRelease();\ngetHomeDirectory[SymbolToPrimitive] = () => getHomeDirectory();\ngetTotalMem[SymbolToPrimitive] = () => getTotalMem();\ngetUptime[SymbolToPrimitive] = () => getUptime();\n\nconst kEndianness = isBigEndian ? 'BE' : 'LE';\n\nconst avgValues = new Float64Array(3);\n\n/**\n * @returns {[number\x2C number\x2C number]}\n */\nfunction loadavg() {\n  getLoadAvg(avgValues);\n  return [avgValues[0]\x2C avgValues[1]\x2C avgValues[2]];\n}\n\n/**\n * Returns an array of objects containing information about each\n * logical CPU core.\n *\n * @returns {Array<{\n *  model: string\n *  speed: number\n *  times: {\n *    user: number\n *    nice: number\n *    sys: number\n *    idle: number\n *    irq: number\n *  }\n * }>}\n */\nfunction cpus() {\n  // [] is a bugfix for a regression introduced in 51cea61\n  const data = getCPUs() || [];\n  const result = [];\n  let i = 0;\n  while (i < data.length) {\n    ArrayPrototypePush(result\x2C {\n      model: data[i++]\x2C\n      speed: data[i++]\x2C\n      times: {\n        user: data[i++]\x2C\n        nice: data[i++]\x2C\n        sys: data[i++]\x2C\n        idle: data[i++]\x2C\n        irq: data[i++]\n      }\n    });\n  }\n  return result;\n}\n\n/**\n * @returns {string}\n */\nfunction arch() {\n  return process.arch;\n}\narch[SymbolToPrimitive] = () => process.arch;\n\n/**\n * @returns {string}\n */\nfunction platform() {\n  return process.platform;\n}\nplatform[SymbolToPrimitive] = () => process.platform;\n\n/**\n * @returns {string}\n */\nfunction tmpdir() {\n  var path;\n  if (isWindows) {\n    path = process.env.TEMP ||\n           process.env.TMP ||\n           (process.env.SystemRoot || process.env.windir) + '\\\\temp';\n    if (path.length > 1 && StringPrototypeEndsWith(path\x2C '\\\\') &&\n        !StringPrototypeEndsWith(path\x2C ':\\\\'))\n      path = StringPrototypeSlice(path\x2C 0\x2C -1);\n  } else {\n    path = safeGetenv('TMPDIR') ||\n           safeGetenv('TMP') ||\n           safeGetenv('TEMP') ||\n           '/tmp';\n    if (path.length > 1 && StringPrototypeEndsWith(path\x2C '/'))\n      path = StringPrototypeSlice(path\x2C 0\x2C -1);\n  }\n\n  return path;\n}\ntmpdir[SymbolToPrimitive] = () => tmpdir();\n\n/**\n * @returns {'BE' | 'LE'}\n */\nfunction endianness() {\n  return kEndianness;\n}\nendianness[SymbolToPrimitive] = () => kEndianness;\n\n// Returns the number of ones in the binary representation of the decimal\n// number.\nfunction countBinaryOnes(n) {\n  // Count the number of bits set in parallel\x2C which is faster than looping\n  n = n - ((n >>> 1) & 0x55555555);\n  n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);\n  return ((n + (n >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\n}\n\nfunction getCIDR(address\x2C netmask\x2C family) {\n  let ones = 0;\n  let split = '.';\n  let range = 10;\n  let groupLength = 8;\n  let hasZeros = false;\n\n  if (family === 'IPv6') {\n    split = ':';\n    range = 16;\n    groupLength = 16;\n  }\n\n  const parts = StringPrototypeSplit(netmask\x2C split);\n  for (var i = 0; i < parts.length; i++) {\n    if (parts[i] !== '') {\n      const binary = NumberParseInt(parts[i]\x2C range);\n      const tmp = countBinaryOnes(binary);\n      ones += tmp;\n      if (hasZeros) {\n        if (tmp !== 0) {\n          return null;\n        }\n      } else if (tmp !== groupLength) {\n        if ((binary & 1) !== 0) {\n          return null;\n        }\n        hasZeros = true;\n      }\n    }\n  }\n\n  return `${address}/${ones}`;\n}\n\n/**\n * @returns {Record<string\x2C Array<{\n *  address: string\n *  netmask: string\n *  family: 'IPv4' | 'IPv6'\n *  mac: string\n *  internal: boolean\n *  scopeid: number\n *  cidr: string | null\n * }>>}\n */\nfunction networkInterfaces() {\n  const data = getInterfaceAddresses();\n  const result = {};\n\n  if (data === undefined)\n    return result;\n  for (var i = 0; i < data.length; i += 7) {\n    const name = data[i];\n    const entry = {\n      address: data[i + 1]\x2C\n      netmask: data[i + 2]\x2C\n      family: data[i + 3]\x2C\n      mac: data[i + 4]\x2C\n      internal: data[i + 5]\x2C\n      cidr: getCIDR(data[i + 1]\x2C data[i + 2]\x2C data[i + 3])\n    };\n    const scopeid = data[i + 6];\n    if (scopeid !== -1)\n      entry.scopeid = scopeid;\n\n    const existing = result[name];\n    if (existing !== undefined)\n      ArrayPrototypePush(existing\x2C entry);\n    else\n      result[name] = [entry];\n  }\n\n  return result;\n}\n\n/**\n * @param {number} [pid=0]\n * @param {number} priority\n * @returns {void}\n */\nfunction setPriority(pid\x2C priority) {\n  if (priority === undefined) {\n    priority = pid;\n    pid = 0;\n  }\n\n  validateInt32(pid\x2C 'pid');\n  validateInt32(priority\x2C 'priority'\x2C -20\x2C 19);\n\n  const ctx = {};\n\n  if (_setPriority(pid\x2C priority\x2C ctx) !== 0)\n    throw new ERR_SYSTEM_ERROR(ctx);\n}\n\n/**\n * @param {number} [pid=0]\n * @returns {number}\n */\nfunction getPriority(pid) {\n  if (pid === undefined)\n    pid = 0;\n  else\n    validateInt32(pid\x2C 'pid');\n\n  const ctx = {};\n  const priority = _getPriority(pid\x2C ctx);\n\n  if (priority === undefined)\n    throw new ERR_SYSTEM_ERROR(ctx);\n\n  return priority;\n}\n\n/**\n * @param {{ encoding?: string }} [options=utf8] If `encoding` is set to\n * `'buffer'`\x2C the `username`\x2C `shell`\x2C and `homedir` values will\n * be `Buffer` instances.\n * @returns {{\n *   uid: number\n *   gid: number\n *   username: string\n *   homedir: string\n *   shell: string | null\n * }}\n */\nfunction userInfo(options) {\n  if (typeof options !== 'object')\n    options = null;\n\n  const ctx = {};\n  const user = getUserInfo(options\x2C ctx);\n\n  if (user === undefined)\n    throw new ERR_SYSTEM_ERROR(ctx);\n\n  return user;\n}\n\nmodule.exports = {\n  arch\x2C\n  cpus\x2C\n  endianness\x2C\n  freemem: getFreeMem\x2C\n  getPriority\x2C\n  homedir: getHomeDirectory\x2C\n  hostname: getHostname\x2C\n  loadavg\x2C\n  networkInterfaces\x2C\n  platform\x2C\n  release: getOSRelease\x2C\n  setPriority\x2C\n  tmpdir\x2C\n  totalmem: getTotalMem\x2C\n  type: getOSType\x2C\n  userInfo\x2C\n  uptime: getUptime\x2C\n  version: getOSVersion\n};\n\nObjectDefineProperties(module.exports\x2C {\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n\n  EOL: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    writable: false\x2C\n    value: isWindows ? '\\r\\n' : '\\n'\n  }\x2C\n\n  devNull: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    writable: false\x2C\n    value: isWindows ? '\\\\\\\\.\\\\nul' : '/dev/null'\n  }\n});\n
code-source-info,0x1208b7362ce,206,0,9062,C0O0C4O9062,,
code-creation,Function,10,156875,0x1208b737486,823, node:os:1:1,0x1208b736248,~
code-source-info,0x1208b737486,206,0,9062,C0O0C167O1159C173O1181C178O1197C184O1215C189O1241C195O1268C201O1292C207O1316C212O1376C216O1376C222O1361C228O1426C232O1426C238O1454C243O1477C247O1485C255O1494C258O1477C260O1575C264O1575C270O1575C276O1531C282O1555C288O1629C292O1629C298O1611C304O1984C308O1984C314O1672C320O1683C326O1715C331O1749C336O1788C341O1814C347O1841C353O1875C358O1896C364O1911C370O1926C376O1939C381O1967C387O2302C392O2264C400O2275C409O2289C418O2349C422O2349C424O2408C428O2408C430O2472C434O2472C436O2566C440O2566C442O2628C446O2628C448O2690C452O2690C454O2706C458O2717C462O2736C466O2758C470O2770C474O2789C478O2812C482O2825C486O2844C490O2868C494O2878C498O2897C502O2918C506O2931C510O2950C514O2974C518O2991C522O3010C526O3038C530O3050C534O3069C538O3092C542O3102C546O3121C550O3163C560O3163C562O3209C568O3209C573O3209C575O4159C579O4178C583O4290C587O4309C591O4971C595O4978C599O4997C603O5109C607O5128C611O8335C619O8356C625O8364C631O8372C637O8395C643O8409C649O8433C655O8463C661O8478C667O8489C673O8510C679O8531C685O8547C691O8562C697O8582C703O8603C709O8616C715O8636C721O8658C727O8350C731O8705C743O8729C751O8789C761O8812C772O8892C790O8935C798O9015C816O8675C822O9061,,
code-creation,LazyCompile,10,157000,0x1208b7396e6,26,getCheckedFunction node:os:63:28,0x1208b736300,~
code-source-info,0x1208b7396e6,206,2035,2249,C0O2035C9O2044C21O2051C25O2247,,
code-creation,LazyCompile,10,157084,0x1208b73beb6,56,app.init /Users/vignesh/Projects/HTTP2/index.js:15:20,0x2cbd764a6d00,~
code-source-info,0x1208b73beb6,150,232,444,C0O232C9O269C14O276C19O276C23O310C28O318C33O318C37O378C49O378C55O443,,
code-creation,LazyCompile,10,157125,0x1208b73c0d6,66,server.init /Users/vignesh/Projects/HTTP2/lib/server.js:171:23,0x2cbd764a8578,~
code-source-info,0x1208b73c0d6,151,5576,5947,C0O5609C3O5616C8O5627C16O5641C26O5627C32O5791C35O5798C40O5810C48O5824C58O5810C65O5946,,
code-creation,LazyCompile,10,157209,0x1208b73c406,692,Server.listen node:net:1453:35,0x120d443838e8,~
code-source-info,0x1208b73c406,113,38832,42362,C0O38832C3O38865C6O38865C11O38902C12O38912C16O38930C18O38940C22O38957C28O38972C33O38978C38O38972C39O39018C43O39046C51O39046C57O39166C60O39180C67O39187C74O39198C78O39166C87O39224C94O39231C101O39242C105O39210C110O39295C116O39314C125O39349C128O39366C133O39349C138O39450C140O39473C142O39462C147O39484C149O39497C153O39512C155O39517C158O39541C163O39549C168O39549C172O39534C176O39567C193O39567C198O39625C200O39637C201O39644C204O39644C209O39769C217O39796C223O39799C228O39811C237O39876C249O39811C254O39885C256O39897C257O40167C263O40174C269O40194C276O40238C289O40269C294O40298C300O40319C301O40332C305O40516C307O40546C315O40582C323O40607C328O40628C336O40607C341O40673C350O40764C356O40778C359O40808C363O40813C367O40826C372O40871C387O40778C394O41032C399O41068C403O41073C413O41131C425O41032C430O41153C432O41165C433O41305C442O41332C447O41313C453O41387C458O41377C465O41415C474O41447C486O41535C501O41447C506O41562C512O41683C514O41695C515O41718C517O41737C523O41749C528O41765C530O41773C533O41787C544O41816C550O41828C555O41844C557O41852C560O41866C571O41883C572O41892C577O41924C582O41932C587O41932C593O41952C595O41976C600O41984C605O41984C609O42001C610O42014C614O42030C622O42036C627O42030C628O42092C630O42104C631O42112C636O42126C646O42149C651O42169C667O42175C672O42169C673O42308C686O42314C691O42308,,
code-creation,LazyCompile,10,157250,0x1208b73c9fe,183,normalizeArgs node:net:217:23,0x120d44381f50,~
code-source-info,0x1208b73c9fe,113,5532,6236,C0O5547C2O5564C8O5571C13O5584C18O5606C20O5610C24O5632C28O5644C30O5655C31O5676C32O5680C36O5701C38O5707C48O5788C55O5813C58O5817C64O5866C66O5879C72O5937C74O5950C78O5971C85O5978C92O5996C99O6022C101O6041C104O6035C108O6080C112O6087C115O6074C119O6095C123O6129C132O6136C143O6163C152O6170C161O6179C170O6187C172O6191C176O6213C180O6223C182O6234,,
code-creation,LazyCompile,10,157292,0x1208b73cbd6,19,isPipeName node:net:162:20,0x120d44381e60,~
code-source-info,0x1208b73cbd6,113,4132,4196,C0O4140C9O4172C15O4184C18O4194,,
code-creation,LazyCompile,10,157292,0x1208b73cd4e,39,once node:events:660:44,0x232faba26e00,~
code-source-info,0x1208b73cd4e,23,19413,19526,C0O19434C3O19434C7O19467C24O19476C30O19467C36O19512C38O19524,,
code-creation,LazyCompile,10,157334,0x1208b73cefe,60,_onceWrap node:events:646:19,0x232faba26db0,~
code-source-info,0x1208b73cefe,23,18986,19209,C0O19029C6O19053C12O19064C18O19072C24O19078C31O19108C34O19120C39O19120C45O19135C47O19152C51O19166C53O19179C57O19192C59O19207,,
code-creation,LazyCompile,10,157334,0x1208b73d036,23,toNumber node:net:1264:18,0x120d44382450,~
code-source-info,0x1208b73d036,113,33388,33436,C0O33394C5O33406C12O33417C22O33434,,
code-creation,LazyCompile,10,157375,0x1208b73d12e,19,getFlags node:net:133:18,0x120d44381d70,~
code-source-info,0x1208b73d12e,113,3509,3586,C0O3524C1O3540C8O3551C11O3564C18O3584,,
code-creation,LazyCompile,10,157375,0x1208b73d346,138,addAbortSignalOption node:net:1200:30,0x120d443823b0,~
code-source-info,0x1208b73d346,113,31586,31997,C0O31586C15O31606C22O31617C31O31647C32O31654C33O31661C40O31689C48O31661C53O31726C59O31766C63O31766C65O31799C68O31810C74O31825C79O31833C87O31833C94O31869C97O31876C108O31876C114O31918C117O31923C130O31923C137O31996,,
code-creation,LazyCompile,10,157417,0x1208b73d6de,199,listenInCluster node:net:1410:25,0x120d443825e0,~
code-source-info,0x1208b73d6de,113,37583,38795,C0O37583C38O37680C44O37708C52O37735C60O37745C69O37743C77O37768C84O37780C92O37793C94O37968C97O37975C120O37975C125O38037C126O38044C127O38072C134O38087C140O38106C146O38129C152O38150C158O38158C164O38169C171O38241C178O38249C192O38249C198O38794,,
tick,0x10055c3b4,157500,0,0x0,2,0x0,0x1208b73d756,0x1208b73c5af,0x1208b73c0f0,0x1208b73bec9,0x2cbd764a6ec6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,157500,0x1208b73da16,443,setupListenHandle node:net:1325:27,0x120d443824f0,~
code-source-info,0x1208b73da16,113,34984,37309,C0O35037C23O35037C28O35254C34O35269C42O35269C48O35335C56O35335C60O35396C62O35484C72O35532C77O35558C92O35539C98O35605C102O35645C104O35666C110O35703C116O35743C122O35780C126O35816C130O35841C148O35848C154O35912C160O35964C177O35964C183O36026C186O36034C200O36034C205O36076C206O36083C207O36094C209O36107C213O36122C215O36127C221O36165C226O36146C230O36144C234O36182C241O36203C245O36226C252O36234C257O36248C261O36480C266O36488C273O36495C280O36488C286O36515C288O36541C305O36541C311O36605C316O36613C321O36613C325O36626C326O36639C330O36651C337O36683C339O36682C346O36740C360O36651C365O36871C366O36878C367O36956C369O36990C375O36996C381O37006C387O37012C390O36976C394O37100C400O37117C405O37117C409O37129C416O37161C418O37160C425O37216C436O37129C442O37308,,
code-creation,LazyCompile,10,157542,0x1208b73dd9e,10, node:net:38:63,0x120d44382770,~
code-source-info,0x1208b73dd9e,113,1464,1489,C0O1476C2O1482C9O1488,,
code-creation,LazyCompile,10,157584,0x1208b73dfee,379,createServerHandle node:net:1267:28,0x120d443824a0,~
code-source-info,0x1208b73dfee,113,33531,34956,C0O33585C2O33661C4O33684C6O33693C13O33726C21O33750C26O33759C35O33757C45O33872C58O33909C66O33872C71O33925C77O33942C78O33967C83O33967C89O33981C91O33996C93O34007C94O34013C101O34021C106O34033C108O34013C114O34049C116O34058C123O34080C128O34094C135O34112C138O34126C145O34103C151O34139C157O34180C165O34203C170O34207C175O34180C180O34243C185O34248C191O34289C196O34289C203O34350C210O34367C213O34380C220O34359C226O34393C228O34414C234O34429C238O34437C240O34450C250O34467C255O34450C260O34490C264O34560C271O34566C283O34560C289O34605C291O34631C296O34631C300O34676C305O34702C308O34683C313O34727C316O34747C318O34763C323O34791C340O34791C348O34852C353O34852C360O34886C364O34908C369O34908C373O34921C375O34932C376O34940C378O34954,,
code-creation,LazyCompile,10,157709,0x1208b73e3d6,121,defaultTriggerAsyncIdScope node:internal/async_hooks:456:36,0x2b48e0c77ca8,~
script-source,13,node:internal/async_hooks,'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  ErrorCaptureStackTrace\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectDefineProperty\x2C\n  Symbol\x2C\n} = primordials;\n\nconst promiseHooks = require('internal/promise_hooks');\n\nconst async_wrap = internalBinding('async_wrap');\nconst { setCallbackTrampoline } = async_wrap;\n/* async_hook_fields is a Uint32Array wrapping the uint32_t array of\n * Environment::AsyncHooks::fields_[]. Each index tracks the number of active\n * hooks for each type.\n *\n * async_id_fields is a Float64Array wrapping the double array of\n * Environment::AsyncHooks::async_id_fields_[]. Each index contains the ids for\n * the various asynchronous states of the application. These are:\n *  kExecutionAsyncId: The async_id assigned to the resource responsible for the\n *    current execution stack.\n *  kTriggerAsyncId: The async_id of the resource that caused (or 'triggered')\n *    the resource corresponding to the current execution stack.\n *  kAsyncIdCounter: Incremental counter tracking the next assigned async_id.\n *  kDefaultTriggerAsyncId: Written immediately before a resource's constructor\n *    that sets the value of the init()'s triggerAsyncId. The precedence order\n *    of retrieving the triggerAsyncId value is:\n *    1. the value passed directly to the constructor\n *    2. value set in kDefaultTriggerAsyncId\n *    3. executionAsyncId of the current resource.\n *\n * async_ids_stack is a Float64Array that contains part of the async ID\n * stack. Each pushAsyncContext() call adds two doubles to it\x2C and each\n * popAsyncContext() call removes two doubles from it.\n * It has a fixed size\x2C so if that is exceeded\x2C calls to the native\n * side are used instead in pushAsyncContext() and popAsyncContext().\n */\nconst {\n  async_hook_fields\x2C\n  async_id_fields\x2C\n  execution_async_resources\n} = async_wrap;\n// Store the pair executionAsyncId and triggerAsyncId in a AliasedFloat64Array\n// in Environment::AsyncHooks::async_ids_stack_ which tracks the resource\n// responsible for the current execution stack. This is unwound as each resource\n// exits. In the case of a fatal exception this stack is emptied after calling\n// each hook's after() callback.\nconst {\n  pushAsyncContext: pushAsyncContext_\x2C\n  popAsyncContext: popAsyncContext_\x2C\n  executionAsyncResource: executionAsyncResource_\x2C\n  clearAsyncIdStack\x2C\n} = async_wrap;\n// Properties in active_hooks are used to keep track of the set of hooks being\n// executed in case another hook is enabled/disabled. The new set of hooks is\n// then restored once the active set of hooks is finished executing.\nconst active_hooks = {\n  // Array of all AsyncHooks that will be iterated whenever an async event\n  // fires. Using var instead of (preferably const) in order to assign\n  // active_hooks.tmp_array if a hook is enabled/disabled during hook\n  // execution.\n  array: []\x2C\n  // Use a counter to track nested calls of async hook callbacks and make sure\n  // the active_hooks.array isn't altered mid execution.\n  call_depth: 0\x2C\n  // Use to temporarily store and updated active_hooks.array if the user\n  // enables or disables a hook while hooks are being processed. If a hook is\n  // enabled() or disabled() during hook execution then the current set of\n  // active hooks is duplicated and set equal to active_hooks.tmp_array. Any\n  // subsequent changes are on the duplicated array. When all hooks have\n  // completed executing active_hooks.tmp_array is assigned to\n  // active_hooks.array.\n  tmp_array: null\x2C\n  // Keep track of the field counts held in active_hooks.tmp_array. Because the\n  // async_hook_fields can't be reassigned\x2C store each uint32 in an array that\n  // is written back to async_hook_fields when active_hooks.array is restored.\n  tmp_fields: null\n};\n\nconst { registerDestroyHook } = async_wrap;\nconst { enqueueMicrotask } = internalBinding('task_queue');\nconst { resource_symbol\x2C owner_symbol } = internalBinding('symbols');\n\n// Each constant tracks how many callbacks there are for any given step of\n// async execution. These are tracked so if the user didn't include callbacks\n// for a given step\x2C that step can bail out early.\nconst {\n  kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\x2C\n  kCheck\x2C kExecutionAsyncId\x2C kAsyncIdCounter\x2C kTriggerAsyncId\x2C\n  kDefaultTriggerAsyncId\x2C kStackLength\x2C kUsesExecutionAsyncResource\x2C\n} = async_wrap.constants;\n\nconst { async_id_symbol\x2C\n        trigger_async_id_symbol } = internalBinding('symbols');\n\n// Lazy load of internal/util/inspect;\nlet inspect;\n\n// Used in AsyncHook and AsyncResource.\nconst init_symbol = Symbol('init');\nconst before_symbol = Symbol('before');\nconst after_symbol = Symbol('after');\nconst destroy_symbol = Symbol('destroy');\nconst promise_resolve_symbol = Symbol('promiseResolve');\nconst emitBeforeNative = emitHookFactory(before_symbol\x2C 'emitBeforeNative');\nconst emitAfterNative = emitHookFactory(after_symbol\x2C 'emitAfterNative');\nconst emitDestroyNative = emitHookFactory(destroy_symbol\x2C 'emitDestroyNative');\nconst emitPromiseResolveNative =\n    emitHookFactory(promise_resolve_symbol\x2C 'emitPromiseResolveNative');\n\nlet domain_cb;\nfunction useDomainTrampoline(fn) {\n  domain_cb = fn;\n}\n\nfunction callbackTrampoline(asyncId\x2C resource\x2C cb\x2C ...args) {\n  const index = async_hook_fields[kStackLength] - 1;\n  execution_async_resources[index] = resource;\n\n  if (asyncId !== 0 && hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n\n  let result;\n  if (asyncId === 0 && typeof domain_cb === 'function') {\n    args.unshift(cb);\n    result = domain_cb.apply(this\x2C args);\n  } else {\n    result = cb.apply(this\x2C args);\n  }\n\n  if (asyncId !== 0 && hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  execution_async_resources.pop();\n  return result;\n}\n\nconst topLevelResource = {};\n\nfunction executionAsyncResource() {\n  // Indicate to the native layer that this function is likely to be used\x2C\n  // in which case it will inform JS about the current async resource via\n  // the trampoline above.\n  async_hook_fields[kUsesExecutionAsyncResource] = 1;\n\n  const index = async_hook_fields[kStackLength] - 1;\n  if (index === -1) return topLevelResource;\n  const resource = execution_async_resources[index] ||\n    executionAsyncResource_(index);\n  return lookupPublicResource(resource);\n}\n\nfunction inspectExceptionValue(e) {\n  inspect ??= require('internal/util/inspect').inspect;\n  return { message: inspect(e) };\n}\n\n// Used to fatally abort the process if a callback throws.\nfunction fatalError(e) {\n  if (typeof e?.stack === 'string') {\n    process._rawDebug(e.stack);\n  } else {\n    const o = inspectExceptionValue(e);\n    ErrorCaptureStackTrace(o\x2C fatalError);\n    process._rawDebug(o.stack);\n  }\n\n  const { getOptionValue } = require('internal/options');\n  if (getOptionValue('--abort-on-uncaught-exception')) {\n    process.abort();\n  }\n  process.exit(1);\n}\n\nfunction lookupPublicResource(resource) {\n  if (typeof resource !== 'object' || resource === null) return resource;\n  // TODO(addaleax): Merge this with owner_symbol and use it across all\n  // AsyncWrap instances.\n  const publicResource = resource[resource_symbol];\n  if (publicResource !== undefined)\n    return publicResource;\n  return resource;\n}\n\n// Emit From Native //\n\n// Used by C++ to call all init() callbacks. Because some state can be setup\n// from C++ there's no need to perform all the same operations as in\n// emitInitScript.\nfunction emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  active_hooks.call_depth += 1;\n  resource = lookupPublicResource(resource);\n  // Use a single try/catch for all hooks to avoid setting up one per iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][init_symbol] === 'function') {\n        active_hooks.array[i][init_symbol](\n          asyncId\x2C type\x2C triggerAsyncId\x2C\n          resource\n        );\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case active_hooks.tmp_array\n  // will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\n// Called from native. The asyncId stack handling is taken care of there\n// before this is called.\nfunction emitHook(symbol\x2C asyncId) {\n  active_hooks.call_depth += 1;\n  // Use a single try/catch for all hook to avoid setting up one per\n  // iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][symbol] === 'function') {\n        active_hooks.array[i][symbol](asyncId);\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case\n  // active_hooks.tmp_array will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\nfunction emitHookFactory(symbol\x2C name) {\n  const fn = emitHook.bind(undefined\x2C symbol);\n\n  // Set the name property of the function as it looks good in the stack trace.\n  ObjectDefineProperty(fn\x2C 'name'\x2C {\n    value: name\n  });\n  return fn;\n}\n\n// Manage Active Hooks //\n\nfunction getHookArrays() {\n  if (active_hooks.call_depth === 0)\n    return [active_hooks.array\x2C async_hook_fields];\n  // If this hook is being enabled while in the middle of processing the array\n  // of currently active hooks then duplicate the current set of active hooks\n  // and store this there. This shouldn't fire until the next time hooks are\n  // processed.\n  if (active_hooks.tmp_array === null)\n    storeActiveHooks();\n  return [active_hooks.tmp_array\x2C active_hooks.tmp_fields];\n}\n\n\nfunction storeActiveHooks() {\n  active_hooks.tmp_array = ArrayPrototypeSlice(active_hooks.array);\n  // Don't want to make the assumption that kInit to kDestroy are indexes 0 to\n  // 4. So do this the long way.\n  active_hooks.tmp_fields = [];\n  copyHooks(active_hooks.tmp_fields\x2C async_hook_fields);\n}\n\nfunction copyHooks(destination\x2C source) {\n  destination[kInit] = source[kInit];\n  destination[kBefore] = source[kBefore];\n  destination[kAfter] = source[kAfter];\n  destination[kDestroy] = source[kDestroy];\n  destination[kPromiseResolve] = source[kPromiseResolve];\n}\n\n\n// Then restore the correct hooks array in case any hooks were added/removed\n// during hook callback execution.\nfunction restoreActiveHooks() {\n  active_hooks.array = active_hooks.tmp_array;\n  copyHooks(async_hook_fields\x2C active_hooks.tmp_fields);\n\n  active_hooks.tmp_array = null;\n  active_hooks.tmp_fields = null;\n}\n\nfunction trackPromise(promise\x2C parent) {\n  if (promise[async_id_symbol]) {\n    return;\n  }\n\n  // Get trigger id from parent async id before making the async id of the\n  // child so if a new one must be made it will be lower than the child.\n  const triggerAsyncId = parent ? getOrSetAsyncId(parent) :\n    getDefaultTriggerAsyncId();\n\n  promise[async_id_symbol] = newAsyncId();\n  promise[trigger_async_id_symbol] = triggerAsyncId;\n}\n\nfunction promiseInitHook(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  const triggerAsyncId = promise[trigger_async_id_symbol];\n  emitInitScript(asyncId\x2C 'PROMISE'\x2C triggerAsyncId\x2C promise);\n}\n\nfunction promiseInitHookWithDestroyTracking(promise\x2C parent) {\n  promiseInitHook(promise\x2C parent);\n  destroyTracking(promise\x2C parent);\n}\n\nconst destroyedSymbol = Symbol('destroyed');\n\nfunction destroyTracking(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  const destroyed = { destroyed: false };\n  promise[destroyedSymbol] = destroyed;\n  registerDestroyHook(promise\x2C asyncId\x2C destroyed);\n}\n\nfunction promiseBeforeHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  const triggerId = promise[trigger_async_id_symbol];\n  emitBeforeScript(asyncId\x2C triggerId\x2C promise);\n}\n\nfunction promiseAfterHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  if (hasHooks(kAfter)) {\n    emitAfterNative(asyncId);\n  }\n  if (asyncId === executionAsyncId()) {\n    // This condition might not be true if async_hooks was enabled during\n    // the promise callback execution.\n    // Popping it off the stack can be skipped in that case\x2C because it is\n    // known that it would correspond to exactly one call with\n    // PromiseHookType::kBefore that was not witnessed by the PromiseHook.\n    popAsyncContext(asyncId);\n  }\n}\n\nfunction promiseResolveHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  emitPromiseResolveNative(asyncId);\n}\n\nlet wantPromiseHook = false;\nfunction enableHooks() {\n  async_hook_fields[kCheck] += 1;\n\n  setCallbackTrampoline(callbackTrampoline);\n}\n\nlet stopPromiseHook;\nfunction updatePromiseHookMode() {\n  wantPromiseHook = true;\n  let initHook;\n  if (initHooksExist()) {\n    initHook = destroyHooksExist() ? promiseInitHookWithDestroyTracking :\n      promiseInitHook;\n  } else if (destroyHooksExist()) {\n    initHook = destroyTracking;\n  }\n  if (stopPromiseHook) stopPromiseHook();\n  stopPromiseHook = promiseHooks.createHook({\n    init: initHook\x2C\n    before: promiseBeforeHook\x2C\n    after: promiseAfterHook\x2C\n    settled: promiseResolveHooksExist() ? promiseResolveHook : undefined\n  });\n}\n\nfunction disableHooks() {\n  async_hook_fields[kCheck] -= 1;\n\n  wantPromiseHook = false;\n\n  setCallbackTrampoline();\n\n  // Delay the call to `disablePromiseHook()` because we might currently be\n  // between the `before` and `after` calls of a Promise.\n  enqueueMicrotask(disablePromiseHookIfNecessary);\n}\n\nfunction disablePromiseHookIfNecessary() {\n  if (!wantPromiseHook && stopPromiseHook) {\n    stopPromiseHook();\n  }\n}\n\n// Internal Embedder API //\n\n// Increment the internal id counter and return the value. Important that the\n// counter increment first. Since it's done the same way in\n// Environment::new_async_uid()\nfunction newAsyncId() {\n  return ++async_id_fields[kAsyncIdCounter];\n}\n\nfunction getOrSetAsyncId(object) {\n  if (ObjectPrototypeHasOwnProperty(object\x2C async_id_symbol)) {\n    return object[async_id_symbol];\n  }\n\n  return object[async_id_symbol] = newAsyncId();\n}\n\n\n// Return the triggerAsyncId meant for the constructor calling it. It's up to\n// the user to safeguard this call and make sure it's zero'd out when the\n// constructor is complete.\nfunction getDefaultTriggerAsyncId() {\n  const defaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  // If defaultTriggerAsyncId isn't set\x2C use the executionAsyncId\n  if (defaultTriggerAsyncId < 0)\n    return async_id_fields[kExecutionAsyncId];\n  return defaultTriggerAsyncId;\n}\n\n\nfunction clearDefaultTriggerAsyncId() {\n  async_id_fields[kDefaultTriggerAsyncId] = -1;\n}\n\n/**\n * Sets a default top level trigger ID to be used\n *\n * @template {Array<unknown>} T\n * @template {unknown} R\n * @param {number} triggerAsyncId\n * @param { (...T: args) => R } block\n * @param  {T} args\n * @returns {R}\n */\nfunction defaultTriggerAsyncIdScope(triggerAsyncId\x2C block\x2C ...args) {\n  if (triggerAsyncId === undefined)\n    return block.apply(null\x2C args);\n  // CHECK(NumberIsSafeInteger(triggerAsyncId))\n  // CHECK(triggerAsyncId > 0)\n  const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;\n\n  try {\n    return block.apply(null\x2C args);\n  } finally {\n    async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;\n  }\n}\n\nfunction hasHooks(key) {\n  return async_hook_fields[key] > 0;\n}\n\nfunction enabledHooksExist() {\n  return hasHooks(kCheck);\n}\n\nfunction initHooksExist() {\n  return hasHooks(kInit);\n}\n\nfunction afterHooksExist() {\n  return hasHooks(kAfter);\n}\n\nfunction destroyHooksExist() {\n  return hasHooks(kDestroy);\n}\n\nfunction promiseResolveHooksExist() {\n  return hasHooks(kPromiseResolve);\n}\n\n\nfunction emitInitScript(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  // Short circuit all checks for the common case. Which is that no hooks have\n  // been set. Do this to remove performance impact for embedders (and core).\n  if (!hasHooks(kInit))\n    return;\n\n  if (triggerAsyncId === null) {\n    triggerAsyncId = getDefaultTriggerAsyncId();\n  }\n\n  emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource);\n}\n\n\nfunction emitBeforeScript(asyncId\x2C triggerAsyncId\x2C resource) {\n  pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource);\n\n  if (hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n}\n\n\nfunction emitAfterScript(asyncId) {\n  if (hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  popAsyncContext(asyncId);\n}\n\n\nfunction emitDestroyScript(asyncId) {\n  // Return early if there are no destroy callbacks\x2C or invalid asyncId.\n  if (!hasHooks(kDestroy) || asyncId <= 0)\n    return;\n  async_wrap.queueDestroyAsyncId(asyncId);\n}\n\n\nfunction hasAsyncIdStack() {\n  return hasHooks(kStackLength);\n}\n\n\n// This is the equivalent of the native push_async_ids() call.\nfunction pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource) {\n  const offset = async_hook_fields[kStackLength];\n  execution_async_resources[offset] = resource;\n  if (offset * 2 >= async_wrap.async_ids_stack.length)\n    return pushAsyncContext_(asyncId\x2C triggerAsyncId);\n  async_wrap.async_ids_stack[offset * 2] = async_id_fields[kExecutionAsyncId];\n  async_wrap.async_ids_stack[offset * 2 + 1] = async_id_fields[kTriggerAsyncId];\n  async_hook_fields[kStackLength]++;\n  async_id_fields[kExecutionAsyncId] = asyncId;\n  async_id_fields[kTriggerAsyncId] = triggerAsyncId;\n}\n\n\n// This is the equivalent of the native pop_async_ids() call.\nfunction popAsyncContext(asyncId) {\n  const stackLength = async_hook_fields[kStackLength];\n  if (stackLength === 0) return false;\n\n  if (enabledHooksExist() && async_id_fields[kExecutionAsyncId] !== asyncId) {\n    // Do the same thing as the native code (i.e. crash hard).\n    return popAsyncContext_(asyncId);\n  }\n\n  const offset = stackLength - 1;\n  async_id_fields[kExecutionAsyncId] = async_wrap.async_ids_stack[2 * offset];\n  async_id_fields[kTriggerAsyncId] = async_wrap.async_ids_stack[2 * offset + 1];\n  execution_async_resources.pop();\n  async_hook_fields[kStackLength] = offset;\n  return offset > 0;\n}\n\n\nfunction executionAsyncId() {\n  return async_id_fields[kExecutionAsyncId];\n}\n\nfunction triggerAsyncId() {\n  return async_id_fields[kTriggerAsyncId];\n}\n\n\nmodule.exports = {\n  executionAsyncId\x2C\n  triggerAsyncId\x2C\n  // Private API\n  getHookArrays\x2C\n  symbols: {\n    async_id_symbol\x2C trigger_async_id_symbol\x2C\n    init_symbol\x2C before_symbol\x2C after_symbol\x2C destroy_symbol\x2C\n    promise_resolve_symbol\x2C owner_symbol\n  }\x2C\n  constants: {\n    kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\n  }\x2C\n  enableHooks\x2C\n  disableHooks\x2C\n  updatePromiseHookMode\x2C\n  clearDefaultTriggerAsyncId\x2C\n  clearAsyncIdStack\x2C\n  hasAsyncIdStack\x2C\n  executionAsyncResource\x2C\n  // Internal Embedder API\n  newAsyncId\x2C\n  getOrSetAsyncId\x2C\n  getDefaultTriggerAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  enabledHooksExist\x2C\n  initHooksExist\x2C\n  afterHooksExist\x2C\n  destroyHooksExist\x2C\n  emitInit: emitInitScript\x2C\n  emitBefore: emitBeforeScript\x2C\n  emitAfter: emitAfterScript\x2C\n  emitDestroy: emitDestroyScript\x2C\n  pushAsyncContext\x2C\n  popAsyncContext\x2C\n  registerDestroyHook\x2C\n  useDomainTrampoline\x2C\n  nativeHooks: {\n    init: emitInitNative\x2C\n    before: emitBeforeNative\x2C\n    after: emitAfterNative\x2C\n    destroy: emitDestroyNative\x2C\n    promise_resolve: emitPromiseResolveNative\n  }\x2C\n  asyncWrap: {\n    Providers: async_wrap.Providers\x2C\n  }\n};\n
code-source-info,0x1208b73e3d6,13,15584,16042,C0O15584C11O15621C15O15672C22O15672C28O15690C29O15805C36O15821C38O15820C42O15848C49O15864C54O15888C61O15932C68O15932C86O15969C93O15985C98O16009C120O16041,,
code-creation,LazyCompile,10,158459,0x1208b73fa7e,368,nextTick node:internal/process/task_queues:104:18,0x815de60f668,~
script-source,32,node:internal/process/task_queues,'use strict';\n\nconst {\n  Array\x2C\n  FunctionPrototypeBind\x2C\n} = primordials;\n\nconst {\n  // For easy access to the nextTick state in the C++ land\x2C\n  // and to avoid unnecessary calls into JS land.\n  tickInfo\x2C\n  // Used to run V8's micro task queue.\n  runMicrotasks\x2C\n  setTickCallback\x2C\n  enqueueMicrotask\n} = internalBinding('task_queue');\n\nconst {\n  setHasRejectionToWarn\x2C\n  hasRejectionToWarn\x2C\n  listenForRejections\x2C\n  processPromiseRejections\n} = require('internal/process/promises');\n\nconst {\n  getDefaultTriggerAsyncId\x2C\n  newAsyncId\x2C\n  initHooksExist\x2C\n  destroyHooksExist\x2C\n  emitInit\x2C\n  emitBefore\x2C\n  emitAfter\x2C\n  emitDestroy\x2C\n  symbols: { async_id_symbol\x2C trigger_async_id_symbol }\n} = require('internal/async_hooks');\nconst FixedQueue = require('internal/fixed_queue');\n\nconst {\n  validateCallback\x2C\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst { AsyncResource } = require('async_hooks');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasTickScheduled = 0;\n\nfunction hasTickScheduled() {\n  return tickInfo[kHasTickScheduled] === 1;\n}\n\nfunction setHasTickScheduled(value) {\n  tickInfo[kHasTickScheduled] = value ? 1 : 0;\n}\n\nconst queue = new FixedQueue();\n\n// Should be in sync with RunNextTicksNative in node_task_queue.cc\nfunction runNextTicks() {\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    runMicrotasks();\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    return;\n\n  processTicksAndRejections();\n}\n\nfunction processTicksAndRejections() {\n  let tock;\n  do {\n    while ((tock = queue.shift()) !== null) {\n      const asyncId = tock[async_id_symbol];\n      emitBefore(asyncId\x2C tock[trigger_async_id_symbol]\x2C tock);\n\n      try {\n        const callback = tock.callback;\n        if (tock.args === undefined) {\n          callback();\n        } else {\n          const args = tock.args;\n          switch (args.length) {\n            case 1: callback(args[0]); break;\n            case 2: callback(args[0]\x2C args[1]); break;\n            case 3: callback(args[0]\x2C args[1]\x2C args[2]); break;\n            case 4: callback(args[0]\x2C args[1]\x2C args[2]\x2C args[3]); break;\n            default: callback(...args);\n          }\n        }\n      } finally {\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n      }\n\n      emitAfter(asyncId);\n    }\n    runMicrotasks();\n  } while (!queue.isEmpty() || processPromiseRejections());\n  setHasTickScheduled(false);\n  setHasRejectionToWarn(false);\n}\n\n// `nextTick()` will not enqueue any callback when the process is about to\n// exit since the callback would not have a chance to be executed.\nfunction nextTick(callback) {\n  validateCallback(callback);\n\n  if (process._exiting)\n    return;\n\n  let args;\n  switch (arguments.length) {\n    case 1: break;\n    case 2: args = [arguments[1]]; break;\n    case 3: args = [arguments[1]\x2C arguments[2]]; break;\n    case 4: args = [arguments[1]\x2C arguments[2]\x2C arguments[3]]; break;\n    default:\n      args = new Array(arguments.length - 1);\n      for (let i = 1; i < arguments.length; i++)\n        args[i - 1] = arguments[i];\n  }\n\n  if (queue.isEmpty())\n    setHasTickScheduled(true);\n  const asyncId = newAsyncId();\n  const triggerAsyncId = getDefaultTriggerAsyncId();\n  const tickObject = {\n    [async_id_symbol]: asyncId\x2C\n    [trigger_async_id_symbol]: triggerAsyncId\x2C\n    callback\x2C\n    args\n  };\n  if (initHooksExist())\n    emitInit(asyncId\x2C 'TickObject'\x2C triggerAsyncId\x2C tickObject);\n  queue.push(tickObject);\n}\n\nfunction runMicrotask() {\n  this.runInAsyncScope(() => {\n    const callback = this.callback;\n    try {\n      callback();\n    } finally {\n      this.emitDestroy();\n    }\n  });\n}\n\nconst defaultMicrotaskResourceOpts = { requireManualDestroy: true };\n\nfunction queueMicrotask(callback) {\n  validateFunction(callback\x2C 'callback');\n\n  const asyncResource = new AsyncResource(\n    'Microtask'\x2C\n    defaultMicrotaskResourceOpts\n  );\n  asyncResource.callback = callback;\n\n  enqueueMicrotask(FunctionPrototypeBind(runMicrotask\x2C asyncResource));\n}\n\nmodule.exports = {\n  setupTaskQueue() {\n    // Sets the per-isolate promise rejection callback\n    listenForRejections();\n    // Sets the callback to be run in every tick.\n    setTickCallback(processTicksAndRejections);\n    return {\n      nextTick\x2C\n      runNextTicks\n    };\n  }\x2C\n  queueMicrotask\n};\n
code-source-info,0x1208b73fa7e,32,2602,3446,C0O2602C2O2617C7O2617C11O2648C14O2660C20O2674C21O2681C22O2689C24O2715C59O2737C61O2756C70O2773C82O2779C84O2798C93O2815C105O2829C117O2835C119O2854C128O2871C140O2885C152O2899C164O2905C166O2931C171O2958C175O2965C181O2938C187O2990C190O3007C194O2995C199O3028C201O3035C207O3051C210O3040C214O3016C219O2977C222O3063C227O3073C232O3073C238O3088C243O3088C247O3133C252O3133C256O3172C261O3172C265O3221C272O3228C278O3246C285O3260C291O3286C301O3306C311O3320C319O3332C324O3336C329O3358C346O3358C351O3421C356O3427C361O3427C367O3445,,
code-creation,LazyCompile,10,158667,0x1208b73fcfe,21, node:internal/validators:222:42,0x2b48e0c7c3e0,~
code-source-info,0x1208b73fcfe,15,6815,6916,C0O6833C6O6873C13O6879C18O6873C20O6915,,
code-creation,LazyCompile,10,158667,0x1208b73fdfe,15,isEmpty node:internal/fixed_queue:95:10,0x815de6146c8,~
script-source,34,node:internal/fixed_queue,'use strict';\n\nconst {\n  Array\x2C\n} = primordials;\n\n// Currently optimal queue size\x2C tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or\x2C if there is only one circular buffer\x2C it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one\x2C removing means\n// moving `bottom` forward by one. After reaching the end\x2C the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue\x2C sets the old queue's `.next` to it\x2C\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue\x2C it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n
code-source-info,0x1208b73fdfe,34,3637,3677,C0O3658C5O3663C10O3663C14O3673,,
code-creation,LazyCompile,10,158834,0x1208b73fef6,13,isEmpty node:internal/fixed_queue:67:10,0x815de614458,~
code-source-info,0x1208b73fef6,34,3084,3129,C0O3105C5O3118C9O3109C12O3125,,
tick,0x1bfcd791c,158875,0,0x0,3,0x0,0x1208b73fb66,0x1208b73e41a,0x1208b73dbca,0x1208b73d756,0x1208b73c5af,0x1208b73c0f0,0x1208b73bec9,0x2cbd764a6ec6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,158875,0x1208b73ffe6,25,setHasTickScheduled node:internal/process/task_queues:52:29,0x815de60f578,~
code-source-info,0x1208b73ffe6,32,1104,1162,C0O1116C7O1125C12O1146C19O1144C24O1161,,
new,MemoryChunk,0xa12169c0000,262144
code-creation,LazyCompile,10,158917,0xa12169c11be,23,newAsyncId node:internal/async_hooks:417:20,0x2b48e0c77b38,~
code-source-info,0xa12169c11be,13,14513,14564,C0O14520C7O14545C16O14560C22O14562,,
code-creation,LazyCompile,10,158917,0xa12169c12e6,35,getDefaultTriggerAsyncId node:internal/async_hooks:433:34,0x2b48e0c77bd8,~
code-source-info,0xa12169c12e6,13,14972,15229,C0O15009C7O15025C9O15024C13O15118C14O15144C19O15153C26O15176C28O15175C31O15195C32O15198C34O15227,,
code-creation,LazyCompile,10,158959,0xa12169c13f6,13,initHooksExist node:internal/async_hooks:479:24,0x2b48e0c77dc8,~
code-source-info,0xa12169c13f6,13,16193,16225,C0O16200C5O16216C8O16207C12O16223,,
code-creation,LazyCompile,10,158959,0xa12169c14de,16,hasHooks node:internal/async_hooks:471:18,0x2b48e0c77d28,~
code-source-info,0xa12169c14de,13,16061,16107,C0O16071C7O16095C12O16101C15O16105,,
code-creation,LazyCompile,10,158959,0xa12169c15ee,59,push node:internal/fixed_queue:99:7,0x815de614718,~
code-source-info,0xa12169c15ee,34,3685,3945,C0O3707C5O3712C10O3712C16O3871C23O3887C26O3883C32O3881C38O3864C42O3925C47O3930C52O3930C58O3944,,
code-creation,LazyCompile,10,159000,0xa12169c1736,24,isFull node:internal/fixed_queue:71:9,0x815de6144a8,~
code-source-info,0xa12169c1736,34,3139,3200,C0O3162C4O3166C10O3173C12O3171C16O3189C20O3180C23O3196,,
code-creation,LazyCompile,10,159000,0xa12169c1846,37,push node:internal/fixed_queue:75:7,0x815de614510,~
code-source-info,0xa12169c1846,34,3208,3291,C0O3226C5O3236C12O3241C16O3270C20O3274C26O3281C28O3279C31O3262C36O3290,,
code-creation,LazyCompile,10,159084,0xa12169c19ee,71,workers.init /Users/vignesh/Projects/HTTP2/lib/workers.js:255:24,0x1208b7102e0,~
code-source-info,0xa12169c19ee,195,9608,10017,C0O9647C4O9655C15O9655C21O9757C24O9765C29O9765C33O9842C36O9850C41O9850C45O9900C48O9908C53O9908C57O9988C60O9996C65O9996C70O10016,,
code-creation,LazyCompile,10,159125,0xa12169c1b4e,38,log node:internal/console/constructor:359:6,0x815de61e040,~
script-source,37,node:internal/console/constructor,'use strict';\n\n// The Console constructor is not actually used to construct the global\n// console. It's exported for backwards compatibility.\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeUnshift\x2C\n  Boolean\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  MathFloor\x2C\n  Number\x2C\n  NumberPrototypeToFixed\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectValues\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  ReflectOwnKeys\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypePadStart\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolHasInstance\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst { trace } = internalBinding('trace_events');\nconst {\n  isStackOverflowError\x2C\n  codes: {\n    ERR_CONSOLE_WRITABLE_STREAM\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateInteger\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst { previewEntries } = internalBinding('util');\nconst { Buffer: { isBuffer } } = require('buffer');\nconst {\n  inspect\x2C\n  formatWithOptions\n} = require('internal/util/inspect');\nconst {\n  isTypedArray\x2C isSet\x2C isMap\x2C isSetIterator\x2C isMapIterator\x2C\n} = require('internal/util/types');\nconst {\n  CHAR_LOWERCASE_B: kTraceBegin\x2C\n  CHAR_LOWERCASE_E: kTraceEnd\x2C\n  CHAR_LOWERCASE_N: kTraceInstant\x2C\n  CHAR_UPPERCASE_C: kTraceCount\x2C\n} = require('internal/constants');\nconst kCounts = Symbol('counts');\n\nconst kTraceConsoleCategory = 'node\x2Cnode.console';\n\nconst kSecond = 1000;\nconst kMinute = 60 * kSecond;\nconst kHour = 60 * kMinute;\nconst kMaxGroupIndentation = 1000;\n\n// Lazy loaded for startup performance.\nlet cliTable;\n\n// Track amount of indentation required via `console.group()`.\nconst kGroupIndent = Symbol('kGroupIndent');\nconst kGroupIndentationWidth = Symbol('kGroupIndentWidth');\nconst kFormatForStderr = Symbol('kFormatForStderr');\nconst kFormatForStdout = Symbol('kFormatForStdout');\nconst kGetInspectOptions = Symbol('kGetInspectOptions');\nconst kColorMode = Symbol('kColorMode');\nconst kIsConsole = Symbol('kIsConsole');\nconst kWriteToConsole = Symbol('kWriteToConsole');\nconst kBindProperties = Symbol('kBindProperties');\nconst kBindStreamsEager = Symbol('kBindStreamsEager');\nconst kBindStreamsLazy = Symbol('kBindStreamsLazy');\nconst kUseStdout = Symbol('kUseStdout');\nconst kUseStderr = Symbol('kUseStderr');\n\nconst optionsMap = new SafeWeakMap();\n\nfunction Console(options /* or: stdout\x2C stderr\x2C ignoreErrors = true */) {\n  // We have to test new.target here to see if this function is called\n  // with new\x2C because we need to define a custom instanceof to accommodate\n  // the global console.\n  if (!new.target) {\n    return ReflectConstruct(Console\x2C arguments);\n  }\n\n  if (!options || typeof options.write === 'function') {\n    options = {\n      stdout: options\x2C\n      stderr: arguments[1]\x2C\n      ignoreErrors: arguments[2]\n    };\n  }\n\n  const {\n    stdout\x2C\n    stderr = stdout\x2C\n    ignoreErrors = true\x2C\n    colorMode = 'auto'\x2C\n    inspectOptions\x2C\n    groupIndentation\x2C\n  } = options;\n\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stdout');\n  }\n  if (!stderr || typeof stderr.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stderr');\n  }\n\n  if (typeof colorMode !== 'boolean' && colorMode !== 'auto')\n    throw new ERR_INVALID_ARG_VALUE('colorMode'\x2C colorMode);\n\n  if (groupIndentation !== undefined) {\n    validateInteger(groupIndentation\x2C 'groupIndentation'\x2C\n                    0\x2C kMaxGroupIndentation);\n  }\n\n  if (inspectOptions !== undefined) {\n    validateObject(inspectOptions\x2C 'options.inspectOptions');\n\n    if (inspectOptions.colors !== undefined &&\n        options.colorMode !== undefined) {\n      throw new ERR_INCOMPATIBLE_OPTION_PAIR(\n        'options.inspectOptions.color'\x2C 'colorMode');\n    }\n    optionsMap.set(this\x2C inspectOptions);\n  }\n\n  // Bind the prototype functions to this Console instance\n  ArrayPrototypeForEach(ObjectKeys(Console.prototype)\x2C (key) => {\n    // We have to bind the methods grabbed from the instance instead of from\n    // the prototype so that users extending the Console can override them\n    // from the prototype chain of the subclass.\n    this[key] = FunctionPrototypeBind(this[key]\x2C this);\n    ObjectDefineProperty(this[key]\x2C 'name'\x2C {\n      value: key\n    });\n  });\n\n  this[kBindStreamsEager](stdout\x2C stderr);\n  this[kBindProperties](ignoreErrors\x2C colorMode\x2C groupIndentation);\n}\n\nconst consolePropAttributes = {\n  writable: true\x2C\n  enumerable: false\x2C\n  configurable: true\n};\n\n// Fixup global.console instanceof global.console.Console\nObjectDefineProperty(Console\x2C SymbolHasInstance\x2C {\n  value(instance) {\n    return instance[kIsConsole];\n  }\n});\n\nconst kColorInspectOptions = { colors: true };\nconst kNoColorInspectOptions = {};\n\nObjectDefineProperties(Console.prototype\x2C {\n  [kBindStreamsEager]: {\n    ...consolePropAttributes\x2C\n    // Eager version for the Console constructor\n    value: function(stdout\x2C stderr) {\n      ObjectDefineProperties(this\x2C {\n        '_stdout': { ...consolePropAttributes\x2C value: stdout }\x2C\n        '_stderr': { ...consolePropAttributes\x2C value: stderr }\n      });\n    }\n  }\x2C\n  [kBindStreamsLazy]: {\n    ...consolePropAttributes\x2C\n    // Lazily load the stdout and stderr from an object so we don't\n    // create the stdio streams when they are not even accessed\n    value: function(object) {\n      let stdout;\n      let stderr;\n      ObjectDefineProperties(this\x2C {\n        '_stdout': {\n          enumerable: false\x2C\n          configurable: true\x2C\n          get() {\n            if (!stdout) stdout = object.stdout;\n            return stdout;\n          }\x2C\n          set(value) { stdout = value; }\n        }\x2C\n        '_stderr': {\n          enumerable: false\x2C\n          configurable: true\x2C\n          get() {\n            if (!stderr) { stderr = object.stderr; }\n            return stderr;\n          }\x2C\n          set(value) { stderr = value; }\n        }\n      });\n    }\n  }\x2C\n  [kBindProperties]: {\n    ...consolePropAttributes\x2C\n    value: function(ignoreErrors\x2C colorMode\x2C groupIndentation = 2) {\n      ObjectDefineProperties(this\x2C {\n        '_stdoutErrorHandler': {\n          ...consolePropAttributes\x2C\n          value: createWriteErrorHandler(this\x2C kUseStdout)\n        }\x2C\n        '_stderrErrorHandler': {\n          ...consolePropAttributes\x2C\n          value: createWriteErrorHandler(this\x2C kUseStderr)\n        }\x2C\n        '_ignoreErrors': {\n          ...consolePropAttributes\x2C\n          value: Boolean(ignoreErrors)\n        }\x2C\n        '_times': { ...consolePropAttributes\x2C value: new SafeMap() }\x2C\n        // Corresponds to https://console.spec.whatwg.org/#count-map\n        [kCounts]: { ...consolePropAttributes\x2C value: new SafeMap() }\x2C\n        [kColorMode]: { ...consolePropAttributes\x2C value: colorMode }\x2C\n        [kIsConsole]: { ...consolePropAttributes\x2C value: true }\x2C\n        [kGroupIndent]: { ...consolePropAttributes\x2C value: '' }\x2C\n        [kGroupIndentationWidth]: {\n          ...consolePropAttributes\x2C\n          value: groupIndentation\n        }\x2C\n        [SymbolToStringTag]: {\n          writable: false\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          value: 'console'\n        }\n      });\n    }\n  }\x2C\n  [kWriteToConsole]: {\n    ...consolePropAttributes\x2C\n    value: function(streamSymbol\x2C string) {\n      const ignoreErrors = this._ignoreErrors;\n      const groupIndent = this[kGroupIndent];\n\n      const useStdout = streamSymbol === kUseStdout;\n      const stream = useStdout ? this._stdout : this._stderr;\n      const errorHandler = useStdout ?\n        this._stdoutErrorHandler : this._stderrErrorHandler;\n\n      if (groupIndent.length !== 0) {\n        if (StringPrototypeIncludes(string\x2C '\\n')) {\n          string = StringPrototypeReplace(string\x2C /\\n/g\x2C `\\n${groupIndent}`);\n        }\n        string = groupIndent + string;\n      }\n      string += '\\n';\n\n      if (ignoreErrors === false) return stream.write(string);\n\n      // There may be an error occurring synchronously (e.g. for files or TTYs\n      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems)\x2C so\n      // handle both situations.\n      try {\n        // Add and later remove a noop error handler to catch synchronous\n        // errors.\n        if (stream.listenerCount('error') === 0)\n          stream.once('error'\x2C noop);\n\n        stream.write(string\x2C errorHandler);\n      } catch (e) {\n        // Console is a debugging utility\x2C so it swallowing errors is not\n        // desirable even in edge cases such as low stack space.\n        if (isStackOverflowError(e))\n          throw e;\n        // Sorry\x2C there's no proper way to pass along the error here.\n      } finally {\n        stream.removeListener('error'\x2C noop);\n      }\n    }\n  }\x2C\n  [kGetInspectOptions]: {\n    ...consolePropAttributes\x2C\n    value: function(stream) {\n      let color = this[kColorMode];\n      if (color === 'auto') {\n        color = stream.isTTY && (\n          typeof stream.getColorDepth === 'function' ?\n            stream.getColorDepth() > 2 : true);\n      }\n\n      const options = optionsMap.get(this);\n      if (options) {\n        if (options.colors === undefined) {\n          options.colors = color;\n        }\n        return options;\n      }\n\n      return color ? kColorInspectOptions : kNoColorInspectOptions;\n    }\n  }\x2C\n  [kFormatForStdout]: {\n    ...consolePropAttributes\x2C\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stdout);\n      ArrayPrototypeUnshift(args\x2C opts);\n      return ReflectApply(formatWithOptions\x2C null\x2C args);\n    }\n  }\x2C\n  [kFormatForStderr]: {\n    ...consolePropAttributes\x2C\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stderr);\n      ArrayPrototypeUnshift(args\x2C opts);\n      return ReflectApply(formatWithOptions\x2C null\x2C args);\n    }\n  }\x2C\n});\n\n// Make a function that can serve as the callback passed to `stream.write()`.\nfunction createWriteErrorHandler(instance\x2C streamSymbol) {\n  return (err) => {\n    // This conditional evaluates to true if and only if there was an error\n    // that was not already emitted (which happens when the _write callback\n    // is invoked asynchronously).\n    const stream = streamSymbol === kUseStdout ?\n      instance._stdout : instance._stderr;\n    if (err !== null && !stream._writableState.errorEmitted) {\n      // If there was an error\x2C it will be emitted on `stream` as\n      // an `error` event. Adding a `once` listener will keep that error\n      // from becoming an uncaught exception\x2C but since the handler is\n      // removed after the event\x2C non-console.* writes won't be affected.\n      // we are only adding noop if there is no one else listening for 'error'\n      if (stream.listenerCount('error') === 0) {\n        stream.once('error'\x2C noop);\n      }\n    }\n  };\n}\n\nconst consoleMethods = {\n  log(...args) {\n    this[kWriteToConsole](kUseStdout\x2C this[kFormatForStdout](args));\n  }\x2C\n\n\n  warn(...args) {\n    this[kWriteToConsole](kUseStderr\x2C this[kFormatForStderr](args));\n  }\x2C\n\n\n  dir(object\x2C options) {\n    this[kWriteToConsole](kUseStdout\x2C inspect(object\x2C {\n      customInspect: false\x2C\n      ...this[kGetInspectOptions](this._stdout)\x2C\n      ...options\n    }));\n  }\x2C\n\n  time(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    if (this._times.has(label)) {\n      process.emitWarning(`Label '${label}' already exists for console.time()`);\n      return;\n    }\n    trace(kTraceBegin\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n    this._times.set(label\x2C process.hrtime());\n  }\x2C\n\n  timeEnd(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    const found = timeLogImpl(this\x2C 'timeEnd'\x2C label);\n    trace(kTraceEnd\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n    if (found) {\n      this._times.delete(label);\n    }\n  }\x2C\n\n  timeLog(label = 'default'\x2C ...data) {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    timeLogImpl(this\x2C 'timeLog'\x2C label\x2C data);\n    trace(kTraceInstant\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n  }\x2C\n\n  trace: function trace(...args) {\n    const err = {\n      name: 'Trace'\x2C\n      message: this[kFormatForStderr](args)\n    };\n    ErrorCaptureStackTrace(err\x2C trace);\n    this.error(err.stack);\n  }\x2C\n\n  assert(expression\x2C ...args) {\n    if (!expression) {\n      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;\n      // The arguments will be formatted in warn() again\n      ReflectApply(this.warn\x2C this\x2C args);\n    }\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#clear\n  clear() {\n    // It only makes sense to clear if _stdout is a TTY.\n    // Otherwise\x2C do nothing.\n    if (this._stdout.isTTY && process.env.TERM !== 'dumb') {\n      // The require is here intentionally to avoid readline being\n      // required too early when console is first loaded.\n      const {\n        cursorTo\x2C\n        clearScreenDown\x2C\n      } = require('internal/readline/callbacks');\n      cursorTo(this._stdout\x2C 0\x2C 0);\n      clearScreenDown(this._stdout);\n    }\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#count\n  count(label = 'default') {\n    // Ensures that label is a string\x2C and only things that can be\n    // coerced to strings. e.g. Symbol is not allowed\n    label = `${label}`;\n    const counts = this[kCounts];\n    let count = counts.get(label);\n    if (count === undefined)\n      count = 1;\n    else\n      count++;\n    counts.set(label\x2C count);\n    trace(kTraceCount\x2C kTraceConsoleCategory\x2C `count::${label}`\x2C 0\x2C count);\n    this.log(`${label}: ${count}`);\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#countreset\n  countReset(label = 'default') {\n    const counts = this[kCounts];\n    if (!counts.has(label)) {\n      process.emitWarning(`Count for '${label}' does not exist`);\n      return;\n    }\n    trace(kTraceCount\x2C kTraceConsoleCategory\x2C `count::${label}`\x2C 0\x2C 0);\n    counts.delete(`${label}`);\n  }\x2C\n\n  group(...data) {\n    if (data.length > 0) {\n      ReflectApply(this.log\x2C this\x2C data);\n    }\n    this[kGroupIndent] +=\n      StringPrototypeRepeat(' '\x2C this[kGroupIndentationWidth]);\n  }\x2C\n\n  groupEnd() {\n    this[kGroupIndent] = StringPrototypeSlice(\n      this[kGroupIndent]\x2C\n      0\x2C\n      this[kGroupIndent].length - this[kGroupIndentationWidth]\n    );\n  }\x2C\n\n  // https://console.spec.whatwg.org/#table\n  table(tabularData\x2C properties) {\n    if (properties !== undefined)\n      validateArray(properties\x2C 'properties');\n\n    if (tabularData === null || typeof tabularData !== 'object')\n      return this.log(tabularData);\n\n    if (cliTable === undefined) cliTable = require('internal/cli_table');\n    const final = (k\x2C v) => this.log(cliTable(k\x2C v));\n\n    const _inspect = (v) => {\n      const depth = v !== null &&\n                    typeof v === 'object' &&\n                    !isArray(v) &&\n                    ObjectKeys(v).length > 2 ? -1 : 0;\n      const opt = {\n        depth\x2C\n        maxArrayLength: 3\x2C\n        breakLength: Infinity\x2C\n        ...this[kGetInspectOptions](this._stdout)\n      };\n      return inspect(v\x2C opt);\n    };\n    const getIndexArray = (length) => ArrayFrom(\n      { length }\x2C (_\x2C i) => _inspect(i));\n\n    const mapIter = isMapIterator(tabularData);\n    let isKeyValue = false;\n    let i = 0;\n    if (mapIter) {\n      const res = previewEntries(tabularData\x2C true);\n      tabularData = res[0];\n      isKeyValue = res[1];\n    }\n\n    if (isKeyValue || isMap(tabularData)) {\n      const keys = [];\n      const values = [];\n      let length = 0;\n      if (mapIter) {\n        for (; i < tabularData.length / 2; ++i) {\n          ArrayPrototypePush(keys\x2C _inspect(tabularData[i * 2]));\n          ArrayPrototypePush(values\x2C _inspect(tabularData[i * 2 + 1]));\n          length++;\n        }\n      } else {\n        for (const { 0: k\x2C 1: v } of tabularData) {\n          ArrayPrototypePush(keys\x2C _inspect(k));\n          ArrayPrototypePush(values\x2C _inspect(v));\n          length++;\n        }\n      }\n      return final([\n        iterKey\x2C keyKey\x2C valuesKey\x2C\n      ]\x2C [\n        getIndexArray(length)\x2C\n        keys\x2C\n        values\x2C\n      ]);\n    }\n\n    const setIter = isSetIterator(tabularData);\n    if (setIter)\n      tabularData = previewEntries(tabularData);\n\n    const setlike = setIter || mapIter || isSet(tabularData);\n    if (setlike) {\n      const values = [];\n      let length = 0;\n      for (const v of tabularData) {\n        ArrayPrototypePush(values\x2C _inspect(v));\n        length++;\n      }\n      return final([iterKey\x2C valuesKey]\x2C [getIndexArray(length)\x2C values]);\n    }\n\n    const map = ObjectCreate(null);\n    let hasPrimitives = false;\n    const valuesKeyArray = [];\n    const indexKeyArray = ObjectKeys(tabularData);\n\n    for (; i < indexKeyArray.length; i++) {\n      const item = tabularData[indexKeyArray[i]];\n      const primitive = item === null ||\n          (typeof item !== 'function' && typeof item !== 'object');\n      if (properties === undefined && primitive) {\n        hasPrimitives = true;\n        valuesKeyArray[i] = _inspect(item);\n      } else {\n        const keys = properties || ObjectKeys(item);\n        for (const key of keys) {\n          if (map[key] === undefined)\n            map[key] = [];\n          if ((primitive && properties) ||\n               !ObjectPrototypeHasOwnProperty(item\x2C key))\n            map[key][i] = '';\n          else\n            map[key][i] = _inspect(item[key]);\n        }\n      }\n    }\n\n    const keys = ObjectKeys(map);\n    const values = ObjectValues(map);\n    if (hasPrimitives) {\n      ArrayPrototypePush(keys\x2C valuesKey);\n      ArrayPrototypePush(values\x2C valuesKeyArray);\n    }\n    ArrayPrototypeUnshift(keys\x2C indexKey);\n    ArrayPrototypeUnshift(values\x2C indexKeyArray);\n\n    return final(keys\x2C values);\n  }\x2C\n};\n\n// Returns true if label was found\nfunction timeLogImpl(self\x2C name\x2C label\x2C data) {\n  const time = self._times.get(label);\n  if (time === undefined) {\n    process.emitWarning(`No such label '${label}' for console.${name}()`);\n    return false;\n  }\n  const duration = process.hrtime(time);\n  const ms = duration[0] * 1000 + duration[1] / 1e6;\n\n  const formatted = formatTime(ms);\n\n  if (data === undefined) {\n    self.log('%s: %s'\x2C label\x2C formatted);\n  } else {\n    self.log('%s: %s'\x2C label\x2C formatted\x2C ...new SafeArrayIterator(data));\n  }\n  return true;\n}\n\nfunction pad(value) {\n  return StringPrototypePadStart(`${value}`\x2C 2\x2C '0');\n}\n\nfunction formatTime(ms) {\n  let hours = 0;\n  let minutes = 0;\n  let seconds = 0;\n\n  if (ms >= kSecond) {\n    if (ms >= kMinute) {\n      if (ms >= kHour) {\n        hours = MathFloor(ms / kHour);\n        ms = ms % kHour;\n      }\n      minutes = MathFloor(ms / kMinute);\n      ms = ms % kMinute;\n    }\n    seconds = ms / kSecond;\n  }\n\n  if (hours !== 0 || minutes !== 0) {\n    ({ 0: seconds\x2C 1: ms } = StringPrototypeSplit(\n      NumberPrototypeToFixed(seconds\x2C 3)\x2C\n      '.'\n    ));\n    const res = hours !== 0 ? `${hours}:${pad(minutes)}` : minutes;\n    return `${res}:${pad(seconds)}.${ms} (${hours !== 0 ? 'h:m' : ''}m:ss.mmm)`;\n  }\n\n  if (seconds !== 0) {\n    return `${NumberPrototypeToFixed(seconds\x2C 3)}s`;\n  }\n\n  return `${Number(NumberPrototypeToFixed(ms\x2C 3))}ms`;\n}\n\nconst keyKey = 'Key';\nconst valuesKey = 'Values';\nconst indexKey = '(index)';\nconst iterKey = '(iteration index)';\n\nconst isArray = (v) => ArrayIsArray(v) || isTypedArray(v) || isBuffer(v);\n\nfunction noop() {}\n\nfor (const method of ReflectOwnKeys(consoleMethods))\n  Console.prototype[method] = consoleMethods[method];\n\nConsole.prototype.debug = Console.prototype.log;\nConsole.prototype.info = Console.prototype.log;\nConsole.prototype.dirxml = Console.prototype.log;\nConsole.prototype.error = Console.prototype.warn;\nConsole.prototype.groupCollapsed = Console.prototype.group;\n\nmodule.exports = {\n  Console\x2C\n  kBindStreamsLazy\x2C\n  kBindProperties\x2C\n  formatTime // exported for tests\n};\n
code-source-info,0xa12169c1b4e,37,11007,11091,C0O11007C3O11023C5O11028C7O11027C13O11045C18O11062C20O11061C24O11079C30O11044C37O11090,,
code-creation,LazyCompile,10,159834,0xa12169c31c6,50,value node:internal/console/constructor:321:20,0x815de61dde8,~
code-source-info,0xa12169c31c6,37,9574,9746,C0O9602C2O9607C4O9606C8O9632C13O9626C19O9648C24O9648C29O9689C36O9709C44O9696C49O9740,,
code-creation,LazyCompile,10,159875,0xa12169c32de,27,get node:internal/console/constructor:203:14,0x815de61dab8,~
code-source-info,0xa12169c32de,37,5761,5853,C0O5778C6O5791C9O5807C16O5798C22O5827C26O5841,,
code-creation,LazyCompile,10,159875,0xa12169c343e,96,value node:internal/console/constructor:300:20,0x815de61dd60,~
code-source-info,0xa12169c343e,37,9013,9495,C0O9042C2O9047C4O9046C8O9066C10O9076C15O9113C21O9148C29O9198C34O9198C41O9214C48O9258C53O9269C58O9269C64O9286C66O9321C72O9355C74O9370C78O9397C80O9412C81O9428C87O9443C93O9466C95O9489,,
code-creation,LazyCompile,10,160000,0xa12169c35d6,49,formatWithOptions node:internal/util/inspect:2024:27,0x232faba1b8e0,~
script-source,20,node:internal/util/inspect,'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypePushApply\x2C\n  ArrayPrototypeSort\x2C\n  ArrayPrototypeUnshift\x2C\n  BigIntPrototypeValueOf\x2C\n  BooleanPrototypeValueOf\x2C\n  DatePrototypeGetTime\x2C\n  DatePrototypeToISOString\x2C\n  DatePrototypeToString\x2C\n  ErrorPrototypeToString\x2C\n  FunctionPrototypeCall\x2C\n  FunctionPrototypeToString\x2C\n  JSONStringify\x2C\n  MapPrototypeGetSize\x2C\n  MapPrototypeEntries\x2C\n  MathFloor\x2C\n  MathMax\x2C\n  MathMin\x2C\n  MathRound\x2C\n  MathSqrt\x2C\n  MathTrunc\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  NumberIsNaN\x2C\n  NumberParseFloat\x2C\n  NumberParseInt\x2C\n  NumberPrototypeValueOf\x2C\n  Object\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectIs\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectPrototypePropertyIsEnumerable\x2C\n  ObjectSeal\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectOwnKeys\x2C\n  RegExp\x2C\n  RegExpPrototypeTest\x2C\n  RegExpPrototypeToString\x2C\n  SafeStringIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  SetPrototypeGetSize\x2C\n  SetPrototypeValues\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeNormalize\x2C\n  StringPrototypePadEnd\x2C\n  StringPrototypePadStart\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  StringPrototypeValueOf\x2C\n  SymbolPrototypeToString\x2C\n  SymbolPrototypeValueOf\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  TypedArrayPrototypeGetLength\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n  Uint8Array\x2C\n  globalThis\x2C\n  uncurryThis\x2C\n} = primordials;\n\nconst {\n  getOwnNonIndexProperties\x2C\n  getPromiseDetails\x2C\n  getProxyDetails\x2C\n  kPending\x2C\n  kRejected\x2C\n  previewEntries\x2C\n  getConstructorName: internalGetConstructorName\x2C\n  getExternalValue\x2C\n  propertyFilter: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\n  }\n} = internalBinding('util');\n\nconst {\n  customInspectSymbol\x2C\n  isError\x2C\n  join\x2C\n  removeColors\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  }\x2C\n  isStackOverflowError\n} = require('internal/errors');\n\nconst {\n  isAsyncFunction\x2C\n  isGeneratorFunction\x2C\n  isAnyArrayBuffer\x2C\n  isArrayBuffer\x2C\n  isArgumentsObject\x2C\n  isBoxedPrimitive\x2C\n  isDataView\x2C\n  isExternal\x2C\n  isMap\x2C\n  isMapIterator\x2C\n  isModuleNamespaceObject\x2C\n  isNativeError\x2C\n  isPromise\x2C\n  isSet\x2C\n  isSetIterator\x2C\n  isWeakMap\x2C\n  isWeakSet\x2C\n  isRegExp\x2C\n  isDate\x2C\n  isTypedArray\x2C\n  isStringObject\x2C\n  isNumberObject\x2C\n  isBooleanObject\x2C\n  isBigIntObject\x2C\n} = require('internal/util/types');\n\nconst assert = require('internal/assert');\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nlet hexSlice;\n\nconst builtInObjects = new SafeSet(\n  ArrayPrototypeFilter(\n    ObjectGetOwnPropertyNames(globalThis)\x2C\n    (e) => RegExpPrototypeTest(/^[A-Z][a-zA-Z0-9]+$/\x2C e)\n  )\n);\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\n\n// These options must stay in sync with `getUserOptions`. So if any option will\n// be added or removed\x2C `getUserOptions` must also be updated accordingly.\nconst inspectDefaultOptions = ObjectSeal({\n  showHidden: false\x2C\n  depth: 2\x2C\n  colors: false\x2C\n  customInspect: true\x2C\n  showProxy: false\x2C\n  maxArrayLength: 100\x2C\n  maxStringLength: 10000\x2C\n  breakLength: 80\x2C\n  compact: 3\x2C\n  sorted: false\x2C\n  getters: false\x2C\n  numericSeparator: false\x2C\n});\n\nconst kObjectType = 0;\nconst kArrayType = 1;\nconst kArrayExtrasType = 2;\n\n/* eslint-disable no-control-regex */\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/;\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/g;\nconst strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/;\nconst strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/g;\n/* eslint-enable no-control-regex */\n\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\n\nconst coreModuleRegExp = /^ {4}at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$/;\nconst nodeModulesRegExp = /[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g;\n\nconst classRegExp = /^(\\s+[^(]*?)\\s*{/;\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\nconst stripCommentsRegExp = /(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g;\n\nconst kMinLineLength = 16;\n\n// Constants to map the iterator state.\nconst kWeak = 0;\nconst kIterator = 1;\nconst kMapEntries = 2;\n\n// Escaped control characters (plus the single quote and the backslash). Use\n// empty strings to fill up unused entries.\nconst meta = [\n  '\\\\x00'\x2C '\\\\x01'\x2C '\\\\x02'\x2C '\\\\x03'\x2C '\\\\x04'\x2C '\\\\x05'\x2C '\\\\x06'\x2C '\\\\x07'\x2C // x07\n  '\\\\b'\x2C '\\\\t'\x2C '\\\\n'\x2C '\\\\x0B'\x2C '\\\\f'\x2C '\\\\r'\x2C '\\\\x0E'\x2C '\\\\x0F'\x2C           // x0F\n  '\\\\x10'\x2C '\\\\x11'\x2C '\\\\x12'\x2C '\\\\x13'\x2C '\\\\x14'\x2C '\\\\x15'\x2C '\\\\x16'\x2C '\\\\x17'\x2C // x17\n  '\\\\x18'\x2C '\\\\x19'\x2C '\\\\x1A'\x2C '\\\\x1B'\x2C '\\\\x1C'\x2C '\\\\x1D'\x2C '\\\\x1E'\x2C '\\\\x1F'\x2C // x1F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C "\\\\'"\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C      // x2F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x3F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x4F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\\\\\'\x2C ''\x2C ''\x2C ''\x2C     // x5F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x6F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\x7F'\x2C    // x7F\n  '\\\\x80'\x2C '\\\\x81'\x2C '\\\\x82'\x2C '\\\\x83'\x2C '\\\\x84'\x2C '\\\\x85'\x2C '\\\\x86'\x2C '\\\\x87'\x2C // x87\n  '\\\\x88'\x2C '\\\\x89'\x2C '\\\\x8A'\x2C '\\\\x8B'\x2C '\\\\x8C'\x2C '\\\\x8D'\x2C '\\\\x8E'\x2C '\\\\x8F'\x2C // x8F\n  '\\\\x90'\x2C '\\\\x91'\x2C '\\\\x92'\x2C '\\\\x93'\x2C '\\\\x94'\x2C '\\\\x95'\x2C '\\\\x96'\x2C '\\\\x97'\x2C // x97\n  '\\\\x98'\x2C '\\\\x99'\x2C '\\\\x9A'\x2C '\\\\x9B'\x2C '\\\\x9C'\x2C '\\\\x9D'\x2C '\\\\x9E'\x2C '\\\\x9F'\x2C // x9F\n];\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT\x2C authors: @sindresorhus\x2C Qix-\x2C arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nconst ansiPattern = '[\\\\u001B\\\\u009B][[\\\\]()#;?]*' +\n  '(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*' +\n  '|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)' +\n  '|(?:(?:\\\\d{1\x2C4}(?:;\\\\d{0\x2C4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))';\nconst ansi = new RegExp(ansiPattern\x2C 'g');\n\nlet getStringWidth;\n\nfunction getUserOptions(ctx\x2C isCrossContext) {\n  const ret = {\n    stylize: ctx.stylize\x2C\n    showHidden: ctx.showHidden\x2C\n    depth: ctx.depth\x2C\n    colors: ctx.colors\x2C\n    customInspect: ctx.customInspect\x2C\n    showProxy: ctx.showProxy\x2C\n    maxArrayLength: ctx.maxArrayLength\x2C\n    maxStringLength: ctx.maxStringLength\x2C\n    breakLength: ctx.breakLength\x2C\n    compact: ctx.compact\x2C\n    sorted: ctx.sorted\x2C\n    getters: ctx.getters\x2C\n    numericSeparator: ctx.numericSeparator\x2C\n    ...ctx.userOptions\n  };\n\n  // Typically\x2C the target value will be an instance of `Object`. If that is\n  // *not* the case\x2C the object may come from another vm.Context\x2C and we want\n  // to avoid passing it objects from this Context in that case\x2C so we remove\n  // the prototype from the returned object itself + the `stylize()` function\x2C\n  // and remove all other non-primitives\x2C including non-primitive user options.\n  if (isCrossContext) {\n    ObjectSetPrototypeOf(ret\x2C null);\n    for (const key of ObjectKeys(ret)) {\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\n          ret[key] !== null) {\n        delete ret[key];\n      }\n    }\n    ret.stylize = ObjectSetPrototypeOf((value\x2C flavour) => {\n      let stylized;\n      try {\n        stylized = `${ctx.stylize(value\x2C flavour)}`;\n      } catch {\n        // Continue regardless of error.\n      }\n\n      if (typeof stylized !== 'string') return value;\n      // `stylized` is a string as it should be\x2C which is safe to pass along.\n      return stylized;\n    }\x2C null);\n  }\n\n  return ret;\n}\n\n/**\n * Echos the value of any input. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {any} value The value to print out.\n * @param {object} opts Optional options object that alters the output.\n */\n/* Legacy: value\x2C showHidden\x2C depth\x2C colors */\nfunction inspect(value\x2C opts) {\n  // Default options\n  const ctx = {\n    budget: {}\x2C\n    indentationLvl: 0\x2C\n    seen: []\x2C\n    currentDepth: 0\x2C\n    stylize: stylizeNoColor\x2C\n    showHidden: inspectDefaultOptions.showHidden\x2C\n    depth: inspectDefaultOptions.depth\x2C\n    colors: inspectDefaultOptions.colors\x2C\n    customInspect: inspectDefaultOptions.customInspect\x2C\n    showProxy: inspectDefaultOptions.showProxy\x2C\n    maxArrayLength: inspectDefaultOptions.maxArrayLength\x2C\n    maxStringLength: inspectDefaultOptions.maxStringLength\x2C\n    breakLength: inspectDefaultOptions.breakLength\x2C\n    compact: inspectDefaultOptions.compact\x2C\n    sorted: inspectDefaultOptions.sorted\x2C\n    getters: inspectDefaultOptions.getters\x2C\n    numericSeparator: inspectDefaultOptions.numericSeparator\x2C\n  };\n  if (arguments.length > 1) {\n    // Legacy...\n    if (arguments.length > 2) {\n      if (arguments[2] !== undefined) {\n        ctx.depth = arguments[2];\n      }\n      if (arguments.length > 3 && arguments[3] !== undefined) {\n        ctx.colors = arguments[3];\n      }\n    }\n    // Set user-specified options\n    if (typeof opts === 'boolean') {\n      ctx.showHidden = opts;\n    } else if (opts) {\n      const optKeys = ObjectKeys(opts);\n      for (let i = 0; i < optKeys.length; ++i) {\n        const key = optKeys[i];\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\n        // this function public or add a new API with a similar or better\n        // functionality.\n        if (\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions\x2C key) ||\n          key === 'stylize') {\n          ctx[key] = opts[key];\n        } else if (ctx.userOptions === undefined) {\n          // This is required to pass through the actual user input.\n          ctx.userOptions = opts;\n        }\n      }\n    }\n  }\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\n  return formatValue(ctx\x2C value\x2C 0);\n}\ninspect.custom = customInspectSymbol;\n\nObjectDefineProperty(inspect\x2C 'defaultOptions'\x2C {\n  get() {\n    return inspectDefaultOptions;\n  }\x2C\n  set(options) {\n    validateObject(options\x2C 'options');\n    return ObjectAssign(inspectDefaultOptions\x2C options);\n  }\n});\n\n// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n// Each color consists of an array with the color code as first entry and the\n// reset code as second entry.\nconst defaultFG = 39;\nconst defaultBG = 49;\ninspect.colors = ObjectAssign(ObjectCreate(null)\x2C {\n  reset: [0\x2C 0]\x2C\n  bold: [1\x2C 22]\x2C\n  dim: [2\x2C 22]\x2C // Alias: faint\n  italic: [3\x2C 23]\x2C\n  underline: [4\x2C 24]\x2C\n  blink: [5\x2C 25]\x2C\n  // Swap foreground and background colors\n  inverse: [7\x2C 27]\x2C // Alias: swapcolors\x2C swapColors\n  hidden: [8\x2C 28]\x2C // Alias: conceal\n  strikethrough: [9\x2C 29]\x2C // Alias: strikeThrough\x2C crossedout\x2C crossedOut\n  doubleunderline: [21\x2C 24]\x2C // Alias: doubleUnderline\n  black: [30\x2C defaultFG]\x2C\n  red: [31\x2C defaultFG]\x2C\n  green: [32\x2C defaultFG]\x2C\n  yellow: [33\x2C defaultFG]\x2C\n  blue: [34\x2C defaultFG]\x2C\n  magenta: [35\x2C defaultFG]\x2C\n  cyan: [36\x2C defaultFG]\x2C\n  white: [37\x2C defaultFG]\x2C\n  bgBlack: [40\x2C defaultBG]\x2C\n  bgRed: [41\x2C defaultBG]\x2C\n  bgGreen: [42\x2C defaultBG]\x2C\n  bgYellow: [43\x2C defaultBG]\x2C\n  bgBlue: [44\x2C defaultBG]\x2C\n  bgMagenta: [45\x2C defaultBG]\x2C\n  bgCyan: [46\x2C defaultBG]\x2C\n  bgWhite: [47\x2C defaultBG]\x2C\n  framed: [51\x2C 54]\x2C\n  overlined: [53\x2C 55]\x2C\n  gray: [90\x2C defaultFG]\x2C // Alias: grey\x2C blackBright\n  redBright: [91\x2C defaultFG]\x2C\n  greenBright: [92\x2C defaultFG]\x2C\n  yellowBright: [93\x2C defaultFG]\x2C\n  blueBright: [94\x2C defaultFG]\x2C\n  magentaBright: [95\x2C defaultFG]\x2C\n  cyanBright: [96\x2C defaultFG]\x2C\n  whiteBright: [97\x2C defaultFG]\x2C\n  bgGray: [100\x2C defaultBG]\x2C // Alias: bgGrey\x2C bgBlackBright\n  bgRedBright: [101\x2C defaultBG]\x2C\n  bgGreenBright: [102\x2C defaultBG]\x2C\n  bgYellowBright: [103\x2C defaultBG]\x2C\n  bgBlueBright: [104\x2C defaultBG]\x2C\n  bgMagentaBright: [105\x2C defaultBG]\x2C\n  bgCyanBright: [106\x2C defaultBG]\x2C\n  bgWhiteBright: [107\x2C defaultBG]\x2C\n});\n\nfunction defineColorAlias(target\x2C alias) {\n  ObjectDefineProperty(inspect.colors\x2C alias\x2C {\n    get() {\n      return this[target];\n    }\x2C\n    set(value) {\n      this[target] = value;\n    }\x2C\n    configurable: true\x2C\n    enumerable: false\n  });\n}\n\ndefineColorAlias('gray'\x2C 'grey');\ndefineColorAlias('gray'\x2C 'blackBright');\ndefineColorAlias('bgGray'\x2C 'bgGrey');\ndefineColorAlias('bgGray'\x2C 'bgBlackBright');\ndefineColorAlias('dim'\x2C 'faint');\ndefineColorAlias('strikethrough'\x2C 'crossedout');\ndefineColorAlias('strikethrough'\x2C 'strikeThrough');\ndefineColorAlias('strikethrough'\x2C 'crossedOut');\ndefineColorAlias('hidden'\x2C 'conceal');\ndefineColorAlias('inverse'\x2C 'swapColors');\ndefineColorAlias('inverse'\x2C 'swapcolors');\ndefineColorAlias('doubleunderline'\x2C 'doubleUnderline');\n\n// TODO(BridgeAR): Add function style support for more complex styles.\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = ObjectAssign(ObjectCreate(null)\x2C {\n  special: 'cyan'\x2C\n  number: 'yellow'\x2C\n  bigint: 'yellow'\x2C\n  boolean: 'yellow'\x2C\n  undefined: 'grey'\x2C\n  null: 'bold'\x2C\n  string: 'green'\x2C\n  symbol: 'green'\x2C\n  date: 'magenta'\x2C\n  // "name": intentionally not styling\n  // TODO(BridgeAR): Highlight regular expressions properly.\n  regexp: 'red'\x2C\n  module: 'underline'\n});\n\nfunction addQuotes(str\x2C quotes) {\n  if (quotes === -1) {\n    return `"${str}"`;\n  }\n  if (quotes === -2) {\n    return `\\`${str}\\``;\n  }\n  return `'${str}'`;\n}\n\nfunction escapeFn(str) {\n  const charCode = StringPrototypeCharCodeAt(str);\n  return meta.length > charCode ? meta[charCode] : `\\\\u${charCode.toString(16)}`;\n}\n\n// Escape control characters\x2C single quotes and the backslash.\n// This is similar to JSON stringify escaping.\nfunction strEscape(str) {\n  let escapeTest = strEscapeSequencesRegExp;\n  let escapeReplace = strEscapeSequencesReplacer;\n  let singleQuote = 39;\n\n  // Check for double quotes. If not present\x2C do not escape single quotes and\n  // instead wrap the text in double quotes. If double quotes exist\x2C check for\n  // backticks. If they do not exist\x2C use those as fallback instead of the\n  // double quotes.\n  if (StringPrototypeIncludes(str\x2C "'")) {\n    // This invalidates the charCode and therefore can not be matched for\n    // anymore.\n    if (!StringPrototypeIncludes(str\x2C '"')) {\n      singleQuote = -1;\n    } else if (!StringPrototypeIncludes(str\x2C '`') &&\n               !StringPrototypeIncludes(str\x2C '${')) {\n      singleQuote = -2;\n    }\n    if (singleQuote !== 39) {\n      escapeTest = strEscapeSequencesRegExpSingle;\n      escapeReplace = strEscapeSequencesReplacerSingle;\n    }\n  }\n\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n  if (str.length < 5000 && !RegExpPrototypeTest(escapeTest\x2C str))\n    return addQuotes(str\x2C singleQuote);\n  if (str.length > 100) {\n    str = StringPrototypeReplace(str\x2C escapeReplace\x2C escapeFn);\n    return addQuotes(str\x2C singleQuote);\n  }\n\n  let result = '';\n  let last = 0;\n  for (let i = 0; i < str.length; i++) {\n    const point = StringPrototypeCharCodeAt(str\x2C i);\n    if (point === singleQuote ||\n        point === 92 ||\n        point < 32 ||\n        (point > 126 && point < 160)) {\n      if (last === i) {\n        result += meta[point];\n      } else {\n        result += `${StringPrototypeSlice(str\x2C last\x2C i)}${meta[point]}`;\n      }\n      last = i + 1;\n    } else if (point >= 0xd800 && point <= 0xdfff) {\n      if (point <= 0xdbff && i + 1 < str.length) {\n        const point = StringPrototypeCharCodeAt(str\x2C i + 1);\n        if (point >= 0xdc00 && point <= 0xdfff) {\n          i++;\n          continue;\n        }\n      }\n      result += `${StringPrototypeSlice(str\x2C last\x2C i)}${`\\\\u${point.toString(16)}`}`;\n      last = i + 1;\n    }\n  }\n\n  if (last !== str.length) {\n    result += StringPrototypeSlice(str\x2C last);\n  }\n  return addQuotes(result\x2C singleQuote);\n}\n\nfunction stylizeWithColor(str\x2C styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== undefined) {\n    const color = inspect.colors[style];\n    if (color !== undefined)\n      return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\n  }\n  return str;\n}\n\nfunction stylizeNoColor(str) {\n  return str;\n}\n\n// Return a new empty array to push in the results of the default formatter.\nfunction getEmptyFormatArray() {\n  return [];\n}\n\nfunction isInstanceof(object\x2C proto) {\n  try {\n    return object instanceof proto;\n  } catch {\n    return false;\n  }\n}\n\nfunction getConstructorName(obj\x2C ctx\x2C recurseTimes\x2C protoProps) {\n  let firstProto;\n  const tmp = obj;\n  while (obj || isUndetectableObject(obj)) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '' &&\n        isInstanceof(tmp\x2C descriptor.value)) {\n      if (protoProps !== undefined &&\n         (firstProto !== obj ||\n         !builtInObjects.has(descriptor.value.name))) {\n        addPrototypeProperties(\n          ctx\x2C tmp\x2C firstProto || tmp\x2C recurseTimes\x2C protoProps);\n      }\n      return descriptor.value.name;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n    if (firstProto === undefined) {\n      firstProto = obj;\n    }\n  }\n\n  if (firstProto === null) {\n    return null;\n  }\n\n  const res = internalGetConstructorName(tmp);\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return `${res} <Complex prototype>`;\n  }\n\n  const protoConstr = getConstructorName(\n    firstProto\x2C ctx\x2C recurseTimes + 1\x2C protoProps);\n\n  if (protoConstr === null) {\n    return `${res} <${inspect(firstProto\x2C {\n      ...ctx\x2C\n      customInspect: false\x2C\n      depth: -1\n    })}>`;\n  }\n\n  return `${res} <${protoConstr}>`;\n}\n\n// This function has the side effect of adding prototype properties to the\n// `output` argument (which is an array). This is intended to highlight user\n// defined prototype properties.\nfunction addPrototypeProperties(ctx\x2C main\x2C obj\x2C recurseTimes\x2C output) {\n  let depth = 0;\n  let keys;\n  let keySet;\n  do {\n    if (depth !== 0 || main === obj) {\n      obj = ObjectGetPrototypeOf(obj);\n      // Stop as soon as a null prototype is encountered.\n      if (obj === null) {\n        return;\n      }\n      // Stop as soon as a built-in object type is detected.\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n      if (descriptor !== undefined &&\n          typeof descriptor.value === 'function' &&\n          builtInObjects.has(descriptor.value.name)) {\n        return;\n      }\n    }\n\n    if (depth === 0) {\n      keySet = new SafeSet();\n    } else {\n      ArrayPrototypeForEach(keys\x2C (key) => keySet.add(key));\n    }\n    // Get all own property names and symbols.\n    keys = ReflectOwnKeys(obj);\n    ArrayPrototypePush(ctx.seen\x2C main);\n    for (const key of keys) {\n      // Ignore the `constructor` property and keys that exist on layers above.\n      if (key === 'constructor' ||\n          ObjectPrototypeHasOwnProperty(main\x2C key) ||\n          (depth !== 0 && keySet.has(key))) {\n        continue;\n      }\n      const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n      if (typeof desc.value === 'function') {\n        continue;\n      }\n      const value = formatProperty(\n        ctx\x2C obj\x2C recurseTimes\x2C key\x2C kObjectType\x2C desc\x2C main);\n      if (ctx.colors) {\n        // Faint!\n        ArrayPrototypePush(output\x2C `\\u001b[2m${value}\\u001b[22m`);\n      } else {\n        ArrayPrototypePush(output\x2C value);\n      }\n    }\n    ArrayPrototypePop(ctx.seen);\n  // Limit the inspection to up to three prototype layers. Using `recurseTimes`\n  // is not a good choice here\x2C because it's as if the properties are declared\n  // on the current object from the users perspective.\n  } while (++depth !== 3);\n}\n\nfunction getPrefix(constructor\x2C tag\x2C fallback\x2C size = '') {\n  if (constructor === null) {\n    if (tag !== '' && fallback !== tag) {\n      return `[${fallback}${size}: null prototype] [${tag}] `;\n    }\n    return `[${fallback}${size}: null prototype] `;\n  }\n\n  if (tag !== '' && constructor !== tag) {\n    return `${constructor}${size} [${tag}] `;\n  }\n  return `${constructor}${size} `;\n}\n\n// Look up the keys of the object.\nfunction getKeys(value\x2C showHidden) {\n  let keys;\n  const symbols = ObjectGetOwnPropertySymbols(value);\n  if (showHidden) {\n    keys = ObjectGetOwnPropertyNames(value);\n    if (symbols.length !== 0)\n      ArrayPrototypePushApply(keys\x2C symbols);\n  } else {\n    // This might throw if `value` is a Module Namespace Object from an\n    // unevaluated module\x2C but we don't want to perform the actual type\n    // check because it's expensive.\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n    // and modify this logic as needed.\n    try {\n      keys = ObjectKeys(value);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\n             isModuleNamespaceObject(value));\n      keys = ObjectGetOwnPropertyNames(value);\n    }\n    if (symbols.length !== 0) {\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value\x2C key);\n      ArrayPrototypePushApply(keys\x2C ArrayPrototypeFilter(symbols\x2C filter));\n    }\n  }\n  return keys;\n}\n\nfunction getCtxStyle(value\x2C constructor\x2C tag) {\n  let fallback = '';\n  if (constructor === null) {\n    fallback = internalGetConstructorName(value);\n    if (fallback === tag) {\n      fallback = 'Object';\n    }\n  }\n  return getPrefix(constructor\x2C tag\x2C fallback);\n}\n\nfunction formatProxy(ctx\x2C proxy\x2C recurseTimes) {\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return ctx.stylize('Proxy [Array]'\x2C 'special');\n  }\n  recurseTimes += 1;\n  ctx.indentationLvl += 2;\n  const res = [\n    formatValue(ctx\x2C proxy[0]\x2C recurseTimes)\x2C\n    formatValue(ctx\x2C proxy[1]\x2C recurseTimes)\x2C\n  ];\n  ctx.indentationLvl -= 2;\n  return reduceToSingleString(\n    ctx\x2C res\x2C ''\x2C ['Proxy ['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\n}\n\n// Note: using `formatValue` directly requires the indentation level to be\n// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n// value afterwards again.\nfunction formatValue(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\n  // Primitive types cannot have properties.\n  if (typeof value !== 'object' &&\n      typeof value !== 'function' &&\n      !isUndetectableObject(value)) {\n    return formatPrimitive(ctx.stylize\x2C value\x2C ctx);\n  }\n  if (value === null) {\n    return ctx.stylize('null'\x2C 'null');\n  }\n\n  // Memorize the context for custom inspection on proxies.\n  const context = value;\n  // Always check for proxies to prevent side effects and to prevent triggering\n  // any proxy handlers.\n  const proxy = getProxyDetails(value\x2C !!ctx.showProxy);\n  if (proxy !== undefined) {\n    if (ctx.showProxy) {\n      return formatProxy(ctx\x2C proxy\x2C recurseTimes);\n    }\n    value = proxy;\n  }\n\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it.\n  if (ctx.customInspect) {\n    const maybeCustom = value[customInspectSymbol];\n    if (typeof maybeCustom === 'function' &&\n        // Filter out the util module\x2C its inspect function is special.\n        maybeCustom !== inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      // This makes sure the recurseTimes are reported as before while using\n      // a counter internally.\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\n      const isCrossContext =\n        proxy !== undefined || !(context instanceof Object);\n      const ret = FunctionPrototypeCall(\n        maybeCustom\x2C\n        context\x2C\n        depth\x2C\n        getUserOptions(ctx\x2C isCrossContext)\x2C\n        inspect\n      );\n      // If the custom inspection method returned `this`\x2C don't go into\n      // infinite recursion.\n      if (ret !== context) {\n        if (typeof ret !== 'string') {\n          return formatValue(ctx\x2C ret\x2C recurseTimes);\n        }\n        return ret.replace(/\\n/g\x2C `\\n${' '.repeat(ctx.indentationLvl)}`);\n      }\n    }\n  }\n\n  // Using an array here is actually better for the average case than using\n  // a Set. `seen` will only check for the depth and will never grow too large.\n  if (ctx.seen.includes(value)) {\n    let index = 1;\n    if (ctx.circular === undefined) {\n      ctx.circular = new SafeMap();\n      ctx.circular.set(value\x2C index);\n    } else {\n      index = ctx.circular.get(value);\n      if (index === undefined) {\n        index = ctx.circular.size + 1;\n        ctx.circular.set(value\x2C index);\n      }\n    }\n    return ctx.stylize(`[Circular *${index}]`\x2C 'special');\n  }\n\n  return formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray);\n}\n\nfunction formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\n  let keys;\n  let protoProps;\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\n    protoProps = [];\n  }\n\n  const constructor = getConstructorName(value\x2C ctx\x2C recurseTimes\x2C protoProps);\n  // Reset the variable to check for this later on.\n  if (protoProps !== undefined && protoProps.length === 0) {\n    protoProps = undefined;\n  }\n\n  let tag = value[SymbolToStringTag];\n  // Only list the tag in case it's non-enumerable / not an own property.\n  // Otherwise we'd print this twice.\n  if (typeof tag !== 'string' ||\n      (tag !== '' &&\n      (ctx.showHidden ?\n        ObjectPrototypeHasOwnProperty :\n        ObjectPrototypePropertyIsEnumerable)(\n        value\x2C SymbolToStringTag\n      ))) {\n    tag = '';\n  }\n  let base = '';\n  let formatter = getEmptyFormatArray;\n  let braces;\n  let noIterator = true;\n  let i = 0;\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n\n  let extrasType = kObjectType;\n\n  // Iterators and the rest are split to reduce checks.\n  // We have to check all values in case the constructor is set to null.\n  // Otherwise it would not possible to identify all types properly.\n  if (value[SymbolIterator] || constructor === null) {\n    noIterator = false;\n    if (ArrayIsArray(value)) {\n      // Only set the constructor for non ordinary ("Array [...]") arrays.\n      const prefix = (constructor !== 'Array' || tag !== '') ?\n        getPrefix(constructor\x2C tag\x2C 'Array'\x2C `(${value.length})`) :\n        '';\n      keys = getOwnNonIndexProperties(value\x2C filter);\n      braces = [`${prefix}[`\x2C ']'];\n      if (value.length === 0 && keys.length === 0 && protoProps === undefined)\n        return `${braces[0]}]`;\n      extrasType = kArrayExtrasType;\n      formatter = formatArray;\n    } else if (isSet(value)) {\n      const size = SetPrototypeGetSize(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Set'\x2C `(${size})`);\n      keys = getKeys(value\x2C ctx.showHidden);\n      formatter = constructor !== null ?\n        formatSet.bind(null\x2C value) :\n        formatSet.bind(null\x2C SetPrototypeValues(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`\x2C '}'];\n    } else if (isMap(value)) {\n      const size = MapPrototypeGetSize(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Map'\x2C `(${size})`);\n      keys = getKeys(value\x2C ctx.showHidden);\n      formatter = constructor !== null ?\n        formatMap.bind(null\x2C value) :\n        formatMap.bind(null\x2C MapPrototypeEntries(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`\x2C '}'];\n    } else if (isTypedArray(value)) {\n      keys = getOwnNonIndexProperties(value\x2C filter);\n      let bound = value;\n      let fallback = '';\n      if (constructor === null) {\n        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);\n        // Reconstruct the array information.\n        bound = new primordials[fallback](value);\n      }\n      const size = TypedArrayPrototypeGetLength(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C fallback\x2C `(${size})`);\n      braces = [`${prefix}[`\x2C ']'];\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n        return `${braces[0]}]`;\n      // Special handle the value. The original value is required below. The\n      // bound function is required to reconstruct missing information.\n      formatter = formatTypedArray.bind(null\x2C bound\x2C size);\n      extrasType = kArrayExtrasType;\n    } else if (isMapIterator(value)) {\n      keys = getKeys(value\x2C ctx.showHidden);\n      braces = getIteratorBraces('Map'\x2C tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null\x2C braces);\n    } else if (isSetIterator(value)) {\n      keys = getKeys(value\x2C ctx.showHidden);\n      braces = getIteratorBraces('Set'\x2C tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null\x2C braces);\n    } else {\n      noIterator = true;\n    }\n  }\n  if (noIterator) {\n    keys = getKeys(value\x2C ctx.showHidden);\n    braces = ['{'\x2C '}'];\n    if (constructor === 'Object') {\n      if (isArgumentsObject(value)) {\n        braces[0] = '[Arguments] {';\n      } else if (tag !== '') {\n        braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Object')}{`;\n      }\n      if (keys.length === 0 && protoProps === undefined) {\n        return `${braces[0]}}`;\n      }\n    } else if (typeof value === 'function') {\n      base = getFunctionBase(value\x2C constructor\x2C tag);\n      if (keys.length === 0 && protoProps === undefined)\n        return ctx.stylize(base\x2C 'special');\n    } else if (isRegExp(value)) {\n      // Make RegExps say that they are RegExps\n      base = RegExpPrototypeToString(\n        constructor !== null ? value : new RegExp(value)\n      );\n      const prefix = getPrefix(constructor\x2C tag\x2C 'RegExp');\n      if (prefix !== 'RegExp ')\n        base = `${prefix}${base}`;\n      if ((keys.length === 0 && protoProps === undefined) ||\n          (recurseTimes > ctx.depth && ctx.depth !== null)) {\n        return ctx.stylize(base\x2C 'regexp');\n      }\n    } else if (isDate(value)) {\n      // Make dates with properties first say the date\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ?\n        DatePrototypeToString(value) :\n        DatePrototypeToISOString(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Date');\n      if (prefix !== 'Date ')\n        base = `${prefix}${base}`;\n      if (keys.length === 0 && protoProps === undefined) {\n        return ctx.stylize(base\x2C 'date');\n      }\n    } else if (isError(value)) {\n      base = formatError(value\x2C constructor\x2C tag\x2C ctx\x2C keys);\n      if (keys.length === 0 && protoProps === undefined)\n        return base;\n    } else if (isAnyArrayBuffer(value)) {\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\n      // Can't do the same for DataView because it has a non-primitive\n      // .buffer property that we need to recurse for.\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\n        'SharedArrayBuffer';\n      const prefix = getPrefix(constructor\x2C tag\x2C arrayType);\n      if (typedArray === undefined) {\n        formatter = formatArrayBuffer;\n      } else if (keys.length === 0 && protoProps === undefined) {\n        return prefix +\n              `{ byteLength: ${formatNumber(ctx.stylize\x2C value.byteLength\x2C false)} }`;\n      }\n      braces[0] = `${prefix}{`;\n      ArrayPrototypeUnshift(keys\x2C 'byteLength');\n    } else if (isDataView(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'DataView')}{`;\n      // .buffer goes last\x2C it's not a primitive like the others.\n      ArrayPrototypeUnshift(keys\x2C 'byteLength'\x2C 'byteOffset'\x2C 'buffer');\n    } else if (isPromise(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Promise')}{`;\n      formatter = formatPromise;\n    } else if (isWeakSet(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakSet')}{`;\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n    } else if (isWeakMap(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakMap')}{`;\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n    } else if (isModuleNamespaceObject(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Module')}{`;\n      // Special handle keys for namespace objects.\n      formatter = formatNamespaceObject.bind(null\x2C keys);\n    } else if (isBoxedPrimitive(value)) {\n      base = getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag);\n      if (keys.length === 0 && protoProps === undefined) {\n        return base;\n      }\n    } else {\n      if (keys.length === 0 && protoProps === undefined) {\n        if (isExternal(value)) {\n          const address = getExternalValue(value).toString(16);\n          return ctx.stylize(`[External: ${address}]`\x2C 'special');\n        }\n        return `${getCtxStyle(value\x2C constructor\x2C tag)}{}`;\n      }\n      braces[0] = `${getCtxStyle(value\x2C constructor\x2C tag)}{`;\n    }\n  }\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    let constructorName = getCtxStyle(value\x2C constructor\x2C tag).slice(0\x2C -1);\n    if (constructor !== null)\n      constructorName = `[${constructorName}]`;\n    return ctx.stylize(constructorName\x2C 'special');\n  }\n  recurseTimes += 1;\n\n  ctx.seen.push(value);\n  ctx.currentDepth = recurseTimes;\n  let output;\n  const indentationLvl = ctx.indentationLvl;\n  try {\n    output = formatter(ctx\x2C value\x2C recurseTimes);\n    for (i = 0; i < keys.length; i++) {\n      output.push(\n        formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C extrasType));\n    }\n    if (protoProps !== undefined) {\n      output.push(...protoProps);\n    }\n  } catch (err) {\n    const constructorName = getCtxStyle(value\x2C constructor\x2C tag).slice(0\x2C -1);\n    return handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl);\n  }\n  if (ctx.circular !== undefined) {\n    const index = ctx.circular.get(value);\n    if (index !== undefined) {\n      const reference = ctx.stylize(`<ref *${index}>`\x2C 'special');\n      // Add reference always to the very beginning of the output.\n      if (ctx.compact !== true) {\n        base = base === '' ? reference : `${reference} ${base}`;\n      } else {\n        braces[0] = `${reference} ${braces[0]}`;\n      }\n    }\n  }\n  ctx.seen.pop();\n\n  if (ctx.sorted) {\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\n    if (extrasType === kObjectType) {\n      output = output.sort(comparator);\n    } else if (keys.length > 1) {\n      const sorted = output.slice(output.length - keys.length).sort(comparator);\n      output.splice(output.length - keys.length\x2C keys.length\x2C ...sorted);\n    }\n  }\n\n  const res = reduceToSingleString(\n    ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value);\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\n  const newLength = budget + res.length;\n  ctx.budget[ctx.indentationLvl] = newLength;\n  // If any indentationLvl exceeds this limit\x2C limit further inspecting to the\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n  // This limit also makes sure that huge objects don't block the event loop\n  // significantly.\n  if (newLength > 2 ** 27) {\n    ctx.depth = -1;\n  }\n  return res;\n}\n\nfunction getIteratorBraces(type\x2C tag) {\n  if (tag !== `${type} Iterator`) {\n    if (tag !== '')\n      tag += '] [';\n    tag += `${type} Iterator`;\n  }\n  return [`[${tag}] {`\x2C '}'];\n}\n\nfunction getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag) {\n  let fn;\n  let type;\n  if (isNumberObject(value)) {\n    fn = NumberPrototypeValueOf;\n    type = 'Number';\n  } else if (isStringObject(value)) {\n    fn = StringPrototypeValueOf;\n    type = 'String';\n    // For boxed Strings\x2C we have to remove the 0-n indexed entries\x2C\n    // since they just noisy up the output and are redundant\n    // Make boxed primitive Strings look like such\n    keys.splice(0\x2C value.length);\n  } else if (isBooleanObject(value)) {\n    fn = BooleanPrototypeValueOf;\n    type = 'Boolean';\n  } else if (isBigIntObject(value)) {\n    fn = BigIntPrototypeValueOf;\n    type = 'BigInt';\n  } else {\n    fn = SymbolPrototypeValueOf;\n    type = 'Symbol';\n  }\n  let base = `[${type}`;\n  if (type !== constructor) {\n    if (constructor === null) {\n      base += ' (null prototype)';\n    } else {\n      base += ` (${constructor})`;\n    }\n  }\n  base += `: ${formatPrimitive(stylizeNoColor\x2C fn(value)\x2C ctx)}]`;\n  if (tag !== '' && tag !== constructor) {\n    base += ` [${tag}]`;\n  }\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\n    return base;\n  return ctx.stylize(base\x2C StringPrototypeToLowerCase(type));\n}\n\nfunction getClassBase(value\x2C constructor\x2C tag) {\n  const hasName = ObjectPrototypeHasOwnProperty(value\x2C 'name');\n  const name = (hasName && value.name) || '(anonymous)';\n  let base = `class ${name}`;\n  if (constructor !== 'Function' && constructor !== null) {\n    base += ` [${constructor}]`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  if (constructor !== null) {\n    const superName = ObjectGetPrototypeOf(value).name;\n    if (superName) {\n      base += ` extends ${superName}`;\n    }\n  } else {\n    base += ' extends [null prototype]';\n  }\n  return `[${base}]`;\n}\n\nfunction getFunctionBase(value\x2C constructor\x2C tag) {\n  const stringified = FunctionPrototypeToString(value);\n  if (stringified.startsWith('class') && stringified.endsWith('}')) {\n    const slice = stringified.slice(5\x2C -1);\n    const bracketIndex = slice.indexOf('{');\n    if (bracketIndex !== -1 &&\n        (!slice.slice(0\x2C bracketIndex).includes('(') ||\n          // Slow path to guarantee that it's indeed a class.\n          classRegExp.test(slice.replace(stripCommentsRegExp)))) {\n      return getClassBase(value\x2C constructor\x2C tag);\n    }\n  }\n  let type = 'Function';\n  if (isGeneratorFunction(value)) {\n    type = `Generator${type}`;\n  }\n  if (isAsyncFunction(value)) {\n    type = `Async${type}`;\n  }\n  let base = `[${type}`;\n  if (constructor === null) {\n    base += ' (null prototype)';\n  }\n  if (value.name === '') {\n    base += ' (anonymous)';\n  } else {\n    base += `: ${value.name}`;\n  }\n  base += ']';\n  if (constructor !== type && constructor !== null) {\n    base += ` ${constructor}`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  return base;\n}\n\nfunction identicalSequenceRange(a\x2C b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    // Find the first entry of b that matches the current entry of a.\n    const pos = b.indexOf(a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i\x2C rest);\n        // Count the number of consecutive entries.\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return { len\x2C offset: i };\n        }\n      }\n    }\n  }\n\n  return { len: 0\x2C offset: 0 };\n}\n\nfunction getStackString(error) {\n  return error.stack ? String(error.stack) : ErrorPrototypeToString(error);\n}\n\nfunction getStackFrames(ctx\x2C err\x2C stack) {\n  const frames = stack.split('\\n');\n\n  // Remove stack frames identical to frames in cause.\n  if (err.cause && isError(err.cause)) {\n    const causeStack = getStackString(err.cause);\n    const causeStackStart = causeStack.indexOf('\\n    at');\n    if (causeStackStart !== -1) {\n      const causeFrames = causeStack.slice(causeStackStart + 1).split('\\n');\n      const { len\x2C offset } = identicalSequenceRange(frames\x2C causeFrames);\n      if (len > 0) {\n        const skipped = len - 2;\n        const msg = `    ... ${skipped} lines matching cause stack trace ...`;\n        frames.splice(offset + 1\x2C skipped\x2C ctx.stylize(msg\x2C 'undefined'));\n      }\n    }\n  }\n  return frames;\n}\n\nfunction improveStack(stack\x2C constructor\x2C name\x2C tag) {\n  // A stack trace may contain arbitrary data. Only manipulate the output\n  // for "regular errors" (errors that "look normal") for now.\n  let len = name.length;\n\n  if (constructor === null ||\n      (name.endsWith('Error') &&\n      stack.startsWith(name) &&\n      (stack.length === len || stack[len] === ':' || stack[len] === '\\n'))) {\n    let fallback = 'Error';\n    if (constructor === null) {\n      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/) ||\n        stack.match(/^([a-z_A-Z0-9-]*Error)$/);\n      fallback = (start && start[1]) || '';\n      len = fallback.length;\n      fallback = fallback || 'Error';\n    }\n    const prefix = getPrefix(constructor\x2C tag\x2C fallback).slice(0\x2C -1);\n    if (name !== prefix) {\n      if (prefix.includes(name)) {\n        if (len === 0) {\n          stack = `${prefix}: ${stack}`;\n        } else {\n          stack = `${prefix}${stack.slice(len)}`;\n        }\n      } else {\n        stack = `${prefix} [${name}]${stack.slice(len)}`;\n      }\n    }\n  }\n  return stack;\n}\n\nfunction removeDuplicateErrorKeys(ctx\x2C keys\x2C err\x2C stack) {\n  if (!ctx.showHidden && keys.length !== 0) {\n    for (const name of ['name'\x2C 'message'\x2C 'stack']) {\n      const index = keys.indexOf(name);\n      // Only hide the property in case it's part of the original stack\n      if (index !== -1 && stack.includes(err[name])) {\n        keys.splice(index\x2C 1);\n      }\n    }\n  }\n}\n\nfunction formatError(err\x2C constructor\x2C tag\x2C ctx\x2C keys) {\n  const name = err.name != null ? String(err.name) : 'Error';\n  let stack = getStackString(err);\n\n  removeDuplicateErrorKeys(ctx\x2C keys\x2C err\x2C stack);\n\n  if ('cause' in err &&\n      (keys.length === 0 || !keys.includes('cause'))) {\n    keys.push('cause');\n  }\n\n  stack = improveStack(stack\x2C constructor\x2C name\x2C tag);\n\n  // Ignore the error message if it's contained in the stack.\n  let pos = (err.message && stack.indexOf(err.message)) || -1;\n  if (pos !== -1)\n    pos += err.message.length;\n  // Wrap the error in brackets in case it has no stack trace.\n  const stackStart = stack.indexOf('\\n    at'\x2C pos);\n  if (stackStart === -1) {\n    stack = `[${stack}]`;\n  } else {\n    let newStack = stack.slice(0\x2C stackStart);\n    const lines = getStackFrames(ctx\x2C err\x2C stack.slice(stackStart + 1));\n    if (ctx.colors) {\n      // Highlight userland code and node modules.\n      for (const line of lines) {\n        const core = line.match(coreModuleRegExp);\n        if (core !== null && NativeModule.exists(core[1])) {\n          newStack += `\\n${ctx.stylize(line\x2C 'undefined')}`;\n        } else {\n          // This adds underscores to all node_modules to quickly identify them.\n          let nodeModule;\n          newStack += '\\n';\n          let pos = 0;\n          while ((nodeModule = nodeModulesRegExp.exec(line)) !== null) {\n            // '/node_modules/'.length === 14\n            newStack += line.slice(pos\x2C nodeModule.index + 14);\n            newStack += ctx.stylize(nodeModule[1]\x2C 'module');\n            pos = nodeModule.index + nodeModule[0].length;\n          }\n          newStack += pos === 0 ? line : line.slice(pos);\n        }\n      }\n    } else {\n      newStack += `\\n${lines.join('\\n')}`;\n    }\n    stack = newStack;\n  }\n  // The message and the stack have to be indented as well!\n  if (ctx.indentationLvl !== 0) {\n    const indentation = ' '.repeat(ctx.indentationLvl);\n    stack = stack.replace(/\\n/g\x2C `\\n${indentation}`);\n  }\n  return stack;\n}\n\nfunction groupArrayElements(ctx\x2C output\x2C value) {\n  let totalLength = 0;\n  let maxLength = 0;\n  let i = 0;\n  let outputLength = output.length;\n  if (ctx.maxArrayLength < output.length) {\n    // This makes sure the "... n more items" part is not taken into account.\n    outputLength--;\n  }\n  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.\n  const dataLen = new Array(outputLength);\n  // Calculate the total length of all output entries and the individual max\n  // entries length of all output entries. We have to remove colors first\x2C\n  // otherwise the length would not be calculated properly.\n  for (; i < outputLength; i++) {\n    const len = getStringWidth(output[i]\x2C ctx.colors);\n    dataLen[i] = len;\n    totalLength += len + separatorSpace;\n    if (maxLength < len)\n      maxLength = len;\n  }\n  // Add two to `maxLength` as we add a single whitespace character plus a comma\n  // in-between two entries.\n  const actualMax = maxLength + separatorSpace;\n  // Check if at least three entries fit next to each other and prevent grouping\n  // of arrays that contains entries of very different length (i.e.\x2C if a single\n  // entry is longer than 1/5 of all other entries combined). Otherwise the\n  // space in-between small entries would be enormous.\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&\n      (totalLength / actualMax > 5 || maxLength <= 6)) {\n\n    const approxCharHeights = 2.5;\n    const averageBias = MathSqrt(actualMax - totalLength / output.length);\n    const biasedMax = MathMax(actualMax - 3 - averageBias\x2C 1);\n    // Dynamically check how many columns seem possible.\n    const columns = MathMin(\n      // Ideally a square should be drawn. We expect a character to be about 2.5\n      // times as high as wide. This is the area formula to calculate a square\n      // which contains n rectangles of size `actualMax * approxCharHeights`.\n      // Divide that by `actualMax` to receive the correct number of columns.\n      // The added bias increases the columns for short entries.\n      MathRound(\n        MathSqrt(\n          approxCharHeights * biasedMax * outputLength\n        ) / biasedMax\n      )\x2C\n      // Do not exceed the breakLength.\n      MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax)\x2C\n      // Limit array grouping for small `compact` modes as the user requested\n      // minimal grouping.\n      ctx.compact * 4\x2C\n      // Limit the columns to a maximum of fifteen.\n      15\n    );\n    // Return with the original output if no grouping should happen.\n    if (columns <= 1) {\n      return output;\n    }\n    const tmp = [];\n    const maxLineLength = [];\n    for (let i = 0; i < columns; i++) {\n      let lineMaxLength = 0;\n      for (let j = i; j < output.length; j += columns) {\n        if (dataLen[j] > lineMaxLength)\n          lineMaxLength = dataLen[j];\n      }\n      lineMaxLength += separatorSpace;\n      maxLineLength[i] = lineMaxLength;\n    }\n    let order = StringPrototypePadStart;\n    if (value !== undefined) {\n      for (let i = 0; i < output.length; i++) {\n        if (typeof value[i] !== 'number' && typeof value[i] !== 'bigint') {\n          order = StringPrototypePadEnd;\n          break;\n        }\n      }\n    }\n    // Each iteration creates a single line of grouped entries.\n    for (let i = 0; i < outputLength; i += columns) {\n      // The last lines may contain less entries than columns.\n      const max = MathMin(i + columns\x2C outputLength);\n      let str = '';\n      let j = i;\n      for (; j < max - 1; j++) {\n        // Calculate extra color padding in case it's active. This has to be\n        // done line by line as some lines might contain more colors than\n        // others.\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];\n        str += order(`${output[j]}\x2C `\x2C padding\x2C ' ');\n      }\n      if (order === StringPrototypePadStart) {\n        const padding = maxLineLength[j - i] +\n                        output[j].length -\n                        dataLen[j] -\n                        separatorSpace;\n        str += StringPrototypePadStart(output[j]\x2C padding\x2C ' ');\n      } else {\n        str += output[j];\n      }\n      ArrayPrototypePush(tmp\x2C str);\n    }\n    if (ctx.maxArrayLength < output.length) {\n      ArrayPrototypePush(tmp\x2C output[outputLength]);\n    }\n    output = tmp;\n  }\n  return output;\n}\n\nfunction handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl) {\n  if (isStackOverflowError(err)) {\n    ctx.seen.pop();\n    ctx.indentationLvl = indentationLvl;\n    return ctx.stylize(\n      `[${constructorName}: Inspection interrupted ` +\n        'prematurely. Maximum call stack size exceeded.]'\x2C\n      'special'\n    );\n  }\n  /* c8 ignore next */\n  assert.fail(err.stack);\n}\n\nfunction addNumericSeparator(integerString) {\n  let result = '';\n  let i = integerString.length;\n  const start = integerString.startsWith('-') ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    result = `_${integerString.slice(i - 3\x2C i)}${result}`;\n  }\n  return i === integerString.length ?\n    integerString :\n    `${integerString.slice(0\x2C i)}${result}`;\n}\n\nfunction addNumericSeparatorEnd(integerString) {\n  let result = '';\n  let i = 0;\n  for (; i < integerString.length - 3; i += 3) {\n    result += `${integerString.slice(i\x2C i + 3)}_`;\n  }\n  return i === 0 ?\n    integerString :\n    `${result}${integerString.slice(i)}`;\n}\n\nfunction formatNumber(fn\x2C number\x2C numericSeparator) {\n  if (!numericSeparator) {\n    // Format -0 as '-0'. Checking `number === -0` won't distinguish 0 from -0.\n    if (ObjectIs(number\x2C -0)) {\n      return fn('-0'\x2C 'number');\n    }\n    return fn(`${number}`\x2C 'number');\n  }\n  const integer = MathTrunc(number);\n  const string = String(integer);\n  if (integer === number) {\n    if (!NumberIsFinite(number) || string.includes('e')) {\n      return fn(string\x2C 'number');\n    }\n    return fn(`${addNumericSeparator(string)}`\x2C 'number');\n  }\n  if (NumberIsNaN(number)) {\n    return fn(string\x2C 'number');\n  }\n  return fn(`${\n    addNumericSeparator(string)\n  }.${\n    addNumericSeparatorEnd(String(number).slice(string.length + 1))\n  }`\x2C 'number');\n}\n\nfunction formatBigInt(fn\x2C bigint\x2C numericSeparator) {\n  const string = String(bigint);\n  if (!numericSeparator) {\n    return fn(`${string}n`\x2C 'bigint');\n  }\n  return fn(`${addNumericSeparator(string)}n`\x2C 'bigint');\n}\n\nfunction formatPrimitive(fn\x2C value\x2C ctx) {\n  if (typeof value === 'string') {\n    let trailer = '';\n    if (value.length > ctx.maxStringLength) {\n      const remaining = value.length - ctx.maxStringLength;\n      value = value.slice(0\x2C ctx.maxStringLength);\n      trailer = `... ${remaining} more character${remaining > 1 ? 's' : ''}`;\n    }\n    if (ctx.compact !== true &&\n        // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n        // function.\n        value.length > kMinLineLength &&\n        value.length > ctx.breakLength - ctx.indentationLvl - 4) {\n      return value\n        .split(/(?<=\\n)/)\n        .map((line) => fn(strEscape(line)\x2C 'string'))\n        .join(` +\\n${' '.repeat(ctx.indentationLvl + 2)}`) + trailer;\n    }\n    return fn(strEscape(value)\x2C 'string') + trailer;\n  }\n  if (typeof value === 'number')\n    return formatNumber(fn\x2C value\x2C ctx.numericSeparator);\n  if (typeof value === 'bigint')\n    return formatBigInt(fn\x2C value\x2C ctx.numericSeparator);\n  if (typeof value === 'boolean')\n    return fn(`${value}`\x2C 'boolean');\n  if (typeof value === 'undefined')\n    return fn('undefined'\x2C 'undefined');\n  // es6 symbol primitive\n  return fn(SymbolPrototypeToString(value)\x2C 'symbol');\n}\n\nfunction formatNamespaceObject(keys\x2C ctx\x2C value\x2C recurseTimes) {\n  const output = new Array(keys.length);\n  for (let i = 0; i < keys.length; i++) {\n    try {\n      output[i] = formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C\n                                 kObjectType);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError');\n      // Use the existing functionality. This makes sure the indentation and\n      // line breaks are always correct. Otherwise it is very difficult to keep\n      // this aligned\x2C even though this is a hacky way of dealing with this.\n      const tmp = { [keys[i]]: '' };\n      output[i] = formatProperty(ctx\x2C tmp\x2C recurseTimes\x2C keys[i]\x2C kObjectType);\n      const pos = output[i].lastIndexOf(' ');\n      // We have to find the last whitespace and have to replace that value as\n      // it will be visualized as a regular string.\n      output[i] = output[i].slice(0\x2C pos + 1) +\n                  ctx.stylize('<uninitialized>'\x2C 'special');\n    }\n  }\n  // Reset the keys to an empty array. This prevents duplicated inspection.\n  keys.length = 0;\n  return output;\n}\n\n// The array is sparse and/or has extra keys\nfunction formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C maxLength\x2C output\x2C i) {\n  const keys = ObjectKeys(value);\n  let index = i;\n  for (; i < keys.length && output.length < maxLength; i++) {\n    const key = keys[i];\n    const tmp = +key;\n    // Arrays can only have up to 2^32 - 1 entries\n    if (tmp > 2 ** 32 - 2) {\n      break;\n    }\n    if (`${index}` !== key) {\n      if (!numberRegExp.test(key)) {\n        break;\n      }\n      const emptyItems = tmp - index;\n      const ending = emptyItems > 1 ? 's' : '';\n      const message = `<${emptyItems} empty item${ending}>`;\n      output.push(ctx.stylize(message\x2C 'undefined'));\n      index = tmp;\n      if (output.length === maxLength) {\n        break;\n      }\n    }\n    output.push(formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C kArrayType));\n    index++;\n  }\n  const remaining = value.length - index;\n  if (output.length !== maxLength) {\n    if (remaining > 0) {\n      const ending = remaining > 1 ? 's' : '';\n      const message = `<${remaining} empty item${ending}>`;\n      output.push(ctx.stylize(message\x2C 'undefined'));\n    }\n  } else if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatArrayBuffer(ctx\x2C value) {\n  let buffer;\n  try {\n    buffer = new Uint8Array(value);\n  } catch {\n    return [ctx.stylize('(detached)'\x2C 'special')];\n  }\n  if (hexSlice === undefined)\n    hexSlice = uncurryThis(require('buffer').Buffer.prototype.hexSlice);\n  let str = StringPrototypeTrim(StringPrototypeReplace(\n    hexSlice(buffer\x2C 0\x2C MathMin(ctx.maxArrayLength\x2C buffer.length))\x2C\n    /(.{2})/g\x2C '$1 '));\n  const remaining = buffer.length - ctx.maxArrayLength;\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  return [`${ctx.stylize('[Uint8Contents]'\x2C 'special')}: <${str}>`];\n}\n\nfunction formatArray(ctx\x2C value\x2C recurseTimes) {\n  const valLen = value.length;\n  const len = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C valLen);\n\n  const remaining = valLen - len;\n  const output = [];\n  for (let i = 0; i < len; i++) {\n    // Special handle sparse arrays.\n    if (!ObjectPrototypeHasOwnProperty(value\x2C i)) {\n      return formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C len\x2C output\x2C i);\n    }\n    output.push(formatProperty(ctx\x2C value\x2C recurseTimes\x2C i\x2C kArrayType));\n  }\n  if (remaining > 0)\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  return output;\n}\n\nfunction formatTypedArray(value\x2C length\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const maxLength = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C length);\n  const remaining = value.length - maxLength;\n  const output = new Array(maxLength);\n  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\n    formatNumber :\n    formatBigInt;\n  for (let i = 0; i < maxLength; ++i) {\n    output[i] = elementFormatter(ctx.stylize\x2C value[i]\x2C ctx.numericSeparator);\n  }\n  if (remaining > 0) {\n    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n  }\n  if (ctx.showHidden) {\n    // .buffer goes last\x2C it's not a primitive like the others.\n    // All besides `BYTES_PER_ELEMENT` are actually getters.\n    ctx.indentationLvl += 2;\n    for (const key of [\n      'BYTES_PER_ELEMENT'\x2C\n      'length'\x2C\n      'byteLength'\x2C\n      'byteOffset'\x2C\n      'buffer'\x2C\n    ]) {\n      const str = formatValue(ctx\x2C value[key]\x2C recurseTimes\x2C true);\n      ArrayPrototypePush(output\x2C `[${key}]: ${str}`);\n    }\n    ctx.indentationLvl -= 2;\n  }\n  return output;\n}\n\nfunction formatSet(value\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const v of value) {\n    ArrayPrototypePush(output\x2C formatValue(ctx\x2C v\x2C recurseTimes));\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatMap(value\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const { 0: k\x2C 1: v } of value) {\n    output.push(\n      `${formatValue(ctx\x2C k\x2C recurseTimes)} => ${formatValue(ctx\x2C v\x2C recurseTimes)}`\n    );\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\n  const maxLength = MathMin(maxArrayLength\x2C entries.length);\n  const output = new Array(maxLength);\n  ctx.indentationLvl += 2;\n  for (let i = 0; i < maxLength; i++) {\n    output[i] = formatValue(ctx\x2C entries[i]\x2C recurseTimes);\n  }\n  ctx.indentationLvl -= 2;\n  if (state === kWeak && !ctx.sorted) {\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    ArrayPrototypeSort(output);\n  }\n  const remaining = entries.length - maxLength;\n  if (remaining > 0) {\n    ArrayPrototypePush(output\x2C\n                       `... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\n  // Entries exist as [key1\x2C val1\x2C key2\x2C val2\x2C ...]\n  const len = entries.length / 2;\n  const remaining = len - maxArrayLength;\n  const maxLength = MathMin(maxArrayLength\x2C len);\n  let output = new Array(maxLength);\n  let i = 0;\n  ctx.indentationLvl += 2;\n  if (state === kWeak) {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      output[i] =\n        `${formatValue(ctx\x2C entries[pos]\x2C recurseTimes)} => ${formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)}`;\n    }\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    if (!ctx.sorted)\n      output = output.sort();\n  } else {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      const res = [\n        formatValue(ctx\x2C entries[pos]\x2C recurseTimes)\x2C\n        formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)\x2C\n      ];\n      output[i] = reduceToSingleString(\n        ctx\x2C res\x2C ''\x2C ['['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\n    }\n  }\n  ctx.indentationLvl -= 2;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatWeakCollection(ctx) {\n  return [ctx.stylize('<items unknown>'\x2C 'special')];\n}\n\nfunction formatWeakSet(ctx\x2C value\x2C recurseTimes) {\n  const entries = previewEntries(value);\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\n}\n\nfunction formatWeakMap(ctx\x2C value\x2C recurseTimes) {\n  const entries = previewEntries(value);\n  return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\n}\n\nfunction formatIterator(braces\x2C ctx\x2C value\x2C recurseTimes) {\n  const { 0: entries\x2C 1: isKeyValue } = previewEntries(value\x2C true);\n  if (isKeyValue) {\n    // Mark entry iterators as such.\n    braces[0] = braces[0].replace(/ Iterator] {$/\x2C ' Entries] {');\n    return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kMapEntries);\n  }\n\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kIterator);\n}\n\nfunction formatPromise(ctx\x2C value\x2C recurseTimes) {\n  let output;\n  const { 0: state\x2C 1: result } = getPromiseDetails(value);\n  if (state === kPending) {\n    output = [ctx.stylize('<pending>'\x2C 'special')];\n  } else {\n    ctx.indentationLvl += 2;\n    const str = formatValue(ctx\x2C result\x2C recurseTimes);\n    ctx.indentationLvl -= 2;\n    output = [\n      state === kRejected ?\n        `${ctx.stylize('<rejected>'\x2C 'special')} ${str}` :\n        str\x2C\n    ];\n  }\n  return output;\n}\n\nfunction formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C type\x2C desc\x2C\n                        original = value) {\n  let name\x2C str;\n  let extra = ' ';\n  desc = desc || ObjectGetOwnPropertyDescriptor(value\x2C key) ||\n    { value: value[key]\x2C enumerable: true };\n  if (desc.value !== undefined) {\n    const diff = (ctx.compact !== true || type !== kObjectType) ? 2 : 3;\n    ctx.indentationLvl += diff;\n    str = formatValue(ctx\x2C desc.value\x2C recurseTimes);\n    if (diff === 3 && ctx.breakLength < getStringWidth(str\x2C ctx.colors)) {\n      extra = `\\n${' '.repeat(ctx.indentationLvl)}`;\n    }\n    ctx.indentationLvl -= diff;\n  } else if (desc.get !== undefined) {\n    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';\n    const s = ctx.stylize;\n    const sp = 'special';\n    if (ctx.getters && (ctx.getters === true ||\n          (ctx.getters === 'get' && desc.set === undefined) ||\n          (ctx.getters === 'set' && desc.set !== undefined))) {\n      try {\n        const tmp = FunctionPrototypeCall(desc.get\x2C original);\n        ctx.indentationLvl += 2;\n        if (tmp === null) {\n          str = `${s(`[${label}:`\x2C sp)} ${s('null'\x2C 'null')}${s(']'\x2C sp)}`;\n        } else if (typeof tmp === 'object') {\n          str = `${s(`[${label}]`\x2C sp)} ${formatValue(ctx\x2C tmp\x2C recurseTimes)}`;\n        } else {\n          const primitive = formatPrimitive(s\x2C tmp\x2C ctx);\n          str = `${s(`[${label}:`\x2C sp)} ${primitive}${s(']'\x2C sp)}`;\n        }\n        ctx.indentationLvl -= 2;\n      } catch (err) {\n        const message = `<Inspection threw (${err.message})>`;\n        str = `${s(`[${label}:`\x2C sp)} ${message}${s(']'\x2C sp)}`;\n      }\n    } else {\n      str = ctx.stylize(`[${label}]`\x2C sp);\n    }\n  } else if (desc.set !== undefined) {\n    str = ctx.stylize('[Setter]'\x2C 'special');\n  } else {\n    str = ctx.stylize('undefined'\x2C 'undefined');\n  }\n  if (type === kArrayType) {\n    return str;\n  }\n  if (typeof key === 'symbol') {\n    const tmp = StringPrototypeReplace(\n      SymbolPrototypeToString(key)\x2C\n      strEscapeSequencesReplacer\x2C escapeFn\n    );\n    name = `[${ctx.stylize(tmp\x2C 'symbol')}]`;\n  } else if (key === '__proto__') {\n    name = "['__proto__']";\n  } else if (desc.enumerable === false) {\n    const tmp = StringPrototypeReplace(key\x2C\n                                       strEscapeSequencesReplacer\x2C escapeFn);\n    name = `[${tmp}]`;\n  } else if (RegExpPrototypeTest(keyStrRegExp\x2C key)) {\n    name = ctx.stylize(key\x2C 'name');\n  } else {\n    name = ctx.stylize(strEscape(key)\x2C 'string');\n  }\n  return `${name}:${extra}${str}`;\n}\n\nfunction isBelowBreakLength(ctx\x2C output\x2C start\x2C base) {\n  // Each entry is separated by at least a comma. Thus\x2C we start with a total\n  // length of at least `output.length`. In addition\x2C some cases have a\n  // whitespace in-between each other that is added to the total as well.\n  // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n  // function. Check the performance overhead and make it an opt-in in case it's\n  // significant.\n  let totalLength = output.length + start;\n  if (totalLength + output.length > ctx.breakLength)\n    return false;\n  for (let i = 0; i < output.length; i++) {\n    if (ctx.colors) {\n      totalLength += removeColors(output[i]).length;\n    } else {\n      totalLength += output[i].length;\n    }\n    if (totalLength > ctx.breakLength) {\n      return false;\n    }\n  }\n  // Do not line up properties on the same line if `base` contains line breaks.\n  return base === '' || !StringPrototypeIncludes(base\x2C '\\n');\n}\n\nfunction reduceToSingleString(\n  ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value) {\n  if (ctx.compact !== true) {\n    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {\n      // Memorize the original output length. In case the output is grouped\x2C\n      // prevent lining up the entries on a single line.\n      const entries = output.length;\n      // Group array elements together if the array contains at least six\n      // separate entries.\n      if (extrasType === kArrayExtrasType && entries > 6) {\n        output = groupArrayElements(ctx\x2C output\x2C value);\n      }\n      // `ctx.currentDepth` is set to the most inner depth of the currently\n      // inspected object part while `recurseTimes` is the actual current depth\n      // that is inspected.\n      //\n      // Example:\n      //\n      // const a = { first: [ 1\x2C 2\x2C 3 ]\x2C second: { inner: [ 1\x2C 2\x2C 3 ] } }\n      //\n      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max\n      // depth of 1.\n      //\n      // Consolidate all entries of the local most inner depth up to\n      // `ctx.compact`\x2C as long as the properties are smaller than\n      // `ctx.breakLength`.\n      if (ctx.currentDepth - recurseTimes < ctx.compact &&\n          entries === output.length) {\n        // Line up all entries on a single line in case the entries do not\n        // exceed `breakLength`. Add 10 as constant to start next to all other\n        // factors that may reduce `breakLength`.\n        const start = output.length + ctx.indentationLvl +\n                      braces[0].length + base.length + 10;\n        if (isBelowBreakLength(ctx\x2C output\x2C start\x2C base)) {\n          const joinedOutput = join(output\x2C '\x2C ');\n          if (!joinedOutput.includes('\\n')) {\n            return `${base ? `${base} ` : ''}${braces[0]} ${joinedOutput}` +\n              ` ${braces[1]}`;\n          }\n        }\n      }\n    }\n    // Line up each entry on an individual line.\n    const indentation = `\\n${StringPrototypeRepeat(' '\x2C ctx.indentationLvl)}`;\n    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` +\n      `${join(output\x2C `\x2C${indentation}  `)}${indentation}${braces[1]}`;\n  }\n  // Line up all entries on a single line in case the entries do not exceed\n  // `breakLength`.\n  if (isBelowBreakLength(ctx\x2C output\x2C 0\x2C base)) {\n    return `${braces[0]}${base ? ` ${base}` : ''} ${join(output\x2C '\x2C ')} ` +\n      braces[1];\n  }\n  const indentation = StringPrototypeRepeat(' '\x2C ctx.indentationLvl);\n  // If the opening "brace" is too large\x2C like in the case of "Set {"\x2C\n  // we need to force the first item to be on the next line or the\n  // items will not line up correctly.\n  const ln = base === '' && braces[0].length === 1 ?\n    ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\n  // Line up each entry on an individual line.\n  return `${braces[0]}${ln}${join(output\x2C `\x2C\\n${indentation}  `)} ${braces[1]}`;\n}\n\nfunction hasBuiltInToString(value) {\n  // Prevent triggering proxy traps.\n  const getFullProxy = false;\n  const proxyTarget = getProxyDetails(value\x2C getFullProxy);\n  if (proxyTarget !== undefined) {\n    value = proxyTarget;\n  }\n\n  // Count objects that have no `toString` function as built-in.\n  if (typeof value.toString !== 'function') {\n    return true;\n  }\n\n  // The object has a own `toString` property. Thus it's not not a built-in one.\n  if (ObjectPrototypeHasOwnProperty(value\x2C 'toString')) {\n    return false;\n  }\n\n  // Find the object that has the `toString` property as own property in the\n  // prototype chain.\n  let pointer = value;\n  do {\n    pointer = ObjectGetPrototypeOf(pointer);\n  } while (!ObjectPrototypeHasOwnProperty(pointer\x2C 'toString'));\n\n  // Check closer if the object is a built-in.\n  const descriptor = ObjectGetOwnPropertyDescriptor(pointer\x2C 'constructor');\n  return descriptor !== undefined &&\n    typeof descriptor.value === 'function' &&\n    builtInObjects.has(descriptor.value.name);\n}\n\nconst firstErrorLine = (error) =>\n  StringPrototypeSplit(error.message\x2C '\\n'\x2C 1)[0];\nlet CIRCULAR_ERROR_MESSAGE;\nfunction tryStringify(arg) {\n  try {\n    return JSONStringify(arg);\n  } catch (err) {\n    // Populate the circular error message lazily\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {}; a.a = a; JSONStringify(a);\n      } catch (circularError) {\n        CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);\n      }\n    }\n    if (err.name === 'TypeError' &&\n        firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {\n      return '[Circular]';\n    }\n    throw err;\n  }\n}\n\nfunction format(...args) {\n  return formatWithOptionsInternal(undefined\x2C args);\n}\n\nfunction formatWithOptions(inspectOptions\x2C ...args) {\n  if (typeof inspectOptions !== 'object' || inspectOptions === null) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'inspectOptions'\x2C 'object'\x2C inspectOptions);\n  }\n  return formatWithOptionsInternal(inspectOptions\x2C args);\n}\n\nfunction formatNumberNoColor(number\x2C options) {\n  return formatNumber(\n    stylizeNoColor\x2C\n    number\x2C\n    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator\n  );\n}\n\nfunction formatBigIntNoColor(bigint\x2C options) {\n  return formatBigInt(\n    stylizeNoColor\x2C\n    bigint\x2C\n    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator\n  );\n}\n\nfunction formatWithOptionsInternal(inspectOptions\x2C args) {\n  const first = args[0];\n  let a = 0;\n  let str = '';\n  let join = '';\n\n  if (typeof first === 'string') {\n    if (args.length === 1) {\n      return first;\n    }\n    let tempStr;\n    let lastPos = 0;\n\n    for (let i = 0; i < first.length - 1; i++) {\n      if (StringPrototypeCharCodeAt(first\x2C i) === 37) { // '%'\n        const nextChar = StringPrototypeCharCodeAt(first\x2C ++i);\n        if (a + 1 !== args.length) {\n          switch (nextChar) {\n            case 115: { // 's'\n              const tempArg = args[++a];\n              if (typeof tempArg === 'number') {\n                tempStr = formatNumberNoColor(tempArg\x2C inspectOptions);\n              } else if (typeof tempArg === 'bigint') {\n                tempStr = formatBigIntNoColor(tempArg\x2C inspectOptions);\n              } else if (typeof tempArg !== 'object' ||\n                         tempArg === null ||\n                         !hasBuiltInToString(tempArg)) {\n                tempStr = String(tempArg);\n              } else {\n                tempStr = inspect(tempArg\x2C {\n                  ...inspectOptions\x2C\n                  compact: 3\x2C\n                  colors: false\x2C\n                  depth: 0\n                });\n              }\n              break;\n            }\n            case 106: // 'j'\n              tempStr = tryStringify(args[++a]);\n              break;\n            case 100: { // 'd'\n              const tempNum = args[++a];\n              if (typeof tempNum === 'bigint') {\n                tempStr = formatBigIntNoColor(tempNum\x2C inspectOptions);\n              } else if (typeof tempNum === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(Number(tempNum)\x2C inspectOptions);\n              }\n              break;\n            }\n            case 79: // 'O'\n              tempStr = inspect(args[++a]\x2C inspectOptions);\n              break;\n            case 111: // 'o'\n              tempStr = inspect(args[++a]\x2C {\n                ...inspectOptions\x2C\n                showHidden: true\x2C\n                showProxy: true\x2C\n                depth: 4\n              });\n              break;\n            case 105: { // 'i'\n              const tempInteger = args[++a];\n              if (typeof tempInteger === 'bigint') {\n                tempStr = formatBigIntNoColor(tempInteger\x2C inspectOptions);\n              } else if (typeof tempInteger === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(\n                  NumberParseInt(tempInteger)\x2C inspectOptions);\n              }\n              break;\n            }\n            case 102: { // 'f'\n              const tempFloat = args[++a];\n              if (typeof tempFloat === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(\n                  NumberParseFloat(tempFloat)\x2C inspectOptions);\n              }\n              break;\n            }\n            case 99: // 'c'\n              a += 1;\n              tempStr = '';\n              break;\n            case 37: // '%'\n              str += StringPrototypeSlice(first\x2C lastPos\x2C i);\n              lastPos = i + 1;\n              continue;\n            default: // Any other character is not a correct placeholder\n              continue;\n          }\n          if (lastPos !== i - 1) {\n            str += StringPrototypeSlice(first\x2C lastPos\x2C i - 1);\n          }\n          str += tempStr;\n          lastPos = i + 1;\n        } else if (nextChar === 37) {\n          str += StringPrototypeSlice(first\x2C lastPos\x2C i);\n          lastPos = i + 1;\n        }\n      }\n    }\n    if (lastPos !== 0) {\n      a++;\n      join = ' ';\n      if (lastPos < first.length) {\n        str += StringPrototypeSlice(first\x2C lastPos);\n      }\n    }\n  }\n\n  while (a < args.length) {\n    const value = args[a];\n    str += join;\n    str += typeof value !== 'string' ? inspect(value\x2C inspectOptions) : value;\n    join = ' ';\n    a++;\n  }\n  return str;\n}\n\nif (internalBinding('config').hasIntl) {\n  const icu = internalBinding('icu');\n  // icu.getStringWidth(string\x2C ambiguousAsFullWidth\x2C expandEmojiSequence)\n  // Defaults: ambiguousAsFullWidth = false; expandEmojiSequence = true;\n  // TODO(BridgeAR): Expose the options to the user. That is probably the\n  // best thing possible at the moment\x2C since it's difficult to know what\n  // the receiving end supports.\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    for (let i = 0; i < str.length; i++) {\n      // Try to avoid calling into C++ by first handling the ASCII portion of\n      // the string. If it is fully ASCII\x2C we skip the C++ part.\n      const code = str.charCodeAt(i);\n      if (code >= 127) {\n        width += icu.getStringWidth(str.slice(i).normalize('NFC'));\n        break;\n      }\n      width += code >= 32 ? 1 : 0;\n    }\n    return width;\n  };\n} else {\n  /**\n   * Returns the number of columns required to display the given string.\n   */\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    str = StringPrototypeNormalize(str\x2C 'NFC');\n    for (const char of new SafeStringIterator(str)) {\n      const code = StringPrototypeCodePointAt(char\x2C 0);\n      if (isFullWidthCodePoint(code)) {\n        width += 2;\n      } else if (!isZeroWidthCodePoint(code)) {\n        width++;\n      }\n    }\n\n    return width;\n  };\n\n  /**\n   * Returns true if the character represented by a given\n   * Unicode code point is full-width. Otherwise returns false.\n   */\n  const isFullWidthCodePoint = (code) => {\n    // Code points are partially derived from:\n    // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n    return code >= 0x1100 && (\n      code <= 0x115f ||  // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd)\n    );\n  };\n\n  const isZeroWidthCodePoint = (code) => {\n    return code <= 0x1F || // C0 control codes\n      (code >= 0x7F && code <= 0x9F) || // C1 control codes\n      (code >= 0x300 && code <= 0x36F) || // Combining Diacritical Marks\n      (code >= 0x200B && code <= 0x200F) || // Modifying Invisible Characters\n      // Combining Diacritical Marks for Symbols\n      (code >= 0x20D0 && code <= 0x20FF) ||\n      (code >= 0xFE00 && code <= 0xFE0F) || // Variation Selectors\n      (code >= 0xFE20 && code <= 0xFE2F) || // Combining Half Marks\n      (code >= 0xE0100 && code <= 0xE01EF); // Variation Selectors\n  };\n}\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  validateString(str\x2C 'str');\n\n  return str.replace(ansi\x2C '');\n}\n\nmodule.exports = {\n  inspect\x2C\n  format\x2C\n  formatWithOptions\x2C\n  getStringWidth\x2C\n  inspectDefaultOptions\x2C\n  stripVTControlCharacters\n};\n
code-source-info,0xa12169c35d6,20,67958,68207,C0O67958C8O67988C18O68061C34O68067C39O68061C40O68150C43O68157C48O68205,,
tick,0x100911a2c,162792,0,0x0,3,0x0,0xa12169c31f2,0xa12169c1b66,0x1004a05e4,0xa12169c19fd,0x1208b73bed7,0x2cbd764a6ec6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x1bfd39474,162792,0,0x0,3,0x0,0xa12169c31f2,0xa12169c1b66,0x1004a05e4,0xa12169c19fd,0x1208b73bed7,0x2cbd764a6ec6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
tick,0x10035a73c,162792,0,0x0,3,0x0,0xa12169c31f2,0xa12169c1b66,0x1004a05e4,0xa12169c19fd,0x1208b73bed7,0x2cbd764a6ec6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,162834,0xa12169c8016,793,formatWithOptionsInternal node:internal/util/inspect:2048:35,0x232faba1b9f8,~
code-source-info,0xa12169c8016,20,68609,72597,C0O68650C1O68654C5O68669C7O68684C10O68701C13O68708C19O68754C26O68761C31O68776C33O68789C34O68804C36O68831C38O68852C40O68865C44O68872C47O68857C52O68890C57O68894C65O68930C70O68972C77O68998C80O68972C86O69019C88O69025C92O69038C96O69029C101O69058C169O69139C174O69143C178O69164C182O69215C185O69225C193O69292C199O69343C202O69353C210O69420C223O69526C229O69573C234O69583C241O69639C244O69689C256O69732C266O69761C276O69793C281O69649C287O69845C289O69909C294O69932C297O69936C301O69919C306O69958C308O70026C313O70030C317O70051C321O70102C324O70112C332O70179C338O70230C343O70286C348O70316C351O70316C356O70296C362O70380C364O70443C369O70461C372O70465C376O70453C382O70503C384O70553C389O70571C392O70575C396O70603C407O70647C417O70680C428O70709C433O70563C439O70743C441O70815C446O70819C450O70840C454O70895C457O70905C465O70976C471O71031C476O71087C481O71136C484O71136C489O71097C495O71212C497O71296C502O71300C506O71321C510O71374C515O71430C520O71479C523O71479C528O71440C534O71555C536O71618C542O71640C545O71668C547O71717C549O71724C561O71724C573O71779C575O71791C579O71810C581O71907C583O71939C585O71957C588O71951C593O71976C595O71983C600O72022C611O71983C623O72050C625O72057C632O72076C634O72088C640O72108C642O72121C647O72141C649O72148C661O72148C673O72199C675O72211C679O68878C684O68839C690O72244C691O72256C696O72271C701O72282C704O72320C708O72312C713O72338C715O72345C718O72345C730O72420C734O72413C739O72448C741O72452C745O72461C747O72468C754O72478C766O72513C775O72546C779O72557C782O72573C787O72404C790O72584C792O72595,,
code-creation,LazyCompile,10,162917,0xa12169c8716,269,value node:internal/console/constructor:258:20,0x815de61dcd8,~
code-source-info,0xa12169c8716,37,7494,8932,C0O7551C5O7592C7O7597C9O7596C13O7637C15O7654C17O7650C21O7687C23O7704C29O7719C34O7755C38O7780C44O7807C49O7851C55O7858C60O7875C68O7879C75O7930C80O7962C90O7982C98O7939C105O8016C107O8037C112O8061C122O8084C123O8101C128O8126C133O8126C138O8140C145O8457C153O8457C160O8480C165O8504C176O8504C182O8541C187O8541C206O8737C216O8741C222O8776C224O8776C238O8881C239O8888C250O8888C268O8931,,
code-creation,LazyCompile,10,162959,0xa12169c89a6,31,listenerCount node:events:854:23,0x232faba27170,~
code-source-info,0xa12169c89a6,23,24662,24930,C0O24693C5O24705C7O24756C9O24762C13O24775C17O24821C19O24830C20O24842C24O24898C28O24905C29O24919C30O24928,,
code-creation,LazyCompile,10,162959,0xa12169c8a9e,26,Writable.write node:internal/streams/writable:334:36,0xd2efcc08040,~
code-source-info,0xa12169c8a9e,64,10730,10808,C0O10756C15O10763C22O10797C25O10806,,
code-creation,LazyCompile,10,163000,0xa12169c8c86,338,_write node:internal/streams/writable:284:16,0xd2efcc07ff0,~
code-source-info,0xa12169c8c86,64,9364,10693,C0O9419C5O9438C11O9480C14O9516C22O9548C26O9586C34O9612C36O9625C43O9642C46O9649C51O9649C58O9677C65O9683C70O9677C71O9723C77O9759C81O9776C85O9802C90O9808C95O9802C96O9858C102O9876C108O9925C114O9939C119O9960C124O9975C129O9975C137O10006C143O10046C145O10067C147O10056C152O10083C158O10115C163O10126C168O10126C175O10156C180O10171C185O10171C192O10205C198O10245C216O10251C221O10245C222O10355C224O10372C230O10386C235O10392C243O10445C249O10462C259O10468C265O10510C269O10525C272O10533C277O10533C283O10556C296O10556C301O10595C303O10606C304O10613C310O10628C314O10634C332O10641C337O10691,,
code-creation,LazyCompile,10,163084,0xa12169c904e,217,writeOrBuffer node:internal/streams/writable:366:23,0xd2efcc08250,~
code-source-info,0xa12169c904e,64,11649,12640,C0O11714C10O11737C15O11748C22O11764C25O11761C29O11829C34O11844C38O11836C42O11933C44O11947C45O11963C49O11984C55O12001C61O12017C67O12035C73O12060C78O12069C90O12076C96O12083C102O12093C106O12069C111O12120C119O12143C124O12165C125O12182C129O12211C137O12231C142O12248C143O12262C149O12292C151O12307C155O12318C157O12332C161O12348C162O12362C166O12374C167O12385C171O12404C176O12434C190O12404C195O12448C196O12459C200O12589C204O12610C211O12628C216O12638,,
code-creation,LazyCompile,10,163084,0xa12169c9286,26,Socket._write node:net:828:35,0x120d44383628,~
code-source-info,0xa12169c9286,113,21360,21433,C0O21390C19O21390C25O21432,,
code-creation,LazyCompile,10,163125,0xa12169c9486,186,Socket._writeGeneric node:net:791:42,0x120d443834e8,~
code-source-info,0xa12169c9486,113,20470,21223,C0O20470C21O20672C27O20690C29O20708C33O20720C35O20742C39O20763C52O20763C58O20866C59O20873C60O20880C61O20898C65O20908C67O20930C71O20949C77O20964C84O20971C87O20967C93O20964C97O20997C98O21010C99O21023C104O21023C108O21045C110O21052C114O21068C130O21074C138O21116C157O21122C163O21172C169O21183C173O21188C176O21215C180O21209C185O21222,,
code-creation,LazyCompile,10,163167,0xa12169c96ee,45,_unrefTimer node:net:431:52,0x120d44382810,~
code-source-info,0xa12169c96ee,113,11830,11940,C0O11850C5O11858C9O11889C11O11895C13O11894C18O11912C20O11914C22O11913C26O11924C31O11924C35O11874C40O11837C44O11939,,
code-creation,LazyCompile,10,163167,0xa12169c980e,55,writeGeneric node:internal/stream_base_commons:147:22,0x3beccacbf90,~
script-source,88,node:internal/stream_base_commons,'use strict';\n\nconst {\n  Array\x2C\n  Symbol\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst { FastBuffer } = require('internal/buffer');\nconst {\n  WriteWrap\x2C\n  kReadBytesOrError\x2C\n  kArrayBufferOffset\x2C\n  kBytesWritten\x2C\n  kLastWriteWasAsync\x2C\n  streamBaseState\n} = internalBinding('stream_wrap');\nconst { UV_EOF } = internalBinding('uv');\nconst {\n  errnoException\n} = require('internal/errors');\nconst { owner_symbol } = require('internal/async_hooks').symbols;\nconst {\n  kTimeout\x2C\n  setUnrefTimeout\x2C\n  getTimerDuration\n} = require('internal/timers');\nconst { isUint8Array } = require('internal/util/types');\nconst { clearTimeout } = require('timers');\nconst { validateCallback } = require('internal/validators');\n\nconst kMaybeDestroy = Symbol('kMaybeDestroy');\nconst kUpdateTimer = Symbol('kUpdateTimer');\nconst kAfterAsyncWrite = Symbol('kAfterAsyncWrite');\nconst kHandle = Symbol('kHandle');\nconst kSession = Symbol('kSession');\n\nlet debug = require('internal/util/debuglog').debuglog('stream'\x2C (fn) => {\n  debug = fn;\n});\nconst kBuffer = Symbol('kBuffer');\nconst kBufferGen = Symbol('kBufferGen');\nconst kBufferCb = Symbol('kBufferCb');\n\nfunction handleWriteReq(req\x2C data\x2C encoding) {\n  const { handle } = req;\n\n  switch (encoding) {\n    case 'buffer':\n    {\n      const ret = handle.writeBuffer(req\x2C data);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = data;\n      return ret;\n    }\n    case 'latin1':\n    case 'binary':\n      return handle.writeLatin1String(req\x2C data);\n    case 'utf8':\n    case 'utf-8':\n      return handle.writeUtf8String(req\x2C data);\n    case 'ascii':\n      return handle.writeAsciiString(req\x2C data);\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return handle.writeUcs2String(req\x2C data);\n    default:\n    {\n      const buffer = Buffer.from(data\x2C encoding);\n      const ret = handle.writeBuffer(req\x2C buffer);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = buffer;\n      return ret;\n    }\n  }\n}\n\nfunction onWriteComplete(status) {\n  debug('onWriteComplete'\x2C status\x2C this.error);\n\n  const stream = this.handle[owner_symbol];\n\n  if (stream.destroyed) {\n    if (typeof this.callback === 'function')\n      this.callback(null);\n    return;\n  }\n\n  // TODO (ronag): This should be moved before if(stream.destroyed)\n  // in order to avoid swallowing error.\n  if (status < 0) {\n    const ex = errnoException(status\x2C 'write'\x2C this.error);\n    if (typeof this.callback === 'function')\n      this.callback(ex);\n    else\n      stream.destroy(ex);\n    return;\n  }\n\n  stream[kUpdateTimer]();\n  stream[kAfterAsyncWrite](this);\n\n  if (typeof this.callback === 'function')\n    this.callback(null);\n}\n\nfunction createWriteWrap(handle\x2C callback) {\n  const req = new WriteWrap();\n\n  req.handle = handle;\n  req.oncomplete = onWriteComplete;\n  req.async = false;\n  req.bytes = 0;\n  req.buffer = null;\n  req.callback = callback;\n\n  return req;\n}\n\nfunction writevGeneric(self\x2C data\x2C cb) {\n  const req = createWriteWrap(self[kHandle]\x2C cb);\n  const allBuffers = data.allBuffers;\n  let chunks;\n  if (allBuffers) {\n    chunks = data;\n    for (let i = 0; i < data.length; i++)\n      data[i] = data[i].chunk;\n  } else {\n    chunks = new Array(data.length << 1);\n    for (let i = 0; i < data.length; i++) {\n      const entry = data[i];\n      chunks[i * 2] = entry.chunk;\n      chunks[i * 2 + 1] = entry.encoding;\n    }\n  }\n  const err = req.handle.writev(req\x2C chunks\x2C allBuffers);\n\n  // Retain chunks\n  if (err === 0) req._chunks = chunks;\n\n  afterWriteDispatched(req\x2C err\x2C cb);\n  return req;\n}\n\nfunction writeGeneric(self\x2C data\x2C encoding\x2C cb) {\n  const req = createWriteWrap(self[kHandle]\x2C cb);\n  const err = handleWriteReq(req\x2C data\x2C encoding);\n\n  afterWriteDispatched(req\x2C err\x2C cb);\n  return req;\n}\n\nfunction afterWriteDispatched(req\x2C err\x2C cb) {\n  req.bytes = streamBaseState[kBytesWritten];\n  req.async = !!streamBaseState[kLastWriteWasAsync];\n\n  if (err !== 0)\n    return cb(errnoException(err\x2C 'write'\x2C req.error));\n\n  if (!req.async && typeof req.callback === 'function') {\n    req.callback();\n  }\n}\n\nfunction onStreamRead(arrayBuffer) {\n  const nread = streamBaseState[kReadBytesOrError];\n\n  const handle = this;\n  const stream = this[owner_symbol];\n\n  stream[kUpdateTimer]();\n\n  if (nread > 0 && !stream.destroyed) {\n    let ret;\n    let result;\n    const userBuf = stream[kBuffer];\n    if (userBuf) {\n      result = (stream[kBufferCb](nread\x2C userBuf) !== false);\n      const bufGen = stream[kBufferGen];\n      if (bufGen !== null) {\n        const nextBuf = bufGen();\n        if (isUint8Array(nextBuf))\n          stream[kBuffer] = ret = nextBuf;\n      }\n    } else {\n      const offset = streamBaseState[kArrayBufferOffset];\n      const buf = new FastBuffer(arrayBuffer\x2C offset\x2C nread);\n      result = stream.push(buf);\n    }\n    if (!result) {\n      handle.reading = false;\n      if (!stream.destroyed) {\n        const err = handle.readStop();\n        if (err)\n          stream.destroy(errnoException(err\x2C 'read'));\n      }\n    }\n\n    return ret;\n  }\n\n  if (nread === 0) {\n    return;\n  }\n\n  // After seeing EOF\x2C most streams will be closed permanently\x2C\n  // and will not deliver any more read events after this point.\n  // (equivalently\x2C it should have called readStop on itself already).\n  // Some streams may be reset and explicitly started again with a call\n  // to readStart\x2C such as TTY.\n\n  if (nread !== UV_EOF) {\n    // CallJSOnreadMethod expects the return value to be a buffer.\n    // Ref: https://github.com/nodejs/node/pull/34375\n    stream.destroy(errnoException(nread\x2C 'read'));\n    return;\n  }\n\n  // Defer this until we actually emit end\n  if (stream._readableState.endEmitted) {\n    if (stream[kMaybeDestroy])\n      stream[kMaybeDestroy]();\n  } else {\n    if (stream[kMaybeDestroy])\n      stream.on('end'\x2C stream[kMaybeDestroy]);\n\n    // Push a null to signal the end of data.\n    // Do it before `maybeDestroy` for correct order of events:\n    // `end` -> `close`\n    stream.push(null);\n    stream.read(0);\n  }\n}\n\nfunction setStreamTimeout(msecs\x2C callback) {\n  if (this.destroyed)\n    return this;\n\n  this.timeout = msecs;\n\n  // Type checking identical to timers.enroll()\n  msecs = getTimerDuration(msecs\x2C 'msecs');\n\n  // Attempt to clear an existing timer in both cases -\n  //  even if it will be rescheduled we don't want to leak an existing timer.\n  clearTimeout(this[kTimeout]);\n\n  if (msecs === 0) {\n    if (callback !== undefined) {\n      validateCallback(callback);\n      this.removeListener('timeout'\x2C callback);\n    }\n  } else {\n    this[kTimeout] = setUnrefTimeout(this._onTimeout.bind(this)\x2C msecs);\n    if (this[kSession]) this[kSession][kUpdateTimer]();\n\n    if (callback !== undefined) {\n      validateCallback(callback);\n      this.once('timeout'\x2C callback);\n    }\n  }\n  return this;\n}\n\nmodule.exports = {\n  writevGeneric\x2C\n  writeGeneric\x2C\n  onStreamRead\x2C\n  kAfterAsyncWrite\x2C\n  kMaybeDestroy\x2C\n  kUpdateTimer\x2C\n  kHandle\x2C\n  kSession\x2C\n  setStreamTimeout\x2C\n  kBuffer\x2C\n  kBufferCb\x2C\n  kBufferGen\n};\n
code-source-info,0xa12169c980e,88,3597,3781,C0O3640C5O3661C7O3660C11O3640C17O3690C29O3690C35O3730C47O3730C52O3768C54O3779,,
code-creation,LazyCompile,10,163459,0xa12169ca236,47,createWriteWrap node:internal/stream_base_commons:109:25,0x3beccacbed0,~
code-source-info,0xa12169ca236,88,2719,2933,C0O2754C5O2754C11O2774C13O2785C17O2797C19O2812C23O2833C24O2843C28O2854C29O2864C33O2871C34O2882C38O2892C40O2905C44O2920C46O2931,,
code-creation,LazyCompile,10,163500,0xa12169ca43e,215,handleWriteReq node:internal/stream_base_commons:45:24,0x3beccacbe30,~
code-source-info,0xa12169ca43e,88,1174,2006,C0O1208C5O1227C80O1297C85O1297C92O1327C99O1347C101O1346C106O1376C108O1387C112O1401C114O1412C115O1477C120O1477C126O1506C127O1562C132O1562C138O1589C139O1628C144O1628C150O1656C151O1753C156O1753C162O1780C163O1821C168O1828C173O1828C180O1875C185O1875C192O1907C199O1927C201O1926C206O1956C208O1967C212O1983C214O1994,,
code-creation,LazyCompile,10,163542,0xa12169ca686,92,afterWriteDispatched node:internal/stream_base_commons:155:30,0x3beccacc000,~
code-source-info,0xa12169ca686,88,3812,4086,C0O3831C2O3843C7O3859C9O3858C12O3841C16O3877C18O3891C23O3907C25O3906C30O3887C34O3931C35O3939C40O3950C42O3960C48O3993C56O3960C62O3957C66O4001C67O4014C73O4034C81O4069C86O4069C91O4085,,
code-creation,LazyCompile,10,163584,0xa12169ca8de,323,onwrite node:internal/streams/writable:426:17,0xd2efcc08340,~
code-source-info,0xa12169ca8de,64,13425,15048,C0O13463C5O13500C10O13525C15O13537C19O13573C26O13600C29O13596C35O13573C40O13630C41O13637C42O13645C43O13659C47O13670C48O13684C52O13694C57O13716C64O13707C68O13728C69O13743C73O13751C77O13855C81O13923C87O13940C89O13954C93O14072C99O14098C104O14113C110O14137C117O14160C121O14177C125O14195C128O14203C148O14203C155O14269C170O14269C177O14337C182O14346C187O14361C191O14353C196O14384C199O14384C204O14423C208O14704C214O14751C219O14770C226O14773C231O14797C242O14821C248O14848C255O14887C261O14891C267O14899C273O14873C277O14916C280O14924C288O14955C293O14924C301O15003C316O15003C322O15047,,
code-creation,LazyCompile,10,163625,0xa12169cabde,62,Readable.removeListener node:internal/streams/readable:927:45,0x174551ef4738,~
code-source-info,0xa12169cabde,57,29295,29852,C0O29320C5O29327C10O29337C15O29352C29O29352C35O29426C37O29433C42O29783C45O29791C53O29791C59O29839C61O29850,,
code-creation,LazyCompile,10,163667,0xa12169cad5e,307,removeListener node:events:689:28,0x232faba26ec8,~
code-source-info,0xa12169cad5e,23,20159,21430,C0O20184C3O20184C7O20236C12O20251C14O20285C16O20297C17O20318C19O20324C23O20338C25O20370C27O20382C28O20390C30O20399C35O20420C42O20429C47O20453C54O20464C59O20477C64O20494C66O20509C71O20509C75O20507C81O20554C83O20568C85O20596C91O20629C99O20663C114O20629C121O20709C127O20766C130O20797C134O20804C138O20811C139O20811C144O20834C146O20842C152O20846C159O20866C163O20870C170O20879C175O20907C180O20933C182O20818C187O20779C190O20971C191O20984C196O20999C198O21011C199O21021C200O21034C205O21056C210O21056C216O21090C222O21131C228O21143C233O21167C240O21141C246O21189C251O21189C256O21244C263O21251C268O21268C269O21287C272O21281C276O21312C282O21357C299O21357C304O21412C306O21424,,
code-creation,LazyCompile,10,163709,0xa12169cb086,24,workers.gatherAllChecks /Users/vignesh/Projects/HTTP2/lib/workers.js:22:35,0x1208b70fbc8,~
code-source-info,0xa12169cb086,195,502,1183,C0O532C3O538C16O538C23O1182,,
code-creation,LazyCompile,10,163709,0xa12169cb22e,54,lib.list /Users/vignesh/Projects/HTTP2/lib/data.js:106:20,0x2811abd2c890,~
code-source-info,0xa12169cb22e,189,2685,3031,C0O2685C9O2703C14O2706C24O2718C31O2725C37O2729C46O2706C53O3030,,
code-creation,LazyCompile,10,163750,0xa12169cb49e,159,readdir node:fs:1368:17,0xd2efcc355f0,~
code-source-info,0xa12169cb49e,81,34566,35131,C0O34566C13O34596C31O34607C35O34605C37O34675C44O34696C46O34685C53O34712C63O34719C67O34717C69O34758C76O34758C82O34794C88O34815C90O34830C96O34857C100O34872C104O35012C111O35020C120O35028C123O35039C131O35039C137O35071C142O35109C152O35020C158O35130,,
code-creation,LazyCompile,10,163792,0xa12169cb706,32,makeCallback node:fs:185:22,0xd2efcc343a0,~
code-source-info,0xa12169cb706,81,4813,4898,C0O4813C13O4822C23O4822C27O4847C31O4896,,
tick,0x100780e1c,163792,0,0x0,3,0x0,0xa12169cb25c,0xa12169cb096,0xa12169c1a0b,0x1208b73bed7,0x2cbd764a6ec6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,163917,0xa12169cb8ce,23,workers.loop /Users/vignesh/Projects/HTTP2/lib/workers.js:211:24,0x1208b710048,~
code-source-info,0xa12169cb8ce,195,8396,8474,C0O8402C16O8402C22O8473,,
code-creation,LazyCompile,10,164000,0xa12169cbb36,216,setInterval node:timers:209:21,0x174551ed3678,~
script-source,47,node:timers,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  MathTrunc\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  SymbolToPrimitive\n} = primordials;\n\nconst {\n  immediateInfo\x2C\n  toggleImmediateRef\n} = internalBinding('timers');\nconst L = require('internal/linkedlist');\nconst {\n  async_id_symbol\x2C\n  Timeout\x2C\n  Immediate\x2C\n  decRefCount\x2C\n  immediateInfoFields: {\n    kCount\x2C\n    kRefCount\n  }\x2C\n  kRefed\x2C\n  kHasPrimitive\x2C\n  getTimerDuration\x2C\n  timerListMap\x2C\n  timerListQueue\x2C\n  immediateQueue\x2C\n  active\x2C\n  unrefActive\x2C\n  insert\n} = require('internal/timers');\nconst {\n  promisify: { custom: customPromisify }\x2C\n  deprecate\n} = require('internal/util');\nlet debug = require('internal/util/debuglog').debuglog('timer'\x2C (fn) => {\n  debug = fn;\n});\nconst { validateCallback } = require('internal/validators');\n\nlet timersPromises;\n\nconst {\n  destroyHooksExist\x2C\n  // The needed emit*() functions.\n  emitDestroy\n} = require('internal/async_hooks');\n\n// This stores all the known timer async ids to allow users to clearTimeout and\n// clearInterval using those ids\x2C to match the spec and the rest of the web\n// platform.\nconst knownTimersById = ObjectCreate(null);\n\n// Remove a timer. Cancels the timeout and resets the relevant timer properties.\nfunction unenroll(item) {\n  if (item._destroyed)\n    return;\n\n  item._destroyed = true;\n\n  if (item[kHasPrimitive])\n    delete knownTimersById[item[async_id_symbol]];\n\n  // Fewer checks may be possible\x2C but these cover everything.\n  if (destroyHooksExist() && item[async_id_symbol] !== undefined)\n    emitDestroy(item[async_id_symbol]);\n\n  L.remove(item);\n\n  // We only delete refed lists because unrefed ones are incredibly likely\n  // to come from http and be recreated shortly after.\n  // TODO: Long-term this could instead be handled by creating an internal\n  // clearTimeout that makes it clear that the list should not be deleted.\n  // That function could then be used by http and other similar modules.\n  if (item[kRefed]) {\n    // Compliment truncation during insert().\n    const msecs = MathTrunc(item._idleTimeout);\n    const list = timerListMap[msecs];\n    if (list !== undefined && L.isEmpty(list)) {\n      debug('unenroll: list empty');\n      timerListQueue.removeAt(list.priorityQueuePosition);\n      delete timerListMap[list.msecs];\n    }\n\n    decRefCount();\n  }\n\n  // If active is called later\x2C then we want to make sure not to insert again\n  item._idleTimeout = -1;\n}\n\n// Make a regular object able to act as a timer by setting some properties.\n// This function does not start the timer\x2C see `active()`.\n// Using existing objects as timers slightly reduces object overhead.\nfunction enroll(item\x2C msecs) {\n  msecs = getTimerDuration(msecs\x2C 'msecs');\n\n  // If this item was already in a list somewhere\n  // then we should unenroll it from that\n  if (item._idleNext) unenroll(item);\n\n  L.init(item);\n  item._idleTimeout = msecs;\n}\n\n\n/**\n * Schedules the execution of a one-time `callback`\n * after `after` milliseconds.\n * @param {Function} callback\n * @param {number} [after]\n * @param {any} [arg1]\n * @param {any} [arg2]\n * @param {any} [arg3]\n * @returns {Timeout}\n */\nfunction setTimeout(callback\x2C after\x2C arg1\x2C arg2\x2C arg3) {\n  validateCallback(callback);\n\n  let i\x2C args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n    case 2:\n      break;\n    case 3:\n      args = [arg1];\n      break;\n    case 4:\n      args = [arg1\x2C arg2];\n      break;\n    default:\n      args = [arg1\x2C arg2\x2C arg3];\n      for (i = 5; i < arguments.length; i++) {\n        // Extend array dynamically\x2C makes .apply run much faster in v6.0.0\n        args[i - 2] = arguments[i];\n      }\n      break;\n  }\n\n  const timeout = new Timeout(callback\x2C after\x2C args\x2C false\x2C true);\n  insert(timeout\x2C timeout._idleTimeout);\n\n  return timeout;\n}\n\nObjectDefineProperty(setTimeout\x2C customPromisify\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!timersPromises)\n      timersPromises = require('timers/promises');\n    return timersPromises.setTimeout;\n  }\n});\n\n/**\n * Cancels a timeout.\n * @param {Timeout | string | number} timer\n * @returns {void}\n */\nfunction clearTimeout(timer) {\n  if (timer && timer._onTimeout) {\n    timer._onTimeout = null;\n    unenroll(timer);\n    return;\n  }\n  if (typeof timer === 'number' || typeof timer === 'string') {\n    const timerInstance = knownTimersById[timer];\n    if (timerInstance !== undefined) {\n      timerInstance._onTimeout = null;\n      unenroll(timerInstance);\n    }\n  }\n}\n\n/**\n * Schedules repeated execution of `callback`\n * every `repeat` milliseconds.\n * @param {Function} callback\n * @param {number} [repeat]\n * @param {any} [arg1]\n * @param {any} [arg2]\n * @param {any} [arg3]\n * @returns {Timeout}\n */\nfunction setInterval(callback\x2C repeat\x2C arg1\x2C arg2\x2C arg3) {\n  validateCallback(callback);\n\n  let i\x2C args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n    case 2:\n      break;\n    case 3:\n      args = [arg1];\n      break;\n    case 4:\n      args = [arg1\x2C arg2];\n      break;\n    default:\n      args = [arg1\x2C arg2\x2C arg3];\n      for (i = 5; i < arguments.length; i++) {\n        // Extend array dynamically\x2C makes .apply run much faster in v6.0.0\n        args[i - 2] = arguments[i];\n      }\n      break;\n  }\n\n  const timeout = new Timeout(callback\x2C repeat\x2C args\x2C true\x2C true);\n  insert(timeout\x2C timeout._idleTimeout);\n\n  return timeout;\n}\n\n/**\n * Cancels an interval.\n * @param {Timeout | string | number} timer\n * @returns {void}\n */\nfunction clearInterval(timer) {\n  // clearTimeout and clearInterval can be used to clear timers created from\n  // both setTimeout and setInterval\x2C as specified by HTML Living Standard:\n  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval\n  clearTimeout(timer);\n}\n\nTimeout.prototype.close = function() {\n  clearTimeout(this);\n  return this;\n};\n\n/**\n * Coerces a `Timeout` to a primitive.\n * @returns {number}\n */\nTimeout.prototype[SymbolToPrimitive] = function() {\n  const id = this[async_id_symbol];\n  if (!this[kHasPrimitive]) {\n    this[kHasPrimitive] = true;\n    knownTimersById[id] = this;\n  }\n  return id;\n};\n\n/**\n * Schedules the immediate execution of `callback`\n * after I/O events' callbacks.\n * @param {Function} callback\n * @param {any} [arg1]\n * @param {any} [arg2]\n * @param {any} [arg3]\n * @returns {Immediate}\n */\nfunction setImmediate(callback\x2C arg1\x2C arg2\x2C arg3) {\n  validateCallback(callback);\n\n  let i\x2C args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n      break;\n    case 2:\n      args = [arg1];\n      break;\n    case 3:\n      args = [arg1\x2C arg2];\n      break;\n    default:\n      args = [arg1\x2C arg2\x2C arg3];\n      for (i = 4; i < arguments.length; i++) {\n        // Extend array dynamically\x2C makes .apply run much faster in v6.0.0\n        args[i - 1] = arguments[i];\n      }\n      break;\n  }\n\n  return new Immediate(callback\x2C args);\n}\n\nObjectDefineProperty(setImmediate\x2C customPromisify\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!timersPromises)\n      timersPromises = require('timers/promises');\n    return timersPromises.setImmediate;\n  }\n});\n\n/**\n * Cancels an immediate.\n * @param {Immediate} immediate\n * @returns {void}\n */\nfunction clearImmediate(immediate) {\n  if (!immediate || immediate._destroyed)\n    return;\n\n  immediateInfo[kCount]--;\n  immediate._destroyed = true;\n\n  if (immediate[kRefed] && --immediateInfo[kRefCount] === 0)\n    toggleImmediateRef(false);\n  immediate[kRefed] = null;\n\n  if (destroyHooksExist() && immediate[async_id_symbol] !== undefined) {\n    emitDestroy(immediate[async_id_symbol]);\n  }\n\n  immediate._onImmediate = null;\n\n  immediateQueue.remove(immediate);\n}\n\nmodule.exports = {\n  setTimeout\x2C\n  clearTimeout\x2C\n  setImmediate\x2C\n  clearImmediate\x2C\n  setInterval\x2C\n  clearInterval\x2C\n  _unrefActive: deprecate(\n    unrefActive\x2C\n    'timers._unrefActive() is deprecated.' +\n    ' Please use timeout.refresh() instead.'\x2C\n    'DEP0127')\x2C\n  active: deprecate(\n    active\x2C\n    'timers.active() is deprecated. Please use timeout.refresh() instead.'\x2C\n    'DEP0126')\x2C\n  unenroll: deprecate(\n    unenroll\x2C\n    'timers.unenroll() is deprecated. Please use clearTimeout instead.'\x2C\n    'DEP0096')\x2C\n  enroll: deprecate(\n    enroll\x2C\n    'timers.enroll() is deprecated. Please use setTimeout instead.'\x2C\n    'DEP0095')\n};\n
code-source-info,0xa12169cbb36,47,5786,6413,C0O5786C2O5827C7O5827C11O5862C13O5865C15O5891C50O5949C52O5974C61O5982C70O5995C72O6020C81O6028C90O6034C99O6047C101O6073C110O6081C119O6087C128O6093C135O6111C138O6132C142O6120C147O6231C149O6238C155O6254C158O6243C162O6141C167O6106C170O6273C172O6303C192O6303C198O6354C203O6378C208O6354C213O6396C215O6411,,
code-creation,LazyCompile,10,164417,0xa12169ccac6,180,Timeout node:internal/timers:167:17,0x2b48e0c70720,~
script-source,12,node:internal/timers,'use strict';\n\n// HOW and WHY the timers implementation works the way it does.\n//\n// Timers are crucial to Node.js. Internally\x2C any TCP I/O connection creates a\n// timer so that we can time out of connections. Additionally\x2C many user\n// libraries and applications also use timers. As such there may be a\n// significantly large amount of timeouts scheduled at any given time.\n// Therefore\x2C it is very important that the timers implementation is performant\n// and efficient.\n//\n// Note: It is suggested you first read through the lib/internal/linkedlist.js\n// linked list implementation\x2C since timers depend on it extensively. It can be\n// somewhat counter-intuitive at first\x2C as it is not actually a class. Instead\x2C\n// it is a set of helpers that operate on an existing object.\n//\n// In order to be as performant as possible\x2C the architecture and data\n// structures are designed so that they are optimized to handle the following\n// use cases as efficiently as possible:\n\n// - Adding a new timer. (insert)\n// - Removing an existing timer. (remove)\n// - Handling a timer timing out. (timeout)\n//\n// Whenever possible\x2C the implementation tries to make the complexity of these\n// operations as close to constant-time as possible.\n// (So that performance is not impacted by the number of scheduled timers.)\n//\n// Object maps are kept which contain linked lists keyed by their duration in\n// milliseconds.\n//\n/* eslint-disable node-core/non-ascii-character */\n//\n// \u2554\u2550\u2550\u2550\u2550 > Object Map\n// \u2551\n// \u2560\u2550\u2550\n// \u2551 lists: { '40': { }\x2C '320': { etc } } (keys of millisecond duration)\n// \u255a\u2550\u2550          \u250c\u2500\u2500\u2500\u2500\u2518\n//              \u2502\n// \u2554\u2550\u2550          \u2502\n// \u2551 TimersList { _idleNext: { }\x2C _idlePrev: (self) }\n// \u2551         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n// \u2551    \u2554\u2550\u2550  \u2502                              ^\n// \u2551    \u2551    { _idleNext: { }\x2C  _idlePrev: { }\x2C _onTimeout: (callback) }\n// \u2551    \u2551      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n// \u2551    \u2551      \u2502                                  ^\n// \u2551    \u2551      { _idleNext: { etc }\x2C  _idlePrev: { }\x2C _onTimeout: (callback) }\n// \u2560\u2550\u2550  \u2560\u2550\u2550\n// \u2551    \u2551\n// \u2551    \u255a\u2550\u2550\u2550\u2550 >  Actual JavaScript timeouts\n// \u2551\n// \u255a\u2550\u2550\u2550\u2550 > Linked List\n//\n/* eslint-enable node-core/non-ascii-character */\n//\n// With this\x2C virtually constant-time insertion (append)\x2C removal\x2C and timeout\n// is possible in the JavaScript layer. Any one list of timers is able to be\n// sorted by just appending to it because all timers within share the same\n// duration. Therefore\x2C any timer added later will always have been scheduled to\n// timeout later\x2C thus only needing to be appended.\n// Removal from an object-property linked list is also virtually constant-time\n// as can be seen in the lib/internal/linkedlist.js implementation.\n// Timeouts only need to process any timers currently due to expire\x2C which will\n// always be at the beginning of the list for reasons stated above. Any timers\n// after the first one encountered that does not yet need to timeout will also\n// always be due to timeout at a later time.\n//\n// Less-than constant time operations are thus contained in two places:\n// The PriorityQueue \u2014 an efficient binary heap implementation that does all\n// operations in worst-case O(log n) time \u2014 which manages the order of expiring\n// Timeout lists and the object map lookup of a specific list by the duration of\n// timers within (or creation of a new list). However\x2C these operations combined\n// have shown to be trivial in comparison to other timers architectures.\n\nconst {\n  MathMax\x2C\n  MathTrunc\x2C\n  NumberIsFinite\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  ObjectCreate\x2C\n  ReflectApply\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  scheduleTimer\x2C\n  toggleTimerRef\x2C\n  getLibuvNow\x2C\n  immediateInfo\x2C\n  toggleImmediateRef\n} = internalBinding('timers');\n\nconst {\n  getDefaultTriggerAsyncId\x2C\n  newAsyncId\x2C\n  initHooksExist\x2C\n  destroyHooksExist\x2C\n  // The needed emit*() functions.\n  emitInit\x2C\n  emitBefore\x2C\n  emitAfter\x2C\n  emitDestroy\x2C\n} = require('internal/async_hooks');\n\n// Symbols for storing async id state.\nconst async_id_symbol = Symbol('asyncId');\nconst trigger_async_id_symbol = Symbol('triggerId');\n\nconst kHasPrimitive = Symbol('kHasPrimitive');\n\nconst {\n  ERR_OUT_OF_RANGE\n} = require('internal/errors').codes;\nconst {\n  validateCallback\x2C\n  validateNumber\x2C\n} = require('internal/validators');\n\nconst L = require('internal/linkedlist');\nconst PriorityQueue = require('internal/priority_queue');\n\nconst { inspect } = require('internal/util/inspect');\nlet debug = require('internal/util/debuglog').debuglog('timer'\x2C (fn) => {\n  debug = fn;\n});\n\n// *Must* match Environment::ImmediateInfo::Fields in src/env.h.\nconst kCount = 0;\nconst kRefCount = 1;\nconst kHasOutstanding = 2;\n\n// Timeout values > TIMEOUT_MAX are set to 1.\nconst TIMEOUT_MAX = 2 ** 31 - 1;\n\nlet timerListId = NumberMIN_SAFE_INTEGER;\n\nconst kRefed = Symbol('refed');\n\n// Create a single linked list instance only once at startup\nconst immediateQueue = new ImmediateList();\n\nlet nextExpiry = Infinity;\nlet refCount = 0;\n\n// This is a priority queue with a custom sorting function that first compares\n// the expiry times of two lists and if they're the same then compares their\n// individual IDs to determine which list was created first.\nconst timerListQueue = new PriorityQueue(compareTimersLists\x2C setPosition);\n\n// Object map containing linked lists of timers\x2C keyed and sorted by their\n// duration in milliseconds.\n//\n// - key = time in milliseconds\n// - value = linked list\nconst timerListMap = ObjectCreate(null);\n\nfunction initAsyncResource(resource\x2C type) {\n  const asyncId = resource[async_id_symbol] = newAsyncId();\n  const triggerAsyncId =\n    resource[trigger_async_id_symbol] = getDefaultTriggerAsyncId();\n  if (initHooksExist())\n    emitInit(asyncId\x2C type\x2C triggerAsyncId\x2C resource);\n}\n\n// Timer constructor function.\n// The entire prototype is defined in lib/timers.js\nfunction Timeout(callback\x2C after\x2C args\x2C isRepeat\x2C isRefed) {\n  after *= 1; // Coalesce to number or NaN\n  if (!(after >= 1 && after <= TIMEOUT_MAX)) {\n    if (after > TIMEOUT_MAX) {\n      process.emitWarning(`${after} does not fit into` +\n                          ' a 32-bit signed integer.' +\n                          '\\nTimeout duration was set to 1.'\x2C\n                          'TimeoutOverflowWarning');\n    }\n    after = 1; // Schedule on next tick\x2C follows browser behavior\n  }\n\n  this._idleTimeout = after;\n  this._idlePrev = this;\n  this._idleNext = this;\n  this._idleStart = null;\n  // This must be set to null first to avoid function tracking\n  // on the hidden class\x2C revisit in V8 versions after 6.2\n  this._onTimeout = null;\n  this._onTimeout = callback;\n  this._timerArgs = args;\n  this._repeat = isRepeat ? after : null;\n  this._destroyed = false;\n\n  if (isRefed)\n    incRefCount();\n  this[kRefed] = isRefed;\n  this[kHasPrimitive] = false;\n\n  initAsyncResource(this\x2C 'Timeout');\n}\n\n// Make sure the linked list only shows the minimal necessary information.\nTimeout.prototype[inspect.custom] = function(_\x2C options) {\n  return inspect(this\x2C {\n    ...options\x2C\n    // Only inspect one level.\n    depth: 0\x2C\n    // It should not recurse.\n    customInspect: false\n  });\n};\n\nTimeout.prototype.refresh = function() {\n  if (this[kRefed])\n    active(this);\n  else\n    unrefActive(this);\n\n  return this;\n};\n\nTimeout.prototype.unref = function() {\n  if (this[kRefed]) {\n    this[kRefed] = false;\n    if (!this._destroyed)\n      decRefCount();\n  }\n  return this;\n};\n\nTimeout.prototype.ref = function() {\n  if (!this[kRefed]) {\n    this[kRefed] = true;\n    if (!this._destroyed)\n      incRefCount();\n  }\n  return this;\n};\n\nTimeout.prototype.hasRef = function() {\n  return this[kRefed];\n};\n\nfunction TimersList(expiry\x2C msecs) {\n  this._idleNext = this; // Create the list with the linkedlist properties to\n  this._idlePrev = this; // Prevent any unnecessary hidden class changes.\n  this.expiry = expiry;\n  this.id = timerListId++;\n  this.msecs = msecs;\n  this.priorityQueuePosition = null;\n}\n\n// Make sure the linked list only shows the minimal necessary information.\nTimersList.prototype[inspect.custom] = function(_\x2C options) {\n  return inspect(this\x2C {\n    ...options\x2C\n    // Only inspect one level.\n    depth: 0\x2C\n    // It should not recurse.\n    customInspect: false\n  });\n};\n\n// A linked list for storing `setImmediate()` requests\nfunction ImmediateList() {\n  this.head = null;\n  this.tail = null;\n}\n\n// Appends an item to the end of the linked list\x2C adjusting the current tail's\n// next pointer and the item's previous pointer where applicable\nImmediateList.prototype.append = function(item) {\n  if (this.tail !== null) {\n    this.tail._idleNext = item;\n    item._idlePrev = this.tail;\n  } else {\n    this.head = item;\n  }\n  this.tail = item;\n};\n\n// Removes an item from the linked list\x2C adjusting the pointers of adjacent\n// items and the linked list's head or tail pointers as necessary\nImmediateList.prototype.remove = function(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  if (item === this.head)\n    this.head = item._idleNext;\n  if (item === this.tail)\n    this.tail = item._idlePrev;\n\n  item._idleNext = null;\n  item._idlePrev = null;\n};\n\nfunction incRefCount() {\n  if (refCount++ === 0)\n    toggleTimerRef(true);\n}\n\nfunction decRefCount() {\n  if (--refCount === 0)\n    toggleTimerRef(false);\n}\n\n// Schedule or re-schedule a timer.\n// The item must have been enroll()'d first.\nfunction active(item) {\n  insertGuarded(item\x2C true);\n}\n\n// Internal APIs that need timeouts should use `unrefActive()` instead of\n// `active()` so that they do not unnecessarily keep the process open.\nfunction unrefActive(item) {\n  insertGuarded(item\x2C false);\n}\n\n// The underlying logic for scheduling or re-scheduling a timer.\n//\n// Appends a timer onto the end of an existing timers list\x2C or creates a new\n// list if one does not already exist for the specified timeout duration.\nfunction insertGuarded(item\x2C refed\x2C start) {\n  const msecs = item._idleTimeout;\n  if (msecs < 0 || msecs === undefined)\n    return;\n\n  insert(item\x2C msecs\x2C start);\n\n  const isDestroyed = item._destroyed;\n  if (isDestroyed || !item[async_id_symbol]) {\n    item._destroyed = false;\n    initAsyncResource(item\x2C 'Timeout');\n  }\n\n  if (isDestroyed) {\n    if (refed)\n      incRefCount();\n  } else if (refed === !item[kRefed]) {\n    if (refed)\n      incRefCount();\n    else\n      decRefCount();\n  }\n  item[kRefed] = refed;\n}\n\nfunction insert(item\x2C msecs\x2C start = getLibuvNow()) {\n  // Truncate so that accuracy of sub-millisecond timers is not assumed.\n  msecs = MathTrunc(msecs);\n  item._idleStart = start;\n\n  // Use an existing list if there is one\x2C otherwise we need to make a new one.\n  let list = timerListMap[msecs];\n  if (list === undefined) {\n    debug('no %d list was found in insert\x2C creating a new one'\x2C msecs);\n    const expiry = start + msecs;\n    timerListMap[msecs] = list = new TimersList(expiry\x2C msecs);\n    timerListQueue.insert(list);\n\n    if (nextExpiry > expiry) {\n      scheduleTimer(msecs);\n      nextExpiry = expiry;\n    }\n  }\n\n  L.append(list\x2C item);\n}\n\nfunction setUnrefTimeout(callback\x2C after) {\n  // Type checking identical to setTimeout()\n  validateCallback(callback);\n\n  const timer = new Timeout(callback\x2C after\x2C undefined\x2C false\x2C false);\n  insert(timer\x2C timer._idleTimeout);\n\n  return timer;\n}\n\n// Type checking used by timers.enroll() and Socket#setTimeout()\nfunction getTimerDuration(msecs\x2C name) {\n  validateNumber(msecs\x2C name);\n  if (msecs < 0 || !NumberIsFinite(msecs)) {\n    throw new ERR_OUT_OF_RANGE(name\x2C 'a non-negative finite number'\x2C msecs);\n  }\n\n  // Ensure that msecs fits into signed int32\n  if (msecs > TIMEOUT_MAX) {\n    process.emitWarning(`${msecs} does not fit into a 32-bit signed integer.` +\n                        `\\nTimer duration was truncated to ${TIMEOUT_MAX}.`\x2C\n                        'TimeoutOverflowWarning');\n    return TIMEOUT_MAX;\n  }\n\n  return msecs;\n}\n\nfunction compareTimersLists(a\x2C b) {\n  const expiryDiff = a.expiry - b.expiry;\n  if (expiryDiff === 0) {\n    if (a.id < b.id)\n      return -1;\n    if (a.id > b.id)\n      return 1;\n  }\n  return expiryDiff;\n}\n\nfunction setPosition(node\x2C pos) {\n  node.priorityQueuePosition = pos;\n}\n\nfunction getTimerCallbacks(runNextTicks) {\n  // If an uncaught exception was thrown during execution of immediateQueue\x2C\n  // this queue will store all remaining Immediates that need to run upon\n  // resolution of all error handling (if process is still alive).\n  const outstandingQueue = new ImmediateList();\n\n  function processImmediate() {\n    const queue = outstandingQueue.head !== null ?\n      outstandingQueue : immediateQueue;\n    let immediate = queue.head;\n\n    // Clear the linked list early in case new `setImmediate()`\n    // calls occur while immediate callbacks are executed\n    if (queue !== outstandingQueue) {\n      queue.head = queue.tail = null;\n      immediateInfo[kHasOutstanding] = 1;\n    }\n\n    let prevImmediate;\n    let ranAtLeastOneImmediate = false;\n    while (immediate !== null) {\n      if (ranAtLeastOneImmediate)\n        runNextTicks();\n      else\n        ranAtLeastOneImmediate = true;\n\n      // It's possible for this current Immediate to be cleared while executing\n      // the next tick queue above\x2C which means we need to use the previous\n      // Immediate's _idleNext which is guaranteed to not have been cleared.\n      if (immediate._destroyed) {\n        outstandingQueue.head = immediate = prevImmediate._idleNext;\n        continue;\n      }\n\n      // TODO(RaisinTen): Destroy and unref the Immediate after _onImmediate()\n      // gets executed\x2C just like how Timeouts work.\n      immediate._destroyed = true;\n\n      immediateInfo[kCount]--;\n      if (immediate[kRefed])\n        immediateInfo[kRefCount]--;\n      immediate[kRefed] = null;\n\n      prevImmediate = immediate;\n\n      const asyncId = immediate[async_id_symbol];\n      emitBefore(asyncId\x2C immediate[trigger_async_id_symbol]\x2C immediate);\n\n      try {\n        const argv = immediate._argv;\n        if (!argv)\n          immediate._onImmediate();\n        else\n          immediate._onImmediate(...argv);\n      } finally {\n        immediate._onImmediate = null;\n\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n\n        outstandingQueue.head = immediate = immediate._idleNext;\n      }\n\n      emitAfter(asyncId);\n    }\n\n    if (queue === outstandingQueue)\n      outstandingQueue.head = null;\n    immediateInfo[kHasOutstanding] = 0;\n  }\n\n\n  function processTimers(now) {\n    debug('process timer lists %d'\x2C now);\n    nextExpiry = Infinity;\n\n    let list;\n    let ranAtLeastOneList = false;\n    while ((list = timerListQueue.peek()) != null) {\n      if (list.expiry > now) {\n        nextExpiry = list.expiry;\n        return refCount > 0 ? nextExpiry : -nextExpiry;\n      }\n      if (ranAtLeastOneList)\n        runNextTicks();\n      else\n        ranAtLeastOneList = true;\n      listOnTimeout(list\x2C now);\n    }\n    return 0;\n  }\n\n  function listOnTimeout(list\x2C now) {\n    const msecs = list.msecs;\n\n    debug('timeout callback %d'\x2C msecs);\n\n    let ranAtLeastOneTimer = false;\n    let timer;\n    while ((timer = L.peek(list)) != null) {\n      const diff = now - timer._idleStart;\n\n      // Check if this loop iteration is too early for the next timer.\n      // This happens if there are more timers scheduled for later in the list.\n      if (diff < msecs) {\n        list.expiry = MathMax(timer._idleStart + msecs\x2C now + 1);\n        list.id = timerListId++;\n        timerListQueue.percolateDown(1);\n        debug('%d list wait because diff is %d'\x2C msecs\x2C diff);\n        return;\n      }\n\n      if (ranAtLeastOneTimer)\n        runNextTicks();\n      else\n        ranAtLeastOneTimer = true;\n\n      // The actual logic for when a timeout happens.\n      L.remove(timer);\n\n      const asyncId = timer[async_id_symbol];\n\n      if (!timer._onTimeout) {\n        if (!timer._destroyed) {\n          timer._destroyed = true;\n\n          if (timer[kRefed])\n            refCount--;\n\n          if (destroyHooksExist())\n            emitDestroy(asyncId);\n        }\n        continue;\n      }\n\n      emitBefore(asyncId\x2C timer[trigger_async_id_symbol]\x2C timer);\n\n      let start;\n      if (timer._repeat)\n        start = getLibuvNow();\n\n      try {\n        const args = timer._timerArgs;\n        if (args === undefined)\n          timer._onTimeout();\n        else\n          ReflectApply(timer._onTimeout\x2C timer\x2C args);\n      } finally {\n        if (timer._repeat && timer._idleTimeout !== -1) {\n          timer._idleTimeout = timer._repeat;\n          insert(timer\x2C timer._idleTimeout\x2C start);\n        } else if (!timer._idleNext && !timer._idlePrev && !timer._destroyed) {\n          timer._destroyed = true;\n\n          if (timer[kRefed])\n            refCount--;\n\n          if (destroyHooksExist())\n            emitDestroy(asyncId);\n        }\n      }\n\n      emitAfter(asyncId);\n    }\n\n    // If `L.peek(list)` returned nothing\x2C the list was either empty or we have\n    // called all of the timer timeouts.\n    // As such\x2C we can remove the list from the object map and\n    // the PriorityQueue.\n    debug('%d list empty'\x2C msecs);\n\n    // The current list may have been removed and recreated since the reference\n    // to `list` was created. Make sure they're the same instance of the list\n    // before destroying.\n    if (list === timerListMap[msecs]) {\n      delete timerListMap[msecs];\n      timerListQueue.shift();\n    }\n  }\n\n  return {\n    processImmediate\x2C\n    processTimers\n  };\n}\n\nclass Immediate {\n  constructor(callback\x2C args) {\n    this._idleNext = null;\n    this._idlePrev = null;\n    this._onImmediate = callback;\n    this._argv = args;\n    this._destroyed = false;\n    this[kRefed] = false;\n\n    initAsyncResource(this\x2C 'Immediate');\n\n    this.ref();\n    immediateInfo[kCount]++;\n\n    immediateQueue.append(this);\n  }\n\n  ref() {\n    if (this[kRefed] === false) {\n      this[kRefed] = true;\n      if (immediateInfo[kRefCount]++ === 0)\n        toggleImmediateRef(true);\n    }\n    return this;\n  }\n\n  unref() {\n    if (this[kRefed] === true) {\n      this[kRefed] = false;\n      if (--immediateInfo[kRefCount] === 0)\n        toggleImmediateRef(false);\n    }\n    return this;\n  }\n\n  hasRef() {\n    return !!this[kRefed];\n  }\n}\n\nfunction getTimerCounts() {\n  return {\n    timeoutCount: refCount\x2C\n    immediateCount: immediateInfo[kRefCount]\x2C\n  };\n}\n\nmodule.exports = {\n  TIMEOUT_MAX\x2C\n  kTimeout: Symbol('timeout')\x2C // For hiding Timeouts on other internals.\n  async_id_symbol\x2C\n  trigger_async_id_symbol\x2C\n  Timeout\x2C\n  Immediate\x2C\n  kRefed\x2C\n  kHasPrimitive\x2C\n  initAsyncResource\x2C\n  setUnrefTimeout\x2C\n  getTimerDuration\x2C\n  immediateQueue\x2C\n  getTimerCallbacks\x2C\n  immediateInfoFields: {\n    kCount\x2C\n    kRefCount\x2C\n    kHasOutstanding\n  }\x2C\n  active\x2C\n  unrefActive\x2C\n  insert\x2C\n  timerListMap\x2C\n  timerListQueue\x2C\n  decRefCount\x2C\n  incRefCount\x2C\n  getTimerCounts\x2C\n};\n
code-source-info,0xa12169ccac6,12,5778,6759,C0O5825C7O5868C9O5880C16O5897C18O5894C23O5917C25O5929C27O5927C32O5950C35O5958C42O5973C52O5999C58O6055C65O5958C71O6182C75O6251C77O6269C81O6280C83O6295C87O6305C89O6320C93O6330C94O6346C98O6478C99O6494C103O6504C105O6520C109O6534C111O6550C115O6560C120O6575C127O6573C131O6602C132O6618C136O6630C140O6647C143O6647C146O6664C148O6669C153O6677C157O6690C159O6695C163O6710C167O6722C173O6722C179O6758,,
tick,0x1bfd39474,165125,0,0x0,3,0x0,0xa12169cbbf6,0xa12169cb8de,0xa12169c1a17,0x1208b73bed7,0x2cbd764a6ec6,0x26b72db31789,0x26b72db2d3e3,0x26b72db2c8a6,0x26b72db1b07f,0x2cbd764a6127,0x3172a1b05b11
code-creation,LazyCompile,10,165167,0xa12169ce246,37,incRefCount node:internal/timers:299:21,0x2b48e0c70ca0,~
code-source-info,0xa12169ce246,12,9151,9207,C0O9158C12O9170C19O9173C24O9184C31O9184C36O9206,,
code-creation,LazyCompile,10,165167,0xa12169ce36e,76,initAsyncResource node:internal/timers:157:27,0x2b48e0c706d0,~
code-source-info,0xa12169ce36e,12,5425,5677,C0O5462C2O5471C7O5490C10O5490C14O5488C21O5533C23O5542C28O5569C31O5569C35O5567C42O5599C47O5603C52O5625C69O5625C75O5676,,
code-creation,LazyCompile,10,165209,0xa12169ce57e,159,insert node:internal/timers:350:16,0x2b48e0c70e30,~
code-source-info,0xa12169ce57e,12,10384,11020,C12O10406C15O10406C23O10498C28O10506C33O10526C35O10542C39O10645C46O10657C50O10668C52O10698C60O10698C65O10785C67O10791C71O10804C87O10833C93O10824C97O10868C102O10883C107O10883C112O10902C119O10917C124O10935C129O10935C133O10963C135O10974C141O10997C146O10999C151O10999C158O11019,,
code-creation,LazyCompile,10,165250,0xa12169ce756,10, node:internal/timers:123:65,0x2b48e0c6fdc0,~
code-source-info,0xa12169ce756,12,4431,4456,C0O4443C2O4449C9O4455,,
code-creation,LazyCompile,10,165250,0xa12169ce87e,55,TimersList node:internal/timers:241:20,0x2b48e0c70a08,~
code-source-info,0xa12169ce87e,12,7573,7854,C0O7593C2O7608C6O7671C8O7686C12O7745C14O7757C18O7769C30O7790C38O7777C42O7796C44O7807C48O7818C49O7845C54O7853,,
code-creation,LazyCompile,10,165292,0xa12169cea16,67,insert node:internal/priority_queue:34:9,0x232faba05178,~
script-source,19,node:internal/priority_queue,'use strict';\n\nconst {\n  Array\x2C\n  Symbol\x2C\n} = primordials;\n\nconst kCompare = Symbol('compare');\nconst kHeap = Symbol('heap');\nconst kSetPosition = Symbol('setPosition');\nconst kSize = Symbol('size');\n\n// The PriorityQueue is a basic implementation of a binary heap that accepts\n// a custom sorting function via its constructor. This function is passed\n// the two nodes to compare\x2C similar to the native Array#sort. Crucially\n// this enables priority queues that are based on a comparison of more than\n// just a single criteria.\n\nmodule.exports = class PriorityQueue {\n  constructor(comparator\x2C setPosition) {\n    if (comparator !== undefined)\n      this[kCompare] = comparator;\n    if (setPosition !== undefined)\n      this[kSetPosition] = setPosition;\n\n    this[kHeap] = new Array(64);\n    this[kSize] = 0;\n  }\n\n  [kCompare](a\x2C b) {\n    return a - b;\n  }\n\n  insert(value) {\n    const heap = this[kHeap];\n    const pos = ++this[kSize];\n    heap[pos] = value;\n\n    if (heap.length === pos)\n      heap.length *= 2;\n\n    this.percolateUp(pos);\n  }\n\n  peek() {\n    return this[kHeap][1];\n  }\n\n  percolateDown(pos) {\n    const compare = this[kCompare];\n    const setPosition = this[kSetPosition];\n    const heap = this[kHeap];\n    const size = this[kSize];\n    const item = heap[pos];\n\n    while (pos * 2 <= size) {\n      let childIndex = pos * 2 + 1;\n      if (childIndex > size || compare(heap[pos * 2]\x2C heap[childIndex]) < 0)\n        childIndex = pos * 2;\n      const child = heap[childIndex];\n      if (compare(item\x2C child) <= 0)\n        break;\n      if (setPosition !== undefined)\n        setPosition(child\x2C pos);\n      heap[pos] = child;\n      pos = childIndex;\n    }\n    heap[pos] = item;\n    if (setPosition !== undefined)\n      setPosition(item\x2C pos);\n  }\n\n  percolateUp(pos) {\n    const heap = this[kHeap];\n    const compare = this[kCompare];\n    const setPosition = this[kSetPosition];\n    const item = heap[pos];\n\n    while (pos > 1) {\n      const parent = heap[pos / 2 | 0];\n      if (compare(parent\x2C item) <= 0)\n        break;\n      heap[pos] = parent;\n      if (setPosition !== undefined)\n        setPosition(parent\x2C pos);\n      pos = pos / 2 | 0;\n    }\n    heap[pos] = item;\n    if (setPosition !== undefined)\n      setPosition(item\x2C pos);\n  }\n\n  removeAt(pos) {\n    const heap = this[kHeap];\n    const size = --this[kSize];\n    heap[pos] = heap[size + 1];\n    heap[size + 1] = undefined;\n\n    if (size > 0 && pos <= size) {\n      if (pos > 1 && this[kCompare](heap[pos / 2 | 0]\x2C heap[pos]) > 0)\n        this.percolateUp(pos);\n      else\n        this.percolateDown(pos);\n    }\n  }\n\n  shift() {\n    const heap = this[kHeap];\n    const value = heap[1];\n    if (value === undefined)\n      return;\n\n    this.removeAt(1);\n\n    return value;\n  }\n};\n
code-source-info,0xa12169cea16,19,865,1044,C0O892C2O897C4O896C8O921C10O928C19O933C26O940C28O950C32O973C39O980C44O995C51O1007C55O1023C60O1023C66O1043,,
code-creation,LazyCompile,10,165417,0xa12169cef2e,108,percolateUp node:internal/priority_queue:73:14,0x232faba05288,~
code-source-info,0xa12169cef2e,19,1774,2254,C0O1799C2O1804C4O1803C8O1832C10O1837C12O1836C16O1872C18O1877C20O1876C24O1909C26O1913C30O1936C32O1936C37O1964C39O1973C42O1977C45O1968C49O1993C56O2015C61O2029C63O2042C65O2052C69O2068C73O2107C78O2139C80O2149C83O2153C88O1925C91O2168C93O2178C97O2190C101O2227C107O2253,,
code-creation,LazyCompile,10,165459,0xa12169cf0c6,8,setPosition node:internal/timers:411:21,0x2b48e0c70fd8,~
code-source-info,0xa12169cf0c6,12,12092,12143,C0O12108C2O12135C7O12142,,
code-creation,LazyCompile,10,165459,0xa12169cf1ae,52,append node:internal/linkedlist:30:16,0x232faba04140,~
script-source,18,node:internal/linkedlist,'use strict';\n\nfunction init(list) {\n  list._idleNext = list;\n  list._idlePrev = list;\n  return list;\n}\n\n// Show the most idle item.\nfunction peek(list) {\n  if (list._idlePrev === list) return null;\n  return list._idlePrev;\n}\n\n// Remove an item from its list.\nfunction remove(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  item._idleNext = null;\n  item._idlePrev = null;\n}\n\n// Remove an item from its list and place at the end.\nfunction append(list\x2C item) {\n  if (item._idleNext || item._idlePrev) {\n    remove(item);\n  }\n\n  // Items are linked  with _idleNext -> (older) and _idlePrev -> (newer).\n  // Note: This linkage (next being older) may seem counter-intuitive at first.\n  item._idleNext = list._idleNext;\n  item._idlePrev = list;\n\n  // The list _idleNext points to tail (newest) and _idlePrev to head (oldest).\n  list._idleNext._idlePrev = item;\n  list._idleNext = item;\n}\n\nfunction isEmpty(list) {\n  return list._idleNext === list;\n}\n\nmodule.exports = {\n  init\x2C\n  peek\x2C\n  remove\x2C\n  append\x2C\n  isEmpty\n};\n
code-source-info,0xa12169cf1ae,18,558,995,C0O584C6O602C12O619C15O619C19O817C23O810C27O830C29O845C33O941C40O961C44O971C46O986C51O994,,
code-creation,LazyCompile,10,165542,0xa12169cf4ae,50,remove node:internal/linkedlist:16:16,0x232faba040f0,~
code-source-info,0xa12169cf4ae,18,275,487,C0O295C6O317C11O344C15O337C19O371C25O393C30O420C34O413C38O438C39O453C43O463C44O478C49O486,,
code-creation,LazyCompile,10,165542,0xa12169cf626,23,workers.rotateLogs /Users/vignesh/Projects/HTTP2/lib/workers.js:218:30,0x1208b7100f8,~
code-source-info,0xa12169cf626,195,8541,9390,C0O8592C3O8598C15O8598C22O9389,,
code-creation,LazyCompile,10,165584,0xa12169cf7d6,46,lib.list /Users/vignesh/Projects/HTTP2/lib/logs.js:43:20,0x1208b712258,~
code-source-info,0xa12169cf7d6,196,1115,1733,C0O1115C13O1151C18O1154C28O1166C38O1154C45O1732,,
code-creation,LazyCompile,10,165625,0xa12169cf96e,23,workers.logRotationLoop /Users/vignesh/Projects/HTTP2/lib/workers.js:248:35,0x1208b710228,~
code-source-info,0xa12169cf96e,195,9485,9568,C0O9491C16O9491C22O9567,,
code-creation,LazyCompile,10,165625,0xa12169cfab6,56,compareTimersLists node:internal/timers:400:28,0x2b48e0c70f60,~
code-source-info,0xa12169cfab6,12,11892,12070,C0O11924C5O11935C9O11931C13O11945C14O11960C19O11979C24O11986C28O11982C33O11996C35O12006C36O12017C41O12024C45O12020C50O12034C52O12043C53O12050C55O12068,,
code-creation,LazyCompile,10,165667,0xa12169cfcbe,216,setTimeout node:timers:140:20,0x174551ed3588,~
code-source-info,0xa12169cfcbe,47,4237,4863,C0O4237C2O4277C7O4277C11O4312C13O4315C15O4341C50O4399C52O4424C61O4432C70O4445C72O4470C81O4478C90O4484C99O4497C101O4523C110O4531C119O4537C128O4543C135O4561C138O4582C142O4570C147O4681C149O4688C155O4704C158O4693C162O4591C167O4556C170O4723C172O4753C192O4753C198O4804C203O4828C208O4804C213O4846C215O4861,,
code-creation,LazyCompile,10,165750,0xa12169cffe6,318,processTicksAndRejections node:internal/process/task_queues:68:35,0x815de60f618,~
code-source-info,0xa12169cffe6,32,1496,2441,C0O1507C2O1554C7O1545C12O1545C19O1588C21O1593C23O1592C27O1617C34O1642C36O1641C46O1617C54O1718C59O1745C65O1777C70O1834C75O1863C110O1893C111O1906C115O1893C119O1912C121O1939C122O1952C128O1961C132O1939C137O1967C139O1994C140O2007C146O2016C152O2025C156O1994C161O2031C163O2058C164O2071C170O2080C176O2089C182O2098C186O2058C191O2104C193O2132C198O2132C215O2199C220O2203C225O2234C230O2234C245O2271C250O2271C256O2301C261O2301C264O2346C269O2336C274O2336C282O2349C285O2349C290O1515C296O2380C301O2380C305O2410C312O2410C317O2440,,
code-creation,LazyCompile,10,165750,0xa12169d02be,43,shift node:internal/fixed_queue:108:8,0x815de614768,~
code-source-info,0xa12169d02be,34,3954,4180,C0O3981C5O4009C10O4009C15O4031C20O4031C26O4049C32O4148C36O4141C40O4164C42O4176,,
code-creation,LazyCompile,10,165792,0xa12169d0406,54,shift node:internal/fixed_queue:80:8,0x815de614578,~
code-source-info,0xa12169d0406,34,3300,3510,C0O3331C5O3341C9O3335C13O3354C15O3388C16O3400C17O3410C22O3420C28O3428C32O3465C36O3472C42O3479C44O3477C47O3457C51O3490C53O3506,,
code-creation,LazyCompile,10,165792,0xa12169d053e,42,emitBeforeScript node:internal/async_hooks:510:26,0x2b48e0c77f78,~
code-source-info,0xa12169d053e,13,16863,17014,C0O16903C12O16903C17O16959C22O16972C25O16963C31O16986C36O16986C41O17013,,
code-creation,LazyCompile,10,165834,0xa12169d068e,180,pushAsyncContext node:internal/async_hooks:540:26,0x2b48e0c78120,~
code-source-info,0xa12169d068e,13,17507,18052,C0O17562C7O17580C9O17579C13O17597C20O17631C24O17645C26O17656C32O17663C35O17674C40O17690C44O17660C49O17702C54O17709C59O17752C60O17755C65O17766C72O17789C78O17796C83O17812C85O17811C88O17794C92O17834C97O17845C104O17868C107O17872C113O17879C118O17895C120O17894C123O17877C127O17915C134O17933C142O17946C146O17952C153O17968C158O17987C162O18000C169O18016C174O18033C179O18051,,
code-creation,LazyCompile,10,165875,0xa12169d0886,21,emitListeningNT node:net:1403:25,0x120d44382590,~
code-source-info,0xa12169d0886,113,37465,37556,C0O37518C6O37536C14O37536C20O37555,,
code-creation,LazyCompile,10,165875,0xa12169d09be,95,onceWrapper node:events:636:21,0x232faba26d60,~
code-source-info,0xa12169d09be,23,18722,18966,C0O18722C2O18739C8O18757C13O18764C18O18784C23O18795C28O18764C34O18808C35O18819C39O18845C45O18852C50O18877C55O18886C60O18896C65O18886C70O18904C71O18921C76O18930C81O18941C86O18930C92O18960C94O18965,,
code-creation,LazyCompile,10,165917,0xa12169d0ba6,34, /Users/vignesh/Projects/HTTP2/lib/server.js:173:52,0x1208b73bfb8,~
code-source-info,0xa12169d0ba6,151,5658,5757,C0O5666C4O5674C18O5743C22O5735C26O5674C33O5756,,
code-creation,LazyCompile,10,165959,0xa12169d0ca6,13,destroyHooksExist node:internal/async_hooks:487:27,0x2b48e0c77e88,~
code-source-info,0xa12169d0ca6,13,16312,16347,C0O16319C5O16335C8O16326C12O16345,,
code-creation,LazyCompile,10,165959,0xa12169d0d96,32,emitAfterScript node:internal/async_hooks:518:25,0x2b48e0c77fc8,~
code-source-info,0xa12169d0d96,13,17041,17137,C0O17055C5O17068C8O17059C14O17081C19O17081C23O17110C26O17110C31O17136,,
code-creation,LazyCompile,10,166000,0xa12169d0f46,167,popAsyncContext node:internal/async_hooks:554:25,0x2b48e0c78170,~
code-source-info,0xa12169d0f46,13,18141,18728,C0O18175C7O18193C9O18192C13O18210C14O18226C19O18233C20O18246C21O18250C24O18254C31O18277C36O18293C38O18292C44O18312C49O18394C54O18401C58O18427C59O18450C61O18462C65O18469C72O18485C77O18506C80O18517C87O18535C90O18532C93O18504C97O18548C104O18564C109O18583C112O18594C119O18612C122O18621C125O18609C128O18581C132O18629C137O18655C142O18655C146O18664C153O18682C158O18696C162O18708C163O18722C166O18726,,
code-creation,LazyCompile,10,166042,0xa12169d1126,13,enabledHooksExist node:internal/async_hooks:475:27,0x2b48e0c77d78,~
code-source-info,0xa12169d1126,13,16135,16168,C0O16142C5O16158C8O16149C12O16166,,
code-creation,LazyCompile,10,166042,0xa12169d1286,34, /Users/vignesh/Projects/HTTP2/lib/server.js:178:54,0x1208b73c008,~
code-source-info,0xa12169d1286,151,5842,5943,C0O5850C4O5858C18O5928C22O5920C26O5858C33O5942,,
code-creation,LazyCompile,10,166084,0xa12169d13a6,46,afterWriteTick node:internal/streams/writable:483:24,0xd2efcc08390,~
code-source-info,0xa12169d13a6,64,15073,15189,C0O15076C5O15084C10O15091C15O15098C20O15108C21O15133C25O15143C40O15150C45O15187,,
code-creation,LazyCompile,10,166125,0xa12169d14fe,104,afterWrite node:internal/streams/writable:488:20,0xd2efcc083e0,~
code-source-info,0xa12169d14fe,64,15210,15566,C0O15266C7O15284C14O15303C20O15310C25O15329C30O15342C32O15363C33O15379C37O15399C45O15399C50O15436C60O15436C65O15447C71O15462C75O15470C78O15421C81O15493C87O15510C90O15510C94O15537C97O15537C103O15565,,
code-creation,LazyCompile,10,166125,0xa12169d168e,35,get node:internal/streams/duplex:102:8,0x174551ee8d30,~
code-source-info,0xa12169d168e,56,3577,3786,C0O3597C6O3642C12O3682C13O3695C14O3722C19O3737C25O3755C30O3770C34O3780,,
code-creation,LazyCompile,10,166167,0xa12169d17ce,87, node:internal/console/constructor:339:10,0x815de61dff0,~
code-source-info,0xa12169d17ce,37,10154,10972,C0O10371C7O10388C9O10384C17O10416C26O10435C31O10448C35O10476C40O10491C46O10887C54O10887C61O10910C66O10934C79O10934C86O10971,,
code-creation,LazyCompile,10,166209,0xa12169d1926,85,finishMaybe node:internal/streams/writable:732:21,0xd2efcc086b8,~
code-source-info,0xa12169d1926,64,21361,21653,C0O21387C3O21391C9O21416C12O21416C17O21456C23O21466C31O21475C37O21502C43O21517C47O21527C51O21547C54O21555C68O21555C75O21611C78O21611C84O21652,,
tick,0x1bfd3cab0,166209,0,0x0,3,0x0,0xa12169d155f,0xa12169d13ce,0xa12169d0059
code-creation,LazyCompile,10,166209,0xa12169d1ab6,73,needFinish node:internal/streams/writable:651:20,0xd2efcc085c8,~
code-source-info,0xa12169d1ab6,64,19376,19667,C0O19402C6O19428C12O19459C18O19466C23O19492C30O19519C35O19528C41O19535C46O19561C53O19590C60O19618C67O19651C72O19665,,
code-creation,LazyCompile,10,166292,0xa12169d1db6,627,processPromiseRejections node:internal/process/promises:211:34,0x815de612ef8,~
script-source,33,node:internal/process/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  Error\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeWeakMap\x2C\n} = primordials;\n\nconst {\n  tickInfo\x2C\n  promiseRejectEvents: {\n    kPromiseRejectWithNoHandler\x2C\n    kPromiseHandlerAddedAfterReject\x2C\n    kPromiseResolveAfterResolved\x2C\n    kPromiseRejectAfterResolved\n  }\x2C\n  setPromiseRejectCallback\n} = internalBinding('task_queue');\n\nconst {\n  noSideEffectsToString\x2C\n  triggerUncaughtException\n} = internalBinding('errors');\n\nconst {\n  pushAsyncContext\x2C\n  popAsyncContext\x2C\n  symbols: {\n    async_id_symbol: kAsyncIdSymbol\x2C\n    trigger_async_id_symbol: kTriggerAsyncIdSymbol\n  }\n} = require('internal/async_hooks');\nconst { isErrorStackTraceLimitWritable } = require('internal/errors');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasRejectionToWarn = 1;\n\nconst maybeUnhandledPromises = new SafeWeakMap();\nconst pendingUnhandledRejections = [];\nconst asyncHandledRejections = [];\nlet lastPromiseId = 0;\n\n// --unhandled-rejections=none:\n// Emit 'unhandledRejection'\x2C but do not emit any warning.\nconst kIgnoreUnhandledRejections = 0;\n\n// --unhandled-rejections=warn:\n// Emit 'unhandledRejection'\x2C then emit 'UnhandledPromiseRejectionWarning'.\nconst kAlwaysWarnUnhandledRejections = 1;\n\n// --unhandled-rejections=strict:\n// Emit 'uncaughtException'. If it's not handled\x2C print the error to stderr\n// and exit the process.\n// Otherwise\x2C emit 'unhandledRejection'. If 'unhandledRejection' is not\n// handled\x2C emit 'UnhandledPromiseRejectionWarning'.\nconst kStrictUnhandledRejections = 2;\n\n// --unhandled-rejections=throw:\n// Emit 'unhandledRejection'\x2C if it's unhandled\x2C emit\n// 'uncaughtException'. If it's not handled\x2C print the error to stderr\n// and exit the process.\nconst kThrowUnhandledRejections = 3;\n\n// --unhandled-rejections=warn-with-error-code:\n// Emit 'unhandledRejection'\x2C if it's unhandled\x2C emit\n// 'UnhandledPromiseRejectionWarning'\x2C then set process exit code to 1.\n\nconst kWarnWithErrorCodeUnhandledRejections = 4;\n\nlet unhandledRejectionsMode;\n\nfunction setHasRejectionToWarn(value) {\n  tickInfo[kHasRejectionToWarn] = value ? 1 : 0;\n}\n\nfunction hasRejectionToWarn() {\n  return tickInfo[kHasRejectionToWarn] === 1;\n}\n\nfunction isErrorLike(o) {\n  return typeof o === 'object' &&\n         o !== null &&\n         ObjectPrototypeHasOwnProperty(o\x2C 'stack');\n}\n\nfunction getUnhandledRejectionsMode() {\n  const { getOptionValue } = require('internal/options');\n  switch (getOptionValue('--unhandled-rejections')) {\n    case 'none':\n      return kIgnoreUnhandledRejections;\n    case 'warn':\n      return kAlwaysWarnUnhandledRejections;\n    case 'strict':\n      return kStrictUnhandledRejections;\n    case 'throw':\n      return kThrowUnhandledRejections;\n    case 'warn-with-error-code':\n      return kWarnWithErrorCodeUnhandledRejections;\n    default:\n      return kThrowUnhandledRejections;\n  }\n}\n\nfunction promiseRejectHandler(type\x2C promise\x2C reason) {\n  if (unhandledRejectionsMode === undefined) {\n    unhandledRejectionsMode = getUnhandledRejectionsMode();\n  }\n  switch (type) {\n    case kPromiseRejectWithNoHandler:\n      unhandledRejection(promise\x2C reason);\n      break;\n    case kPromiseHandlerAddedAfterReject:\n      handledRejection(promise);\n      break;\n    case kPromiseResolveAfterResolved:\n      resolveError('resolve'\x2C promise\x2C reason);\n      break;\n    case kPromiseRejectAfterResolved:\n      resolveError('reject'\x2C promise\x2C reason);\n      break;\n  }\n}\n\nfunction resolveError(type\x2C promise\x2C reason) {\n  // We have to wrap this in a next tick. Otherwise the error could be caught by\n  // the executed promise.\n  process.nextTick(() => {\n    process.emit('multipleResolves'\x2C type\x2C promise\x2C reason);\n  });\n}\n\nfunction unhandledRejection(promise\x2C reason) {\n  const emit = (reason\x2C promise\x2C promiseInfo) => {\n    if (promiseInfo.domain) {\n      return promiseInfo.domain.emit('error'\x2C reason);\n    }\n    return process.emit('unhandledRejection'\x2C reason\x2C promise);\n  };\n\n  maybeUnhandledPromises.set(promise\x2C {\n    reason\x2C\n    uid: ++lastPromiseId\x2C\n    warned: false\x2C\n    domain: process.domain\x2C\n    emit\n  });\n  // This causes the promise to be referenced at least for one tick.\n  ArrayPrototypePush(pendingUnhandledRejections\x2C promise);\n  setHasRejectionToWarn(true);\n}\n\nfunction handledRejection(promise) {\n  const promiseInfo = maybeUnhandledPromises.get(promise);\n  if (promiseInfo !== undefined) {\n    maybeUnhandledPromises.delete(promise);\n    if (promiseInfo.warned) {\n      const { uid } = promiseInfo;\n      // Generate the warning object early to get a good stack trace.\n      // eslint-disable-next-line no-restricted-syntax\n      const warning = new Error('Promise rejection was handled ' +\n                                `asynchronously (rejection id: ${uid})`);\n      warning.name = 'PromiseRejectionHandledWarning';\n      warning.id = uid;\n      ArrayPrototypePush(asyncHandledRejections\x2C { promise\x2C warning });\n      setHasRejectionToWarn(true);\n      return;\n    }\n  }\n  if (maybeUnhandledPromises.size === 0 && asyncHandledRejections.length === 0)\n    setHasRejectionToWarn(false);\n}\n\nconst unhandledRejectionErrName = 'UnhandledPromiseRejectionWarning';\nfunction emitUnhandledRejectionWarning(uid\x2C reason) {\n  const warning = getErrorWithoutStack(\n    unhandledRejectionErrName\x2C\n    'Unhandled promise rejection. This error originated either by ' +\n      'throwing inside of an async function without a catch block\x2C ' +\n      'or by rejecting a promise which was not handled with .catch(). ' +\n      'To terminate the node process on unhandled promise ' +\n      'rejection\x2C use the CLI flag `--unhandled-rejections=strict` (see ' +\n      'https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). ' +\n      `(rejection id: ${uid})`\n  );\n  try {\n    if (isErrorLike(reason)) {\n      warning.stack = reason.stack;\n      process.emitWarning(reason.stack\x2C unhandledRejectionErrName);\n    } else {\n      process.emitWarning(\n        noSideEffectsToString(reason)\x2C unhandledRejectionErrName);\n    }\n  } catch {\n    try {\n      process.emitWarning(\n        noSideEffectsToString(reason)\x2C unhandledRejectionErrName);\n    } catch {\n      // Ignore.\n    }\n  }\n\n  process.emitWarning(warning);\n}\n\n// If this method returns true\x2C we've executed user code or triggered\n// a warning to be emitted which requires the microtask and next tick\n// queues to be drained again.\nfunction processPromiseRejections() {\n  let maybeScheduledTicksOrMicrotasks = asyncHandledRejections.length > 0;\n\n  while (asyncHandledRejections.length > 0) {\n    const { promise\x2C warning } = ArrayPrototypeShift(asyncHandledRejections);\n    if (!process.emit('rejectionHandled'\x2C promise)) {\n      process.emitWarning(warning);\n    }\n  }\n\n  let len = pendingUnhandledRejections.length;\n  while (len--) {\n    const promise = ArrayPrototypeShift(pendingUnhandledRejections);\n    const promiseInfo = maybeUnhandledPromises.get(promise);\n    if (promiseInfo === undefined) {\n      continue;\n    }\n    promiseInfo.warned = true;\n    const { reason\x2C uid\x2C emit } = promiseInfo;\n\n    let needPop = true;\n    const {\n      [kAsyncIdSymbol]: promiseAsyncId\x2C\n      [kTriggerAsyncIdSymbol]: promiseTriggerAsyncId\x2C\n    } = promise;\n    // We need to check if async_hooks are enabled\n    // don't use enabledHooksExist as a Promise could\n    // come from a vm.* context and not have an async id\n    if (typeof promiseAsyncId !== 'undefined') {\n      pushAsyncContext(\n        promiseAsyncId\x2C\n        promiseTriggerAsyncId\x2C\n        promise\n      );\n    }\n    try {\n      switch (unhandledRejectionsMode) {\n        case kStrictUnhandledRejections: {\n          const err = isErrorLike(reason) ?\n            reason : generateUnhandledRejectionError(reason);\n          // This destroys the async stack\x2C don't clear it after\n          triggerUncaughtException(err\x2C true /* fromPromise */);\n          if (typeof promiseAsyncId !== 'undefined') {\n            pushAsyncContext(\n              promise[kAsyncIdSymbol]\x2C\n              promise[kTriggerAsyncIdSymbol]\x2C\n              promise\n            );\n          }\n          const handled = emit(reason\x2C promise\x2C promiseInfo);\n          if (!handled) emitUnhandledRejectionWarning(uid\x2C reason);\n          break;\n        }\n        case kIgnoreUnhandledRejections: {\n          emit(reason\x2C promise\x2C promiseInfo);\n          break;\n        }\n        case kAlwaysWarnUnhandledRejections: {\n          emit(reason\x2C promise\x2C promiseInfo);\n          emitUnhandledRejectionWarning(uid\x2C reason);\n          break;\n        }\n        case kThrowUnhandledRejections: {\n          const handled = emit(reason\x2C promise\x2C promiseInfo);\n          if (!handled) {\n            const err = isErrorLike(reason) ?\n              reason : generateUnhandledRejectionError(reason);\n              // This destroys the async stack\x2C don't clear it after\n            triggerUncaughtException(err\x2C true /* fromPromise */);\n            needPop = false;\n          }\n          break;\n        }\n        case kWarnWithErrorCodeUnhandledRejections: {\n          const handled = emit(reason\x2C promise\x2C promiseInfo);\n          if (!handled) {\n            emitUnhandledRejectionWarning(uid\x2C reason);\n            process.exitCode = 1;\n          }\n          break;\n        }\n      }\n    } finally {\n      if (needPop) {\n        if (typeof promiseAsyncId !== 'undefined') {\n          popAsyncContext(promiseAsyncId);\n        }\n      }\n    }\n    maybeScheduledTicksOrMicrotasks = true;\n  }\n  return maybeScheduledTicksOrMicrotasks ||\n         pendingUnhandledRejections.length !== 0;\n}\n\nfunction getErrorWithoutStack(name\x2C message) {\n  // Reset the stack to prevent any overhead.\n  const tmp = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmp;\n  ObjectDefineProperty(err\x2C 'name'\x2C {\n    value: name\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: true\x2C\n  });\n  return err;\n}\n\nfunction generateUnhandledRejectionError(reason) {\n  const message =\n    'This error originated either by ' +\n    'throwing inside of an async function without a catch block\x2C ' +\n    'or by rejecting a promise which was not handled with .catch().' +\n    ' The promise rejected with the reason ' +\n    `"${noSideEffectsToString(reason)}".`;\n\n  const err = getErrorWithoutStack('UnhandledPromiseRejection'\x2C message);\n  err.code = 'ERR_UNHANDLED_REJECTION';\n  return err;\n}\n\nfunction listenForRejections() {\n  setPromiseRejectCallback(promiseRejectHandler);\n}\nmodule.exports = {\n  hasRejectionToWarn\x2C\n  setHasRejectionToWarn\x2C\n  listenForRejections\x2C\n  processPromiseRejections\x2C\n};\n
code-source-info,0xa12169d1db6,33,6440,9566,C0O6485C6O6508C13O6515C17O6560C23O6553C30O6560C35O6600C43O6620C47O6600C53O6579C58O6588C64O6649C68O6662C78O6662C86O6705C90O6713C96O6713C101O6523C104O6758C110O6785C115O6805C126O6805C128O6831C136O6851C140O6831C145O6904C151O6927C157O6927C163O6945C165O6984C167O7004C168O7023C172O7043C177O7051C182O7056C187O7097C189O7217C198O7113C203O7139C215O7186C227O7392C233O7443C248O7443C256O7563C264O7611C273O8266C282O8382C291O8556C300O9000C309O7663C313O7663C327O7706C332O7822C341O7822C346O7887C352O7944C360O7984C362O7983C369O8023C371O8022C379O7944C384O8122C393O8122C399O8168C401O8182C405O8182C410O8236C412O8306C421O8306C426O8352C428O8426C437O8426C442O8472C446O8472C451O8526C453O8611C462O8611C468O8657C470O8697C474O8697C488O8742C493O8864C502O8864C507O8931C509O8970C511O9067C520O9067C526O9113C528O9141C532O9141C537O9197C543O9214C547O9241C564O9288C570O9311C576O9366C582O9366C597O9427C599O6795C605O9473C611O9524C615O9551C622O9558C626O9564,,
code-creation,LazyCompile,10,166750,0xa12169d2d0e,25,setHasRejectionToWarn node:internal/process/promises:75:31,0x815de612468,~
code-source-info,0xa12169d2d0e,33,2095,2155,C0O2107C7O2116C12O2139C19O2137C24O2154,,
code-creation,LazyCompile,10,166750,0xa12169d2dfe,25, node:fs:188:10,0xa12169cb658,~
code-source-info,0xa12169d2dfe,81,4854,4895,C0O4854C3O4867C19O4867C24O4895,,
code-creation,LazyCompile,10,166792,0xa12169d2f66,72, /Users/vignesh/Projects/HTTP2/lib/data.js:107:43,0xa12169cb168,~
code-source-info,0xa12169d2f66,189,2743,3027,C0O2743C5O2759C11O2770C13O2783C19O2790C24O2825C26O2825C28O2840C38O2840C43O2945C53O2945C60O2998C65O2998C71O3026,,
code-creation,LazyCompile,10,166792,0xa12169d30e6,33, /Users/vignesh/Projects/HTTP2/lib/data.js:110:28,0xa12169d2eb0,~
code-source-info,0xa12169d30e6,189,2856,2936,C0O2876C3O2893C8O2907C19O2907C26O2893C32O2935,,
code-creation,LazyCompile,10,166834,0xa12169d328e,48, /Users/vignesh/Projects/HTTP2/lib/workers.js:24:31,0xa12169cafd0,~
code-source-info,0xa12169d328e,195,560,1179,C0O578C6O589C8O606C14O613C19O632C29O632C36O1116C42O1116C47O1178,,
code-creation,LazyCompile,10,166834,0xa12169d342e,26, /Users/vignesh/Projects/HTTP2/lib/workers.js:26:30,0xa12169d31d0,~
code-source-info,0xa12169d342e,195,648,1094,C0O699C3O705C11O719C19O705C25O1093,,
code-creation,LazyCompile,10,166875,0xa12169d35de,68,lib.read /Users/vignesh/Projects/HTTP2/lib/data.js:47:20,0x2811abd2c610,~
code-source-info,0xa12169d35de,189,1131,1392,C0O1131C9O1154C14O1157C24O1170C31O1177C37O1181C43O1185C49O1190C61O1157C67O1391,,
code-creation,LazyCompile,10,166917,0xa12169d389e,264,readFile node:fs:373:18,0xd2efcc347a0,~
code-source-info,0xa12169d389e,81,9464,10336,C0O9464C9O9494C16O9519C21O9505C27O9543C34O9564C39O9553C46O9607C53O9645C63O9607C69O9658C73O9677C79O9677C83O9675C87O9733C93O9772C97O9762C101O9798C107O9814C112O9822C122O9822C128O9943C129O9950C130O9958C135O9983C140O9962C147O10006C148O10013C149O10037C156O10059C164O10037C170O10084C180O10091C184O10089C186O10130C193O10130C199O10153C201O10165C205O10178C209O10193C213O10216C220O10224C229O10229C232O10240C240O10240C257O10224C263O10335,,
code-creation,LazyCompile,10,166917,0xa12169d3b26,12,maybeCallback node:fs:176:23,0xd2efcc34350,~
code-source-info,0xa12169d3b26,81,4543,4589,C0O4552C5O4552C9O4577C11O4587,,
code-creation,LazyCompile,10,166959,0xa12169d3c7e,54,ReadFileContext node:internal/fs/read_file_context:72:14,0x3beccac59e8,~
script-source,85,node:internal/fs/read_file_context,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  MathMin\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst {\n  constants: {\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n  }\n} = require('internal/fs/utils');\n\nconst { Buffer } = require('buffer');\n\nconst { FSReqCallback\x2C close\x2C read } = internalBinding('fs');\n\nconst {\n  AbortError\x2C\n  aggregateTwoErrors\x2C\n} = require('internal/errors');\n\nfunction readFileAfterRead(err\x2C bytesRead) {\n  const context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  context.pos += bytesRead;\n\n  if (context.pos === context.size || bytesRead === 0) {\n    context.close();\n  } else {\n    if (context.size === 0) {\n      // Unknown size\x2C just read until we don't get bytes.\n      const buffer = bytesRead === kReadFileUnknownBufferLength ?\n        context.buffer : context.buffer.slice(0\x2C bytesRead);\n      ArrayPrototypePush(context.buffers\x2C buffer);\n    }\n    context.read();\n  }\n}\n\nfunction readFileAfterClose(err) {\n  const context = this.context;\n  const callback = context.callback;\n  let buffer = null;\n\n  if (context.err || err)\n    return callback(aggregateTwoErrors(err\x2C context.err));\n\n  try {\n    if (context.size === 0)\n      buffer = Buffer.concat(context.buffers\x2C context.pos);\n    else if (context.pos < context.size)\n      buffer = context.buffer.slice(0\x2C context.pos);\n    else\n      buffer = context.buffer;\n\n    if (context.encoding)\n      buffer = buffer.toString(context.encoding);\n  } catch (err) {\n    return callback(err);\n  }\n\n  callback(null\x2C buffer);\n}\n\nclass ReadFileContext {\n  constructor(callback\x2C encoding) {\n    this.fd = undefined;\n    this.isUserFd = undefined;\n    this.size = 0;\n    this.callback = callback;\n    this.buffers = null;\n    this.buffer = null;\n    this.pos = 0;\n    this.encoding = encoding;\n    this.err = null;\n    this.signal = undefined;\n  }\n\n  read() {\n    let buffer;\n    let offset;\n    let length;\n\n    if (this.signal?.aborted) {\n      return this.close(\n        new AbortError(undefined\x2C { cause: this.signal?.reason }));\n    }\n    if (this.size === 0) {\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\n      offset = 0;\n      length = kReadFileUnknownBufferLength;\n      this.buffer = buffer;\n    } else {\n      buffer = this.buffer;\n      offset = this.pos;\n      length = MathMin(kReadFileBufferLength\x2C this.size - this.pos);\n    }\n\n    const req = new FSReqCallback();\n    req.oncomplete = readFileAfterRead;\n    req.context = this;\n\n    read(this.fd\x2C buffer\x2C offset\x2C length\x2C -1\x2C req);\n  }\n\n  close(err) {\n    if (this.isUserFd) {\n      process.nextTick(function tick(context) {\n        ReflectApply(readFileAfterClose\x2C { context }\x2C [null]);\n      }\x2C this);\n      return;\n    }\n\n    const req = new FSReqCallback();\n    req.oncomplete = readFileAfterClose;\n    req.context = this;\n    this.err = err;\n\n    close(this.fd\x2C req);\n  }\n}\n\nmodule.exports = ReadFileContext;\n
code-source-info,0xa12169d3c7e,85,1565,1843,C0O1592C1O1600C5O1617C6O1631C10O1648C11O1658C15O1667C17O1681C21O1697C22O1710C26O1722C27O1734C31O1746C32O1755C36O1764C38O1778C42O1794C43O1803C47O1815C48O1827C53O1842,,
code-creation,LazyCompile,10,167084,0xa12169d4266,65,checkAborted node:fs:351:22,0xd2efcc34750,~
code-source-info,0xa12169d4266,81,8962,9114,C0O8985C7O8995C16O9012C18O9025C23O9036C38O9062C51O9021C57O9012C61O9080C62O9092C63O9099C64O9112,,
code-creation,Function,11,167125,0x10511e3c0,496,assertEncoding node:internal/fs/utils:152:24,0xd2efcc3e798,^
code-source-info,0x10511e3c0,82,3561,3738,,,
code-creation,Function,11,167167,0x10511e620,408,hideStackFrames node:internal/errors:383:25,0x2b48e0c65510,^
code-source-info,0x10511e620,11,10671,10895,,,
code-creation,Function,11,167167,0x10511e820,352, node:internal/validators:236:42,0x2b48e0c7c480,^
code-source-info,0x10511e820,15,7226,7342,,,
code-creation,Function,11,167209,0x10511e9e0,2088,Module.load node:internal/modules/cjs/loader:963:33,0x3172a1b2b3e8,^
code-source-info,0x10511e9e0,103,30014,30827,,,
code-creation,Function,11,167209,0x10511f280,160,get node:net:1753:6,0x120d44383db0,^
code-source-info,0x10511f280,113,46980,47008,,,
code-creation,Function,11,167209,0x10511f380,184,hasHooks node:internal/async_hooks:471:18,0x2b48e0c77d28,^
code-source-info,0x10511f380,13,16061,16107,,,
code-creation,LazyCompile,10,167250,0xa12169d47e6,72, /Users/vignesh/Projects/HTTP2/lib/logs.js:44:35,0xa12169cf718,~
code-source-info,0xa12169d47e6,196,1183,1729,C0O1183C5O1199C11O1210C13O1223C19O1230C24O1265C26O1265C28O1280C38O1280C43O1647C53O1647C60O1700C65O1700C71O1728,,
code-creation,LazyCompile,10,167292,0xa12169d49a6,112, /Users/vignesh/Projects/HTTP2/lib/logs.js:47:28,0xa12169d4730,~
code-source-info,0xa12169d49a6,196,1296,1638,C0O1359C8O1359C16O1375C21O1392C24O1409C29O1423C40O1423C47O1409C52O1504C60O1504C68O1523C77O1531C79O1565C82O1582C87O1596C98O1596C105O1582C111O1637,,
code-creation,LazyCompile,10,167292,0xa12169d4bbe,48, /Users/vignesh/Projects/HTTP2/lib/workers.js:220:28,0xa12169cf578,~
code-source-info,0xa12169d4bbe,195,8617,9386,C0O8633C6O8644C8O8657C14O8664C19O8681C29O8681C36O9326C42O9326C47O9385,,
code-creation,LazyCompile,10,167334,0xa12169d4da6,78, /Users/vignesh/Projects/HTTP2/lib/workers.js:222:28,0xa12169d4b00,~
code-source-info,0xa12169d4da6,195,8697,9304,C0O8697C5O8785C16O8785C22O8777C24O8829C29O8834C33O8839C37O8844C42O8844C46O8838C50O8859C55O8865C63O8880C71O8865C77O9303,,
new,MemoryChunk,0x191a590c0000,278528
code-creation,LazyCompile,10,167375,0xa12169d4fe6,63,lib.compress /Users/vignesh/Projects/HTTP2/lib/logs.js:68:24,0x1208b712328,~
code-source-info,0xa12169d4fe6,196,1847,3082,C0O1847C9O1894C11O1899C15O1925C17O1934C20O1925C22O1975C27O1978C37O1991C44O1998C56O1978C62O3081,,
scavenge,begin,0,165578,1648733370802
new,MemoryChunk,0x1f3f48300000,262144
tick,0x100669f14,167459,0,0x0,1
new,MemoryChunk,0x1e1035040000,262144
new,MemoryChunk,0x155376280000,262144
new,MemoryChunk,0xb4baa00000,262144
scavenge,end,0,166073,1648733370803
code-creation,LazyCompile,10,167792,0xa12169d51f6,75,readFileAfterOpen node:fs:310:27,0xd2efcc346b0,~
code-source-info,0xa12169d51f6,81,8182,8436,C0O8217C5O8229C9O8252C14O8252C19O8271C20O8278C21O8286C23O8297C27O8318C32O8318C38O8341C40O8356C44O8379C46O8391C50O8404C55O8412C68O8412C74O8435,,
code-creation,LazyCompile,10,167875,0xa12169d53fe,162,readFileAfterStat node:fs:326:27,0xd2efcc34700,~
code-source-info,0xa12169d53fe,81,8464,8939,C0O8502C5O8514C9O8542C14O8542C19O8553C20O8570C25O8603C28O8585C40O8619C47O8583C54O8631C56O8642C58O8640C63O8662C70O8668C77O8720C82O8720C87O8731C91O8749C92O8758C97O8773C99O8789C105O8814C107O8831C110O8838C115O8838C120O8829C137O8904C145O8904C150O8915C151O8930C156O8930C161O8938,,
code-creation,LazyCompile,10,167917,0xa12169d55ce,19,allocUnsafeSlow node:buffer:383:50,0x232faba31eb8,~
code-source-info,0xa12169d55ce,24,11225,11290,C0O11236C5O11236C9O11256C14O11263C18O11288,,
code-creation,LazyCompile,10,167959,0xa12169d5786,215,read node:internal/fs/read_file_context:85:7,0x3beccac5a38,~
code-source-info,0xa12169d5786,85,1851,2522,C0O1864C2O1880C4O1896C6O1918C13O1924C22O1955C29O1974C34O1985C39O2010C49O2016C62O1970C68O1955C73O2029C74O2049C80O2054C85O2069C90O2085C97O2101C100O2085C106O2138C108O2156C113O2201C115O2213C121O2256C126O2284C131O2295C138O2312C141O2340C146O2352C150O2345C154O2304C160O2381C165O2381C171O2406C173O2421C177O2446C179O2458C183O2471C188O2481C208O2471C214O2521,,
code-creation,LazyCompile,10,168042,0xa12169d5a4e,136,readFileAfterRead node:internal/fs/read_file_context:25:27,0x3beccac5778,~
code-source-info,0xa12169d5a4e,85,418,929,C0O460C5O472C9O500C14O500C19O511C20O515C27O530C30O527C34O556C39O572C43O560C49O590C54O611C59O611C65O647C71O652C76O741C78O755C80O751C85O802C91O819C96O826C103O826C110O853C115O880C120O853C125O916C130O916C135O928,,
code-creation,LazyCompile,10,168042,0xa12169d5c8e,73,close node:internal/fs/read_file_context:112:8,0x3beccac5a88,~
code-source-info,0xa12169d5c8e,85,2531,2863,C0O2552C6O2570C9O2578C19O2578C25O2697C26O2704C27O2728C32O2728C38O2753C40O2768C44O2794C46O2806C50O2818C52O2827C56O2839C61O2850C66O2839C72O2862,,
code-creation,LazyCompile,10,168125,0xa12169d5ec6,183,readFileAfterClose node:internal/fs/read_file_context:46:28,0x3beccac5998,~
code-source-info,0xa12169d5ec6,85,958,1526,C0O989C5O1025C10O1050C12O1071C20O1078C22O1087C24O1103C27O1135C32O1103C38O1094C42O1141C46O1167C52O1172C57O1185C62O1201C67O1216C72O1233C77O1201C86O1260C91O1274C95O1264C100O1303C105O1310C112O1327C117O1310C126O1365C131O1390C137O1422C142O1439C147O1422C156O1413C166O1472C169O1479C173O1493C174O1501C176O1501C182O1525,,
code-creation,LazyCompile,10,168167,0xa12169d60b6,46, /Users/vignesh/Projects/HTTP2/lib/data.js:48:65,0xa12169d3510,~
code-source-info,0xa12169d60b6,189,1216,1388,C0O1232C6O1243C8O1273C13O1281C18O1281C24O1312C29O1312C36O1359C39O1359C45O1387,,
code-creation,LazyCompile,10,168167,0xa12169d622e,32,helpers.parseJsonToObject /Users/vignesh/Projects/HTTP2/lib/helpers.js:23:37,0x2811abd2e110,~
code-source-info,0xa12169d622e,190,502,597,C3O530C7O535C12O535C18O562C30O581C31O591,,
code-creation,LazyCompile,10,168209,0xa12169d646e,36, /Users/vignesh/Projects/HTTP2/lib/workers.js:28:43,0xa12169d3380,~
code-source-info,0xa12169d646e,195,733,1084,C0O768C6O779C8O932C11O940C16O940C23O1009C29O1009C35O1083,,
code-creation,LazyCompile,10,168250,0xa12169d6726,557,workers.validateCheckData /Users/vignesh/Projects/HTTP2/lib/workers.js:44:37,0x1208b70fcd0,~
code-source-info,0xa12169d6726,195,1254,3622,C0O1277C14O1367C17O1441C28O1478C33O1481C38O1481C43O1487C50O1495C55O1521C60O1524C65O1524C72O1414C76O1597C87O1641C92O1651C97O1651C102O1657C109O1665C114O1691C119O1701C124O1701C131O1570C135O1773C146O1783C151O1815C156O1841C161O1815C169O1851C174O1876C181O1746C185O1945C196O1983C201O1987C206O1987C211O1993C217O2001C222O2025C227O2029C232O2029C239O1918C243O2099C254O2107C259O2153C264O2179C269O2153C277O2187C282O2212C289O2072C293O2288C304O2335C309O2359C312O2348C317O2386C322O2399C328O2406C333O2430C340O2261C344O2514C355O2563C359O2578C364O2582C369O2609C376O2624C381O2650C388O2665C393O2690C400O2487C404O2856C415O2863C420O2892C425O2918C430O2892C438O2925C443O2950C451O2829C455O3025C466O3071C472O3083C477O3107C484O2998C488O3229C494O3255C500O3288C506O3320C512O3347C518O3377C524O3413C530O3434C533O3442C538O3442C545O3545C551O3545C556O3621,,
code-creation,LazyCompile,10,168292,0xa12169d6de6,239,workers.performCheck /Users/vignesh/Projects/HTTP2/lib/workers.js:73:32,0x1208b70fd60,~
code-source-info,0xa12169d6de6,195,3775,5730,C0O3775C9O3856C13O3856C15O3981C16O3981C18O4069C23O4073C31O4097C38O4105C45O4130C49O4111C55O4073C62O4169C67O4202C72O4319C80O4356C87O4364C96O4387C103O4430C108O4437C113O4437C123O4465C130O4505C134O4520C147O4630C150O4648C157O4657C173O4708C178O4716C183O4708C190O5123C203O5123C209O5423C222O5423C228O5722C233O5722C238O5729,,
code-creation,LazyCompile,10,168375,0xa12169d70f6,44,urlParse node:url:153:18,0x3beccad88a8,~
script-source,90,node:url,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Int8Array\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  SafeSet\x2C\n  StringPrototypeCharCodeAt\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { toASCII } = require('internal/idna');\nconst { encodeStr\x2C hexTable } = require('internal/querystring');\nconst querystring = require('querystring');\n\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_URL\x2C\n} = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n// This ensures setURLConstructor() is called before the native\n// URL::ToObject() method is used.\nconst { spliceOne } = require('internal/util');\n\n// WHATWG URL implementation provided by internal/url\nconst {\n  URL\x2C\n  URLSearchParams\x2C\n  domainToASCII\x2C\n  domainToUnicode\x2C\n  fileURLToPath\x2C\n  formatSymbol\x2C\n  pathToFileURL\x2C\n  urlToHttpOptions\x2C\n} = require('internal/url');\n\n// Original url.parse() API\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986\x2C RFC 1808\x2C RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nconst protocolPattern = /^[a-z0-9.+-]+:/i;\nconst portPattern = /:[0-9]*$/;\nconst hostPattern = /^\\/\\/[^@/]+@[^@/]+/;\n\n// Special case for a simple path URL\nconst simplePathPattern = /^(\\/\\/?(?!\\/)[^?\\s]*)(\\?[^\\s]*)?$/;\n\nconst hostnameMaxLen = 255;\n// Protocols that can allow "unsafe" and "unwise" chars.\nconst unsafeProtocol = new SafeSet([\n  'javascript'\x2C\n  'javascript:'\x2C\n]);\n// Protocols that never have a hostname.\nconst hostlessProtocol = new SafeSet([\n  'javascript'\x2C\n  'javascript:'\x2C\n]);\n// Protocols that always contain a // bit.\nconst slashedProtocol = new SafeSet([\n  'http'\x2C\n  'http:'\x2C\n  'https'\x2C\n  'https:'\x2C\n  'ftp'\x2C\n  'ftp:'\x2C\n  'gopher'\x2C\n  'gopher:'\x2C\n  'file'\x2C\n  'file:'\x2C\n  'ws'\x2C\n  'ws:'\x2C\n  'wss'\x2C\n  'wss:'\x2C\n]);\nconst {\n  CHAR_SPACE\x2C\n  CHAR_TAB\x2C\n  CHAR_CARRIAGE_RETURN\x2C\n  CHAR_LINE_FEED\x2C\n  CHAR_FORM_FEED\x2C\n  CHAR_NO_BREAK_SPACE\x2C\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\x2C\n  CHAR_HASH\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_LEFT_SQUARE_BRACKET\x2C\n  CHAR_RIGHT_SQUARE_BRACKET\x2C\n  CHAR_LEFT_ANGLE_BRACKET\x2C\n  CHAR_RIGHT_ANGLE_BRACKET\x2C\n  CHAR_LEFT_CURLY_BRACKET\x2C\n  CHAR_RIGHT_CURLY_BRACKET\x2C\n  CHAR_QUESTION_MARK\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_UPPERCASE_A\x2C\n  CHAR_UPPERCASE_Z\x2C\n  CHAR_DOT\x2C\n  CHAR_0\x2C\n  CHAR_9\x2C\n  CHAR_HYPHEN_MINUS\x2C\n  CHAR_PLUS\x2C\n  CHAR_UNDERSCORE\x2C\n  CHAR_DOUBLE_QUOTE\x2C\n  CHAR_SINGLE_QUOTE\x2C\n  CHAR_PERCENT\x2C\n  CHAR_SEMICOLON\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_CIRCUMFLEX_ACCENT\x2C\n  CHAR_GRAVE_ACCENT\x2C\n  CHAR_VERTICAL_LINE\x2C\n  CHAR_AT\x2C\n} = require('internal/constants');\n\nfunction urlParse(url\x2C parseQueryString\x2C slashesDenoteHost) {\n  if (url instanceof Url) return url;\n\n  const urlObject = new Url();\n  urlObject.parse(url\x2C parseQueryString\x2C slashesDenoteHost);\n  return urlObject;\n}\n\nfunction isIpv6Hostname(hostname) {\n  return (\n    StringPrototypeCharCodeAt(hostname\x2C 0) === CHAR_LEFT_SQUARE_BRACKET &&\n    StringPrototypeCharCodeAt(hostname\x2C hostname.length - 1) ===\n    CHAR_RIGHT_SQUARE_BRACKET\n  );\n}\n\n// This prevents some common spoofing bugs due to our use of IDNA toASCII. For\n// compatibility\x2C the set of characters we use here is the *intersection* of\n// "forbidden host code point" in the WHATWG URL Standard [1] and the\n// characters in the host parsing loop in Url.prototype.parse\x2C with the\n// following additions:\n//\n// - ':' since this could cause a "protocol spoofing" bug\n// - '@' since this could cause parts of the hostname to be confused with auth\n// - '[' and ']' since this could cause a non-IPv6 hostname to be interpreted\n//   as IPv6 by isIpv6Hostname above\n//\n// [1]: https://url.spec.whatwg.org/#forbidden-host-code-point\nconst forbiddenHostChars = /[\\t\\n\\r #%/:<>?@[\\\\\\]^|]/;\n\nUrl.prototype.parse = function parse(url\x2C parseQueryString\x2C slashesDenoteHost) {\n  validateString(url\x2C 'url');\n\n  // Copy chrome\x2C IE\x2C opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  let hasHash = false;\n  let hasAt = false;\n  let start = -1;\n  let end = -1;\n  let rest = '';\n  let lastPos = 0;\n  for (let i = 0\x2C inWs = false\x2C split = false; i < url.length; ++i) {\n    const code = url.charCodeAt(i);\n\n    // Find first and last non-whitespace characters for trimming\n    const isWs = code === CHAR_SPACE ||\n                 code === CHAR_TAB ||\n                 code === CHAR_CARRIAGE_RETURN ||\n                 code === CHAR_LINE_FEED ||\n                 code === CHAR_FORM_FEED ||\n                 code === CHAR_NO_BREAK_SPACE ||\n                 code === CHAR_ZERO_WIDTH_NOBREAK_SPACE;\n    if (start === -1) {\n      if (isWs)\n        continue;\n      lastPos = start = i;\n    } else if (inWs) {\n      if (!isWs) {\n        end = -1;\n        inWs = false;\n      }\n    } else if (isWs) {\n      end = i;\n      inWs = true;\n    }\n\n    // Only convert backslashes while we haven't seen a split character\n    if (!split) {\n      switch (code) {\n        case CHAR_AT:\n          hasAt = true;\n          break;\n        case CHAR_HASH:\n          hasHash = true;\n        // Fall through\n        case CHAR_QUESTION_MARK:\n          split = true;\n          break;\n        case CHAR_BACKWARD_SLASH:\n          if (i - lastPos > 0)\n            rest += url.slice(lastPos\x2C i);\n          rest += '/';\n          lastPos = i + 1;\n          break;\n      }\n    } else if (!hasHash && code === CHAR_HASH) {\n      hasHash = true;\n    }\n  }\n\n  // Check if string was non-empty (including strings with only whitespace)\n  if (start !== -1) {\n    if (lastPos === start) {\n      // We didn't convert any backslashes\n\n      if (end === -1) {\n        if (start === 0)\n          rest = url;\n        else\n          rest = url.slice(start);\n      } else {\n        rest = url.slice(start\x2C end);\n      }\n    } else if (end === -1 && lastPos < url.length) {\n      // We converted some backslashes and have only part of the entire string\n      rest += url.slice(lastPos);\n    } else if (end !== -1 && lastPos < end) {\n      // We converted some backslashes and have only part of the entire string\n      rest += url.slice(lastPos\x2C end);\n    }\n  }\n\n  if (!slashesDenoteHost && !hasHash && !hasAt) {\n    // Try fast path regexp\n    const simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.slice(1));\n        } else {\n          this.query = this.search.slice(1);\n        }\n      } else if (parseQueryString) {\n        this.search = null;\n        this.query = ObjectCreate(null);\n      }\n      return this;\n    }\n  }\n\n  let proto = protocolPattern.exec(rest);\n  let lowerProto;\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.slice(proto.length);\n  }\n\n  // Figure out if it's got a host\n  // user@server is *always* interpreted as a hostname\x2C and url\n  // resolution will treat //foo/bar as host=foo\x2Cpath=bar because that's\n  // how the browser resolves relative URLs.\n  let slashes;\n  if (slashesDenoteHost || proto || hostPattern.test(rest)) {\n    slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH &&\n              rest.charCodeAt(1) === CHAR_FORWARD_SLASH;\n    if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {\n      rest = rest.slice(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol.has(lowerProto) &&\n      (slashes || (proto && !slashedProtocol.has(proto)))) {\n\n    // there's a hostname.\n    // the first instance of /\x2C ?\x2C ;\x2C or # ends the host.\n    //\n    // If there is an @ in the hostname\x2C then non-host chars *are* allowed\n    // to the left of the last @ sign\x2C unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:b path:/?@c\n\n    let hostEnd = -1;\n    let atSign = -1;\n    let nonHost = -1;\n    for (let i = 0; i < rest.length; ++i) {\n      switch (rest.charCodeAt(i)) {\n        case CHAR_TAB:\n        case CHAR_LINE_FEED:\n        case CHAR_CARRIAGE_RETURN:\n        case CHAR_SPACE:\n        case CHAR_DOUBLE_QUOTE:\n        case CHAR_PERCENT:\n        case CHAR_SINGLE_QUOTE:\n        case CHAR_SEMICOLON:\n        case CHAR_LEFT_ANGLE_BRACKET:\n        case CHAR_RIGHT_ANGLE_BRACKET:\n        case CHAR_BACKWARD_SLASH:\n        case CHAR_CIRCUMFLEX_ACCENT:\n        case CHAR_GRAVE_ACCENT:\n        case CHAR_LEFT_CURLY_BRACKET:\n        case CHAR_VERTICAL_LINE:\n        case CHAR_RIGHT_CURLY_BRACKET:\n          // Characters that are never ever allowed in a hostname from RFC 2396\n          if (nonHost === -1)\n            nonHost = i;\n          break;\n        case CHAR_HASH:\n        case CHAR_FORWARD_SLASH:\n        case CHAR_QUESTION_MARK:\n          // Find the first instance of any host-ending characters\n          if (nonHost === -1)\n            nonHost = i;\n          hostEnd = i;\n          break;\n        case CHAR_AT:\n          // At this point\x2C either we have an explicit point where the\n          // auth portion cannot go past\x2C or the last @ char is the decider.\n          atSign = i;\n          nonHost = -1;\n          break;\n      }\n      if (hostEnd !== -1)\n        break;\n    }\n    start = 0;\n    if (atSign !== -1) {\n      this.auth = decodeURIComponent(rest.slice(0\x2C atSign));\n      start = atSign + 1;\n    }\n    if (nonHost === -1) {\n      this.host = rest.slice(start);\n      rest = '';\n    } else {\n      this.host = rest.slice(start\x2C nonHost);\n      rest = rest.slice(nonHost);\n    }\n\n    // pull out port.\n    this.parseHost();\n\n    // We've indicated that there is a hostname\x2C\n    // so even if it's empty\x2C it has to be present.\n    if (typeof this.hostname !== 'string')\n      this.hostname = '';\n\n    const hostname = this.hostname;\n\n    // If hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    const ipv6Hostname = isIpv6Hostname(hostname);\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      rest = getHostname(this\x2C rest\x2C hostname);\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // Hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname && this.hostname !== '') {\n      // IDNA Support: Returns a punycoded representation of "domain".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters\x2C i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n\n      // Use lenient mode (`true`) to try to support even non-compliant\n      // URLs.\n      this.hostname = toASCII(this.hostname\x2C true);\n\n      // Prevent two potential routes of hostname spoofing.\n      // 1. If this.hostname is empty\x2C it must have become empty due to toASCII\n      //    since we checked this.hostname above.\n      // 2. If any of forbiddenHostChars appears in this.hostname\x2C it must have\n      //    also gotten in due to toASCII. This is since getHostname would have\n      //    filtered them out otherwise.\n      // Rather than trying to correct this by moving the non-host part into\n      // the pathname as we've done in getHostname\x2C throw an exception to\n      // convey the severity of this issue.\n      if (this.hostname === '' || forbiddenHostChars.test(this.hostname)) {\n        throw new ERR_INVALID_URL(url);\n      }\n    }\n\n    const p = this.port ? ':' + this.port : '';\n    const h = this.hostname || '';\n    this.host = h + p;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them\x2C though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.slice(1\x2C -1);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // Now rest is set to the post-host stuff.\n  // Chop off any delim chars.\n  if (!unsafeProtocol.has(lowerProto)) {\n    // First\x2C make 100% sure that any "autoEscape" chars get\n    // escaped\x2C even if encodeURIComponent doesn't think they\n    // need to be.\n    rest = autoEscapeStr(rest);\n  }\n\n  let questionIdx = -1;\n  let hashIdx = -1;\n  for (let i = 0; i < rest.length; ++i) {\n    const code = rest.charCodeAt(i);\n    if (code === CHAR_HASH) {\n      this.hash = rest.slice(i);\n      hashIdx = i;\n      break;\n    } else if (code === CHAR_QUESTION_MARK && questionIdx === -1) {\n      questionIdx = i;\n    }\n  }\n\n  if (questionIdx !== -1) {\n    if (hashIdx === -1) {\n      this.search = rest.slice(questionIdx);\n      this.query = rest.slice(questionIdx + 1);\n    } else {\n      this.search = rest.slice(questionIdx\x2C hashIdx);\n      this.query = rest.slice(questionIdx + 1\x2C hashIdx);\n    }\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n  } else if (parseQueryString) {\n    // No query string\x2C but parseQueryString still requested\n    this.search = null;\n    this.query = ObjectCreate(null);\n  }\n\n  const useQuestionIdx =\n    questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);\n  const firstIdx = useQuestionIdx ? questionIdx : hashIdx;\n  if (firstIdx === -1) {\n    if (rest.length > 0)\n      this.pathname = rest;\n  } else if (firstIdx > 0) {\n    this.pathname = rest.slice(0\x2C firstIdx);\n  }\n  if (slashedProtocol.has(lowerProto) &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  // To support http.request\n  if (this.pathname || this.search) {\n    const p = this.pathname || '';\n    const s = this.search || '';\n    this.path = p + s;\n  }\n\n  // Finally\x2C reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\nfunction getHostname(self\x2C rest\x2C hostname) {\n  for (let i = 0; i < hostname.length; ++i) {\n    const code = hostname.charCodeAt(i);\n    const isValid = (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z) ||\n                    code === CHAR_DOT ||\n                    (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n                    (code >= CHAR_0 && code <= CHAR_9) ||\n                    code === CHAR_HYPHEN_MINUS ||\n                    code === CHAR_PLUS ||\n                    code === CHAR_UNDERSCORE ||\n                    code > 127;\n\n    // Invalid host character\n    if (!isValid) {\n      self.hostname = hostname.slice(0\x2C i);\n      return `/${hostname.slice(i)}${rest}`;\n    }\n  }\n  return rest;\n}\n\n// Escaped characters. Use empty strings to fill up unused entries.\n// Using Array is faster than Object/Map\nconst escapedCodes = [\n  /* 0 - 9 */ ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '%09'\x2C\n  /* 10 - 19 */ '%0A'\x2C ''\x2C ''\x2C '%0D'\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C\n  /* 20 - 29 */ ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C\n  /* 30 - 39 */ ''\x2C ''\x2C '%20'\x2C ''\x2C '%22'\x2C ''\x2C ''\x2C ''\x2C ''\x2C '%27'\x2C\n  /* 40 - 49 */ ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C\n  /* 50 - 59 */ ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C\n  /* 60 - 69 */ '%3C'\x2C ''\x2C '%3E'\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C\n  /* 70 - 79 */ ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C\n  /* 80 - 89 */ ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C\n  /* 90 - 99 */ ''\x2C ''\x2C '%5C'\x2C ''\x2C '%5E'\x2C ''\x2C '%60'\x2C ''\x2C ''\x2C ''\x2C\n  /* 100 - 109 */ ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C\n  /* 110 - 119 */ ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C\n  /* 120 - 125 */ ''\x2C ''\x2C ''\x2C '%7B'\x2C '%7C'\x2C '%7D'\x2C\n];\n\n// Automatically escape all delimiters and unwise characters from RFC 2396.\n// Also escape single quotes in case of an XSS attack.\n// Return the escaped string.\nfunction autoEscapeStr(rest) {\n  let escaped = '';\n  let lastEscapedPos = 0;\n  for (let i = 0; i < rest.length; ++i) {\n    // `escaped` contains substring up to the last escaped character.\n    const escapedChar = escapedCodes[rest.charCodeAt(i)];\n    if (escapedChar) {\n      // Concat if there are ordinary characters in the middle.\n      if (i > lastEscapedPos)\n        escaped += rest.slice(lastEscapedPos\x2C i);\n      escaped += escapedChar;\n      lastEscapedPos = i + 1;\n    }\n  }\n  if (lastEscapedPos === 0)  // Nothing has been escaped.\n    return rest;\n\n  // There are ordinary characters at the end.\n  if (lastEscapedPos < rest.length)\n    escaped += rest.slice(lastEscapedPos);\n\n  return escaped;\n}\n\n// Format a parsed object into a url string\nfunction urlFormat(urlObject\x2C options) {\n  // Ensure it's an object\x2C and not a string url.\n  // If it's an object\x2C this is a no-op.\n  // this way\x2C you can call urlParse() on strings\n  // to clean up potentially wonky urls.\n  if (typeof urlObject === 'string') {\n    urlObject = urlParse(urlObject);\n  } else if (typeof urlObject !== 'object' || urlObject === null) {\n    throw new ERR_INVALID_ARG_TYPE('urlObject'\x2C\n                                   ['Object'\x2C 'string']\x2C urlObject);\n  } else if (!(urlObject instanceof Url)) {\n    const format = urlObject[formatSymbol];\n    return format ?\n      format.call(urlObject\x2C options) :\n      Url.prototype.format.call(urlObject);\n  }\n  return urlObject.format();\n}\n\n// These characters do not need escaping:\n// ! - . _ ~\n// ' ( ) * :\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\nconst noEscapeAuth = new Int8Array([\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x00 - 0x0F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x10 - 0x1F\n  0\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 1\x2C 1\x2C 0\x2C // 0x20 - 0x2F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x30 - 0x3F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x40 - 0x4F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C // 0x50 - 0x5F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x60 - 0x6F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 1\x2C 0\x2C  // 0x70 - 0x7F\n]);\n\nUrl.prototype.format = function format() {\n  let auth = this.auth || '';\n  if (auth) {\n    auth = encodeStr(auth\x2C noEscapeAuth\x2C hexTable);\n    auth += '@';\n  }\n\n  let protocol = this.protocol || '';\n  let pathname = this.pathname || '';\n  let hash = this.hash || '';\n  let host = '';\n  let query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (\n      this.hostname.includes(':') && !isIpv6Hostname(this.hostname) ?\n        '[' + this.hostname + ']' :\n        this.hostname\n    );\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query !== null && typeof this.query === 'object') {\n    query = querystring.stringify(this.query);\n  }\n\n  let search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58/* : */)\n    protocol += ':';\n\n  let newPathname = '';\n  let lastPos = 0;\n  for (let i = 0; i < pathname.length; ++i) {\n    switch (pathname.charCodeAt(i)) {\n      case CHAR_HASH:\n        if (i - lastPos > 0)\n          newPathname += pathname.slice(lastPos\x2C i);\n        newPathname += '%23';\n        lastPos = i + 1;\n        break;\n      case CHAR_QUESTION_MARK:\n        if (i - lastPos > 0)\n          newPathname += pathname.slice(lastPos\x2C i);\n        newPathname += '%3F';\n        lastPos = i + 1;\n        break;\n    }\n  }\n  if (lastPos > 0) {\n    if (lastPos !== pathname.length)\n      pathname = newPathname + pathname.slice(lastPos);\n    else\n      pathname = newPathname;\n  }\n\n  // Only the slashedProtocols get the //.  Not mailto:\x2C xmpp:\x2C etc.\n  // unless they had them to begin with.\n  if (this.slashes || slashedProtocol.has(protocol)) {\n    if (this.slashes || host) {\n      if (pathname && pathname.charCodeAt(0) !== CHAR_FORWARD_SLASH)\n        pathname = '/' + pathname;\n      host = '//' + host;\n    } else if (protocol.length >= 4 &&\n               protocol.charCodeAt(0) === 102/* f */ &&\n               protocol.charCodeAt(1) === 105/* i */ &&\n               protocol.charCodeAt(2) === 108/* l */ &&\n               protocol.charCodeAt(3) === 101/* e */) {\n      host = '//';\n    }\n  }\n\n  search = search.replace(/#/g\x2C '%23');\n\n  if (hash && hash.charCodeAt(0) !== CHAR_HASH)\n    hash = '#' + hash;\n  if (search && search.charCodeAt(0) !== CHAR_QUESTION_MARK)\n    search = '?' + search;\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source\x2C relative) {\n  return urlParse(source\x2C false\x2C true).resolve(relative);\n}\n\nUrl.prototype.resolve = function resolve(relative) {\n  return this.resolveObject(urlParse(relative\x2C false\x2C true)).format();\n};\n\nfunction urlResolveObject(source\x2C relative) {\n  if (!source) return relative;\n  return urlParse(source\x2C false\x2C true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function resolveObject(relative) {\n  if (typeof relative === 'string') {\n    const rel = new Url();\n    rel.parse(relative\x2C false\x2C true);\n    relative = rel;\n  }\n\n  const result = new Url();\n  const tkeys = ObjectKeys(this);\n  for (let tk = 0; tk < tkeys.length; tk++) {\n    const tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // Hash is always overridden\x2C no matter what.\n  // even href="" will remove it.\n  result.hash = relative.hash;\n\n  // If the relative url is empty\x2C then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // Hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // Take everything except the protocol from relative\n    const rkeys = ObjectKeys(relative);\n    for (let rk = 0; rk < rkeys.length; rk++) {\n      const rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    // urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol.has(result.protocol) &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // If it's a known url protocol\x2C then changing\n    // the protocol does weird things\n    // first\x2C if it's not file:\x2C then we MUST have a host\x2C\n    // and if there was a path\n    // to begin with\x2C then we MUST have a path.\n    // if it is file:\x2C then the host is dropped\x2C\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol.has(relative.protocol)) {\n      const keys = ObjectKeys(relative);\n      for (let v = 0; v < keys.length; v++) {\n        const k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host &&\n        !/^file:?$/.test(relative.protocol) &&\n        !hostlessProtocol.has(relative.protocol)) {\n      const relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // To support http.request\n    if (result.pathname || result.search) {\n      const p = result.pathname || '';\n      const s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  const isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/');\n  const isRelAbs = (\n    relative.host || (relative.pathname && relative.pathname.charAt(0) === '/')\n  );\n  let mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname));\n  const removeAllDots = mustEndAbs;\n  let srcPath = (result.pathname && result.pathname.split('/')) || [];\n  const relPath = (relative.pathname && relative.pathname.split('/')) || [];\n  const noLeadingSlashes = result.protocol &&\n      !slashedProtocol.has(result.protocol);\n\n  // If the url is a non-slashed url\x2C then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname\x2C as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on\x2C put the first path part into the host field.\n  if (noLeadingSlashes) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      result.auth = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    if (relative.host || relative.host === '') {\n      if (result.host !== relative.host) result.auth = null;\n      result.host = relative.host;\n      result.port = relative.port;\n    }\n    if (relative.hostname || relative.hostname === '') {\n      if (result.hostname !== relative.hostname) result.auth = null;\n      result.hostname = relative.hostname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // Fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file\x2C and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (relative.search !== null && relative.search !== undefined) {\n    // Just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (noLeadingSlashes) {\n      result.hostname = result.host = srcPath.shift();\n      // Occasionally the auth can get stuck only in host.\n      // This especially happens in cases like\n      // url.resolveObject('mailto:local1@domain1'\x2C 'local2@domain2')\n      const authInHost =\n        result.host && result.host.indexOf('@') > 0 && result.host.split('@');\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    // To support http.request\n    if (result.pathname !== null || result.search !== null) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // No path at all. All other things were already handled above.\n    result.pathname = null;\n    // To support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // If a url ENDs in . or ..\x2C then it must get a trailing slash.\n  // however\x2C if it ends in anything else non-slashy\x2C\n  // then it must NOT get a trailing slash.\n  let last = srcPath.slice(-1)[0];\n  const hasTrailingSlash = (\n    ((result.host || relative.host || srcPath.length > 1) &&\n    (last === '.' || last === '..')) || last === '');\n\n  // Strip single dots\x2C resolve double dots to parent dir\n  // if the path tries to go above the root\x2C `up` ends up > 0\n  let up = 0;\n  for (let i = srcPath.length - 1; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      spliceOne(srcPath\x2C i);\n    } else if (last === '..') {\n      spliceOne(srcPath\x2C i);\n      up++;\n    } else if (up) {\n      spliceOne(srcPath\x2C i);\n      up--;\n    }\n  }\n\n  // If the path is allowed to go above the root\x2C restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    while (up--) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  const isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (noLeadingSlashes) {\n    result.hostname =\n      result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n    // Occasionally the auth can get stuck only in host.\n    // This especially happens in cases like\n    // url.resolveObject('mailto:local1@domain1'\x2C 'local2@domain2')\n    const authInHost = result.host && result.host.indexOf('@') > 0 ?\n      result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  // To support request.http\n  if (result.pathname !== null || result.search !== null) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function parseHost() {\n  let host = this.host;\n  let port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.slice(1);\n    }\n    host = host.slice(0\x2C host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\nmodule.exports = {\n  // Original API\n  Url\x2C\n  parse: urlParse\x2C\n  resolve: urlResolve\x2C\n  resolveObject: urlResolveObject\x2C\n  format: urlFormat\x2C\n\n  // WHATWG API\n  URL\x2C\n  URLSearchParams\x2C\n  domainToASCII\x2C\n  domainToUnicode\x2C\n\n  // Utilities\n  pathToFileURL\x2C\n  fileURLToPath\x2C\n  urlToHttpOptions\x2C\n};\n
code-source-info,0xa12169d70f6,90,3902,4099,C0O3949C2O3957C7O3973C9O3984C10O4006C13O4006C19O4029C36O4029C41O4080C43O4097,,
code-creation,LazyCompile,10,169542,0xa12169d929e,62,Url node:url:61:13,0x3beccad7e50,~
code-source-info,0xa12169d929e,90,1998,2262,C0O2005C1O2019C5O2029C6O2042C10O2052C11O2062C15O2072C16O2082C20O2092C21O2102C25O2112C26O2126C30O2136C31O2146C35O2156C36O2168C40O2178C41O2189C45O2199C46O2213C50O2223C51O2233C55O2243C56O2253C61O2261,,
tick,0x1bfd70c28,169584,0,0x0,3,0x0,0xa12169d6e1d,0xa12169d6940,0xa12169d647e,0xa12169d60d3,0xa12169d5f76
code-creation,LazyCompile,10,169709,0xa12169d980e,2127,parse node:url:183:37,0x3beccad8948,~
code-source-info,0xa12169d980e,90,5061,15043,C0O5108C10O5108C15O5353C17O5374C19O5395C22O5411C25O5428C28O5448C30O5466C33O5476C36O5491C39O5506C43O5500C48O5542C54O5542C61O5641C63O5650C65O5646C72O5690C74O5686C81O5728C83O5724C90O5778C92O5774C99O5822C101O5818C108O5866C110O5862C117O5915C119O5911C124O5950C126O5960C131O5976C135O5994C137O6010C147O6042C151O6060C155O6081C158O6099C163O6132C167O6150C170O6165C173O6261C177O6281C179O6310C191O6373C200O6447C209O6521C218O6329C220O6353C222O6394C224O6477C227O6501C229O6552C231O6558C237O6568C242O6597C248O6597C261O6626C270O6649C272O6661C276O6676C280O6702C286O6727C288O6723C293O6746C295O5516C301O5453C307O6851C309O6861C314O6875C316O6887C321O6950C323O6958C328O6976C329O6986C334O7003C341O7049C347O7049C355O7097C361O7097C370O7135C372O7143C377O7167C381O7161C386O7274C392O7274C406O7301C408O7309C415O7327C420O7433C426O7433C439O7467C445O7494C449O7506C451O7566C457O7584C463O7584C470O7600C472O7624C474O7634C478O7648C480O7658C484O7672C486O7698C489O7686C493O7709C495O7723C500O7738C502O7762C505O7750C509O7775C513O7809C515O7822C519O7834C525O7845C531O7852C541O7852C548O7834C553O7820C559O7908C565O7915C575O7915C580O7901C586O7948C590O7980C591O7992C595O8008C597O8021C604O8021C608O8019C612O8055C614O8067C615O8093C621O8109C627O8109C633O8127C635O8141C639O8158C640O8171C644O8199C650O8199C655O8218C657O8232C661O8262C667O8274C673O8262C679O8511C681O8522C687O8547C691O8556C695O8568C701O8568C708O8601C717O8601C726O8619C728O8615C733O8660C743O8660C752O8678C754O8674C758O8702C762O8719C766O8728C770O8745C776O8745C783O8783C793O8783C799O8799C800O8812C804O8833C810O8855C816O8855C825O8881C829O8893C833O8903C837O8919C843O8919C850O9362C854O9383C858O9405C862O9426C865O9438C869O9431C874O9472C880O9472C889O9502C898O9525C907O9554C916O9589C925O9614C934O9646C943O9673C952O9705C961O9734C970O9772C979O9811C988O9845C997O9882C1006O9914C1015O9952C1024O9985C1033O10176C1042O10200C1051O10233C1060O10428C1069O10101C1071O10113C1076O10133C1081O10156C1083O10330C1085O10342C1090O10362C1095O10385C1100O10408C1102O10595C1105O10617C1109O10641C1111O10662C1113O10674C1118O10690C1120O9448C1126O9413C1132O10707C1134O10722C1136O10733C1141O10749C1143O10761C1147O10785C1156O10785C1164O10761C1168O10759C1172O10810C1174O10825C1178O10840C1180O10852C1185O10885C1191O10885C1196O10878C1200O10905C1205O10952C1211O10952C1217O10945C1221O10993C1227O10993C1233O11047C1239O11047C1243O11182C1251O11211C1253O11225C1257O11258C1263O11384C1267O11384C1273O11441C1275O11468C1288O11475C1294O11530C1300O11539C1308O11548C1310O11546C1315O11572C1317O11586C1323O11674C1329O11683C1335O11683C1339O11667C1343O11709C1347O11735C1355O11744C1360O12100C1362O12116C1366O12129C1375O12116C1380O12114C1384O12748C1392O12757C1399O12767C1403O12786C1409O12796C1415O12786C1422O12817C1430O12823C1435O12817C1436O12883C1446O12901C1450O12894C1459O12931C1469O12951C1471O12965C1474O12961C1478O13063C1482O13110C1488O13119C1502O13119C1508O13103C1512O13139C1513O13147C1520O13151C1525O13170C1531O13181C1535O13286C1541O13306C1547O13306C1554O13471C1558O13478C1563O13524C1566O13544C1569O13563C1571O13575C1575O13568C1580O13612C1586O13612C1593O13631C1595O13644C1597O13640C1602O13680C1608O13680C1613O13673C1617O13696C1622O13715C1624O13733C1626O13746C1628O13742C1635O13780C1640O13796C1645O13585C1650O13550C1653O13826C1655O13842C1660O13856C1662O13868C1667O13903C1673O13903C1678O13896C1686O13947C1694O13965C1702O13947C1712O13940C1722O14009C1728O14009C1740O14002C1748O14062C1756O14080C1764O14062C1776O14055C1784O14105C1788O14135C1790O14148C1794O14160C1800O14171C1810O14160C1820O14146C1830O14194C1834O14283C1835O14295C1843O14307C1845O14320C1852O14320C1860O14318C1868O14374C1870O14386C1881O14405C1891O14427C1898O14458C1907O14500C1909O14513C1917O14536C1924O14543C1932O14554C1934O14568C1944O14585C1945O14598C1953O14630C1962O14630C1974O14623C1982O14656C1988O14676C1994O14676C2006O14706C2016O14724C2026O14740C2028O14754C2036O14806C2046O14823C2056O14852C2069O14887C2082O14905C2084O14919C2090O14915C2098O15017C2108O15017C2116O15010C2124O15029C2126O15041,,
code-creation,LazyCompile,10,169875,0xa12169da6d6,91,parseHost node:url:990:45,0x3beccad8c98,~
code-source-info,0xa12169da6d6,90,30948,31203,C0O30971C5O30990C10O31002C15O31002C21O31016C23O31032C24O31043C28O31052C30O31061C35O31095C43O31095C48O31088C52O31127C59O31141C64O31155C68O31148C72O31127C79O31170C83O31180C85O31194C90O31202,,
code-creation,LazyCompile,10,169917,0xa12169da85e,49,isIpv6Hostname node:url:161:24,0x3beccad88f8,~
code-source-info,0xa12169da85e,90,4124,4324,C0O4139C7O4152C15O4195C17O4191C24O4227C27O4272C31O4279C35O4227C43O4292C45O4284C48O4322,,
code-creation,LazyCompile,10,169959,0xa12169da9fe,173,getHostname node:url:511:21,0x3beccad8998,~
code-source-info,0xa12169da9fe,90,15066,15771,C0O15106C2O15122C6O15111C11O15163C16O15163C22O15198C24O15207C26O15204C33O15235C35O15232C42O15285C44O15281C51O15326C53O15323C60O15354C62O15351C69O15404C71O15401C78O15422C80O15419C87O15462C89O15458C96O15512C98O15508C105O15554C107O15550C114O15598C118O15640C120O15687C127O15687C133O15676C137O15706C140O15726C145O15726C157O15737C161O15744C162O15132C167O15093C170O15757C172O15769,,
tick,0x10035a5f4,170000,0,0x0,3,0x0,0xa12169d9d16,0xa12169d711a,0xa12169d6e1d,0xa12169d6940,0xa12169d647e,0xa12169d60d3,0xa12169d5f76
code-creation,LazyCompile,10,170000,0xa12169dacde,123,autoEscapeStr node:url:553:23,0x3beccad89e8,~
code-source-info,0xa12169dacde,90,16850,17534,C0O16875C3O16902C5O16920C7O16932C11O16925C16O17041C21O17059C26O17059C31O17053C35O17079C37O17168C39O17174C44O17216C49O17216C62O17248C64O17259C71O17278C73O17297C77O16942C82O16907C85O17314C86O17333C91O17374C93O17386C94O17463C98O17456C103O17491C108O17491C120O17517C122O17532,,
code-creation,LazyCompile,10,170084,0xa12169db01e,758,format node:url:614:39,0x3beccad8aa8,~
code-source-info,0xa12169db01e,90,19013,21375,C0O19036C9O19050C11O19066C18O19089C23O19103C29O19073C35O19118C44O19158C53O19196C62O19230C71O19255C74O19273C77O19289C83O19320C87O19313C93O19344C99O19387C104O19396C112O19396C125O19434C130O19414C139O19465C143O19458C149O19474C154O19495C158O19372C162O19524C168O19538C171O19557C175O19550C185O19585C191O19615C199O19641C204O19661C209O19676C214O19661C220O19709C228O19720C235O19734C243O19754C247O19779C252O19799C256O19806C260O19779C268O19811C273O19830C282O19868C285O19888C287O19906C289O19922C293O19911C298O19958C303O19958C311O19986C320O20160C329O20005C331O20011C336O20021C341O20060C346O20060C359O20087C368O20117C370O20129C374O20142C376O20188C378O20194C383O20204C388O20243C393O20243C406O20270C415O20300C417O20312C421O20325C423O19932C428O19893C431O20344C432O20356C437O20392C441O20379C446O20440C451O20440C456O20429C462O20471C467O20621C475O20632C478O20648C483O20648C490O20678C498O20689C500O20703C504O20728C511O20728C519O20746C521O20742C526O20774C531O20789C535O20807C540O20819C546O20851C553O20858C558O20890C565O20890C573O20904C578O20946C586O20946C594O20960C599O21002C607O21002C615O21016C620O21058C628O21058C636O21072C641O21096C644O21138C657O21138C664O21163C668O21180C675O21180C683O21198C685O21194C690O21213C695O21224C699O21234C703O21255C710O21255C718O21273C720O21269C725O21297C730O21310C734O21323C736O21339C742O21346C748O21357C754O21366C757O21373,,
code-creation,LazyCompile,10,170167,0xa12169db63e,265,stringify node:querystring:228:19,0x815de63f0d8,~
script-source,42,node:querystring,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Query String Utilities\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  Int8Array\x2C\n  MathAbs\x2C\n  NumberIsFinite\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeSlice\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  encodeStr\x2C\n  hexTable\x2C\n  isHexTable\n} = require('internal/querystring');\nconst QueryString = module.exports = {\n  unescapeBuffer\x2C\n  // `unescape()` is a JS global\x2C so we need to use a different local name\n  unescape: qsUnescape\x2C\n\n  // `escape()` is a JS global\x2C so we need to use a different local name\n  escape: qsEscape\x2C\n\n  stringify\x2C\n  encode: stringify\x2C\n\n  parse\x2C\n  decode: parse\n};\n\nconst unhexTable = new Int8Array([\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C // 0 - 15\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C // 16 - 31\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C // 32 - 47\n  +0\x2C +1\x2C +2\x2C +3\x2C +4\x2C +5\x2C +6\x2C +7\x2C +8\x2C +9\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C // 48 - 63\n  -1\x2C 10\x2C 11\x2C 12\x2C 13\x2C 14\x2C 15\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C // 64 - 79\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C // 80 - 95\n  -1\x2C 10\x2C 11\x2C 12\x2C 13\x2C 14\x2C 15\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C // 96 - 111\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C // 112 - 127\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C // 128 ...\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C\n  -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C -1\x2C  // ... 255\n]);\n/**\n * A safe fast alternative to decodeURIComponent\n * @param {string} s\n * @param {boolean} decodeSpaces\n * @returns {string}\n */\nfunction unescapeBuffer(s\x2C decodeSpaces) {\n  const out = Buffer.allocUnsafe(s.length);\n  let index = 0;\n  let outIndex = 0;\n  let currentChar;\n  let nextChar;\n  let hexHigh;\n  let hexLow;\n  const maxLength = s.length - 2;\n  // Flag to know if some hex chars have been decoded\n  let hasHex = false;\n  while (index < s.length) {\n    currentChar = StringPrototypeCharCodeAt(s\x2C index);\n    if (currentChar === 43 /* '+' */ && decodeSpaces) {\n      out[outIndex++] = 32; // ' '\n      index++;\n      continue;\n    }\n    if (currentChar === 37 /* '%' */ && index < maxLength) {\n      currentChar = StringPrototypeCharCodeAt(s\x2C ++index);\n      hexHigh = unhexTable[currentChar];\n      if (!(hexHigh >= 0)) {\n        out[outIndex++] = 37; // '%'\n        continue;\n      } else {\n        nextChar = StringPrototypeCharCodeAt(s\x2C ++index);\n        hexLow = unhexTable[nextChar];\n        if (!(hexLow >= 0)) {\n          out[outIndex++] = 37; // '%'\n          index--;\n        } else {\n          hasHex = true;\n          currentChar = hexHigh * 16 + hexLow;\n        }\n      }\n    }\n    out[outIndex++] = currentChar;\n    index++;\n  }\n  return hasHex ? out.slice(0\x2C outIndex) : out;\n}\n\n/**\n * @param {string} s\n * @param {boolean} decodeSpaces\n * @returns {string}\n */\nfunction qsUnescape(s\x2C decodeSpaces) {\n  try {\n    return decodeURIComponent(s);\n  } catch {\n    return QueryString.unescapeBuffer(s\x2C decodeSpaces).toString();\n  }\n}\n\n\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\nconst noEscape = new Int8Array([\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0 - 15\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 16 - 31\n  0\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 1\x2C 1\x2C 0\x2C // 32 - 47\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 48 - 63\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 64 - 79\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C // 80 - 95\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 96 - 111\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 1\x2C 0\x2C  // 112 - 127\n]);\n\n/**\n * QueryString.escape() replaces encodeURIComponent()\n * @see https://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3.4\n * @param {any} str\n * @returns {string}\n */\nfunction qsEscape(str) {\n  if (typeof str !== 'string') {\n    if (typeof str === 'object')\n      str = String(str);\n    else\n      str += '';\n  }\n\n  return encodeStr(str\x2C noEscape\x2C hexTable);\n}\n\n/**\n * @param {string | number | bigint | boolean | symbol | undefined | null} v\n * @returns {string}\n */\nfunction stringifyPrimitive(v) {\n  if (typeof v === 'string')\n    return v;\n  if (typeof v === 'number' && NumberIsFinite(v))\n    return '' + v;\n  if (typeof v === 'bigint')\n    return '' + v;\n  if (typeof v === 'boolean')\n    return v ? 'true' : 'false';\n  return '';\n}\n\n/**\n * @param {string | number | bigint | boolean} v\n * @param {(v: string) => string} encode\n * @returns {string}\n */\nfunction encodeStringified(v\x2C encode) {\n  if (typeof v === 'string')\n    return (v.length ? encode(v) : '');\n  if (typeof v === 'number' && NumberIsFinite(v)) {\n    // Values >= 1e21 automatically switch to scientific notation which requires\n    // escaping due to the inclusion of a '+' in the output\n    return (MathAbs(v) < 1e21 ? '' + v : encode('' + v));\n  }\n  if (typeof v === 'bigint')\n    return '' + v;\n  if (typeof v === 'boolean')\n    return v ? 'true' : 'false';\n  return '';\n}\n\n/**\n * @param {string | number | boolean | null} v\n * @param {(v: string) => string} encode\n * @returns {string}\n */\nfunction encodeStringifiedCustom(v\x2C encode) {\n  return encode(stringifyPrimitive(v));\n}\n\n/**\n * @param {Record<string\x2C string | number | boolean\n * | ReadonlyArray<string | number | boolean> | null>} obj\n * @param {string} [sep]\n * @param {string} [eq]\n * @param {{ encodeURIComponent?: (v: string) => string }} [options]\n * @returns {string}\n */\nfunction stringify(obj\x2C sep\x2C eq\x2C options) {\n  sep = sep || '&';\n  eq = eq || '=';\n\n  let encode = QueryString.escape;\n  if (options && typeof options.encodeURIComponent === 'function') {\n    encode = options.encodeURIComponent;\n  }\n  const convert =\n    (encode === qsEscape ? encodeStringified : encodeStringifiedCustom);\n\n  if (obj !== null && typeof obj === 'object') {\n    const keys = ObjectKeys(obj);\n    const len = keys.length;\n    let fields = '';\n    for (let i = 0; i < len; ++i) {\n      const k = keys[i];\n      const v = obj[k];\n      let ks = convert(k\x2C encode);\n      ks += eq;\n\n      if (ArrayIsArray(v)) {\n        const vlen = v.length;\n        if (vlen === 0) continue;\n        if (fields)\n          fields += sep;\n        for (let j = 0; j < vlen; ++j) {\n          if (j)\n            fields += sep;\n          fields += ks;\n          fields += convert(v[j]\x2C encode);\n        }\n      } else {\n        if (fields)\n          fields += sep;\n        fields += ks;\n        fields += convert(v\x2C encode);\n      }\n    }\n    return fields;\n  }\n  return '';\n}\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction charCodes(str) {\n  if (str.length === 0) return [];\n  if (str.length === 1) return [StringPrototypeCharCodeAt(str\x2C 0)];\n  const ret = new Array(str.length);\n  for (let i = 0; i < str.length; ++i)\n    ret[i] = StringPrototypeCharCodeAt(str\x2C i);\n  return ret;\n}\nconst defSepCodes = [38]; // &\nconst defEqCodes = [61]; // =\n\nfunction addKeyVal(obj\x2C key\x2C value\x2C keyEncoded\x2C valEncoded\x2C decode) {\n  if (key.length > 0 && keyEncoded)\n    key = decodeStr(key\x2C decode);\n  if (value.length > 0 && valEncoded)\n    value = decodeStr(value\x2C decode);\n\n  if (obj[key] === undefined) {\n    obj[key] = value;\n  } else {\n    const curValue = obj[key];\n    // A simple Array-specific property check is enough here to\n    // distinguish from a string value and is faster and still safe\n    // since we are generating all of the values being assigned.\n    if (curValue.pop)\n      curValue[curValue.length] = value;\n    else\n      obj[key] = [curValue\x2C value];\n  }\n}\n\n/**\n * Parse a key/val string.\n * @param {string} qs\n * @param {string} sep\n * @param {string} eq\n * @param {{\n *   maxKeys?: number;\n *   decodeURIComponent?(v: string): string;\n *   }} [options]\n * @returns {Record<string\x2C string | string[]>}\n */\nfunction parse(qs\x2C sep\x2C eq\x2C options) {\n  const obj = ObjectCreate(null);\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  const sepCodes = (!sep ? defSepCodes : charCodes(String(sep)));\n  const eqCodes = (!eq ? defEqCodes : charCodes(String(eq)));\n  const sepLen = sepCodes.length;\n  const eqLen = eqCodes.length;\n\n  let pairs = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    // -1 is used in place of a value like Infinity for meaning\n    // "unlimited pairs" because of additional checks V8 (at least as of v5.4)\n    // has to do when using variables that contain values like Infinity. Since\n    // `pairs` is always decremented and checked explicitly for 0\x2C -1 works\n    // effectively the same as Infinity\x2C while providing a significant\n    // performance boost.\n    pairs = (options.maxKeys > 0 ? options.maxKeys : -1);\n  }\n\n  let decode = QueryString.unescape;\n  if (options && typeof options.decodeURIComponent === 'function') {\n    decode = options.decodeURIComponent;\n  }\n  const customDecode = (decode !== qsUnescape);\n\n  let lastPos = 0;\n  let sepIdx = 0;\n  let eqIdx = 0;\n  let key = '';\n  let value = '';\n  let keyEncoded = customDecode;\n  let valEncoded = customDecode;\n  const plusChar = (customDecode ? '%20' : ' ');\n  let encodeCheck = 0;\n  for (let i = 0; i < qs.length; ++i) {\n    const code = StringPrototypeCharCodeAt(qs\x2C i);\n\n    // Try matching key/value pair separator (e.g. '&')\n    if (code === sepCodes[sepIdx]) {\n      if (++sepIdx === sepLen) {\n        // Key/value pair separator match!\n        const end = i - sepIdx + 1;\n        if (eqIdx < eqLen) {\n          // We didn't find the (entire) key/value separator\n          if (lastPos < end) {\n            // Treat the substring as part of the key instead of the value\n            key += StringPrototypeSlice(qs\x2C lastPos\x2C end);\n          } else if (key.length === 0) {\n            // We saw an empty substring between separators\n            if (--pairs === 0)\n              return obj;\n            lastPos = i + 1;\n            sepIdx = eqIdx = 0;\n            continue;\n          }\n        } else if (lastPos < end) {\n          value += StringPrototypeSlice(qs\x2C lastPos\x2C end);\n        }\n\n        addKeyVal(obj\x2C key\x2C value\x2C keyEncoded\x2C valEncoded\x2C decode);\n\n        if (--pairs === 0)\n          return obj;\n        keyEncoded = valEncoded = customDecode;\n        key = value = '';\n        encodeCheck = 0;\n        lastPos = i + 1;\n        sepIdx = eqIdx = 0;\n      }\n    } else {\n      sepIdx = 0;\n      // Try matching key/value separator (e.g. '=') if we haven't already\n      if (eqIdx < eqLen) {\n        if (code === eqCodes[eqIdx]) {\n          if (++eqIdx === eqLen) {\n            // Key/value separator match!\n            const end = i - eqIdx + 1;\n            if (lastPos < end)\n              key += StringPrototypeSlice(qs\x2C lastPos\x2C end);\n            encodeCheck = 0;\n            lastPos = i + 1;\n          }\n          continue;\n        } else {\n          eqIdx = 0;\n          if (!keyEncoded) {\n            // Try to match an (valid) encoded byte once to minimize unnecessary\n            // calls to string decoding functions\n            if (code === 37/* % */) {\n              encodeCheck = 1;\n              continue;\n            } else if (encodeCheck > 0) {\n              if (isHexTable[code] === 1) {\n                if (++encodeCheck === 3)\n                  keyEncoded = true;\n                continue;\n              } else {\n                encodeCheck = 0;\n              }\n            }\n          }\n        }\n        if (code === 43/* + */) {\n          if (lastPos < i)\n            key += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n          key += plusChar;\n          lastPos = i + 1;\n          continue;\n        }\n      }\n      if (code === 43/* + */) {\n        if (lastPos < i)\n          value += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n        value += plusChar;\n        lastPos = i + 1;\n      } else if (!valEncoded) {\n        // Try to match an (valid) encoded byte (once) to minimize unnecessary\n        // calls to string decoding functions\n        if (code === 37/* % */) {\n          encodeCheck = 1;\n        } else if (encodeCheck > 0) {\n          if (isHexTable[code] === 1) {\n            if (++encodeCheck === 3)\n              valEncoded = true;\n          } else {\n            encodeCheck = 0;\n          }\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n  if (lastPos < qs.length) {\n    if (eqIdx < eqLen)\n      key += StringPrototypeSlice(qs\x2C lastPos);\n    else if (sepIdx < sepLen)\n      value += StringPrototypeSlice(qs\x2C lastPos);\n  } else if (eqIdx === 0 && key.length === 0) {\n    // We ended on an empty substring\n    return obj;\n  }\n\n  addKeyVal(obj\x2C key\x2C value\x2C keyEncoded\x2C valEncoded\x2C decode);\n\n  return obj;\n}\n\n\n/**\n * V8 does not optimize functions with try-catch blocks\x2C so we isolate them here\n * to minimize the damage (Note: no longer true as of V8 5.4 -- but still will\n * not be inlined).\n * @param {string} s\n * @param {(v: string) => string} decoder\n * @returns {string}\n */\nfunction decodeStr(s\x2C decoder) {\n  try {\n    return decoder(s);\n  } catch {\n    return QueryString.unescape(s\x2C true);\n  }\n}\n
code-source-info,0xa12169db63e,42,7097,8145,C0O7125C8O7145C16O7177C21O7189C26O7199C30O7229C38O7287C43O7333C45O7341C57O7405C67O7469C72O7469C77O7507C82O7532C85O7553C87O7558C89O7558C94O7588C96O7592C100O7613C102O7616C106O7636C112O7662C114O7668C121O7679C126O7683C132O7725C137O7741C138O7750C143O7757C145O7775C149O7797C151O7807C158O7833C160O7838C162O7838C167O7863C171O7882C173O7892C180O7907C182O7917C189O7931C191O7950C195O7941C207O7848C212O7820C217O7997C221O8019C223O8029C230O8042C232O8052C239O8074C251O7567C256O7540C259O8112C261O8126C262O8133C264O8143,,
code-creation,LazyCompile,10,170792,0xa12169dc85e,186,request node:https:334:17,0x29d5d5b8e6c8,~
code-source-info,0xa12169dc85e,162,8495,9120,C0O8495C3O8523C5O8530C6O8545C13O8584C18O8584C23O8615C30O8646C35O8642C41O8625C48O8669C49O8677C55O8688C61O8692C63O8691C69O8732C75O8736C77O8735C83O8756C85O8755C90O8807C97O8834C100O8834C105O8817C110O8869C111O8877C117O8895C124O8921C131O8943C134O8943C139O8921C144O8978C147O9009C152O9017C156O9000C160O9032C165O9032C170O9073C177O9097C180O9080C185O9118,,
code-creation,LazyCompile,10,170959,0xa12169dd1be,2090,ClientRequest node:_http_client:106:23,0x2cbd764afb98,~
code-source-info,0xa12169dd1be,154,3295,10495,C0O3295C9O3320C21O3342C29O3320C34O3369C40O3421C43O3432C55O3461C61O3457C68O3440C76O3484C84O3503C86O3502C95O3545C97O3544C106O3565C108O3564C113O3616C121O3624C129O3664C132O3682C135O3703C138O3724C144O3765C147O3783C156O3821C166O3844C171O3831C178O3894C183O3932C193O3949C197O3955C202O3970C203O3980C208O4022C214O4005C222O4046C230O4114C238O4155C245O4323C253O4356C276O4362C281O4356C282O4533C288O4544C292O4581C298O4606C303O4654C308O4666C312O4675C322O4689C328O4695C334O4709C338O4733C344O4739C349O4764C355O4789C363O4804C369O4789C375O4815C387O4839C391O4819C398O4872C412O4878C417O4872C418O4931C420O4944C425O4972C441O4978C446O4972C447O5067C457O5108C467O5122C473O5128C478O5181C489O5189C495O5171C502O5223C508O5259C518O5238C534O5333C544O5312C555O5236C562O5391C573O5416C577O5432C583O5416C588O5446C592O5472C596O5462C600O5499C606O5526C614O5541C618O5566C628O5541C633O5539C637O5613C642O5623C644O5641C656O5641C661O5698C666O5731C669O5763C679O5811C681O5833C702O5839C707O5833C708O5908C714O5930C716O5944C724O5949C730O5983C747O5989C752O5983C753O6045C761O6068C765O6068C771O6066C782O6119C790O6140C799O6186C804O6203C806O6240C824O6240C829O6294C835O6313C839O6368C844O6390C852O6483C873O6489C878O6483C879O6589C885O6613C889O6638C893O6658C901O6648C905O6673C909O6687C913O6692C923O6692C929O6721C931O6732C938O6758C945O6785C952O6814C959O6844C966O6872C971O6893C976O6926C982O6950C987O6983C991O6998C996O7010C1000O7021C1005O7030C1009O7040C1014O7053C1018O7064C1023O7079C1027O7089C1032O7111C1036O7122C1041O7134C1045O7144C1050O7165C1054O7175C1059O7193C1063O7204C1069O7214C1073O7224C1079O7238C1083O7253C1087O7262C1093O7555C1097O7565C1103O7571C1113O7585C1121O7605C1127O7611C1133O7585C1139O7632C1144O7643C1148O7657C1153O7678C1159O7706C1164O7717C1168O7732C1173O7753C1177O7795C1185O7816C1191O7795C1196O7828C1198O7865C1204O7895C1212O7914C1218O7895C1224O8053C1227O8065C1231O8058C1236O8100C1238O8104C1243O8117C1247O8122C1253O8145C1261O8152C1266O8122C1272O8074C1278O8040C1281O8179C1289O8197C1299O8197C1308O8218C1310O8252C1313O8469C1325O8469C1332O8516C1334O8529C1343O8549C1353O8599C1361O8549C1372O8617C1379O8617C1388O8658C1393O8685C1399O8702C1412O8732C1418O8744C1424O8750C1429O8777C1435O8795C1446O8817C1450O8822C1460O8822C1466O8876C1476O8890C1486O8890C1493O8926C1497O8931C1515O8990C1519O8997C1525O9010C1531O8997C1538O9015C1548O9016C1553O8967C1558O8931C1564O9048C1568O9057C1578O9057C1585O9086C1589O9095C1595O9114C1609O9120C1614O9114C1615O9172C1619O9177C1629O9195C1637O9202C1646O9215C1650O9208C1657O9220C1673O9268C1675O9267C1683O9177C1697O9304C1701O9309C1715O9327C1727O9334C1739O9347C1747O9340C1757O9352C1765O9401C1771O9309C1783O9442C1786O9475C1796O9489C1807O9509C1818O9540C1822O9605C1826O9614C1836O9627C1840O9632C1850O9638C1864O9638C1878O9736C1883O9747C1891O9759C1896O9780C1904O9822C1916O9880C1930O9880C1942O10109C1952O10109C1966O10225C1968O10252C1971O10252C1996O10319C2000O10319C2012O10361C2024O10361C2034O10428C2038O10433C2052O10442C2056O10446C2066O10446C2078O10433C2089O10494,,
code-creation,LazyCompile,10,171125,0xa12169dfd26,172,OutgoingMessage node:_http_outgoing:97:25,0x2cbd764b9740,~
code-source-info,0xa12169dfd26,158,3185,4425,C0O3192C5O3199C10O3199C15O3366C17O3382C21O3685C22O3701C26O3709C27O3723C31O3733C32O3748C36O3760C37O3771C41O3782C42O3803C46O3814C47O3835C51O3845C52O3881C56O3892C57O3915C61O3925C62O3958C66O3968C67O3982C71O3993C72O4017C76O4028C77O4049C81O4060C82O4076C86O4088C87O4108C91O4118C92O4132C96O4142C98O4156C102O4164C104O4169C108O4181C112O4193C113O4207C117O4218C118O4235C122O4246C124O4251C128O4260C132O4267C133O4280C137O4292C138O4304C142O4314C143O4327C147O4337C149O4342C153O4355C157O4366C158O4389C162O4397C164O4419C166O4417C171O4424,,
code-creation,LazyCompile,10,171167,0xa12169e1fa6,48,validateHost node:_http_client:90:22,0x2cbd764afb48,~
code-source-info,0xa12169e1fa6,154,2891,3163,C0O2908C14O2983C24O3025C39O2989C44O2983C45O3149C47O3161,,
code-creation,LazyCompile,10,171209,0xa12169e21de,114,getTimerDuration node:internal/timers:383:26,0x2b48e0c70ef0,~
code-source-info,0xa12169e21de,12,11360,11863,C0O11378C5O11378C10O11409C11O11419C18O11427C21O11427C27O11456C43O11462C48O11456C49O11582C51O11594C53O11592C58O11613C61O11621C68O11636C81O11750C93O11687C100O11621C106O11821C110O11840C111O11848C113O11861,,
code-creation,LazyCompile,10,171250,0xa12169e235e,16,checkIsHttpToken node:_http_common:221:26,0x2cbd764b3c48,~
code-source-info,0xa12169e235e,155,6924,6981,C0O6934C7O6961C10O6941C15O6979,,
tick,0x1bfb84cb0,171250,0,0x0,3,0x0,0xa12169dd432,0xa12169dc912,0xa12169d6e9d,0xa12169d6940,0xa12169d647e,0xa12169d60d3,0xa12169d5f76
code-creation,LazyCompile,10,171292,0xa12169e2e5e,46,getHeader node:_http_outgoing:590:57,0x2cbd764ba2c0,~
code-source-info,0xa12169e2e5e,158,18066,18270,C0O18077C8O18077C13O18126C15O18131C17O18130C21O18147C23O18173C24O18180C25O18198C27O18206C30O18206C34O18205C38O18243C42O18264C45O18268,,
code-creation,LazyCompile,10,171334,0xa12169e2ffe,113,setHeader node:_http_outgoing:574:57,0x2cbd764ba270,~
code-source-info,0xa12169e2ffe,158,17664,18006,C0O17691C6O17706C16O17712C21O17706C22O17752C27O17752C31O17780C36O17780C41O17831C43O17836C45O17835C49O17852C51O17878C53O17883C58O17908C63O17908C68O17896C72O17931C74O17939C77O17939C91O17976C100O17982C106O17973C110O17992C112O18004,,
code-creation,LazyCompile,10,171334,0xa12169e318e,42, node:_http_outgoing:558:44,0x2cbd764ba1d0,~
code-source-info,0xa12169e318e,158,17140,17286,C0O17154C8O17187C12O17196C15O17196C21O17226C34O17232C39O17226C41O17285,,
code-creation,RegExp,3,171375,0x10511f4a0,1240,^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$
code-creation,LazyCompile,10,171375,0xa12169e341e,68, node:_http_outgoing:564:45,0x2cbd764ba220,~
code-source-info,0xa12169e341e,158,17334,17604,C0O17355C4O17386C17O17392C22O17386C23O17446C28O17450C34O17487C42O17487C47O17547C60O17553C65O17547C67O17603,,
code-creation,LazyCompile,10,171417,0xa12169e3556,16,checkInvalidHeaderChar node:_http_common:232:32,0x2cbd764b3c98,~
code-source-info,0xa12169e3556,155,7274,7335,C0O7284C7O7311C10O7291C15O7333,,
code-creation,LazyCompile,10,171459,0xa12169e386e,589,addRequest node:_http_agent:242:49,0x2cbd764ab350,~
code-source-info,0xa12169e386e,153,7674,9817,C0O7674C13O7845C19O7884C26O7931C32O7946C38O7958C47O7985C58O8017C65O8034C77O8059C83O8098C87O8088C91O8126C97O8148C104O8159C109O8171C117O8192C122O8190C126O8243C129O8248C134O8248C140O8268C143O8278C150O8285C155O8299C158O8304C163O8312C165O8318C169O8351C172O8356C179O8367C183O8381C185O8391C189O8433C196O8454C200O8458C206O8477C213O8477C217O8414C220O8521C223O8535C230O8546C239O8565C242O8565C252O8606C255O8606C260O8659C266O8673C269O8685C276O8697C278O8727C282O8753C290O8783C293O8798C300O8805C304O8812C308O8791C312O8823C316O8841C321O8841C325O8871C328O8876C336O8876C342O8906C356O8906C361O8947C371O8971C378O8978C382O8947C389O9004C392O9023C396O9016C404O9055C412O9079C416O9072C421O9102C437O9102C442O9200C445O9205C453O9223C461O9205C468O9380C478O9380C482O9465C485O9475C492O9483C497O9499C500O9504C505O9513C507O9519C511O9609C518O9613C523O9630C527O9696C534O9700C541O9729C549O9725C554O9723C558O9766C568O9790C575O9798C582O9766C588O9816,,
code-creation,LazyCompile,10,171542,0xa12169e3d7e,150,calculateServerName node:_http_agent:345:29,0x2cbd764ab0e8,~
code-source-info,0xa12169e3d7e,153,10778,11570,C0O10822C5O10853C13O10853C19O10874C21O10896C29O10896C34O11037C42O11041C49O11107C57O11107C63O11154C65O11164C70O11242C77O11290C87O11346C94O11303C102O11379C116O11392C123O11432C127O11501C132O11509C137O11509C144O11531C147O11550C149O11568,,
code-creation,LazyCompile,10,171542,0xa12169e3f16,26,isIP node:internal/net:39:14,0x120d4438a690,~
code-source-info,0xa12169e3f16,114,1142,1215,C0O1150C3O1154C9O1165C11O1174C12O1177C15O1181C21O1192C23O1201C24O1204C25O1213,,
code-creation,LazyCompile,10,171584,0xa12169e4256,16,isIPv4 node:internal/net:31:16,0x120d4438a5f0,~
code-source-info,0xa12169e4256,114,1012,1061,C0O1020C7O1047C10O1027C15O1059,,
code-creation,LazyCompile,10,171625,0xa12169e4346,16,isIPv6 node:internal/net:35:16,0x120d4438a640,~
code-source-info,0xa12169e4346,114,1078,1127,C0O1086C7O1113C10O1093C15O1125,,
code-creation,LazyCompile,10,172000,0xa12169e4506,589,getName node:https:206:43,0x29d5d5b8e7b8,~
code-source-info,0xa12169e4506,162,5668,7366,C4O5668C10O5698C17O5720C20O5730C25O5740C36O5698C42O5768C51O5795C57O5819C68O5826C77O5853C83O5879C94O5888C103O5915C109O5953C120O5974C129O6001C135O6030C146O6042C155O6069C161O6094C172O6102C181O6129C187O6154C198O6162C207O6189C213O6243C224O6266C233O6293C239O6315C244O6338C248O6326C253O6364C264O6379C273O6406C279O6438C290O6453C299O6480C305O6512C316O6527C325O6554C331O6590C342O6609C351O6636C357O6661C368O6669C377O6696C383O6748C394O6769C403O6796C409O6827C420O6841C429O6868C435O6897C446O6909C455O6936C461O6985C472O7003C481O7030C487O7068C498O7089C507O7116C513O7129C515O7137C518O7159C523O7137C534O7172C543O7199C549O7241C560O7266C569O7293C575O7331C586O7352C588O7364,,
code-creation,LazyCompile,10,172042,0xa12169e492e,140,getName node:_http_agent:220:43,0x2cbd764ab300,~
code-source-info,0xa12169e492e,153,7151,7623,C4O7151C10O7189C19O7213C28O7240C34O7266C45O7275C54O7302C60O7336C71O7469C78O7476C83O7493C90O7500C95O7511C98O7531C113O7556C119O7572C122O7592C137O7609C139O7621,,
code-creation,LazyCompile,10,172084,0xa12169e4b0e,10, node:_http_agent:47:64,0x2cbd764ab260,~
code-source-info,0xa12169e4b0e,153,1693,1718,C0O1705C2O1711C9O1717,,
code-creation,LazyCompile,10,172084,0xa12169e4cf6,220,createSocket node:_http_agent:313:53,0x2cbd764ab3a0,~
code-source-info,0xa12169e4cf6,153,9872,10747,C0O9872C20O9895C31O9927C38O9944C49O9903C51O9957C54O9969C60O9985C66O10008C70O9998C74O10023C77O10036C86O10058C93O10069C98O10081C109O10102C114O10100C118O10153C121O10158C129O10158C134O10153C136O10178C141O10196C145O10207C161O10207C166O10251C170O10268C174O10296C186O10296C191O10656C194O10661C202O10661C209O10700C211O10719C213O10719C219O10746,,
code-creation,LazyCompile,10,172125,0xa12169e4fc6,20,once node:internal/util:438:14,0x232faba024c0,~
code-source-info,0xa12169e4fc6,16,12352,12505,C0O12352C12O12380C13O12380C15O12389C19O12503,,
code-creation,LazyCompile,10,172167,0xa12169e527e,271,createConnection node:https:111:26,0x29d5d5b8e628,~
code-source-info,0xa12169e527e,162,3468,4540,C0O3468C13O3494C23O3547C25O3555C29O3572C39O3625C43O3633C47O3657C57O3716C58O3724C62O3745C69O3753C71O3778C77O3814C82O3827C86O3842C92O3878C97O3891C101O3906C114O3906C119O3945C122O3957C128O3990C131O3995C139O4015C144O3995C150O4031C152O4052C165O4090C170O4052C175O4108C182O4128C192O4148C198O4116C200O4193C207O4197C215O4197C221O4218C224O4230C230O4289C243O4289C249O4422C262O4422C268O4524C270O4538,,
code-creation,LazyCompile,10,172209,0xa12169e553e,10, node:https:47:65,0x29d5d5b8e768,~
code-source-info,0xa12169e553e,162,1736,1761,C0O1748C2O1754C9O1760,,
code-creation,LazyCompile,10,172209,0xa12169e5616,16,_getSession node:https:292:51,0x29d5d5b8e808,~
code-source-info,0xa12169e5616,162,7419,7466,C0O7441C5O7455C12O7458C15O7464,,
code-creation,LazyCompile,10,172292,0xa12169e5bae,568,connect node:_tls_wrap:1599:35,0x29d5d5bace10,~
code-source-info,0xa12169e5bae,169,46839,49634,C0O46839C3O46853C6O46860C11O46904C12O46908C16O46926C18O46930C22O46963C27O46963C31O46990C38O47027C45O47059C48O47063C58O47105C61O47109C75O47158C82O47187C88O47202C89O47220C93O47231C98O47253C105O47231C109O47292C114O47314C124O47395C128O47385C132O47292C137O47409C142O47424C148O47434C155O47514C159O47495C163O47409C168O47553C176O47570C179O47574C184O47574C190O47623C193O47645C203O47682C211O47717C223O47742C227O47827C233O47846C241O47878C249O47914C257O47954C265O47992C273O48030C281O48070C289O48105C297O48133C307O47623C313O48564C319O48583C323O48554C327O48597C329O48605C334O48622C338O48636C342O48656C350O48656C356O48699C362O48867C368O48892C373O48911C378O48892C383O48940C388O48965C393O48940C399O48989C404O48989C408O49023C414O49044C419O49063C424O49044C429O49088C435O49106C443O49133C446O49137C451O49150C456O49137C463O49171C466O49179C476O49267C486O49179C491O49395C495O49414C501O49440C506O49462C511O49440C516O49494C522O49514C527O49514C531O49535C542O49535C548O49576C559O49576C565O49617C567O49632,,
code-creation,LazyCompile,10,172334,0xa12169e608e,139,normalizeConnectArgs node:_tls_wrap:1499:30,0x29d5d5babe08,~
code-source-info,0xa12169e608e,169,43202,43901,C0O43230C5O43234C10O43234C16O43278C17O43282C21O43300C23O43304C27O43639C29O43651C36O43682C43O43706C50O43736C54O43706C61O43751C63O43763C70O43794C77O43818C84O43848C88O43818C93O43861C106O43874C115O43883C132O43890C138O43899,,
code-creation,LazyCompile,10,172334,0xa12169e6396,74,getAllowUnauthorized node:internal/options:48:30,0x3172a1b0a468,~
code-source-info,0xa12169e6396,97,1176,1612,C0O1209C3O1217C8O1221C15O1250C19O1262C23O1287C27O1318C31O1342C37O1355C40O1363C50O1426C56O1489C62O1541C66O1363C71O1585C73O1610,,
tick,0x100efaf8c,172500,1,0x1004cac6c,6,0x0,0x1208b70bb8d,0x1208b70b40e,0xa12169e5c66,0xa12169e5355,0xa12169e4dc0,0xa12169e3a3b,0xa12169dd906,0xa12169dc912,0xa12169d6e9d,0xa12169d6940,0xa12169d647e,0xa12169d60d3,0xa12169d5f76
code-creation,LazyCompile,10,172917,0xa12169e6986,438,TLSSocket node:_tls_wrap:464:19,0x29d5d5bab9a8,~
code-source-info,0xa12169e6986,169,12885,15172,C0O12923C5O12967C10O12983C13O13014C18O13043C22O13063C26O13089C30O13106C36O13120C39O13128C49O13193C53O13128C60O13265C68O13265C73O13340C79O13359C84O13363C89O13395C94O13363C100O13426C102O13443C106O13459C107O13483C111O13494C112O13514C116O13525C117O13549C121O13560C122O13582C126O13593C127O13615C131O13625C132O13643C136O13653C137O13669C141O13679C142O13697C146O13707C147O13723C151O13734C152O13758C156O13768C158O13773C162O13779C166O13789C168O13794C172O13807C176O13818C178O13823C182O13840C186O13855C188O13863C190O13886C193O13890C197O13875C202O13907C210O13920C212O14028C219O14329C226O14336C232O14466C233O14481C237O14492C244O14505C247O14509C264O14543C269O14543C283O14581C285O14597C291O14624C299O14669C307O14738C317O14766C319O14786C330O14824C347O14492C352O14891C356O14884C360O14931C368O14948C373O14931C379O14968C384O14968C390O14992C394O15016C400O15034C405O15042C410O15042C414O15129C417O15137C431O15137C437O15171,,
code-creation,LazyCompile,10,173000,0xa12169e6f06,256,TLSSocket._wrapHandle node:_tls_wrap:596:43,0x29d5d5babfe8,~
code-source-info,0xa12169e6f06,169,16814,17809,C0O16829C2O16840C6O16868C11O16901C16O16916C20O16952C28O16969C33O16974C36O16988C43O16965C52O17008C57O17012C60O17025C67O17004C73O17038C75O17045C80O17059C84O17124C90O17167C98O17200C101O17204C106O17204C112O17236C117O17250C125O17236C130O17312C137O17331C139O17320C144O17359C154O17365C159O17359C160O17423C165O17432C170O17453C175O17472C185O17432C191O17485C193O17497C197O17555C199O17571C203O17628C205O17647C209O17681C213O17672C217O17692C219O17697C224O17703C228O17712C231O17712C236O17755C247O17755C253O17796C255O17807,,
code-creation,LazyCompile,10,173084,0xa12169e7346,50,defineHandleReading node:_tls_wrap:633:29,0x29d5d5baba70,~
code-source-info,0xa12169e7346,169,17976,18169,C0O17976C9O17997C19O18018C24O18048C32O18107C43O17997C49O18168,,
code-creation,LazyCompile,10,173209,0xa12169e7bb6,921,TLSSocket._init node:_tls_wrap:669:37,0x29d5d5bac0c8,~
code-source-info,0xa12169e7bb6,169,18846,23566,C0O18846C15O18881C18O18886C23O18913C26O18918C31O18929C34O18951C38O18941C42O18962C52O18996C70O19049C73O18962C78O19206C86O19230C92O19279C99O19302C104O19320C108O19337C113O19362C117O19386C123O19405C125O19433C130O19433C136O19540C140O19553C144O19567C147O19572C158O19572C164O19956C170O19972C174O19993C178O20017C182O20037C186O20060C190O20078C194O20097C198O20110C202O20125C206O20142C210O20162C211O20184C215O20193C216O20208C220O20218C223O20227C229O20243C232O20252C237O20259C245O20259C252O20290C260O20312C265O20319C273O20319C280O20347C285O20431C290O20431C294O20471C297O20480C302O20487C310O20487C317O20516C322O20533C327O20533C343O20570C347O20593C349O20591C353O20603C357O20623C361O20709C365O20728C369O20763C375O20782C380O20801C385O20782C390O20816C394O20833C398O20923C403O20928C414O20928C422O21309C430O21330C438O21359C444O21375C452O21390C457O21398C467O21463C475O21517C477O21515C481O21398C486O21539C489O21544C502O21544C508O21871C512O21883C516O22041C522O22067C528O22097C537O22109C542O22144C548O22162C553O22169C558O22179C564O22195C571O22217C578O22195C582O22250C585O22278C589O22268C593O22299C598O22299C602O22334C608O22414C613O22450C617O22440C621O22473C626O22494C631O22509C636O22473C641O22541C647O22560C653O22585C660O22610C668O22585C673O22644C677O22648C680O22674C699O22664C703O22739C710O22744C713O22768C717O22758C721O22789C726O22789C730O22827C736O22852C743O22875C751O22852C756O22930C761O22957C766O22930C771O23001C777O23018C782O23027C785O23032C790O23051C798O23074C803O23032C809O23094C813O23116C816O23120C820O23105C825O23134C830O23147C834O23240C837O23265C843O23287C848O23256C852O23307C865O23307C871O23433C875O23454C888O23454C896O23516C905O23524C907O23516C911O23537C915O23553C920O23565,,
code-creation,LazyCompile,10,173292,0xa12169e82ee,10, node:_tls_wrap:57:63,0x29d5d5babef8,~
code-source-info,0xa12169e82ee,169,1942,1967,C0O1954C2O1960C9O1966,,
code-creation,LazyCompile,10,173292,0xa12169e8466,50,keylogNewListener node:_tls_wrap:693:29,0xa12169e76f0,~
code-source-info,0xa12169e8466,169,19639,19940,C0O19653C2O19663C7O19683C8O19690C9O19762C15O19771C16O19778C17O19788C22O19796C27O19796C31O19887C42O19887C49O19939,,
code-creation,LazyCompile,10,173334,0xa12169e85ae,19,_getMaxListeners node:events:404:26,0x232faba26968,~
code-source-info,0xa12169e85ae,23,11869,11993,C0O11889C6O11922C9O11942C13O11962C14O11977C18O11991,,
code-creation,LazyCompile,10,173375,0xa12169e876e,176,setStreamTimeout node:internal/stream_base_commons:237:26,0x3beccacc0a0,~
code-source-info,0xa12169e876e,88,6046,6807,C0O6077C6O6092C8O6104C9O6108C11O6121C15O6181C23O6189C30O6360C37O6378C39O6377C43O6360C47O6393C48O6403C53O6416C57O6452C62O6452C66O6491C74O6491C82O6549C84O6554C89O6566C92O6587C97O6598C102O6598C108O6566C113O6564C117O6622C119O6631C121O6630C126O6642C128O6647C130O6646C136O6657C138O6656C142O6670C146O6679C150O6715C155O6715C159O6754C167O6754C173O6793C175O6805,,
code-creation,LazyCompile,10,173417,0xa12169e898e,63,clearTimeout node:timers:184:22,0x174551ed3628,~
code-source-info,0xa12169e898e,47,5184,5529,C0O5196C4O5215C10O5233C11O5250C15O5262C18O5262C22O5283C23O5290C24O5297C36O5385C43O5400C47O5413C49O5454C50O5479C54O5493C57O5493C62O5528,,
code-creation,LazyCompile,10,173417,0xa12169e8ace,48,setUnrefTimeout node:internal/timers:372:25,0x2b48e0c70e80,~
code-source-info,0xa12169e8ace,12,11046,11268,C0O11113C5O11113C9O11158C26O11158C32O11215C35O11235C40O11215C45O11253C47O11266,,
code-creation,LazyCompile,10,173459,0xa12169e8d3e,337,Socket.connect node:net:959:36,0x120d44383750,~
code-source-info,0xa12169e8d3e,113,25241,26683,C0O25241C3O25259C5O25551C11O25572C15O25555C22O25584C28O25588C30O25587C35O25617C36O25634C42O25654C45O25667C50O25710C51O25720C55O25738C57O25748C61O25818C67O25848C74O25866C86O25872C91O25866C92O25935C100O25952C105O25962C109O25941C114O25973C117O25993C122O26003C126O25984C130O26022C136O26039C137O26052C141O26064C142O26079C146O26091C147O26106C151O26129C156O26162C159O26172C173O26172C178O26212C184O26227C189O26242C193O26259C198O26264C201O26278C208O26255C217O26298C222O26302C225O26315C232O26294C237O26240C241O26328C244O26328C248O26359C252O26387C260O26387C266O26420C271O26420C275O26438C276O26454C280O26465C284O26481C292O26481C297O26523C304O26562C306O26561C319O26523C326O26630C329O26630C334O26669C336O26681,,
code-creation,LazyCompile,10,173500,0xa12169e91ce,322,arrayClone node:events:879:20,0x232faba27230,~
code-source-info,0xa12169e91ce,23,25201,25655,C0O25340C42O25362C50O25373C62O25381C71O25386C72O25399C80O25410C92O25418C104O25426C113O25431C114O25444C122O25455C134O25463C146O25471C158O25479C167O25484C168O25497C176O25508C188O25516C200O25524C212O25532C224O25540C233O25545C234O25558C242O25569C254O25577C266O25585C278O25593C290O25601C302O25609C311O25614C312O25621C317O25628C321O25653,,
code-creation,LazyCompile,10,173542,0xa12169e946e,50,newListener node:_tls_wrap:739:25,0xa12169e7740,~
code-source-info,0xa12169e946e,169,20985,21301,C0O21001C2O21011C7O21034C8O21041C9O21119C15O21128C16O21135C17O21147C22O21155C27O21155C31O21252C42O21252C49O21300,,
code-creation,LazyCompile,10,173542,0xa12169e959e,28,Timeout.refresh node:internal/timers:210:37,0x2b48e0c70800,~
code-source-info,0xa12169e959e,12,7082,7172,C0O7089C2O7098C4O7097C9O7111C12O7111C18O7136C21O7136C25O7158C27O7170,,
code-creation,LazyCompile,10,173584,0xa12169e9686,12,unrefActive node:internal/timers:317:21,0x2b48e0c70d90,~
code-source-info,0xa12169e9686,12,9590,9630,C0O9601C5O9601C11O9629,,
code-creation,LazyCompile,10,173584,0xa12169e978e,126,insertGuarded node:internal/timers:325:23,0x2b48e0c70de0,~
code-source-info,0xa12169e978e,12,9873,10367,C0O9917C5O9933C6O9943C15O9975C16O9982C17O9986C29O9986C34O10042C39O10056C43O10081C45O10080C50O10105C51O10121C55O10134C61O10134C66O10177C70O10200C74O10217C77O10217C82O10241C84O10261C86O10260C90O10251C95O10276C99O10293C102O10293C107O10323C110O10323C113O10344C115O10349C120O10357C125O10366,,
code-creation,LazyCompile,10,173667,0xa12169e9c5e,526,lookupAndConnect node:net:1017:26,0x120d44382270,~
code-source-info,0xa12169e9c5e,113,26712,29567,C0O26712C34O26768C37O26740C43O26754C49O26792C52O26800C60O26792C62O26838C65O26829C71O26850C79O26871C85O26871C91O26897C103O26903C108O26897C109O26952C113O26973C126O26973C131O27028C137O27067C149O27133C169O27139C174O27133C175O27256C185O27256C189O27282C194O27287C196O27364C206O27364C210O27364C212O27378C216O27401C230O27433C232O27432C241O27459C251O27401C256O27688C257O27695C258O27703C261O27715C267O27741C277O27766C285O27741C290O27796C298O27819C306O27825C315O27823C323O27859C331O27881C342O27908C355O27859C357O27927C368O27959C375O27966C383O27989C390O27996C398O28019C404O28025C409O28038C416O28054C419O28058C423O28052C427O28077C440O28077C445O28114C458O28114C463O28156C468O28167C472O28192C475O28200C485O28210C488O28214C492O28192C494O28224C508O28256C510O28255C519O28224C525O29566,,
code-creation,RegExp,3,173709,0x10511f9e0,2936,^((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$
tick,0x1bfd8d0fc,173792,0,0x0,0,0x0,0x100d5a448,0xa12169e4260,0xa12169e3f19,0xa12169e9d2c,0xa12169e8e87,0xa12169e5d37,0xa12169e5355,0xa12169e4dc0,0xa12169e3a3b,0xa12169dd906,0xa12169dc912,0xa12169d6e9d,0xa12169d6940,0xa12169d647e,0xa12169d60d3,0xa12169d5f76
code-creation,RegExp,3,174042,0x1051205c0,35808,^((?:(?:[0-9a-fA-F]{1\x2C4}):){7}(?:(?:[0-9a-fA-F]{1\x2C4})|:)|(?:(?:[0-9a-fA-F]{1\x2C4}):){6}(?:((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|:(?:[0-9a-fA-F]{1\x2C4})|:)|(?:(?:[0-9a-fA-F]{1\x2C4}):){5}(?::((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(?:[0-9a-fA-F]{1\x2C4})){1\x2C2}|:)|(?:(?:[0-9a-fA-F]{1\x2C4}):){4}(?:(:(?:[0-9a-fA-F]{1\x2C4})){0\x2C1}:((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(?:[0-9a-fA-F]{1\x2C4})){1\x2C3}|:)|(?:(?:[0-9a-fA-F]{1\x2C4}):){3}(?:(:(?:[0-9a-fA-F]{1\x2C4})){0\x2C2}:((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(?:[0-9a-fA-F]{1\x2C4})){1\x2C4}|:)|(?:(?:[0-9a-fA-F]{1\x2C4}):){2}(?:(:(?:[0-9a-fA-F]{1\x2C4})){0\x2C3}:((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(?:[0-9a-fA-F]{1\x2C4})){1\x2C5}|:)|(?:(?:[0-9a-fA-F]{1\x2C4}):){1}(?:(:(?:[0-9a-fA-F]{1\x2C4})){0\x2C4}:((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(:(?:[0-9a-fA-F]{1\x2C4})){1\x2C6}|:)|(?::((?::(?:[0-9a-fA-F]{1\x2C4})){0\x2C5}:((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|(?::(?:[0-9a-fA-F]{1\x2C4})){1\x2C7}|:)))(%[0-9a-zA-Z-.:]{1\x2C})?$
code-creation,LazyCompile,10,174125,0xa12169ea13e,27, node:net:1073:61,0xa12169e9a50,~
code-source-info,0xa12169ea13e,113,28282,29563,C0O28291C7O28298C12O28304C20O28291C26O29562,,
code-creation,LazyCompile,10,174167,0xa12169ea3ce,548,lookup node:dns:98:16,0x2811abd37da0,~
code-source-info,0xa12169ea3ce,192,2791,4995,C0O2837C2O2855C5O2871C7O2895C12O2895C16O2941C20O2961C28O2961C33O3006C39O3047C42O3071C46O3098C51O3098C55O3131C65O3204C72O3236C80O3266C85O3266C88O3334C92O3340C96O3365C103O3398C111O3429C116O3429C119O3498C123O3505C127O3530C134O3560C142O3589C147O3589C150O3655C156O3659C160O3694C168O3747C174O3756C180O3791C187O3819C192O3819C195O3872C200O3872C206O3913C217O3975C222O3975C225O4027C227O4044C231O4064C239O4078C247O4064C252O4111C256O4132C261O4132C265O4174C269O4191C272O4199C279O4208C285O4199C292O4248C295O4256C306O4294C321O4256C326O4320C327O4330C328O4360C333O4360C338O4378C340O4403C344O4420C347O4428C354O4446C368O4474C374O4492C390O4428C397O4530C400O4538C416O4538C421O4599C422O4609C423O4629C428O4629C434O4657C436O4670C440O4684C442O4695C446O4707C448O4720C452O4734C457O4751C465O4749C469O4796C474O4802C481O4824C484O4824C501O4802C507O4874C509O4889C512O4897C519O4916C531O4916C537O4897C543O4965C544O4975C545O4982C547O4993,,
code-creation,LazyCompile,10,174209,0xa12169ea806,12,getDefaultVerbatim node:internal/dns/utils:207:28,0x2811abd3a320,~
code-source-info,0xa12169ea806,193,5168,5209,C0O5175C7O5191C11O5207,,
code-creation,LazyCompile,10,174250,0xa12169ea90e,53,validateHints node:internal/dns/utils:174:23,0x2811abd3a230,~
code-source-info,0xa12169ea90e,193,4234,4367,C0O4246C2O4261C7O4277C9O4275C15O4286C17O4284C20O4259C22O4257C27O4300C32O4313C45O4319C50O4313C52O4366,,
code-creation,LazyCompile,10,174250,0xa12169eaa96,34,TLSSocket._releaseControl node:_tls_wrap:912:47,0x29d5d5bac4a8,~
code-source-info,0xa12169eaa96,169,25797,25945,C0O25813C6O25835C7O25848C8O25851C9O25873C13O25888C21O25917C26O25888C32O25931C33O25943,,
code-creation,LazyCompile,10,174292,0xa12169eabd6,52,TLSSocket.setServername node:_tls_wrap:970:45,0x29d5d5bac650,~
code-source-info,0xa12169eabd6,169,27619,27779,C0O27630C8O27630C13O27672C18O27684C24O27700C29O27706C34O27700C35O27749C40O27757C45O27757C51O27778,,
code-creation,LazyCompile,10,174292,0xa12169eacee,20,prependListener node:events:632:29,0x232faba26cf0,~
code-source-info,0xa12169eacee,23,18620,18699,C0O18645C14O18652C19O18693,,
code-creation,LazyCompile,10,174334,0xa12169eade6,47,spliceOne node:internal/util:394:19,0x232faba023d8,~
code-source-info,0xa12169eade6,16,10925,11034,C0O10960C2O10956C6O10967C10O10960C15O10988C17O11013C20O11006C23O11000C27O10980C33O10943C36O11026C41O11026C46O11033,,
code-creation,LazyCompile,10,174375,0xa12169eb046,44, node:internal/util:440:18,0xa12169e4f20,~
code-source-info,0xa12169eb046,16,12404,12502,C0O12404C3O12420C9O12432C10O12439C11O12444C15O12451C21O12463C37O12463C43O12501,,
code-creation,LazyCompile,10,174375,0xa12169eb17e,169, node:_http_agent:327:25,0xa12169e4bf0,~
code-source-info,0xa12169eb17e,153,10301,10632,C0O10319C4O10334C7O10341C11O10349C12O10354C15O10364C22O10372C24O10371C29O10387C32O10392C39O10400C44O10406C48O10422C58O10446C65O10454C67O10453C71O10422C76O10469C85O10490C89O10498C101O10515C107O10526C114O10534C116O10533C120O10540C128O10553C133O10498C138O10576C152O10576C157O10616C162O10616C168O10631,,
code-creation,LazyCompile,10,174417,0xa12169eb56e,167,installListeners node:_http_agent:373:26,0x2cbd764ab138,~
code-source-info,0xa12169eb56e,153,11597,13059,C0O11597C41O11718C44O11720C55O11720C61O12069C64O12071C75O12071C81O12443C84O12445C95O12445C101O12958C104O12960C115O12960C121O12992C128O13002C130O13001C135O13020C138O13022C153O13041C155O13040C159O13022C166O13058,,
code-creation,Function,11,174459,0x105129200,2696,_addListener node:events:555:22,0x232faba26b88,^
code-source-info,0x105129200,23,16167,18039,,,
code-creation,Function,11,174500,0x105129d00,328,normalizeEncoding node:internal/util:160:27,0x232faba01e78,^
code-source-info,0x105129d00,16,4206,4311,,,
code-creation,Function,11,174500,0x105129ec0,648,createUnsafeBuffer node:internal/buffer:1059:28,0x232faba3ee30,^
code-source-info,0x105129ec0,25,30321,30430,,,
code-creation,Function,11,174500,0x10512a1c0,136,SafeIterator node:internal/per_context/primordials:279:16,0x2b48e0c498a8,^
code-source-info,0x10512a1c0,6,7920,7980,,,
code-creation,Function,11,174542,0x10512a2c0,136,isEmpty node:internal/fixed_queue:67:10,0x815de614458,^
code-source-info,0x10512a2c0,34,3084,3129,,,
code-creation,Function,11,174542,0x10512a3c0,392,_onceWrap node:events:646:19,0x232faba26db0,^
code-source-info,0x10512a3c0,23,18986,19209,,,
code-creation,Function,11,174542,0x10512a5c0,272,once node:events:660:44,0x232faba26e00,^
code-source-info,0x10512a5c0,23,19413,19526,,,
code-creation,LazyCompile,10,174584,0xa12169ebe16,41, node:_http_agent:291:37,0xa12169e3678,~
code-source-info,0xa12169ebe16,153,9232,9362,C0O9257C4O9274C7O9278C12O9278C20O9320C34O9320C40O9361,,
code-creation,LazyCompile,10,174584,0xa12169ebf36,60,setRequestSocket node:_http_agent:514:26,0x2cbd764ab1c0,~
code-source-info,0xa12169ebf36,153,15790,16006,C0O15819C5O15819C10O15866C15O15874C23O15898C29O15927C36O15935C41O15959C42O15966C43O15980C48O15995C53O15980C59O16005,,
code-creation,LazyCompile,10,174625,0xa12169ec06e,27,onSocket node:_http_client:778:53,0x2cbd764b0408,~
code-source-info,0xa12169ec06e,154,23202,23356,C0O23306C3O23314C20O23314C26O23355,,
code-creation,LazyCompile,10,174667,0xa12169ec2be,200,unenroll node:timers:78:18,0x174551ed34d0,~
code-source-info,0xa12169ec2be,47,2349,3516,C0O2369C6O2385C7O2392C8O2396C9O2412C13O2423C15O2432C17O2431C22O2452C29O2480C31O2479C36O2565C41O2569C48O2597C50O2596C55O2633C62O2650C64O2649C68O2633C72O2672C77O2674C82O2674C87O3044C89O3053C91O3052C96O3128C101O3143C106O3128C111O3175C118O3187C122O3200C126O3226C129O3228C134O3228C141O3251C149O3251C153O3288C158O3303C163O3317C168O3303C173O3347C178O3372C184O3391C189O3391C192O3491C194O3509C199O3515,,
code-creation,LazyCompile,10,174750,0xa12169ec6ae,473,end node:_http_outgoing:833:45,0x2cbd764ba728,~
code-source-info,0xa12169ec6ae,158,24416,26189,C0O24448C6O24487C9O24509C12O24527C17O24553C23O24595C26O24620C29O24644C33O24670C39O24688C44O24720C47O24716C64O24797C71O24688C76O24820C78O24832C79O24853C85O24874C90O24881C95O24881C99O24900C115O24900C122O24961C128O24977C134O25031C140O25064C148O25064C156O25111C158O25124C166O25120C172O25111C176O25179C178O25191C179O25211C185O25235C191O25256C196O25263C201O25263C205O25282C206O25302C210O25316C215O25316C219O25342C225O25387C233O25387C239O25431C242O25440C249O25440C256O25475C262O25492C268O25520C276O25541C280O25534C286O25550C299O25520C306O25598C312O25618C320O25636C322O25654C339O25654C346O25698C349O25706C354O25706C359O25740C365O25800C370O25807C377O25829C381O25843C386O25850C391O25850C395O25866C397O25871C401O25880C405O25888C406O25902C410O26014C418O26014C422O26057C427O26068C433O26075C438O26095C444O26116C449O26123C456O26136C461O26157C466O26157C470O26175C472O26187,,
code-creation,LazyCompile,10,174792,0xa12169ecaae,68,_implicitHeader node:_http_client:342:67,0x2cbd764b0318,~
code-source-info,0xa12169ecaae,154,10865,11053,C0O10881C6O10896C16O10902C21O10896C22O10950C27O10968C34O10975C38O10988C42O10981C48O10993C54O11037C56O11036C60O10950C67O11052,,
code-creation,LazyCompile,10,174875,0xa12169ecfd6,808,_storeHeader node:_http_outgoing:374:22,0x2cbd764b97e0,~
code-source-info,0xa12169ecfd6,158,11051,15500,C0O11221C7O11349C14O11367C18O11386C20O11407C22O11406C25O11398C30O11447C44O11440C57O11440C58O11480C60O11487C64O11502C69O11534C76O11544C90O11502C99O11429C104O11576C109O11580C115O11623C123O11633C127O11653C131O11633C137O11682C139O11697C143O11687C148O11736C150O11743C154O11758C158O11790C165O11800C179O11758C184O11706C189O11669C194O11857C198O11864C203O11868C208O11887C221O11893C226O11887C227O11972C229O11987C233O11977C238O12015C243O12052C246O12049C253O12068C256O12065C270O12015C275O11997C281O11959C286O12136C300O12129C313O12129C314O12155C320O12159C327O12216C333O12255C350O12216C359O12118C362O12306C367O12353C373O12372C379O12384C384O12405C388O12405C391O12403C397O12415C407O13006C413O13031C422O13042C427O13089C436O13100C441O13116C446O13127C453O13138C459O13185C463O13116C467O13226C468O13247C472O13260C473O13281C477O13328C483O13354C484O13365C488O13377C489O13398C495O13427C501O13478C507O13512C513O13528C519O13564C524O13576C526O13608C532O13648C543O13694C547O13727C556O13782C562O13808C568O13860C573O13875C577O13893C584O13860C589O13910C594O13943C613O13992C614O14003C618O14017C627O14076C633O14094C639O14114C645O14205C646O14226C652O14256C658O14293C659O14304C665O14334C671O14366C677O14412C685O14449C688O14485C692O14478C698O14500C710O14531C716O14551C725O14601C726O14622C732O14841C740O14841C744O15192C750O15208C755O15226C761O15241C766O15247C771O15241C772O15286C774O15308C777O15299C781O15320C782O15337C786O15475C792O15488C801O15488C807O15499,,
code-creation,LazyCompile,10,174917,0xa12169ed706,132,processHeader node:_http_outgoing:501:23,0x2cbd764b9830,~
code-source-info,0xa12169ed706,158,15524,16021,C0O15564C4O15582C9O15582C13O15609C18O15613C24O15650C31O15657C39O15665C45O15816C47O15829C51O15821C56O15850C61O15885C77O15850C82O15838C87O15803C90O15907C91O15914C92O15925C100O15933C107O15972C125O15972C131O16020,,
code-creation,LazyCompile,10,174959,0xa12169ed8b6,65,storeHeader node:_http_outgoing:517:21,0x2cbd764b9880,~
code-source-info,0xa12169ed8b6,158,16043,16222,C0O16083C4O16101C9O16101C14O16136C21O16156C27O16163C33O16171C39O16149C43O16183C58O16183C64O16221,,
code-creation,LazyCompile,10,175000,0xa12169edae6,194,matchHeader node:_http_outgoing:524:21,0x2cbd764b98d0,~
code-source-info,0xa12169edae6,158,16244,17095,C0O16286C7O16293C12O16306C19O16313C24O16323C25O16330C26O16333C31O16341C37O16378C91O16424C92O16441C96O16455C97O16479C101O16494C108O16518C111O16498C118O16549C119O16560C125O16587C126O16608C130O16622C132O16665C133O16674C137O16688C138O16704C142O16719C149O16743C152O16723C159O16774C160O16795C164O16809C166O16849C167O16863C171O16877C172O16898C176O16913C178O16982C179O16995C183O17009C185O17045C186O17068C190O17083C193O17094,,
code-creation,LazyCompile,10,175042,0xa12169edd8e,134,_send node:_http_outgoing:319:49,0x2cbd764ba180,~
code-source-info,0xa12169edd8e,158,9347,10080,C0O9588C6O9607C14O9657C21O9680C28O9697C30O9728C37O9736C44O9783C49O9803C54O9814C66O9838C70O9814C75O9913C80O9939C87O9929C91O9958C96O9980C101O9958C106O9999C107O10016C111O10042C128O10042C133O10078,,
code-creation,LazyCompile,10,175042,0xa12169edfee,175,_writeRaw node:_http_outgoing:344:19,0x2cbd764b9790,~
code-source-info,0xa12169edfee,158,10151,10972,C0O10200C5O10210C7O10227C13O10368C14O10381C15O10389C21O10431C24O10456C27O10480C31O10497C38O10510C43O10527C49O10614C54O10625C60O10646C65O10646C70O10721C87O10721C92O10753C93O10810C98O10821C110O10828C116O10834C122O10844C126O10821C131O10859C136O10883C143O10875C147O10898C152O10918C157O10898C162O10941C169O10954C171O10952C174O10970,,
code-creation,LazyCompile,10,175084,0xa12169ee1be,2,nop node:_http_outgoing:86:13,0x2cbd764b9b00,~
code-source-info,0xa12169ee1be,158,2808,2816,C1O2815,,
code-creation,LazyCompile,10,175125,0xa12169ee276,10, node:_http_outgoing:78:64,0x2cbd764b9ab0,~
code-source-info,0xa12169ee276,158,2680,2705,C0O2692C2O2698C9O2704,,
code-creation,LazyCompile,10,175125,0xa12169ee3d6,119,initRead node:_tls_wrap:440:18,0x29d5d5bab958,~
code-source-info,0xa12169ee3d6,169,12260,12789,C0O12284C8O12323C13O12335C29O12398C41O12430C45O12447C50O12284C55O12539C61O12552C62O12559C63O12629C67O12650C73O12676C75O12706C80O12706C87O12740C92O12748C97O12748C102O12685C105O12779C112O12779C118O12788,,
tick,0x1bfc4760c,175167,0,0x0,3,0x0,0xa12169ed8f0,0xa12169ed783,0xa12169ed030,0xa12169ecaea,0xa12169ec785,0xa12169d6ecf,0xa12169d6940,0xa12169d647e,0xa12169d60d3,0xa12169d5f76
code-creation,LazyCompile,10,175167,0xa12169ee5a6,71,Socket.read node:net:661:33,0x120d44382fb0,~
code-source-info,0xa12169ee5a6,113,17452,17630,C0O17460C2O17469C4O17468C9O17487C15O17506C21O17529C26O17537C32O17552C35O17552C39O17578C44O17592C49O17599C54O17609C59O17614C64O17614C70O17628,,
code-creation,LazyCompile,10,175250,0xa12169ee99e,671,Readable.read node:internal/streams/readable:402:35,0x174551ef42c8,~
code-source-info,0xa12169ee99e,57,12848,17608,C0O12856C8O12856C13O13003C17O13030C24O13048C29O13053C35O13079C43O13083C50O13131C55O13163C58O13255C62O13247C67O13274C70O13296C74O13294C78O13327C79O13333C84O13344C85O13366C89O13548C90O13554C95O13575C101O13605C107O13619C112O13641C117O13657C121O13648C126O13687C132O13694C137O13715C143O13729C151O13763C156O13777C161O13729C166O13799C172O13806C177O13821C183O13834C186O13834C192O13868C195O13868C199O13892C200O13904C201O13912C204O13916C211O14005C212O14011C217O14026C223O14049C229O14056C234O14069C237O14069C241O14092C242O14104C243O15234C248O15250C256O15250C261O15371C267O15378C272O15393C279O15400C283O15412C287O15404C292O15433C294O15452C302O15452C307O15723C313O15738C319O15755C325O15774C331O15798C337O15817C339O15837C347O15837C354O15895C358O15913C366O15913C370O15935C371O15949C375O15961C376O15972C380O16067C386O16074C391O16087C392O16106C399O16184C404O16196C409O16184C415O16218C418O16268C423O16282C427O16331C434O16369C448O16331C466O16503C476O16503C483O16541C484O16552C488O16724C494O16739C497O16743C504O16783C506O16790C507O16796C512O16805C515O16811C523O16842C525O16857C529O16908C534O16924C538O16915C541O16900C545O16943C550O16965C557O16981C560O16978C564O16998C570O17029C575O17047C580O17047C586O17075C587O17099C591O17130C597O17137C602O17280C608O17293C609O17312C613O17400C615O17410C620O17425C626O17438C629O17438C633O17464C637O17491C643O17514C649O17534C650O17552C654O17569C662O17569C668O17595C670O17606,,
code-creation,LazyCompile,10,175292,0xa12169eef06,10, node:internal/streams/readable:50:66,0x174551ef34f8,~
code-source-info,0xa12169eef06,57,1776,1801,C0O1788C2O1794C9O1800,,
code-creation,LazyCompile,10,175334,0xa12169eeffe,108,howMuchToRead node:internal/streams/readable:385:23,0x174551ef4278,~
code-source-info,0xa12169eeffe,57,12371,12743,C0O12386C1O12392C6O12407C12O12414C17O12429C23O12441C24O12450C25O12463C31O12479C33O12488C34O12491C39O12495C45O12566C51O12583C57O12610C62O12617C67O12617C72O12624C76O12632C77O12650C81O12657C82O12679C86O12670C91O12691C93O12700C94O12716C100O12730C107O12741,,
code-creation,LazyCompile,10,175334,0xa12169ef26e,111,Socket._read node:net:618:34,0x120d44382d90,~
code-source-info,0xa12169ef26e,113,16404,16625,C0O16404C13O16412C23O16412C27O16431C30O16440C39O16460C45O16475C55O16475C59O16515C62O16520C75O16520C83O16567C86O16577C91O16585C97O16600C105O16600C110O16624,,
code-creation,LazyCompile,10,175417,0xa12169ef5e6,207,onSocketNT node:_http_client:784:20,0x2cbd764b00e8,~
code-source-info,0xa12169ef5e6,154,23378,24153,C0O23378C13O23401C16O23409C24O23422C36O23433C42O23447C46O23703C50O23723C61O23739C67O23756C73O23784C81O23784C88O23821C95O23837C107O23845C118O23856C120O23855C124O23837C135O23821C140O24026C141O24033C142O24053C154O24067C165O24078C167O24077C171O24053C180O24103C188O24103C193O24134C196O24138C201O24138C206O24152,,
code-creation,LazyCompile,10,175459,0xa12169ef95e,311,tickOnSocket node:_http_client:717:22,0x2cbd764afff8,~
code-source-info,0xa12169ef95e,154,21522,22645,C0O21555C5O21563C10O21563C15O21574C17O21585C21O21617C29O21656C32O21656C37O21674C42O21703C49O21714C52O21725C59O21759C70O21755C76O21836C89O21876C93O21886C99O21900C104O21703C109O21940C111O21954C115O21966C117O21982C121O21991C123O22002C127O22015C129O22029C133O22041C135O22061C139O22145C147O22209C151O22225C154O22203C158O22238C160O22256C164O22291C175O22291C181O22334C192O22334C198O22369C209O22369C215O22402C226O22402C232O22445C243O22445C249O22483C255O22517C261O22530C266O22536C272O22551C277O22557C282O22565C288O22584C291O22584C295O22620C303O22620C310O22644,,
code-creation,LazyCompile,10,175500,0xa12169efc3e,56,alloc node:internal/freelist:15:8,0x2cbd764b5f80,~
code-source-info,0xa12169efc3e,156,203,317,C0O203C2O224C7O229C13O236C18O253C23O258C28O258C36O272C39O290C50O272C55O313,,
code-creation,LazyCompile,10,175500,0xa12169efd86,65,parsersCb node:_http_common:170:65,0x2cbd764b3e28,~
code-source-info,0xa12169efd86,155,5430,5700,C0O5452C5O5452C11O5473C14O5473C18O5497C20O5504C25O5516C29O5537C31O5544C36O5564C40O5593C42O5600C47O5609C51O5627C53O5634C58O5654C62O5684C64O5698,,
code-creation,LazyCompile,10,175542,0xa12169eff36,77,cleanParser node:_http_common:236:21,0x2cbd764b3ce8,~
code-source-info,0xa12169eff36,155,7357,7681,C0O7370C2O7386C6O7394C8O7406C12O7414C13O7428C17O7438C18O7454C22O7464C23O7480C27O7490C29O7514C31O7512C35O7534C37O7541C41O7558C45O7568C47O7575C51O7587C55O7597C57O7604C61O7616C65O7626C66O7643C70O7654C71O7672C76O7680,,
code-creation,LazyCompile,10,175542,0xa12169f0126,43,isLenient node:_http_common:258:19,0x2cbd764b3d88,~
code-source-info,0xa12169f0126,155,7924,8091,C0O7931C8O7958C12O7979C16O7993C22O8005C25O8013C33O8013C38O8063C42O8089,,
code-creation,LazyCompile,10,175584,0xa12169f0246,14,HTTPClientAsyncResource node:_http_client:100:14,0x2cbd764b0278,~
code-source-info,0xa12169f0246,154,3210,3269,C0O3228C2O3238C6O3250C8O3259C13O3268,,
code-creation,LazyCompile,10,175584,0xa12169f03de,70,Socket.resume node:net:652:35,0x120d44382f28,~
code-source-info,0xa12169f03de,113,17240,17416,C0O17247C2O17256C4O17255C9O17274C15O17293C21O17316C26O17324C32O17339C35O17339C39O17365C44O17379C49O17386C54O17396C59O17403C64O17403C69O17414,,
code-creation,LazyCompile,10,175625,0xa12169f054e,53,Readable.resume node:internal/streams/readable:986:37,0x174551ef48f8,~
code-source-info,0xa12169f054e,57,31314,31631,C0O31340C5O31369C11O31384C19O31384C23O31541C28O31532C32O31564C35O31564C40O31591C42O31597C46O31606C50O31617C52O31629,,
code-creation,LazyCompile,10,175625,0xa12169f067e,35,resume node:internal/streams/readable:1000:16,0x174551ef4980,~
code-source-info,0xa12169f067e,57,31649,31784,C0O31680C6O31703C7O31725C11O31737C14O31745C28O31745C34O31783,,
code-creation,LazyCompile,10,175667,0xa12169f084e,65,listenSocketTimeout node:_http_client:762:29,0x2cbd764b0098,~
code-source-info,0xa12169f084e,154,22785,23148,C0O22803C6O22820C7O22827C8O22895C10O22909C14O22977C20O22995C25O23002C36O23002C44O23058C57O23058C64O23147,,
code-creation,LazyCompile,10,175709,0xa12169f0a7e,79,_flush node:_http_outgoing:934:51,0x2cbd764ba7c8,~
code-source-info,0xa12169f0a7e,158,27116,27531,C0O27143C5O27154C7O27175C13O27274C18O27274C24O27310C30O27409C35O27409C41O27431C47O27447C49O27446C54O27468C56O27473C60O27485C64O27505C72O27505C78O27530,,
code-creation,LazyCompile,10,175709,0xa12169f0bfe,48,get node:internal/streams/writable:788:8,0xd2efcc087f8,~
code-source-info,0xa12169f0bfe,64,22751,23140,C0O22777C5O23036C9O23052C15O23061C21O23077C28O23093C35O23115C42O23128C47O23134,,
code-creation,LazyCompile,10,175750,0xa12169f0d6e,170,_flushOutput node:_http_outgoing:951:63,0x2cbd764ba818,~
code-source-info,0xa12169f0d6e,158,27596,28218,C0O27620C2O27621C4O27620C9O27637C11O27642C19O27650C23O27665C28O27665C32O27609C35O27706C40O27717C45O27727C46O27744C51O27754C52O27771C53O27799C58O27820C63O27820C67O27834C69O27956C71O27961C73O27961C78O28025C80O28035C84O27996C89O28002C94O28012C99O28057C116O28057C122O27978C127O27943C130O28103C135O28103C139O28116C141O28132C145O28145C150O28166C154O28160C157O28145C162O28181C163O28197C167O28205C169O28216,,
code-creation,LazyCompile,10,175792,0xa12169f0f76,17,Writable.cork node:internal/streams/writable:338:35,0xd2efcc080c8,~
code-source-info,0xa12169f0f76,64,10845,10883,C0O10857C11O10878C16O10882,,
code-creation,LazyCompile,10,175834,0xa12169f1076,37,Writable.uncork node:internal/streams/writable:342:37,0xd2efcc08150,~
code-source-info,0xa12169f1076,64,10922,11069,C0O10948C5O10977C11O10991C17O11003C21O11023C27O11038C30O11038C36O11068,,
code-creation,LazyCompile,10,175875,0xa12169f12ae,402,clearBuffer node:internal/streams/writable:530:21,0xd2efcc08480,~
code-source-info,0xa12169f12ae,64,16281,17755,C0O16281C11O16311C17O16333C23O16365C29O16391C35O16410C36O16417C37O16433C43O16443C48O16458C53O16505C56O16514C63O16521C67O16541C69O16568C70O16575C71O16591C73O16591C75O16609C76O16632C80O16642C82O16661C87O16675C93O16690C100O16724C106O16706C110O16757C122O16767C127O17034C137O17047C150O17072C159O17072C165O17136C169O17128C173O17153C180O17188C201O17153C206O17224C211O17224C217O17308C222O17316C226O17278C231O17285C236O17295C241O17327C251O17337C254O17341C258O17367C266O17390C271O17404C296O17404C301O17500C307O17493C311O17482C316O17510C322O17259C325O17525C331O17544C335O17531C340O17560C345O17560C351O17591C358O17597C363O17612C366O17621C376O17621C382O17641C383O17661C389O17685C391O17705C395O17722C396O17745C401O17754,,
code-creation,LazyCompile,10,175917,0xa12169f164e,109,doWrite node:internal/streams/writable:399:17,0xd2efcc082a0,~
code-source-info,0xa12169f164e,64,12658,13020,C0O12712C2O12727C6O12736C8O12750C12O12758C13O12772C17O12782C18O12793C22O12813C28O12834C35O12846C43O12842C49O12834C56O12885C60O12908C65O12929C70O12908C78O12957C83O12987C97O12957C102O12999C103O13010C108O13019,,
code-creation,LazyCompile,10,175959,0xa12169f17f6,42,_finish node:_http_client:337:51,0x2cbd764b02c8,~
code-source-info,0xa12169f17f6,154,10675,10796,C0O10682C5O10720C10O10682C15O10731C22O10753C25O10769C30O10779C35O10731C41O10795,,
code-creation,LazyCompile,10,175959,0xa12169f1926,29,_finish node:_http_outgoing:909:53,0x2cbd764ba778,~
code-source-info,0xa12169f1926,158,26245,26300,C0O26252C5O26264C10O26252C14O26280C22O26280C28O26299,,
code-creation,LazyCompile,10,176000,0xa12169f1a4e,87,resume_ node:internal/streams/readable:1007:17,0x174551ef49d0,~
code-source-info,0xa12169f1a4e,57,31802,32037,C0O31822C8O31844C13O31822C18O31867C24O31889C31O31889C36O31905C37O31927C41O31945C49O31945C54O31963C57O31963C61O31989C67O32007C73O32027C80O32027C86O32036,,
code-creation,LazyCompile,10,176000,0xa12169f1bbe,45,flow node:internal/streams/readable:1031:14,0x174551ef4aa8,~
code-source-info,0xa12169f1bbe,57,32349,32483,C0O32383C5O32401C13O32421C18O32401C23O32446C29O32464C34O32464C40O32433C44O32482,,
code-creation,RegExp,3,176084,0x10512a740,1920,^(\\/\\/?(?!\\/)[^?\\s]*)(\\?[^\\s]*)?$
code-creation,RegExp,3,176084,0x10512af20,1256,^[a-z0-9.+-]+:
code-creation,RegExp,3,176125,0x10512b480,1112,:[0-9]*$
code-creation,RegExp,3,176167,0x10512b940,1016,[\\t\\n\\r #%/:<>?@[\\\\\\]^|]
code-creation,RegExp,3,176209,0x10512bda0,984,[^\\u0021-\\u00ff]
code-creation,RegExp,3,176209,0x10512c1e0,1000,[^\\t\\x20-\\x7e\\x80-\\xff]
tick,0x1008d54e0,176292,0,0x0,0,0x0,0xa12169e5bf9,0xa12169e5355,0xa12169e4dc0,0xa12169e3a3b,0xa12169dd906,0xa12169dc912,0xa12169d6e9d,0xa12169d6940,0xa12169d647e,0xa12169d60d3,0xa12169d5f76
code-creation,Function,11,176792,0x10512c640,1520,Readable.on node:internal/streams/readable:897:33,0x174551ef46c8,^
code-source-info,0x10512c640,57,28293,29192,,,
code-creation,Function,11,176792,0x10512cca0,272,newAsyncId node:internal/async_hooks:417:20,0x2b48e0c77b38,^
code-source-info,0x10512cca0,13,14513,14564,,,
code-creation,Function,11,176834,0x10512ce20,184,initHooksExist node:internal/async_hooks:479:24,0x2b48e0c77dc8,^
code-source-info,0x10512ce20,13,16193,16225,,,
code-creation,Function,11,176834,0x10512cf40,472,getDefaultTriggerAsyncId node:internal/async_hooks:433:34,0x2b48e0c77bd8,^
code-source-info,0x10512cf40,13,14972,15229,,,
code-creation,Function,11,176834,0x10512d180,64,testEnabled node:internal/util/debuglog:32:19,0x3172a1b1c9f0,^
code-source-info,0x10512d180,22,973,984,,,
code-creation,Function,11,176875,0x10512d220,136,get node:events:264:16,0x232faba26588,^
code-source-info,0x10512d220,23,7780,7820,,,
code-creation,Function,11,176875,0x10512d320,1256,toString node:buffer:783:46,0x232faba33cd0,^
code-source-info,0x10512d320,24,23298,23860,,,
code-creation,Function,11,177042,0x10512d880,3104,emit node:events:475:44,0x232faba26ac8,^
code-source-info,0x10512d880,23,13881,16143,,,
code-creation,Function,11,177042,0x10512e500,152,isEmpty node:internal/fixed_queue:95:10,0x815de6146c8,^
code-source-info,0x10512e500,34,3637,3677,,,
code-creation,Function,11,177084,0x10512e600,296, node:internal/validators:222:42,0x2b48e0c7c3e0,^
code-source-info,0x10512e600,15,6815,6916,,,
code-creation,Function,11,177084,0x10512e7a0,432,remove node:internal/linkedlist:16:16,0x232faba040f0,^
code-source-info,0x10512e7a0,18,275,487,,,
code-creation,Function,11,177084,0x10512e9c0,208,_getMaxListeners node:events:404:26,0x232faba26968,^
code-source-info,0x10512e9c0,23,11869,11993,,,
code-creation,Function,11,177167,0x10512eb00,1856,pushAsyncContext node:internal/async_hooks:540:26,0x2b48e0c78120,^
code-source-info,0x10512eb00,13,17507,18052,,,
code-creation,Function,11,177167,0x10512f2a0,184,destroyHooksExist node:internal/async_hooks:487:27,0x2b48e0c77e88,^
code-source-info,0x10512f2a0,13,16312,16347,,,
code-creation,Function,11,177209,0x10512f3c0,464,shift node:internal/fixed_queue:80:8,0x815de614578,^
code-source-info,0x10512f3c0,34,3300,3510,,,
code-creation,Function,11,177209,0x10512f600,248,isFull node:internal/fixed_queue:71:9,0x815de6144a8,^
code-source-info,0x10512f600,34,3139,3200,,,
code-creation,Function,11,177209,0x10512f760,328,push node:internal/fixed_queue:75:7,0x815de614510,^
code-source-info,0x10512f760,34,3208,3291,,,
code-creation,Function,11,177209,0x10512f920,368,shift node:internal/fixed_queue:108:8,0x815de614768,^
code-source-info,0x10512f920,34,3954,4180,,,
code-creation,LazyCompile,10,177292,0xa12169f36e6,257,concat node:buffer:536:32,0x232faba32340,~
code-source-info,0xa12169f36e6,24,15021,16153,C0O15040C8O15040C13O15081C19O15088C24O15099C29O15106C34O15123C35O15127C39O15159C42O15188C44O15200C48O15193C53O15221C55O15229C59O15233C65O15251C67O15265C71O15269C83O15209C88O15175C93O15306C101O15306C106O15362C109O15369C114O15369C120O15402C122O15420C124O15432C128O15425C133O15463C135O15467C139O15476C144O15481C150O15637C160O15685C178O15721C184O15643C189O15637C190O15737C195O15781C209O15744C218O15441C223O15407C226O15866C228O15874C233O16081C249O16081C254O16137C256O16151,,
code-creation,LazyCompile,10,177334,0xa12169f39c6,40, /Users/vignesh/Projects/HTTP2/lib/logs.js:73:55,0xa12169d4f10,~
code-source-info,0xa12169f39c6,196,2027,3078,C0O2050C6O2061C8O2119C13O2124C18O2129C23O2124C31O3054C34O3054C39O3077,,
code-creation,LazyCompile,10,177334,0xa12169f3b96,45, /Users/vignesh/Projects/HTTP2/lib/workers.js:226:48,0xa12169d4cc0,~
code-source-info,0xa12169f3b96,195,8898,9294,C0O8915C4O8969C9O8975C17O8984C22O8975C30O9219C38O9219C44O9293,,
code-creation,LazyCompile,10,177334,0xa12169f3d56,55,lib.truncate /Users/vignesh/Projects/HTTP2/lib/logs.js:134:24,0x1208b712560,~
code-source-info,0xa12169f3d56,196,3737,3897,C0O3737C9O3757C14O3760C24O3773C31O3780C37O3786C48O3760C54O3896,,
code-creation,LazyCompile,10,177375,0xa12169f3f66,157,truncate node:fs:1003:18,0xd2efcc34f60,~
code-source-info,0xa12169f3f66,81,25563,26207,C0O25563C13O25589C19O25625C24O25625C27O25656C34O25666C48O25666C53O25697C54O25704C60O25741C62O25750C64O25761C65O25765C69O25779C73O25808C74O25812C76O25824C89O25824C94O25855C106O25861C111O25859C113O25880C121O25891C125O25889C127O25918C134O25921C142O25926C150O25921C156O26206,,
code-creation,LazyCompile,10,177417,0xa12169f41a6,158,open node:fs:545:14,0xd2efcc34a78,~
code-source-info,0xa12169f41a6,81,13701,14265,C0O13701C2O13735C7O13742C13O13782C20O13789C25O13800C28O13822C32O13839C40O13862C46O13900C49O13921C57O13950C73O13957C80O14019C85O14019C90O14043C93O14054C99O14093C104O14093C110O14116C112O14131C116O14146C121O14154C128O14159C131O14170C136O14170C151O14154C157O14264,,
tick,0x100bb056c,177542,0,0x0,0,0x0,0xa12169d9c74,0xa12169d711a,0xa12169d6e1d,0xa12169d6940,0xa12169d647e,0xa12169d60d3,0xa12169d5f76
code-creation,Function,11,177625,0x10512fb00,16968,parse node:url:183:37,0x3beccad8948,^
code-source-info,0x10512fb00,90,5061,15043,,,
code-creation,Function,11,177625,0x105133dc0,184,enabledHooksExist node:internal/async_hooks:475:27,0x2b48e0c77d78,^
code-source-info,0x105133dc0,13,16135,16168,,,
code-creation,Function,11,177667,0x105133ee0,1720,popAsyncContext node:internal/async_hooks:554:25,0x2b48e0c78170,^
code-source-info,0x105133ee0,13,18141,18728,,,
code-creation,LazyCompile,10,177709,0xa12169f5626,22,request node:http:95:17,0x2cbd764a9980,~
code-source-info,0xa12169f5626,152,3017,3085,C0O3040C16O3047C21O3083,,
code-creation,Function,11,177750,0x105134600,248,isIPv6 node:internal/net:35:16,0x120d4438a640,^
code-source-info,0x105134600,114,1078,1127,,,
code-creation,Function,11,177792,0x105134760,1912,getHostname node:url:511:21,0x3beccad8998,^
code-source-info,0x105134760,90,15066,15771,,,
code-creation,Function,11,177792,0x105134f40,1432,EventEmitter.init node:events:327:29,0x232faba26798,^
code-source-info,0x105134f40,23,9680,10269,,,
code-creation,Function,11,177834,0x105135540,216,Stream node:internal/streams/legacy:10:16,0x174551ef6738,^
code-source-info,0x105135540,58,127,160,,,
code-creation,Function,11,177834,0x105135680,248,isIPv4 node:internal/net:31:16,0x120d4438a5f0,^
code-source-info,0x105135680,114,1012,1061,,,
code-creation,LazyCompile,10,177875,0xa12169f5c16,72,connect node:net:193:17,0x120d44381f00,~
code-source-info,0xa12169f5c16,113,4740,5015,C0O4740C3O4773C6O4773C11O4812C12O4822C16O4829C24O4829C29O4885C34O4885C40O4921C46O4943C51O4962C56O4943C61O4993C66O4993C71O5013,,
code-creation,LazyCompile,10,178042,0xa12169f619e,80,onlookup node:dns:70:18,0x2811abd37d00,~
code-source-info,0xa12169f619e,192,2154,2338,C0O2175C4O2202C11O2211C17O2249C25O2211C31O2202C36O2260C37O2272C45O2296C49O2306C60O2316C64O2330C68O2316C73O2272C79O2337,,
code-creation,LazyCompile,10,178084,0xa12169f634e,275,emitLookup node:net:1074:46,0xa12169ea088,~
code-source-info,0xa12169f634e,113,28332,29557,C0O28363C3O28368C13O28405C25O28368C30O28579C33O28589C39O28601C40O28608C41O28616C45O28868C50O28876C66O28876C73O28926C80O28931C86O28951C95O28957C102O28997C107O29005C123O29005C130O29055C132O29071C139O29092C144O29109C154O29212C162O29271C172O29115C179O29286C184O29294C200O29294C207O29354C210O29359C215O29359C219O29382C233O29425C235O29424C249O29490C254O29509C259O29523C268O29382C274O29556,,
code-creation,LazyCompile,10,178125,0xa12169f669e,415,internalConnect node:net:897:25,0x120d44382220,~
code-source-info,0xa12169f669e,113,23522,25203,C0O23682C5O23694C10O23682C14O23714C16O23722C22O23742C24O23759C26O23775C31O23790C37O23821C41O23857C46O23865C51O23865C60O23936C66O23967C70O24003C75O24011C89O24011C95O24060C112O24060C117O24187C120O24229C131O24193C137O24243C139O24271C156O24271C162O24343C167O24343C172O24362C173O24369C174O24383C176O24399C183O24420C188O24445C193O24445C199O24471C201O24486C205O24506C207O24518C211O24533C213O24542C217O24554C219O24571C223O24591C225O24605C229O24623C231O24639C236O24663C241O24671C255O24671C263O24726C268O24734C282O24734C290O24791C295O24791C301O24818C303O24830C307O24845C309O24860C313O24892C318O24900C332O24900C338O24944C342O24981C347O24981C352O25005C354O25019C358O25060C365O25068C369O25085C373O25074C377O25113C397O25113C403O25185C408O25185C414O25202,,
code-creation,LazyCompile,10,178167,0xa12169f6a36,49,methodProxy node:_tls_wrap:554:30,0x2811abd1a7c0,~
code-source-info,0xa12169f6a36,169,15677,15787,C0O15677C3O15702C10O15709C15O15723C22O15748C29O15755C33O15768C41O15730C46O15783C48O15786,,
code-creation,Function,11,178334,0x1051357e0,1536,insert node:internal/timers:350:16,0x2b48e0c70e30,^
code-source-info,0x1051357e0,12,10384,11020,,,
code-creation,Function,11,178334,0x105135e40,416,append node:internal/linkedlist:30:16,0x232faba04140,^
code-source-info,0x105135e40,18,558,995,,,
code-creation,Function,11,178334,0x105136040,256,isIP node:internal/net:39:14,0x120d4438a690,^
code-source-info,0x105136040,114,1142,1215,,,
code-creation,Function,11,178375,0x1051361a0,312,setHasTickScheduled node:internal/process/task_queues:52:29,0x815de60f578,^
code-source-info,0x1051361a0,32,1104,1162,,,
code-creation,Function,11,178375,0x105136340,344,validateNumber node:internal/validators:123:24,0x2b48e0c7c088,^
code-source-info,0x105136340,15,3551,3660,,,
code-creation,Function,11,178375,0x105136500,416,emitBeforeScript node:internal/async_hooks:510:26,0x2b48e0c77f78,^
code-source-info,0x105136500,13,16863,17014,,,
code-creation,Function,11,178375,0x105136700,176,maybeCallback node:fs:176:23,0xd2efcc34350,^
code-source-info,0x105136700,81,4543,4589,,,
code-creation,LazyCompile,10,178459,0xa12169f6fae,74, node:fs:1018:23,0xa12169f3e88,~
code-source-info,0xa12169f6fae,81,25938,26203,C0O25938C9O25956C13O25964C18O25971C22O25984C23O26001C30O26001C36O26026C40O26041C44O26167C51O26175C67O26175C73O26202,,
code-creation,LazyCompile,10,178542,0xa12169f7246,39,oncomplete node:fs:1021:41,0xa12169f6ee8,~
code-source-info,0xa12169f7246,81,26062,26161,C0O26062C9O26075C16O26078C26O26084C31O26078C38O26160,,
code-creation,LazyCompile,10,178542,0xa12169f739e,74,close node:fs:511:15,0xd2efcc349b8,~
code-source-info,0xa12169f739e,81,12970,13209,C14O13012C19O13017C24O13039C26O13052C31O13082C34O13093C39O13132C44O13132C50O13155C52O13170C56O13184C61O13192C66O13192C73O13208,,
code-creation,LazyCompile,10,178584,0xa12169f74de,27, node:fs:1022:20,0xa12169f7190,~
code-source-info,0xa12169f74de,81,26088,26153,C0O26107C9O26116C15O26116C21O26107C26O26152,,
code-creation,LazyCompile,10,178625,0xa12169f7686,120, node:internal/errors:154:44,0x2b48e0c65030,~
code-source-info,0xa12169f7686,11,4462,5008,C0O4494C6O4512C10O4537C15O4559C20O4587C25O4563C31O4661C36O4691C41O4661C46O4718C48O4736C49O4812C56O4835C68O4861C77O4879C83O4831C89O4910C96O4812C102O4946C106O4933C110O4956C112O4967C113O4974C119O5006,,
code-creation,LazyCompile,10,178667,0xa12169f77f6,24, /Users/vignesh/Projects/HTTP2/lib/logs.js:135:52,0xa12169f3c98,~
code-source-info,0xa12169f77f6,196,3806,3893,C0O3817C4O3833C9O3833C15O3869C18O3869C23O3892,,
code-creation,LazyCompile,10,178667,0xa12169f7946,32, /Users/vignesh/Projects/HTTP2/lib/workers.js:229:42,0xa12169f3ae8,~
code-source-info,0xa12169f7946,195,8998,9185,C0O9019C4O9045C12O9045C18O9121C26O9121C31O9184,,
tick,0x1bfd3fd2c,192042,0,0x0,8
code-creation,LazyCompile,10,192084,0xa12169f7c16,355,afterConnect node:net:1141:22,0x120d44382360,~
code-source-info,0xa12169f7c16,113,30089,31555,C0O30148C2O30155C4O30154C8O30227C14O30244C15O30251C16O30259C24O30259C28O30285C33O30297C38O30285C42O30312C43O30328C47O30339C48O30354C52O30365C53O30376C58O30398C66O30411C68O30434C75O30434C80O30457C85O30457C89O30484C97O30497C99O30520C104O30520C108O30542C113O30542C117O30562C119O30571C121O30570C126O30592C131O30600C137O30625C142O30633C149O30633C154O30662C156O30671C158O30670C163O30694C168O30702C174O30729C179O30737C188O30761C190O30760C194O30737C200O30806C208O30806C213O30832C221O30832C226O30969C230O30991C235O30991C241O31014C248O31014C255O31039C256O31055C260O31072C262O31093C268O31113C274O31146C281O31159C285O31171C289O31165C293O31203C301O31322C306O31372C317O31203C323O31429C327O31472C331O31466C335O31511C339O31505C343O31537C348O31537C354O31554,,
code-creation,LazyCompile,10,192125,0xa12169f7f56,41,get node:internal/streams/readable:1162:8,0x174551ef4d40,~
code-source-info,0xa12169f7f56,57,35410,35796,C0O35436C5O35695C9O35711C15O35720C21O35736C28O35752C35O35779C40O35790,,
code-creation,LazyCompile,10,192167,0xa12169f80a6,27,connect node:net:798:42,0xa12169c9370,~
code-source-info,0xa12169f80a6,113,20795,20859,C0O20811C20O20811C26O20858,,
code-creation,LazyCompile,10,192209,0xa12169f8246,38,onFinish node:_http_outgoing:828:18,0x2cbd764b9a60,~
code-source-info,0xa12169f8246,158,24267,24370,C0O24280C4O24301C10O24318C15O24325C21O24336C22O24343C23O24353C31O24353C37O24369,,
code-creation,LazyCompile,10,192209,0xa12169f834e,17, node:net:623:26,0xa12169ef188,~
code-source-info,0xa12169f834e,113,16536,16555,C0O16547C3O16547C11O16547C16O16555,,
code-creation,LazyCompile,10,192250,0xa12169f8496,65,tryReadStart node:net:608:22,0x120d443820e0,~
code-source-info,0xa12169f8496,113,16079,16304,C0O16133C8O16133C12O16177C18O16193C22O16222C27O16230C32O16230C37O16245C39O16265C46O16273C52O16273C58O16265C64O16303,,
code-creation,LazyCompile,10,192250,0xa12169f85e6,29,Readable.isPaused node:internal/streams/readable:339:39,0x174551ef4108,~
code-source-info,0xa12169f85e6,57,11095,11199,C0O11121C5O11139C7O11152C9O11151C14O11161C19O11179C25O11187C28O11197,,
tick,0x1bfd3fd2c,212250,0,0x0,8
code-creation,LazyCompile,10,212292,0xa12169f8806,140,TLSSocket._start node:_tls_wrap:949:38,0x29d5d5bac5c8,~
code-source-info,0xa12169f8806,169,27081,27572,C0O27088C8O27120C13O27132C29O27190C39O27227C47O27270C52O27282C59O27088C64O27311C70O27334C78O27355C83O27334C89O27368C90O27375C91O27457C97O27470C98O27477C99O27490C104O27502C110O27524C115O27532C120O27532C124O27554C129O27562C134O27562C139O27571,,
tick,0x1bfd3fd2c,215792,0,0x0,8
code-creation,LazyCompile,10,215834,0xa12169f8b16,141,processTimers node:internal/timers:487:25,0x2b48e0c71210,~
code-source-info,0xa12169f8b16,12,14417,14879,C0O14429C10O14429C15O14471C23O14482C31O14503C33O14537C35O14586C42O14578C47O14578C55O14612C62O14619C67O14654C76O14647C84O14670C92O14686C101O14692C109O14706C111O14705C113O14717C114O14732C118O14763C121O14763C126O14798C128O14830C131O14830C136O14548C139O14866C140O14875,,
code-creation,LazyCompile,10,215875,0xa12169f8cc6,14,peek node:internal/priority_queue:45:7,0x232faba051c8,~
code-source-info,0xa12169f8cc6,19,1052,1087,C0O1061C2O1073C4O1072C10O1079C13O1083,,
code-creation,LazyCompile,10,215917,0xa12169f8f7e,600,listOnTimeout node:internal/timers:507:25,0x2b48e0c71280,~
code-source-info,0xa12169f8f7e,12,14905,17353,C0O14942C5O14954C15O14954C20O15021C22O15036C24O15077C31O15065C36O15065C45O15119C49O15111C53O15289C55O15298C60O15317C64O15331C67O15345C74O15356C80O15369C84O15331C89O15329C93O15383C109O15404C119O15391C123O15416C130O15431C138O15431C143O15457C159O15457C164O15520C165O15527C166O15543C170O15575C173O15575C178O15610C180O15698C187O15700C192O15700C197O15738C201O15744C203O15743C207O15780C213O15813C219O15837C220O15854C224O15873C228O15883C230O15882C235O15904C248O15912C256O15927C263O15931C268O15964C275O15964C279O16004C281O16029C292O16055C294O16054C304O16029C309O16100C311O16123C317O16140C324O16148C331O16203C336O16223C338O16263C343O16263C349O16300C356O16319C367O16300C383O16371C384O16381C390O16398C397O16411C402O16458C406O16450C410O16477C415O16497C426O16477C433O16545C439O16565C445O16585C451O16609C452O16626C456O16645C460O16655C462O16654C467O16676C480O16684C488O16699C495O16703C500O16736C507O16736C522O16783C529O16783C533O15047C539O17024C549O17024C554O17244C558O17257C563O17269C566O17253C571O17286C580O17306C582O17320C589O17335C594O17335C599O17352,,
code-creation,LazyCompile,10,216000,0xa12169f93ce,19,peek node:internal/linkedlist:10:14,0x232faba04088,~
code-source-info,0xa12169f93ce,18,146,225,C0O166C7O176C12O186C13O198C14O213C18O223,,
code-creation,LazyCompile,10,216000,0xa12169f94be,22, /Users/vignesh/Projects/HTTP2/index.js:24:22,0x1208b73be00,~
code-source-info,0xa12169f94be,150,397,436,C0O405C5O409C10O409C14O421C17O421C21O435,,
code-creation,LazyCompile,10,216042,0xa12169f9776,130,cli.init /Users/vignesh/Projects/HTTP2/lib/cli.js:370:20,0x1208b71fe38,~
code-source-info,0xa12169f9776,198,10608,11253,C0O10608C5O10650C9O10658C20O10658C26O10750C31O10759C41O10788C45O10796C53O10815C57O10823C65O10759C70O10750C72O10885C75O10896C80O10896C84O10951C87O10962C100O10962C106O11189C109O11200C122O11200C129O11252,,
code-creation,LazyCompile,10,216167,0xa12169f9ca6,511,getStdin node:internal/bootstrap/switches/is_main_thread:149:18,0x3beccadac08,~
script-source,92,node:internal/bootstrap/switches/is_main_thread,'use strict';\n\nconst { ObjectDefineProperty } = primordials;\nconst rawMethods = internalBinding('process_methods');\n\n// TODO(joyeecheung): deprecate and remove these underscore methods\nprocess._debugProcess = rawMethods._debugProcess;\nprocess._debugEnd = rawMethods._debugEnd;\n\n// See the discussion in https://github.com/nodejs/node/issues/19009 and\n// https://github.com/nodejs/node/pull/34010 for why these are no-ops.\n// Five word summary: they were broken beyond repair.\nprocess._startProfilerIdleNotifier = () => {};\nprocess._stopProfilerIdleNotifier = () => {};\n\nfunction defineStream(name\x2C getter) {\n  ObjectDefineProperty(process\x2C name\x2C {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get: getter\n  });\n}\n\ndefineStream('stdout'\x2C getStdout);\ndefineStream('stdin'\x2C getStdin);\ndefineStream('stderr'\x2C getStderr);\n\n// Worker threads don't receive signals.\nconst {\n  startListeningIfSignal\x2C\n  stopListeningIfSignal\n} = require('internal/process/signal');\nprocess.on('newListener'\x2C startListeningIfSignal);\nprocess.on('removeListener'\x2C stopListeningIfSignal);\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst { guessHandleType } = internalBinding('util');\n\nfunction createWritableStdioStream(fd) {\n  let stream;\n  // Note stream._type is used for test-module-load-list.js\n  switch (guessHandleType(fd)) {\n    case 'TTY': {\n      const tty = require('tty');\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n      break;\n    }\n\n    case 'FILE': {\n      const SyncWriteStream = require('internal/fs/sync_write_stream');\n      stream = new SyncWriteStream(fd\x2C { autoClose: false });\n      stream._type = 'fs';\n      break;\n    }\n\n    case 'PIPE':\n    case 'TCP': {\n      const net = require('net');\n\n      // If fd is already being used for the IPC channel\x2C libuv will return\n      // an error when trying to use it again. In that case\x2C create the socket\n      // using the existing handle instead of the fd.\n      if (process.channel && process.channel.fd === fd) {\n        const { kChannelHandle } = require('internal/child_process');\n        stream = new net.Socket({\n          handle: process[kChannelHandle]\x2C\n          readable: false\x2C\n          writable: true\n        });\n      } else {\n        stream = new net.Socket({\n          fd\x2C\n          readable: false\x2C\n          writable: true\n        });\n      }\n\n      stream._type = 'pipe';\n      break;\n    }\n\n    default: {\n      // Provide a dummy black-hole output for e.g. non-console\n      // Windows applications.\n      const { Writable } = require('stream');\n      stream = new Writable({\n        write(buf\x2C enc\x2C cb) {\n          cb();\n        }\n      });\n    }\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\nfunction dummyDestroy(err\x2C cb) {\n  cb(err);\n  this._undestroy();\n\n  // We need to emit 'close' anyway so that the closing\n  // of the stream is observable. We just make sure we\n  // are not going to do it twice.\n  // The 'close' event is needed so that finished and\n  // pipeline work correctly.\n  if (!this._writableState.emitClose) {\n    process.nextTick(() => {\n      this.emit('close');\n    });\n  }\n}\n\nlet stdin;\nlet stdout;\nlet stderr;\n\nfunction getStdout() {\n  if (stdout) return stdout;\n  stdout = createWritableStdioStream(1);\n  stdout.destroySoon = stdout.destroy;\n  // Override _destroy so that the fd is never actually closed.\n  stdout._destroy = dummyDestroy;\n  if (stdout.isTTY) {\n    process.on('SIGWINCH'\x2C () => stdout._refreshSize());\n  }\n  return stdout;\n}\n\nfunction getStderr() {\n  if (stderr) return stderr;\n  stderr = createWritableStdioStream(2);\n  stderr.destroySoon = stderr.destroy;\n  // Override _destroy so that the fd is never actually closed.\n  stderr._destroy = dummyDestroy;\n  if (stderr.isTTY) {\n    process.on('SIGWINCH'\x2C () => stderr._refreshSize());\n  }\n  return stderr;\n}\n\nfunction getStdin() {\n  if (stdin) return stdin;\n  const fd = 0;\n\n  switch (guessHandleType(fd)) {\n    case 'TTY': {\n      const tty = require('tty');\n      stdin = new tty.ReadStream(fd);\n      break;\n    }\n\n    case 'FILE': {\n      const fs = require('fs');\n      stdin = new fs.ReadStream(null\x2C { fd: fd\x2C autoClose: false });\n      break;\n    }\n\n    case 'PIPE':\n    case 'TCP': {\n      const net = require('net');\n\n      // It could be that process has been started with an IPC channel\n      // sitting on fd=0\x2C in such case the pipe for this fd is already\n      // present and creating a new one will lead to the assertion failure\n      // in libuv.\n      if (process.channel && process.channel.fd === fd) {\n        stdin = new net.Socket({\n          handle: process.channel\x2C\n          readable: true\x2C\n          writable: false\x2C\n          manualStart: true\n        });\n      } else {\n        stdin = new net.Socket({\n          fd: fd\x2C\n          readable: true\x2C\n          writable: false\x2C\n          manualStart: true\n        });\n      }\n      // Make sure the stdin can't be `.end()`-ed\n      stdin._writableState.ended = true;\n      break;\n    }\n\n    default: {\n      // Provide a dummy contentless input for e.g. non-console\n      // Windows applications.\n      const { Readable } = require('stream');\n      stdin = new Readable({ read() {} });\n      stdin.push(null);\n    }\n  }\n\n  // For supporting legacy API we put the FD here.\n  stdin.fd = fd;\n\n  // `stdin` starts out life in a paused state\x2C but node doesn't\n  // know yet. Explicitly to readStop() it to put it in the\n  // not-reading state.\n  if (stdin._handle && stdin._handle.readStop) {\n    stdin._handle.reading = false;\n    stdin._readableState.reading = false;\n    stdin._handle.readStop();\n  }\n\n  // If the user calls stdin.pause()\x2C then we need to stop reading\n  // once the stream implementation does so (one nextTick later)\x2C\n  // so that the process can close down.\n  stdin.on('pause'\x2C () => {\n    process.nextTick(onpause);\n  });\n\n  function onpause() {\n    if (!stdin._handle)\n      return;\n    if (stdin._handle.reading && !stdin.readableFlowing) {\n      stdin._readableState.reading = false;\n      stdin._handle.reading = false;\n      stdin._handle.readStop();\n    }\n  }\n\n  return stdin;\n}\n\n// Used by internal tests.\nrawMethods.resetStdioForTesting = function() {\n  stdin = undefined;\n  stdout = undefined;\n  stderr = undefined;\n};\n
code-source-info,0xa12169f9ca6,92,4004,6253,C0O4004C11O4011C19O4022C25O4035C26O4049C28O4055C35O4063C70O4122C78O4122C83O4160C90O4152C100O4150C108O4182C110O4232C118O4232C123O4268C137O4291C143O4261C153O4259C161O4322C163O4389C171O4389C176O4648C181O4660C192O4679C197O4687C204O4690C209O4724C224O4759C234O4716C244O4714C254O4900C266O4923C272O4892C282O4890C290O5084C297O5090C303O5111C307O5125C309O5276C317O5276C322O5263C327O5301C332O5324C342O5309C352O5307C360O5344C367O5350C374O5350C379O5426C388O5435C392O5593C399O5603C409O5614C412O5620C417O5628C423O5644C430O5650C436O5666C440O5679C447O5685C453O5708C457O5721C464O5727C469O5735C474O5735C478O5928C485O5934C498O5934C504O6238C510O6251,,
tick,0x10096e380,216500,0,0x0,2,0x0,0xa12169f9d35,0xa12169f97a3,0xa12169f94c8,0xa12169f90d5,0xa12169f8b99
code-creation,LazyCompile,10,216542,0xa12169fadb6,526,ReadStream node:internal/fs/streams:148:20,0x2811abd23e00,~
code-source-info,0xa12169fadb6,187,4270,6006,C0O4290C2O4301C7O4329C18O4336C23O4366C24O4429C31O4450C34O4461C36O4450C42O4439C48O4490C54O4523C60O4545C64O4573C70O4606C71O4626C75O4654C82O4672C83O4680C87O4692C89O4697C92O4712C103O4718C105O4702C109O4726C116O4748C118O4747C122O4753C130O4726C135O4853C137O4865C140O4865C144O4863C148O4913C161O4949C165O4903C169O4980C184O5017C188O4970C192O5028C197O5046C202O5028C208O5068C210O5078C216O5093C222O5078C226O5076C230O5156C242O5201C246O5146C250O5215C257O5237C259O5236C263O5242C271O5215C276O5283C282O5302C289O5324C291O5323C295O5329C303O5302C308O5385C312O5375C316O5413C320O5403C324O5420C325O5429C329O5444C330O5459C334O5466C335O5478C339O5489C341O5494C345O5511C349O5532C355O5559C360O5580C370O5559C375O5621C379O5614C383O5645C389O5681C392O5679C398O5709C403O5717C406O5713C411O5733C416O5754C426O5733C431O5784C437O5812C442O5825C446O5818C451O5838C462O5915C477O5936C484O5844C489O5838C490O5964C497O5977C509O5994C519O5964C525O6005,,
code-creation,LazyCompile,10,216584,0xa12169fc186,47,copyObject node:internal/fs/utils:210:20,0xd2efcc3ec50,~
code-source-info,0xa12169fc186,82,4636,4745,C0O4664C2O4688C15O4681C28O4681C29O4700C31O4720C34O4712C41O4670C44O4729C46O4743,,
code-creation,LazyCompile,10,216625,0xa12169fc3e6,207,importFd node:internal/fs/streams:122:18,0x2811abd23db0,~
code-source-info,0xa12169fc3e6,187,3269,4249,C0O3310C8O3541C10O3548C13O3563C24O3569C26O3553C30O3592C34O3595C35O3624C43O3664C50O3678C52O3667C57O3772C63O3847C73O3853C78O3847C79O3917C81O3924C84O3943C88O3933C92O3951C94O3958C99O3965C104O3993C106O3992C110O3965C114O3963C118O4008C120O4015C122O4014C128O4024C130O4023C134O4029C138O4045C143O4048C153O4060C156O4089C161O4060C167O4048C173O4125C178O4128C182O4131C183O4139C196O4243C201O4145C206O4139,,
code-creation,LazyCompile,10,216709,0xa12169fc6ee,23,createInterface node:readline:203:25,0x1208b7226c8,~
code-source-info,0xa12169fc6ee,199,5690,5790,C0O5731C17O5738C22O5788,,
code-creation,LazyCompile,10,216750,0xa12169fd996,202,Interface node:readline:95:19,0x1208b722678,~
code-source-info,0xa12169fd996,199,2538,3265,C0O2579C2O2590C7O2619C24O2626C29O2676C30O2684C37O2693C46O2723C54O2757C59O2767C66O2774C78O2795C84O2820C88O2836C96O2882C102O2931C109O2938C121O2973C123O2973C125O2988C133O3046C140O3068C158O3046C163O3160C166O3172C171O3176C178O3181C183O3199C185O3216C191O3216C196O3214C201O3264,,
code-creation,LazyCompile,10,216834,0xa12169fdbc6,39,Interface node:internal/readline/interface:350:14,0x1208b72b6f0,~
code-source-info,0xa12169fdbc6,203,9672,9761,C3O9715C7O9747C23O9715C38O9760,,
code-creation,LazyCompile,10,216959,0xb4baa06d6e,1116,InterfaceConstructor node:internal/readline/interface:131:30,0x1208b72b640,~
code-source-info,0xb4baa06d6e,203,3787,9420,C0O3787C55O3828C59O3833C63O3847C67O3990C68O4015C72O4025C76O4030C80O4044C84O4055C88O4060C92O4074C96O4084C100O4109C102O4107C106O4132C108O4145C112O4153C123O4175C126O4153C131O4203C133O4218C135O4263C137O4276C139O4302C142O4314C143O4314C145O4325C150O4334C159O4384C162O4399C166O4391C168O4411C171O4429C177O4444C180O4461C186O4475C189O4491C194O4504C197O4524C202O4541C205O4556C209O4548C211O4568C214O4578C220O4609C230O4630C240O4609C245O4663C248O4684C252O4676C256O4703C259O4735C264O4764C267O4774C273O4804C276O4819C281O4837C284O4847C290O4888C300O4913C305O4892C311O4943C314O4974C318O4966C324O5016C334O5101C341O5022C346O5016C347O5149C351O5169C364O5169C369O5227C372O5245C377O5260C380O5274C384O5266C386O5288C396O5358C411O5364C416O5358C417O5422C421O5455C426O5484C436O5484C441O5526C445O5563C452O5598C462O5648C465O5648C472O5694C477O5708C484O5740C497O5714C502O5708C503O5892C515O5972C518O5992C526O6019C528O6019C530O6028C532O6038C536O6046C540O6051C544O6069C548O6079C550O6091C554O6103C556O6114C560O6125C564O6130C569O6142C573O6150C577O6155C582O6167C586O6175C588O6188C592O6201C594O6218C598O6603C602O6608C607O6619C611O6627C615O6632C619O6649C623O6657C625O6690C627O6686C631O6717C636O6734C642O6750C649O6758C652O6750C663O6790C665O6732C669O6807C671O6822C675O6843C680O6843C685O6865C687O6883C689O6879C693O7817C697O7822C701O7841C705O7857C708O7863C719O7863C725O7898C736O8097C739O8103C750O8103C756O8127C759O8133C770O8133C776O8155C779O8160C787O8160C793O8207C797O8212C804O8228C812O8224C817O8222C828O8570C846O8593C855O8589C863O8646C873O8646C878O8723C881O8729C892O8729C898O8761C901O8767C912O8767C918O8794C922O8799C924O8798C930O8811C935O8823C936O8837C940O8886C941O8898C945O8908C947O8926C951O8937C959O8988C962O8995C973O8995C979O9024C982O9029C990O9029C996O9076C1007O9112C1011O9112C1013O9136C1018O9147C1024O9164C1029O9172C1037O9172C1044O9212C1049O9219C1060O9245C1065O9219C1070O9279C1075O9284C1088O9284C1096O9384C1098O9394C1102O9403C1105O9409C1110O9409C1115O9419,,
code-creation,LazyCompile,10,217084,0xb4baa07736,13,setPrompt node:internal/readline/interface:363:12,0x1208b72b7b0,~
code-source-info,0xb4baa07736,203,9994,10036,C0O10009C2O10014C7O10023C12O10035,,
code-creation,LazyCompile,10,217125,0xb4baa07916,71,StringDecoder node:string_decoder:83:23,0x174551efaa58,~
script-source,62,node:string_decoder,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  Symbol\x2C\n  TypedArrayPrototypeSubarray\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  kIncompleteCharactersStart\x2C\n  kIncompleteCharactersEnd\x2C\n  kMissingBytes\x2C\n  kBufferedBytes\x2C\n  kEncodingField\x2C\n  kSize\x2C\n  decode\x2C\n  flush\x2C\n  encodings\n} = internalBinding('string_decoder');\nconst internalUtil = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_UNKNOWN_ENCODING\n} = require('internal/errors').codes;\nconst isEncoding = Buffer[internalUtil.kIsEncodingSymbol];\n\nconst kNativeDecoder = Symbol('kNativeDecoder');\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\n/**\n * Normalize encoding notation\n *\n * @param {string} enc\n * @returns {"utf8" | "utf16le" | "hex" | "ascii"\n *           | "base64" | "latin1" | "base64url"}\n * @throws {TypeError} Throws an error when encoding is invalid\n */\nfunction normalizeEncoding(enc) {\n  const nenc = internalUtil.normalizeEncoding(enc);\n  if (nenc === undefined) {\n    if (Buffer.isEncoding === isEncoding || !Buffer.isEncoding(enc))\n      throw new ERR_UNKNOWN_ENCODING(enc);\n    return enc;\n  }\n  return nenc;\n}\n\nconst encodingsMap = {};\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\n/**\n * StringDecoder provides an interface for efficiently splitting a series of\n * buffers into a series of JS strings without breaking apart multi-byte\n * characters.\n *\n * @param {string} [encoding=utf-8]\n */\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  this[kNativeDecoder] = Buffer.alloc(kSize);\n  this[kNativeDecoder][kEncodingField] = encodingsMap[this.encoding];\n}\n\n/**\n * Returns a decoded string\x2C omitting any incomplete multi-bytes\n * characters at the end of the Buffer\x2C or TypedArray\x2C or DataView\n *\n * @param {string | Buffer | TypedArray | DataView} buf\n * @returns {string}\n * @throws {TypeError} Throws when buf is not in one of supported types\n */\nStringDecoder.prototype.write = function write(buf) {\n  if (typeof buf === 'string')\n    return buf;\n  if (!ArrayBufferIsView(buf))\n    throw new ERR_INVALID_ARG_TYPE('buf'\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buf);\n  return decode(this[kNativeDecoder]\x2C buf);\n};\n\n/**\n * Returns any remaining input stored in the internal buffer as a string.\n * After end() is called\x2C the stringDecoder object can be reused for new\n * input.\n *\n * @param {string | Buffer | TypedArray | DataView} [buf]\n * @returns {string}\n */\nStringDecoder.prototype.end = function end(buf) {\n  let ret = '';\n  if (buf !== undefined)\n    ret = this.write(buf);\n  if (this[kNativeDecoder][kBufferedBytes] > 0)\n    ret += flush(this[kNativeDecoder]);\n  return ret;\n};\n\n/* Everything below this line is undocumented legacy stuff. */\n/**\n *\n * @param {string | Buffer | TypedArray | DataView} buf\n * @param {number} offset\n * @returns {string}\n */\nStringDecoder.prototype.text = function text(buf\x2C offset) {\n  this[kNativeDecoder][kMissingBytes] = 0;\n  this[kNativeDecoder][kBufferedBytes] = 0;\n  return this.write(buf.slice(offset));\n};\n\nObjectDefineProperties(StringDecoder.prototype\x2C {\n  lastChar: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      return TypedArrayPrototypeSubarray(this[kNativeDecoder]\x2C\n                                         kIncompleteCharactersStart\x2C\n                                         kIncompleteCharactersEnd);\n    }\n  }\x2C\n  lastNeed: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      return this[kNativeDecoder][kMissingBytes];\n    }\n  }\x2C\n  lastTotal: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      return this[kNativeDecoder][kBufferedBytes] +\n             this[kNativeDecoder][kMissingBytes];\n    }\n  }\n});\n\nexports.StringDecoder = StringDecoder;\n
code-source-info,0xb4baa07916,62,2711,2888,C0O2726C3O2742C7O2740C11O2773C13O2778C18O2796C21O2803C28O2809C31O2803C36O2794C40O2819C42O2824C44O2823C50O2840C55O2858C58O2876C62O2870C65O2856C70O2887,,
code-creation,LazyCompile,10,217417,0xb4baa07fce,73,normalizeEncoding node:string_decoder:62:27,0x174551efa758,~
code-source-info,0xb4baa07fce,62,2136,2372,C0O2159C5O2172C10O2172C16O2198C18O2228C23O2239C30O2254C32O2250C39O2269C42O2276C47O2276C54O2299C61O2305C66O2299C67O2340C69O2351C70O2358C72O2370,,
code-creation,LazyCompile,10,217459,0xb4baa08166,73,alloc node:buffer:360:30,0x232faba31de0,~
code-source-info,0xb4baa08166,24,10475,10706,C0O10502C5O10502C9O10522C14O10553C20O10567C25O10590C30O10590C35O10620C40O10651C54O10627C59O10669C60O10676C67O10683C72O10704,,
code-creation,LazyCompile,10,217500,0xb4baa082ee,87,prompt node:internal/readline/interface:390:9,0x1208b72b8a0,~
code-source-info,0xb4baa082ee,203,10513,10761,C0O10545C6O10558C11O10558C15O10581C24O10601C29O10605C36O10610C41O10630C45O10651C46O10663C50O10674C52O10679C54O10678C58O10692C64O10715C66O10720C68O10719C74O10741C76O10740C80O10735C86O10760,,
code-creation,LazyCompile,10,217542,0xb4baa08456,5,get node:readline:221:8,0x1208b722968,~
code-source-info,0xb4baa08456,199,6106,6150,C0O6129C4O6144,,
code-creation,LazyCompile,10,217542,0xb4baa0854e,42, node:internal/readline/interface:434:19,0x1208b72ba30,~
code-source-info,0xb4baa0854e,203,11520,11701,C0O11542C8O11542C13O11604C19O11628C25O11663C30O11670C35O11670C41O11700,,
code-creation,Function,11,217625,0x105136820,488,push node:internal/fixed_queue:99:7,0x815de614718,^
code-source-info,0x105136820,34,3685,3945,,,
code-creation,Function,11,217625,0x105136a80,536,_unrefTimer node:net:431:52,0x120d44382810,^
code-source-info,0x105136a80,113,11830,11940,,,
code-creation,Function,11,217625,0x105136d00,232,assert node:internal/assert:11:16,0x232faba1bfe8,^
code-source-info,0x105136d00,21,172,307,,,
code-creation,Function,11,217667,0x105136e60,360,get node:internal/streams/duplex:102:8,0x174551ee8d30,^
code-source-info,0x105136e60,56,3577,3786,,,
code-creation,Function,11,217667,0x105137040,128,unrefActive node:internal/timers:317:21,0x2b48e0c70d90,^
code-source-info,0x105137040,12,9590,9630,,,
code-creation,Function,11,217709,0x105137120,480,Readable.removeListener node:internal/streams/readable:927:45,0x174551ef4738,^
code-source-info,0x105137120,57,29295,29852,,,
code-creation,Function,11,217709,0x105137360,136,get node:internal/bootstrap/pre_execution:394:8,0x3172a1b27730,^
code-source-info,0x105137360,96,12231,12264,,,
code-creation,Function,11,217709,0x105137460,344,listenerCount node:events:854:23,0x232faba27170,^
code-source-info,0x105137460,23,24662,24930,,,
tick,0x1bfd3cab0,217750,0,0x0,0,0x0,0xa12169c1628,0x1208b73fbe7,0xa12169caa03,0xa12169ca6dc,0xa12169c983d,0xa12169c9523,0xa12169c9299,0xa12169c910c,0xa12169c8dd2,0xa12169c8aad,0xb4baa08571,0xb4baa0833e,0xa12169f97c6,0xa12169f94c8,0xa12169f90d5,0xa12169f8b99
code-creation,LazyCompile,10,217792,0xb4baa08c2e,2, /Users/vignesh/Projects/HTTP2/index.js:33:20,0x2cbd764a6da8,~
code-source-info,0xb4baa08c2e,150,538,542,C1O541,,
code-creation,LazyCompile,10,217792,0xb4baa08d56,34,shift node:internal/priority_queue:107:8,0x232faba05360,~
code-source-info,0xb4baa08d56,19,2600,2750,C0O2622C2O2627C4O2626C8O2653C10O2657C14O2666C16O2697C17O2704C18O2715C26O2715C31O2733C33O2746,,
code-creation,LazyCompile,10,217834,0xb4baa08e86,132,removeAt node:internal/priority_queue:93:11,0x232faba052f8,~
code-source-info,0xb4baa08e86,19,2266,2591,C0O2291C2O2296C4O2295C8O2321C10O2328C19O2333C26O2340C28O2362C31O2356C34O2350C38O2372C40O2382C45O2387C49O2405C50O2414C57O2425C62O2442C64O2450C71O2462C73O2461C79O2481C82O2485C85O2476C91O2495C95O2471C103O2502C108O2520C113O2520C120O2562C125O2562C131O2590,,
code-creation,LazyCompile,10,217875,0xb4baa09076,160,percolateDown node:internal/priority_queue:49:16,0x232faba05218,~
code-source-info,0xb4baa09076,19,1104,1759,C0O1132C2O1137C4O1136C8O1172C10O1177C12O1176C16O1209C18O1214C20O1213C24O1239C26O1244C28O1243C32O1269C34O1273C38O1300C40O1296C46O1300C51O1334C53O1338C56O1342C60O1353C62O1368C69O1395C72O1390C78O1405C82O1378C89O1419C94O1432C96O1449C100O1474C102O1478C106O1502C113O1523C118O1537C120O1550C124O1589C129O1620C131O1630C135O1645C140O1285C143O1673C145O1683C149O1695C153O1732C159O1758,,
code-creation,LazyCompile,10,217959,0xb4baa0946e,108,constructNT node:internal/streams/destroy:257:21,0x174551ee7570,~
code-source-info,0xb4baa0946e,55,5233,6318,C0O5233C18O5259C19O5259C24O5833C27O5840C35O5840C41O5869C44O5917C49O5929C53O5976C58O5992C74O5976C92O6295C100O6295C107O6317,,
code-creation,LazyCompile,10,218000,0xb4baa097d6,176,_construct node:internal/fs/streams:42:20,0x2811abd23ce8,~
code-source-info,0xb4baa097d6,187,1019,1903,C0O1019C12O1049C14O1049C16O1057C19O1075C27O1098C30O1098C33O1114C34O1121C35O1129C38O1140C47O1149C49O1145C57O1171C66O1180C68O1176C80O1266C85O1273C89O1266C91O1283C100O1295C104O1614C109O1621C114O1621C122O1644C129O1651C131O1650C135O1656C143O1668C151O1681C159O1695C169O1656C175O1902,,
code-creation,LazyCompile,10,218084,0xb4baa09a3e,168,onConstruct node:internal/streams/destroy:260:23,0xb4baa092d8,~
code-source-info,0xb4baa09a3e,55,5289,5804,C0O5301C6O5321C24O5355C27O5351C33O5321C38O5387C39O5394C40O5405C44O5412C50O5435C53O5442C58O5472C61O5479C66O5509C71O5522C75O5537C76O5551C80O5569C84O5584C85O5598C89O5623C95O5642C98O5649C107O5654C110O5649C118O5681C122O5698C135O5698C142O5752C147O5760C160O5760C167O5803,,
code-creation,LazyCompile,10,218125,0xb4baa09d9e,200,ReadStream._read node:internal/fs/streams:234:38,0x2811abd23fe0,~
code-source-info,0xb4baa09d9e,187,6536,7659,C0O6536C9O6544C12O6553C22O6577C28O6590C36O6601C40O6594C43O6605C47O6577C58O6619C64O6632C72O6643C76O6636C79O6653C83O6619C90O6665C91O6671C96O6683C99O6688C106O6688C111O6704C112O6711C113O6731C120O6738C125O6738C131O6761C138O6766C142O6783C146O6793C153O6798C155O6797C159O6808C167O6818C177O6838C193O6808C199O7658,,
code-creation,LazyCompile,10,218209,0xb4baa0a136,392,read node:fs:603:14,0xd2efcc34b48,~
code-source-info,0xb4baa0a136,81,15194,16744,C0O15194C20O15247C27O15252C33O15289C40O15296C45O15367C54O15367C59O15405C66O15412C71O15501C73O15510C77O15657C80O15681C82O15690C84O15720C97O15729C100O15736C110O15736C117O15756C126O15774C135O15790C142O15801C147O15817C156O15858C166O15858C170O15884C178O15895C182O15893C184O15923C189O15949C194O15976C209O15976C214O16021C221O16037C222O16048C227O16061C232O16076C242O16076C247O16143C248O16151C251O16162C257O16173C262O16186C280O16192C285O16186C286O16314C296O16362C307O16314C312O16378C317O16404C321O16422C331O16422C336O16634C343O16634C349O16657C351O16672C355O16686C362O16694C385O16694C391O16743,,
code-creation,LazyCompile,10,218292,0xb4baa0a46e,2,nop node:internal/streams/writable:73:13,0xd2efcc07718,~
code-source-info,0xb4baa0a46e,64,2399,2404,C1O2403,,
code-creation,LazyCompile,10,218292,0xb4baa0a52e,17,emitConstructNT node:internal/streams/destroy:311:25,0x174551ee75c0,~
code-source-info,0xb4baa0a52e,55,6344,6383,C0O6364C7O6369C10O6364C16O6382,,
code-creation,LazyCompile,10,218334,0xb4baa0a63e,37, node:internal/streams/readable:212:31,0x2cbd7649c170,~
code-source-info,0xb4baa0a63e,57,7111,7220,C0O7123C3O7132C8O7147C14O7169C25O7194C30O7169C36O7219,,
code-creation,LazyCompile,10,218334,0xb4baa0a756,41,maybeReadMore node:internal/streams/readable:625:23,0x174551ef4440,~
code-source-info,0xb4baa0a756,57,19987,20142,C0O20018C6O20039C12O20058C13O20076C17O20088C20O20096C34O20096C40O20141,,
code-creation,Function,11,218417,0x105137620,2840,processTicksAndRejections node:internal/process/task_queues:68:35,0x815de60f618,^
code-source-info,0x105137620,32,1496,2441,,,
code-creation,Function,11,218459,0x1051381a0,2960,nextTick node:internal/process/task_queues:104:18,0x815de60f668,^
code-source-info,0x1051381a0,32,2602,3446,,,
code-creation,Function,11,218459,0x105138da0,376,emitAfterScript node:internal/async_hooks:518:25,0x2b48e0c77fc8,^
code-source-info,0x105138da0,13,17041,17137,,,
code-creation,LazyCompile,10,218500,0xb4baa0ae76,93,maybeReadMore_ node:internal/streams/readable:632:24,0x174551ef4490,~
code-source-info,0xb4baa0ae76,57,20167,21936,C0O21602C6O21620C12O21645C17O21660C21O21652C26O21694C32O21711C38O21718C43O21751C48O21763C56O21763C60O21805C67O21805C72O21836C76O21826C81O21895C83O21588C86O21908C87O21926C92O21935,,
code-creation,LazyCompile,10,218542,0xb4baa0afe6,22,wrapper node:fs:658:19,0xb4baa09f98,~
code-source-info,0xb4baa0afe6,81,16481,16618,C0O16576C8O16590C15O16576C21O16617,,
code-creation,LazyCompile,10,218584,0xb4baa0b12e,204, node:internal/fs/streams:248:41,0xb4baa09ca0,~
code-source-info,0xb4baa0b12e,187,6843,7655,C0O6875C7O6880C11O6897C15O6975C18O6984C24O7005C27O7010C36O7015C39O7010C45O7037C46O7044C47O7060C51O7078C61O7078C68O7117C69O7131C74O7146C77O7155C83O7186C93O7198C96O7195C100O7228C110O7246C113O7243C117O7288C121O7280C126O7469C133O7476C138O7476C144O7518C162O7518C167O7556C172O7586C175O7591C180O7591C187O7625C190O7630C197O7630C203O7654,,
code-creation,LazyCompile,10,218625,0xb4baa0b34e,18,get node:internal/streams/readable:1246:8,0x174551ef5428,~
code-source-info,0xb4baa0b34e,57,37284,37415,C0O37304C6O37344C7O37357C8O37384C13O37399C17O37409,,
code-creation,LazyCompile,10,218625,0xb4baa0b42e,20,Readable.push node:internal/streams/readable:233:35,0x174551ef3f58,~
code-source-info,0xb4baa0b42e,57,7719,7797,C0O7741C14O7748C19O7795,,
code-creation,LazyCompile,10,218709,0xb4baa0b65e,524,readableAddChunk node:internal/streams/readable:242:26,0x174551ef4068,~
code-source-info,0xb4baa0b65e,57,8006,10322,C0O8048C8O8048C13O8105C18O8128C20O8146C26O8164C32O8203C36O8232C42O8265C49O8274C54O8298C58O8322C64O8483C69O8498C74O8498C81O8519C86O8535C91O8520C100O8573C105O8588C110O8588C118O8621C124O8665C126O8686C128O8675C133O8702C139O8728C144O8739C149O8739C156O8769C161O8784C166O8784C173O8818C179O8844C184O8871C202O8877C208O8977C212O8992C217O8992C224O9030C228O9056C229O9070C233O9083C236O9083C243O9129C251O9144C253O9159C259O9166C264O9178C268O9212C274O9232C281O9259C284O9255C290O9232C297O9319C303O9338C309O9355C310O9368C311O9388C325O9388C332O9447C338O9462C345O9489C348O9485C354O9462C361O9540C367O9559C373O9576C374O9589C375O9609C376O9623C380O9648C388O9660C390O9694C395O9702C400O9702C407O9734C413O9754C419O9761C424O9778C438O9778C445O9840C448O9840C455O9893C469O9893C476O9955C480O9978C481O9992C485O10005C488O10005C493O10248C500O10268C505O10283C509O10275C514O10306C520O10313C523O10320,,
code-creation,LazyCompile,10,218792,0xb4baa0ba9e,132,onEofChunk node:internal/streams/readable:556:20,0x174551ef4350,~
code-source-info,0xb4baa0ba9e,57,17630,18431,C0O17650C8O17650C12O17683C18O17690C19O17697C20O17710C26O17745C31O17753C36O17753C41O17764C43O17783C49O17805C54O17812C59O17812C64O17831C69O17853C82O17876C89O17844C93O17896C94O17908C98O17929C104O18112C107O18112C113O18208C114O18227C118O18240C119O18262C123O18403C126O18403C131O18430,,
code-creation,LazyCompile,10,218834,0xb4baa0bcae,117,emitReadable_ node:internal/streams/readable:597:23,0x174551ef43f0,~
code-source-info,0xb4baa0bcae,57,18983,19615,C0O19017C5O19035C13O19064C18O19081C23O19095C28O19035C33O19116C39O19136C45O19154C51O19170C57O19191C65O19191C70O19213C71O19235C75O19526C85O19548C92O19567C97O19583C101O19574C104O19513C108O19600C111O19600C116O19614,,
code-creation,LazyCompile,10,218875,0xb4baa0be5e,58,endReadable node:internal/streams/readable:1325:21,0x174551ef5658,~
code-source-info,0xb4baa0be5e,57,39067,39268,C0O39101C5O39120C13O39147C18O39120C23O39173C29O39191C30O39203C34O39215C37O39223C51O39223C57O39267,,
code-creation,LazyCompile,10,218917,0xb4baa0c006,155,endReadableNT node:internal/streams/readable:1335:23,0x174551ef56a8,~
code-source-info,0xb4baa0c006,57,39292,40190,C0O39312C8O39341C13O39359C18O39312C23O39430C29O39448C35O39477C41O39497C47O39504C52O39517C53O39534C57O39553C65O39553C70O39582C76O39601C82O39615C87O39634C90O39642C98O39642C106O39696C112O39862C117O39904C120O39932C126O40071C132O40090C138O40099C142O40126C144O40160C149O40160C154O40189,,
code-creation,LazyCompile,10,218959,0xb4baa0c1f6,94,onend node:internal/readline/interface:251:17,0xb4baa067e0,~
code-source-info,0xb4baa0c1f6,203,7032,7212,C0O7041C9O7064C11O7063C20O7102C27O7107C29O7106C33O7121C39O7128C44O7146C49O7151C59O7164C66O7169C68O7168C72O7151C78O7195C83O7200C88O7200C93O7211,,
code-creation,LazyCompile,10,218959,0xb4baa0c386,58,close node:internal/readline/interface:522:8,0x1208b72bb20,~
code-source-info,0xb4baa0c386,203,13981,14147,C0O13999C6O14007C7O14014C8O14024C13O14024C17O14046C23O14064C25O14069C27O14068C33O14081C38O14100C39O14112C43O14129C51O14129C57O14146,,
tick,0x1bfd3cab0,219000,0,0x0,3,0x0,0xb4baa0c24e,0x10512e0f4,0xb4baa0c047,0x105137a6c
code-creation,LazyCompile,10,219000,0xb4baa0c4d6,43,pause node:internal/readline/interface:536:8,0x1208b72bb70,~
code-source-info,0xb4baa0c4d6,203,14233,14359,C0O14251C6O14259C7O14266C8O14276C13O14282C18O14282C22O14295C23O14307C27O14324C35O14324C40O14343C42O14355,,
code-creation,LazyCompile,10,219042,0xb4baa0c656,92,Readable.pause node:internal/streams/readable:1020:36,0x174551ef4a20,~
code-source-info,0xb4baa0c656,57,32074,32333,C0O32081C8O32117C13O32132C18O32081C23O32153C28O32168C34O32176C39O32193C47O32193C51O32218C57O32241C61O32259C69O32259C74O32285C81O32300C85O32309C89O32319C91O32331,,
code-creation,LazyCompile,10,219084,0xb4baa0c7de,20, node:internal/bootstrap/switches/is_main_thread:218:21,0xa12169f99e8,~
code-source-info,0xb4baa0c7de,92,5946,5988,C0O5958C5O5966C13O5966C19O5987,,
code-creation,LazyCompile,10,219125,0xb4baa0c8e6,62,onSelfCloseWithoutTerminal node:internal/readline/interface:288:40,0xb4baa06920,~
code-source-info,0xb4baa0c8e6,203,7949,8091,C0O7960C3O7966C14O7966C20O8004C23O8010C34O8010C40O8050C43O8056C54O8056C61O8090,,
code-creation,LazyCompile,10,219125,0xb4baa0ca36,18, /Users/vignesh/Projects/HTTP2/lib/cli.js:396:34,0xa12169f9608,~
code-source-info,0xb4baa0ca36,198,11220,11248,C0O11228C4O11236C11O11236C17O11247,,
code-creation,LazyCompile,10,219167,0xb4baa0cb4e,130,exit node:internal/process/per_thread:181:16,0x815de60d7d0,~
code-source-info,0xb4baa0cb4e,30,4785,5255,C0O4798C5O4806C17O4818C20O4806C26O4843C31O4860C36O4873C43O4890C47O4903C52O4916C58O4934C64O4951C68O4965C73O4973C86O4994C94O4973C100O5209C105O5217C115O5236C123O5217C129O5254,,
